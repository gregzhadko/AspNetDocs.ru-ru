---
title: Заголовки контекста в ASP.NET Core
author: rick-anderson
description: Дополнительные сведения о реализации защиты данных в ASP.NET Core контекста заголовков.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/context-headers
ms.openlocfilehash: 2343e59898c024eba420390d7fb0bce2fc82a895
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57033221"
---
# <a name="context-headers-in-aspnet-core"></a>Заголовки контекста в ASP.NET Core

<a name="data-protection-implementation-context-headers"></a>

## <a name="background-and-theory"></a>Общие сведения и теории

В системе защиты данных «ключа» означает, что объект, который может предоставить службы шифрования прошел проверку подлинности. Каждый ключ определяется с помощью уникального идентификатора (GUID), поэтому он несет с собой алгоритмического сведения и entropic материал. Она предназначена, каждый ключ выполнения уникальный энтропии, но системы не поддерживают применение, и мы также должны учитывать для разработчиков, которые могут изменить набора ключей вручную, изменив алгоритмического сведения существующего ключа в связку ключей. Для достижения наших требований безопасности, учитывая этих случаях система защиты данных существует понятие [криптографическая гибкость](https://www.microsoft.com/en-us/research/publication/cryptographic-agility-and-its-relation-to-circular-encryption/), что позволяет безопасно используют одно значение entropic через несколько алгоритмов шифрования.

Большинство систем, которые поддерживают криптографическая гибкость сделать это, включая некоторые идентификационные сведения об алгоритме внутри полезных данных. OID алгоритма и обычно является хорошим кандидатом для этого. Одна из проблем, мы столкнулись то, что существует несколько способов для указания того же алгоритма: «AES» (CNG) и управляемых Aes, aesmanaged совместим со, AesCryptoServiceProvider, AesCng и (при наличии определенных параметров) RijndaelManaged классы являются фактически все то же самое, и мы должны будут хранить сопоставление все действия, чтобы правильный идентификатор Объекта. Если разработчик хотел предоставить пользовательский алгоритм (или даже другую реализацию AES!), они бы сообщить нам его OID. Дополнительный регистрации на этом шаге создается конфигурация системы затраты особенно велики.

Переход назад, мы решили, что мы достиг проблему с неправильно. OID указывает, что такое алгоритм, но нас не волнуют фактически это. Если нам нужно безопасно использовать одно значение entropic в два разных алгоритма, не необходимые нам знать, что фактически, алгоритмы. Что мы действительно заботитесь, — это поведение. Любой алгоритм неплохую симметричного блочного шифра также является строгим перестановка псевдослучайных чисел (PRP): исправить входные данные (ключ, цепочки режим, IV, открытым текстом) и выходные данные зашифрованного текста с забрасывая вероятности будут отделяться от других симметричный блочный шифр алгоритм, учитывая одинаковыми входными данными. Аналогичным образом любая функция, неплохую хеша также является строгим псевдослучайные функции (PRF), и на основе фиксированного набора входных его выходные данные преимущественно будет отличается от любой другой с ключами хэш-функции.

Мы используем эту концепцию строгой PRP и PRFs для создания заголовка контекста. Этот заголовок контекста по существу выступает в качестве стабильной отпечаток через алгоритмы, используемые для любой конкретной операции, и предоставляет криптографическая гибкость, необходимые системе защиты данных. Этот заголовок можно воспроизвести и используется позже как часть [подраздел процесс наследования](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation). Существует два разных способа для создания заголовка контекста, в зависимости от режима работы базовых алгоритмов.

## <a name="cbc-mode-encryption--hmac-authentication"></a>Шифрование в режиме CBC + проверка подлинности HMAC

<a name="data-protection-implementation-context-headers-cbc-components"></a>

Заголовок контекста состоит из следующих компонентов:

* [16 бит] Значение 00 00, что — это метка это означает «шифрование CBC + HMAC проверки подлинности».

* [32 бита] Длина ключа (в байтах, с прямым порядком байтов) алгоритм симметричного блочного шифрования.

* [32 бита] Размер блока (в байтах, с прямым порядком байтов) алгоритма симметричного блочного шифра.

* [32 бита] Длина ключа (в байтах, с прямым порядком байтов) алгоритм HMAC. (В настоящее время размер ключа всегда соответствует размер хэш-кода.)

* [32 бита] Размер хэш-кода (в байтах, с прямым порядком байтов) алгоритма HMAC.

* EncCBC (K_E, IV, ""), который является результатом работы алгоритма симметричного блочного шифра, заданным входным пустую строку, и где IV — вектор все ноль. Конструирование K_E описан ниже.

* MAC (K_H, ""), который является результатом работы алгоритма HMAC, заданным входным пустая строка. Конструирование K_H описан ниже.

В идеальном случае мы передаем векторы нулевой all, K_E и K_H. Тем не менее мы хотим избежать ситуации, где базовый алгоритм проверяет, наличие слабых ключи перед выполнением любых операций (в частности DES и 3DES), которая не позволяет с помощью такой шаблон простой или повторяющихся операций, как вектор все ноль.

Вместо этого мы используем NIST SP800-108 Проблемы в режиме счетчика (см. в разделе [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), 5.1 в секунду) с ключом нулевой длины, метки и контекст и HMACSHA512 как базового PRF. Мы получаем | K_E | + | K_H | байт из выходных данных, затем разложения результат K_E и K_H сами. Математически она представлена следующим образом.

( K_E || K_H ) = SP800_108_CTR(prf = HMACSHA512, key = "", label = "", context = "")

### <a name="example-aes-192-cbc--hmacsha256"></a>Пример AES-192-CBC + HMACSHA256

Например рассмотрим случай, где алгоритм симметричного блочного шифрования — AES-192-CBC, а алгоритм проверки — HMACSHA256. Система будет создавать заголовок контекста, выполнив следующие действия.

Во-первых, позвольте (K_E || K_H) = SP800_108_CTR (prf = HMACSHA512, key = "", метка = "", контекст = ""), где | K_E | = 192 бита и | K_H | = 256 бит в указанной алгоритмов. Это приводит к K_E = 5BB6... 21DD и K_H = A04A... 00A9 в следующем примере:

```
5B B6 C9 83 13 78 22 1D 8E 10 73 CA CF 65 8E B0
61 62 42 71 CB 83 21 DD A0 4A 05 00 5B AB C0 A2
49 6F A5 61 E3 E2 49 87 AA 63 55 CD 74 0A DA C4
B7 92 3D BF 59 90 00 A9
```

Затем вычислить Enc_CBC (K_E, IV, «») для AES-192-CBC учитывая IV = 0 * и K_E, как описано выше.

result := F474B1872B3B53E4721DE19C0841DB6F

Затем вычислений MAC (K_H, "") для HMACSHA256, учитывая K_H, как описано выше.

result := D4791184B996092EE1202F36E8608FA8FBD98ABDFF5402F264B1D7211536220C

В результате получается полный заголовок ниже:

```
00 00 00 00 00 18 00 00 00 10 00 00 00 20 00 00
00 20 F4 74 B1 87 2B 3B 53 E4 72 1D E1 9C 08 41
DB 6F D4 79 11 84 B9 96 09 2E E1 20 2F 36 E8 60
8F A8 FB D9 8A BD FF 54 02 F2 64 B1 D7 21 15 36
22 0C
```

Этот заголовок контекста — отпечаток пары алгоритм шифрование с проверкой подлинности (шифрование AES-192-CBC + HMACSHA256 проверки). Компоненты, как описано [выше](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers-cbc-components) являются:

* маркер (00 00)

* Длина ключа для шифрования блока (00 00 00 18)

* размер блока шифра блока (00 00 00 10)

* Длина ключа HMAC (00 00 00 20)

* размер хэш-кода HMAC (00 00 00 20)

* блочный шифр выходной политики репликации Паролей (F4 74 - DB 6F) и

* выходные данные HMAC PRF (D4 79 - end).

> [!NOTE]
> Шифрование в режиме CBC + HMAC заголовок проверки подлинности контекста создается так же, независимо от того, предоставляются ли реализаций алгоритмы Windows CNG или управляемых типов SymmetricAlgorithm и KeyedHashAlgorithm. Это позволяет приложениям, выполняющимся в различных операционных системах, надежно производить один и тот же заголовок контекста, несмотря на то, что реализации алгоритмов отличаются в разных операционных системах. (На практике KeyedHashAlgorithm не обязательно должен быть правильной HMAC. Он может быть любого типа алгоритма хэширования с ключом.)

### <a name="example-3des-192-cbc--hmacsha1"></a>Пример 3DES-192-CBC + HMACSHA1

Во-первых, позвольте (K_E || K_H) = SP800_108_CTR (prf = HMACSHA512, key = "", метка = "", контекст = ""), где | K_E | = 192 бита и | K_H | = 160 бит в указанной алгоритмов. Это приводит к K_E = A219... E2BB и K_H = DC4A... B464 в следующем примере:

```
A2 19 60 2F 83 A9 13 EA B0 61 3A 39 B8 A6 7E 22
61 D9 F8 6C 10 51 E2 BB DC 4A 00 D7 03 A2 48 3E
D1 F7 5A 34 EB 28 3E D7 D4 67 B4 64
```

Затем вычислить Enc_CBC (K_E, IV, «») для 3DES-192-CBC учитывая IV = 0 * и K_E, как описано выше.

result := ABB100F81E53E10E

Затем вычислений MAC (K_H, "") для HMAC-SHA1, учитывая K_H, как описано выше.

result := 76EB189B35CF03461DDF877CD9F4B1B4D63A7555

В результате получается полный заголовок, который является отпечатком прошедшего проверку подлинности пары алгоритм шифрования (шифрование 3DES-192-CBC + проверки HMAC-SHA1), показано ниже:

```
00 00 00 00 00 18 00 00 00 08 00 00 00 14 00 00
00 14 AB B1 00 F8 1E 53 E1 0E 76 EB 18 9B 35 CF
03 46 1D DF 87 7C D9 F4 B1 B4 D6 3A 75 55
```

Компоненты разбить следующим образом:

* маркер (00 00)

* Длина ключа для шифрования блока (00 00 00 18)

* размер блока шифра блока (00 00 00 08)

* Длина ключа HMAC (00 00 00 14)

* размер хэш-кода HMAC (00 00 00 14)

* блочный шифр выходной политики репликации Паролей (B1 AB - E1 0E) и

* выходные данные HMAC PRF (76 EB - end).

## <a name="galoiscounter-mode-encryption--authentication"></a>Режим Galois/счетчика шифрования + проверка подлинности

Заголовок контекста состоит из следующих компонентов:

* [16 бит] Значение 00 01, который является маркером это означает «GCM шифрования и проверки подлинности».

* [32 бита] Длина ключа (в байтах, с прямым порядком байтов) алгоритм симметричного блочного шифрования.

* [32 бита] Nonce размер (в байтах, с прямым порядком байтов), используемый во время операций шифрование с проверкой подлинности. (Для нашей системы, эта проблема устранена в размере nonce = 96 битов.)

* [32 бита] Размер блока (в байтах, с прямым порядком байтов) алгоритма симметричного блочного шифра. (Для GCM, это имеет фиксированный размер блока 128 бит.)

* [32 бита] Проверка подлинности тега размер (в байтах, с прямым порядком байтов) создаются с помощью функции шифрование с проверкой подлинности. (Для нашей системы, это имеет фиксированный размер метки = 128 бит.)

* [128 бит] Тег Enc_GCM (K_E, nonce, «»), который является результатом работы алгоритма симметричного блочного шифра, заданным входным пустую строку и где nonce — вектор все ноль 96-разрядного.

K_E формируется с помощью того же механизма, как шифрование CBC + сценарии проверки подлинности HMAC. Тем не менее, так как здесь нет K_H, у нас по сути есть | K_H | = 0, и алгоритм сворачивается до под формой.

K_E = SP800_108_CTR(prf = HMACSHA512, key = "", label = "", context = "")

### <a name="example-aes-256-gcm"></a>Пример AES-256-GCM

Во-первых, позвольте K_E = SP800_108_CTR (prf = HMACSHA512, key = "", метка = "", контекст = ""), где | K_E | = 256 бит.

K_E := 22BC6F1B171C08C4AE2F27444AF8FC8B3087A90006CAEA91FDCFB47C1B8733B8

Затем вычислений в тег проверки подлинности Enc_GCM (K_E, nonce, «») для алгоритма AES-256-GCM учитывая nonce = 096 и K_E как описано выше.

result := E7DCCE66DF855A323A6BB7BD7A59BE45

В результате получается полный заголовок ниже:

```
00 01 00 00 00 20 00 00 00 0C 00 00 00 10 00 00
00 10 E7 DC CE 66 DF 85 5A 32 3A 6B B7 BD 7A 59
BE 45
```

Компоненты разбить следующим образом:

   * маркер (00 01)

   * Длина ключа для шифрования блока (00 00 00 20)

   * nonce размер (00 00 00 0 C)

   * размер блока шифра блока (00 00 00 10)

   * размер тега (00 00 00 10) для проверки подлинности и

   * тег проверки подлинности запуск блочный шифр (E7 DC - end).
