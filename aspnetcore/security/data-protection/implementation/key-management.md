---
title: Управление ключами в ASP.NET Core
author: rick-anderson
description: Дополнительные сведения о реализации API защиты данных в ASP.NET Core ключа управления.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/key-management
ms.openlocfilehash: 431bdf2d3076c83279b78f327ddb647f69e6e584
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57042581"
---
# <a name="key-management-in-aspnet-core"></a><span data-ttu-id="641f4-103">Управление ключами в ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="641f4-103">Key management in ASP.NET Core</span></span>

<a name="data-protection-implementation-key-management"></a>

<span data-ttu-id="641f4-104">Система защиты данных автоматически управляет временем существования главные ключи, используемые для защиты и снятие защиты полезных данных.</span><span class="sxs-lookup"><span data-stu-id="641f4-104">The data protection system automatically manages the lifetime of master keys used to protect and unprotect payloads.</span></span> <span data-ttu-id="641f4-105">Каждый раздел может существовать в одном из четырех этапов:</span><span class="sxs-lookup"><span data-stu-id="641f4-105">Each key can exist in one of four stages:</span></span>

* <span data-ttu-id="641f4-106">Created — ключ существует в набора ключей, но еще не была активирована.</span><span class="sxs-lookup"><span data-stu-id="641f4-106">Created - the key exists in the key ring but has not yet been activated.</span></span> <span data-ttu-id="641f4-107">Ключ не должен использоваться для новых операций защитить до истечения достаточно времени, ключ имели возможность распространять ко всем компьютерам, которые потребляют ресурсы этого набора ключей.</span><span class="sxs-lookup"><span data-stu-id="641f4-107">The key shouldn't be used for new Protect operations until sufficient time has elapsed that the key has had a chance to propagate to all machines that are consuming this key ring.</span></span>

* <span data-ttu-id="641f4-108">Активен - ключ существует в набора ключей и должны использоваться для каждой новой операции защитить.</span><span class="sxs-lookup"><span data-stu-id="641f4-108">Active - the key exists in the key ring and should be used for all new Protect operations.</span></span>

* <span data-ttu-id="641f4-109">Истек срок действия — ключ запуска существования естественным и больше не должен использоваться для новых операций защитить.</span><span class="sxs-lookup"><span data-stu-id="641f4-109">Expired - the key has run its natural lifetime and should no longer be used for new Protect operations.</span></span>

* <span data-ttu-id="641f4-110">Отменено - ключ скомпрометирован и не должны использоваться для новых операций защитить.</span><span class="sxs-lookup"><span data-stu-id="641f4-110">Revoked - the key is compromised and must not be used for new Protect operations.</span></span>

<span data-ttu-id="641f4-111">Ключи созданный active и истекшим сроком действия может использовать на снятие защиты полезных входящих данных.</span><span class="sxs-lookup"><span data-stu-id="641f4-111">Created, active, and expired keys may all be used to unprotect incoming payloads.</span></span> <span data-ttu-id="641f4-112">Отозванные ключи по умолчанию не может использоваться для снятие защиты полезных данных, но разработчик приложения может [переопределить это поведение](xref:security/data-protection/consumer-apis/dangerous-unprotect#data-protection-consumer-apis-dangerous-unprotect) при необходимости.</span><span class="sxs-lookup"><span data-stu-id="641f4-112">Revoked keys by default may not be used to unprotect payloads, but the application developer can [override this behavior](xref:security/data-protection/consumer-apis/dangerous-unprotect#data-protection-consumer-apis-dangerous-unprotect) if necessary.</span></span>

>[!WARNING]
> <span data-ttu-id="641f4-113">Разработчик может возникнуть желание удаления ключа из набора ключей (например, при удалении соответствующего файла из файловой системы).</span><span class="sxs-lookup"><span data-stu-id="641f4-113">The developer might be tempted to delete a key from the key ring (e.g., by deleting the corresponding file from the file system).</span></span> <span data-ttu-id="641f4-114">На этом этапе окончательно получить все данные, защищенные с помощью ключа, а не аварийного переопределение, как с помощью отозванных ключей.</span><span class="sxs-lookup"><span data-stu-id="641f4-114">At that point, all data protected by the key is permanently undecipherable, and there's no emergency override like there's with revoked keys.</span></span> <span data-ttu-id="641f4-115">Удаление ключа является по-настоящему разрушающее поведение и поэтому система защиты данных предоставляет интерфейс API первого класса для выполнения данной операции.</span><span class="sxs-lookup"><span data-stu-id="641f4-115">Deleting a key is truly destructive behavior, and consequently the data protection system exposes no first-class API for performing this operation.</span></span>

## <a name="default-key-selection"></a><span data-ttu-id="641f4-116">Выбор ключа по умолчанию</span><span class="sxs-lookup"><span data-stu-id="641f4-116">Default key selection</span></span>

<span data-ttu-id="641f4-117">Когда система защиты данных считывает набора ключей из резервного хранилища, он попытается найти ключ «default» из набора ключей.</span><span class="sxs-lookup"><span data-stu-id="641f4-117">When the data protection system reads the key ring from the backing repository, it will attempt to locate a "default" key from the key ring.</span></span> <span data-ttu-id="641f4-118">Ключ по умолчанию используется для новых операций защитить.</span><span class="sxs-lookup"><span data-stu-id="641f4-118">The default key is used for new Protect operations.</span></span>

<span data-ttu-id="641f4-119">Общие эвристический алгоритм является то, что система защиты данных выбирает ключ с самой последней даты активации как ключ по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="641f4-119">The general heuristic is that the data protection system chooses the key with the most recent activation date as the default key.</span></span> <span data-ttu-id="641f4-120">(Имеется небольшой настроечным разрешающее для часов между серверами неравномерного распределения). Если ключ просрочен или отозван, и если приложение не отключил автоматическое создание ключей, то будет создан новый ключ с немедленную активацию на [ключа истечение срока действия и последовательное](xref:security/data-protection/implementation/key-management#data-protection-implementation-key-management-expiration) политики ниже.</span><span class="sxs-lookup"><span data-stu-id="641f4-120">(There's a small fudge factor to allow for server-to-server clock skew.) If the key is expired or revoked, and if the application has not disabled automatic key generation, then a new key will be generated with immediate activation per the [key expiration and rolling](xref:security/data-protection/implementation/key-management#data-protection-implementation-key-management-expiration) policy below.</span></span>

<span data-ttu-id="641f4-121">Причина система защиты данных немедленно создает новый ключ, а не откат к другой ключ является создание нового ключа, что следует обрабатывать как неявные срок действия всех ключей, которые были активированы до нового ключа.</span><span class="sxs-lookup"><span data-stu-id="641f4-121">The reason the data protection system generates a new key immediately rather than falling back to a different key is that new key generation should be treated as an implicit expiration of all keys that were activated prior to the new key.</span></span> <span data-ttu-id="641f4-122">Общая идея заключается в новых ключей может быть настроен с помощью различных алгоритмов или механизмов шифрования при хранении, чем старые ключи, что система должна предпочтение откат текущей конфигурации.</span><span class="sxs-lookup"><span data-stu-id="641f4-122">The general idea is that new keys may have been configured with different algorithms or encryption-at-rest mechanisms than old keys, and the system should prefer the current configuration over falling back.</span></span>

<span data-ttu-id="641f4-123">Существует одно исключение.</span><span class="sxs-lookup"><span data-stu-id="641f4-123">There's an exception.</span></span> <span data-ttu-id="641f4-124">Если разработчик приложения [отключено автоматическое создание ключей](xref:security/data-protection/configuration/overview#disableautomatickeygeneration), то система защиты данных необходимо выбрать что-то в качестве ключа по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="641f4-124">If the application developer has [disabled automatic key generation](xref:security/data-protection/configuration/overview#disableautomatickeygeneration), then the data protection system must choose something as the default key.</span></span> <span data-ttu-id="641f4-125">В этом сценарии резервной системой будет выбран ключ не отозван с самой последней даты активации, с предпочтением в пользу ключи, у которых время для распространения на другие компьютеры в кластере.</span><span class="sxs-lookup"><span data-stu-id="641f4-125">In this fallback scenario, the system will choose the non-revoked key with the most recent activation date, with preference given to keys that have had time to propagate to other machines in the cluster.</span></span> <span data-ttu-id="641f4-126">Система резервного использования может оказаться в результате выбора ключ с истекшим сроком действия по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="641f4-126">The fallback system may end up choosing an expired default key as a result.</span></span> <span data-ttu-id="641f4-127">Система резервного использования никогда не выберет отозванных ключ как ключ по умолчанию, и если набора ключей пуст или был отозван каждый ключ система будет создавать ошибку при инициализации.</span><span class="sxs-lookup"><span data-stu-id="641f4-127">The fallback system will never choose a revoked key as the default key, and if the key ring is empty or every key has been revoked then the system will produce an error upon initialization.</span></span>

<a name="data-protection-implementation-key-management-expiration"></a>

## <a name="key-expiration-and-rolling"></a><span data-ttu-id="641f4-128">Срок действия ключа и развертывания</span><span class="sxs-lookup"><span data-stu-id="641f4-128">Key expiration and rolling</span></span>

<span data-ttu-id="641f4-129">При создании ключа, автоматически дала дату активации {now + 2 дня} и дату окончания срока действия {now + 90 дней}.</span><span class="sxs-lookup"><span data-stu-id="641f4-129">When a key is created, it's automatically given an activation date of { now + 2 days } and an expiration date of { now + 90 days }.</span></span> <span data-ttu-id="641f4-130">Задержка 2 дня до активации дает ключевое время для распространения через систему.</span><span class="sxs-lookup"><span data-stu-id="641f4-130">The 2-day delay before activation gives the key time to propagate through the system.</span></span> <span data-ttu-id="641f4-131">То есть он позволяет другим приложениям, указывает на хранилище для наблюдения за ключ в их следующий период автоматического обновления, что повышает вероятность того, что при ключ звонок может стать активной, ее распространения на все приложения, возможно, потребуется использовать его.</span><span class="sxs-lookup"><span data-stu-id="641f4-131">That is, it allows other applications pointing at the backing store to observe the key at their next auto-refresh period, thus maximizing the chances that when the key ring does become active it has propagated to all applications that might need to use it.</span></span>

<span data-ttu-id="641f4-132">Если ключ по умолчанию истекает в течение двух дней и набора ключей еще нет ключом, который будет действовать после истечения срока действия ключа по умолчанию, система защиты данных автоматически сохранять новый ключ в связку ключей.</span><span class="sxs-lookup"><span data-stu-id="641f4-132">If the default key will expire within 2 days and if the key ring doesn't already have a key that will be active upon expiration of the default key, then the data protection system will automatically persist a new key to the key ring.</span></span> <span data-ttu-id="641f4-133">Этот новый ключ имеет дату активации {ключ по умолчанию Дата истечения срока действия} и дату окончания срока действия {now + 90 дней}.</span><span class="sxs-lookup"><span data-stu-id="641f4-133">This new key has an activation date of { default key's expiration date } and an expiration date of { now + 90 days }.</span></span> <span data-ttu-id="641f4-134">Это позволяет системе автоматически изменять ключи на регулярной основе без перерывов в работе службы.</span><span class="sxs-lookup"><span data-stu-id="641f4-134">This allows the system to automatically roll keys on a regular basis with no interruption of service.</span></span>

<span data-ttu-id="641f4-135">Могут возникнуть обстоятельства где создается ключ с немедленную активацию.</span><span class="sxs-lookup"><span data-stu-id="641f4-135">There might be circumstances where a key will be created with immediate activation.</span></span> <span data-ttu-id="641f4-136">Примером может служить, если приложение еще не выполняются в течение времени и истечет срок действия всех ключей в связку ключей.</span><span class="sxs-lookup"><span data-stu-id="641f4-136">One example would be when the application hasn't run for a time and all keys in the key ring are expired.</span></span> <span data-ttu-id="641f4-137">В этом случае ключ предоставляется дату активации {теперь} без задержки активации обычный 2 дня.</span><span class="sxs-lookup"><span data-stu-id="641f4-137">When this happens, the key is given an activation date of { now } without the normal 2-day activation delay.</span></span>

<span data-ttu-id="641f4-138">Время существования ключа по умолчанию составляет 90 дней, хотя это можно настроить, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="641f4-138">The default key lifetime is 90 days, though this is configurable as in the following example.</span></span>

```csharp
services.AddDataProtection()
       // use 14-day lifetime instead of 90-day lifetime
       .SetDefaultKeyLifetime(TimeSpan.FromDays(14));
```

<span data-ttu-id="641f4-139">Администратор также может изменять всей системы по умолчанию, если явный вызов `SetDefaultKeyLifetime` переопределяет любую политику уровня системы.</span><span class="sxs-lookup"><span data-stu-id="641f4-139">An administrator can also change the default system-wide, though an explicit call to `SetDefaultKeyLifetime` will override any system-wide policy.</span></span> <span data-ttu-id="641f4-140">Время существования ключа по умолчанию не может быть менее 7 дней.</span><span class="sxs-lookup"><span data-stu-id="641f4-140">The default key lifetime cannot be shorter than 7 days.</span></span>

## <a name="automatic-key-ring-refresh"></a><span data-ttu-id="641f4-141">Обновление автоматического набора ключей</span><span class="sxs-lookup"><span data-stu-id="641f4-141">Automatic key ring refresh</span></span>

<span data-ttu-id="641f4-142">При инициализации система защиты данных, он считывает из базового хранилища набора ключей и кэширует его в памяти.</span><span class="sxs-lookup"><span data-stu-id="641f4-142">When the data protection system initializes, it reads the key ring from the underlying repository and caches it in memory.</span></span> <span data-ttu-id="641f4-143">Этот кэш позволяет защитить и Unprotect операциям, без обращения резервного хранилища.</span><span class="sxs-lookup"><span data-stu-id="641f4-143">This cache allows Protect and Unprotect operations to proceed without hitting the backing store.</span></span> <span data-ttu-id="641f4-144">Система автоматически проверит резервного хранилища для изменения, приблизительно каждые 24 часа или по истечении срока действия текущего ключа по умолчанию какое событие произойдет первым.</span><span class="sxs-lookup"><span data-stu-id="641f4-144">The system will automatically check the backing store for changes approximately every 24 hours or when the current default key expires, whichever comes first.</span></span>

>[!WARNING]
> <span data-ttu-id="641f4-145">Разработчикам следует очень редко (если когда-нибудь) необходимо непосредственно использовать управление ключами API-интерфейсы.</span><span class="sxs-lookup"><span data-stu-id="641f4-145">Developers should very rarely (if ever) need to use the key management APIs directly.</span></span> <span data-ttu-id="641f4-146">Система защиты данных выполнит автоматическое управление ключами, как описано выше.</span><span class="sxs-lookup"><span data-stu-id="641f4-146">The data protection system will perform automatic key management as described above.</span></span>

<span data-ttu-id="641f4-147">Система защиты данных предоставляет интерфейс `IKeyManager` , можно использовать для проверки и внесения изменений для набора ключей.</span><span class="sxs-lookup"><span data-stu-id="641f4-147">The data protection system exposes an interface `IKeyManager` that can be used to inspect and make changes to the key ring.</span></span> <span data-ttu-id="641f4-148">Система внедрения Зависимостей, предоставленный экземпляр `IDataProtectionProvider` также можно указать экземпляр `IKeyManager` за потребление ресурсов.</span><span class="sxs-lookup"><span data-stu-id="641f4-148">The DI system that provided the instance of `IDataProtectionProvider` can also provide an instance of `IKeyManager` for your consumption.</span></span> <span data-ttu-id="641f4-149">Кроме того, можно извлечь `IKeyManager` прямо из `IServiceProvider` как в примере ниже.</span><span class="sxs-lookup"><span data-stu-id="641f4-149">Alternatively, you can pull the `IKeyManager` straight from the `IServiceProvider` as in the example below.</span></span>

<span data-ttu-id="641f4-150">Любая операция, которая изменяет набора ключей (Создание нового ключа явным образом или выполнении отзыв) сделает недействительными кэш в памяти.</span><span class="sxs-lookup"><span data-stu-id="641f4-150">Any operation which modifies the key ring (creating a new key explicitly or performing a revocation) will invalidate the in-memory cache.</span></span> <span data-ttu-id="641f4-151">Следующий вызов `Protect` или `Unprotect` вызовет система защиты данных, повторное считывание набора ключей и повторное создание кэша.</span><span class="sxs-lookup"><span data-stu-id="641f4-151">The next call to `Protect` or `Unprotect` will cause the data protection system to reread the key ring and recreate the cache.</span></span>

<span data-ttu-id="641f4-152">В следующем примере показано использование `IKeyManager` интерфейса, изучать и манипулировать набора ключей, включая отзыв существующие ключи и создание нового ключа вручную.</span><span class="sxs-lookup"><span data-stu-id="641f4-152">The sample below demonstrates using the `IKeyManager` interface to inspect and manipulate the key ring, including revoking existing keys and generating a new key manually.</span></span>

[!code-csharp[](key-management/samples/key-management.cs)]

## <a name="key-storage"></a><span data-ttu-id="641f4-153">Хранилища ключей</span><span class="sxs-lookup"><span data-stu-id="641f4-153">Key storage</span></span>

<span data-ttu-id="641f4-154">Система защиты данных имеет эвристики, при котором предпринимается попытка автоматически вывести расположение соответствующего хранилища ключей и механизм шифрования при хранении.</span><span class="sxs-lookup"><span data-stu-id="641f4-154">The data protection system has a heuristic whereby it attempts to deduce an appropriate key storage location and encryption-at-rest mechanism automatically.</span></span> <span data-ttu-id="641f4-155">Механизм сохранения ключа, также настраивается разработчиком приложения.</span><span class="sxs-lookup"><span data-stu-id="641f4-155">The key persistence mechanism is also configurable by the app developer.</span></span> <span data-ttu-id="641f4-156">Следующие документы обсудить встроенной реализации этих механизмов:</span><span class="sxs-lookup"><span data-stu-id="641f4-156">The following documents discuss the in-box implementations of these mechanisms:</span></span>

* <xref:security/data-protection/implementation/key-storage-providers>
* <xref:security/data-protection/implementation/key-encryption-at-rest>
