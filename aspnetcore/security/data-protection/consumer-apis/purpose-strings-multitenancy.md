---
title: Иерархия назначений и Мультитенантность в ASP.NET Core
author: rick-anderson
description: Дополнительные сведения о строка иерархия назначений и Мультитенантность по отношению к API защиты данных ASP.NET Core.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/consumer-apis/purpose-strings-multitenancy
ms.openlocfilehash: 1133d40e7b325d58b3f70e7387494dae36ff8ac9
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57047011"
---
# <a name="purpose-hierarchy-and-multi-tenancy-in-aspnet-core"></a><span data-ttu-id="436f1-103">Иерархия назначений и Мультитенантность в ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="436f1-103">Purpose hierarchy and multi-tenancy in ASP.NET Core</span></span>

<span data-ttu-id="436f1-104">Так как `IDataProtector` неявно `IDataProtectionProvider`, целей можно связывать друг с другом.</span><span class="sxs-lookup"><span data-stu-id="436f1-104">Since an `IDataProtector` is also implicitly an `IDataProtectionProvider`, purposes can be chained together.</span></span> <span data-ttu-id="436f1-105">В этом смысле `provider.CreateProtector([ "purpose1", "purpose2" ])` эквивалентен `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.</span><span class="sxs-lookup"><span data-stu-id="436f1-105">In this sense, `provider.CreateProtector([ "purpose1", "purpose2" ])` is equivalent to `provider.CreateProtector("purpose1").CreateProtector("purpose2")`.</span></span>

<span data-ttu-id="436f1-106">Это позволяет выполнять некоторые интересные иерархические связи через систему защиты данных.</span><span class="sxs-lookup"><span data-stu-id="436f1-106">This allows for some interesting hierarchical relationships through the data protection system.</span></span> <span data-ttu-id="436f1-107">В приведенном ранее примере [Contoso.Messaging.SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose), можно вызвать компонент SecureMessage `provider.CreateProtector("Contoso.Messaging.SecureMessage")` после первоначальных и кэш-памяти результат в закрытую `_myProvider` поля.</span><span class="sxs-lookup"><span data-stu-id="436f1-107">In the earlier example of [Contoso.Messaging.SecureMessage](xref:security/data-protection/consumer-apis/purpose-strings#data-protection-contoso-purpose), the SecureMessage component can call `provider.CreateProtector("Contoso.Messaging.SecureMessage")` once up-front and cache the result into a private `_myProvider` field.</span></span> <span data-ttu-id="436f1-108">Будущие предохранители можно создать путем вызова метода `_myProvider.CreateProtector("User: username")`, и эти предохранители ключа будет использоваться для защиты отдельных сообщений.</span><span class="sxs-lookup"><span data-stu-id="436f1-108">Future protectors can then be created via calls to `_myProvider.CreateProtector("User: username")`, and these protectors would be used for securing the individual messages.</span></span>

<span data-ttu-id="436f1-109">Это может также быть перевернуто.</span><span class="sxs-lookup"><span data-stu-id="436f1-109">This can also be flipped.</span></span> <span data-ttu-id="436f1-110">Рассмотрим один логический приложение узлы нескольких клиентов (это система управления Содержимым кажется вполне разумным) и каждого клиента можно настроить с помощью собственной проверки подлинности и состояния управления системой.</span><span class="sxs-lookup"><span data-stu-id="436f1-110">Consider a single logical application which hosts multiple tenants (a CMS seems reasonable), and each tenant can be configured with its own authentication and state management system.</span></span> <span data-ttu-id="436f1-111">Зонтик приложение имеет один главный поставщик, и он вызывает `provider.CreateProtector("Tenant 1")` и `provider.CreateProtector("Tenant 2")` предоставить каждому клиенту собственный изолированной срез система защиты данных.</span><span class="sxs-lookup"><span data-stu-id="436f1-111">The umbrella application has a single master provider, and it calls `provider.CreateProtector("Tenant 1")` and `provider.CreateProtector("Tenant 2")` to give each tenant its own isolated slice of the data protection system.</span></span> <span data-ttu-id="436f1-112">Клиенты затем создать свои собственные отдельных средств защиты, исходя из собственных потребностей, но независимо от того, насколько сильно они пытаются выполнить не могут создавать средства защиты, которые конфликтуют с любым другим клиентом в системе.</span><span class="sxs-lookup"><span data-stu-id="436f1-112">The tenants could then derive their own individual protectors based on their own needs, but no matter how hard they try they cannot create protectors which collide with any other tenant in the system.</span></span> <span data-ttu-id="436f1-113">Графически оно представлено ниже.</span><span class="sxs-lookup"><span data-stu-id="436f1-113">Graphically, this is represented as below.</span></span>

![С несколькими аренды целей](purpose-strings-multitenancy/_static/purposes-multi-tenancy.png)

>[!WARNING]
> <span data-ttu-id="436f1-115">При этом предполагается считать элементы управления приложениями, какие интерфейсы API доступны для отдельных клиентов и что клиенты не могут выполнять произвольный код на сервере.</span><span class="sxs-lookup"><span data-stu-id="436f1-115">This assumes the umbrella application controls which APIs are available to individual tenants and that tenants cannot execute arbitrary code on the server.</span></span> <span data-ttu-id="436f1-116">Если клиент может выполняться произвольный код, они удалось выполнить отражение закрытых переключиться в гарантии изоляции или они может просто выполнить чтение материала основного напрямую и являются производными любые подразделы пожелает.</span><span class="sxs-lookup"><span data-stu-id="436f1-116">If a tenant can execute arbitrary code, they could perform private reflection to break the isolation guarantees, or they could just read the master keying material directly and derive whatever subkeys they desire.</span></span>

<span data-ttu-id="436f1-117">Система защиты данных использует своего рода Многопользовательские приложения в конфигурации по умолчанию out of box.</span><span class="sxs-lookup"><span data-stu-id="436f1-117">The data protection system actually uses a sort of multi-tenancy in its default out-of-the-box configuration.</span></span> <span data-ttu-id="436f1-118">По умолчанию главный материал ключа хранится в папке профиля пользователя учетной записи процесса рабочей роли (или реестр, для удостоверения пула приложений IIS).</span><span class="sxs-lookup"><span data-stu-id="436f1-118">By default master keying material is stored in the worker process account's user profile folder (or the registry, for IIS application pool identities).</span></span> <span data-ttu-id="436f1-119">Но фактически довольно часто, чтобы использовать одну учетную запись для запуска нескольких приложений, и таким образом все эти приложения появятся общего доступа к хозяину материала.</span><span class="sxs-lookup"><span data-stu-id="436f1-119">But it's actually fairly common to use a single account to run multiple applications, and thus all these applications would end up sharing the master keying material.</span></span> <span data-ttu-id="436f1-120">Чтобы решить эту проблему, система защиты данных автоматически вставляет идентификатор уникальный каждого приложения как первый элемент в цепочке общего назначения.</span><span class="sxs-lookup"><span data-stu-id="436f1-120">To solve this, the data protection system automatically inserts a unique-per-application identifier as the first element in the overall purpose chain.</span></span> <span data-ttu-id="436f1-121">Этой цели неявное служит для [изолировать отдельные приложения](xref:security/data-protection/configuration/overview#per-application-isolation) друг у друга рассматривая эффективно каждое приложение как уникальный клиента в системе и процесс создания предохранителя выглядит так же на рисунке выше.</span><span class="sxs-lookup"><span data-stu-id="436f1-121">This implicit purpose serves to [isolate individual applications](xref:security/data-protection/configuration/overview#per-application-isolation) from one another by effectively treating each application as a unique tenant within the system, and the protector creation process looks identical to the image above.</span></span>
