---
title: Поставщик конфигурации хранилища ключей Azure в ASP.NET Core
author: guardrex
description: Узнайте, как использовать поставщик конфигурации Azure Key Vault для настройки приложения с помощью пары "имя значение", загружен во время выполнения.
monikerRange: '>= aspnetcore-2.1'
ms.author: riande
ms.custom: mvc
ms.date: 02/22/2019
uid: security/key-vault-configuration
ms.openlocfilehash: 2188929d6f380327465e8ce0fd8ad659188416d3
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57048031"
---
# <a name="azure-key-vault-configuration-provider-in-aspnet-core"></a>Поставщик конфигурации хранилища ключей Azure в ASP.NET Core

По [Люк Лэтем](https://github.com/guardrex) и [Andrew Stanton медсестра](https://github.com/anurse)

В этом документе объясняется, как использовать [Microsoft Azure Key Vault](https://azure.microsoft.com/services/key-vault/) поставщик конфигурации для загрузки значений конфигурации из секреты Azure Key Vault. Azure Key Vault — это облачная служба, который помогает защита криптографических ключей и секретов, используемых приложений и служб. Распространенные сценарии использования хранилища ключей Azure с приложениями ASP.NET Core:

* Управление доступом к конфиденциальные данные конфигурации.
* Соответствующие требования FIPS 140-2 уровня 2 проверить аппаратных модулей безопасности (HSM), при сохранении данных конфигурации.

Этот сценарий доступен для приложений, предназначенных для ASP.NET Core 2.1 или более поздней версии.

[Просмотреть или скачать образец кода](https://github.com/aspnet/Docs/tree/master/aspnetcore/security/key-vault-configuration/sample) ([как скачивать](xref:index#how-to-download-a-sample))

## <a name="packages"></a>Пакеты

Чтобы использовать поставщик конфигурации Azure Key Vault, добавьте ссылки на пакет [Microsoft.Extensions.Configuration.AzureKeyVault](https://www.nuget.org/packages/Microsoft.Extensions.Configuration.AzureKeyVault/) пакета.

Чтобы внедрить [управляемые удостоверения для ресурсов Azure](/azure/active-directory/managed-identities-azure-resources/overview) сценарий, добавьте ссылку на пакет [Microsoft.Azure.Services.AppAuthentication](https://www.nuget.org/packages/Microsoft.Azure.Services.AppAuthentication/) пакета.

> [!NOTE]
> На момент написания статьи, последний стабильный выпуск `Microsoft.Azure.Services.AppAuthentication`, версии `1.0.3`, обеспечивает поддержку для [назначенный системой управляемые удостоверения](/azure/active-directory/managed-identities-azure-resources/overview#how-does-the-managed-identities-for-azure-resources-worka-namehow-does-it-worka). Поддержка *назначаемого пользователем управляемого удостоверения* доступен в `1.0.2-preview` пакета. В этом разделе демонстрируется использование удостоверения, управляемые системой, и предоставленный пример приложения использует версию `1.0.3` из `Microsoft.Azure.Services.AppAuthentication` пакета.

## <a name="sample-app"></a>Пример приложения

Пример приложения выполняется в одном из двух режимов определяется `#define` инструкция в верхней части *Program.cs* файла:

* `Basic` &ndash; Демонстрирует использование идентификатор приложения Azure Key Vault и пароль (секрет клиента) для доступа к секретные данные, хранящиеся в хранилище ключей. Развертывание `Basic` примера на любом узле, может обслуживать приложения ASP.NET Core. Следуйте указаниям в [используйте идентификатор приложения и секрет клиента для приложений Azure — внепроцессной](#use-application-id-and-client-secret-for-non-azure-hosted-apps) раздел.
* `Managed` &ndash; Демонстрирует использование [управляемые удостоверения для ресурсов Azure](/azure/active-directory/managed-identities-azure-resources/overview) подлинность приложения в хранилище ключей Azure с аутентификацией Azure AD без учетных данных, хранящихся в коде или конфигурации приложения. При использовании управляемых удостоверений для проверки подлинности, идентификатор приложения Azure AD и пароль (секрет клиента) не являются обязательными. `Managed` Версия образца должны быть развернуты в Azure. Следуйте указаниям в [использование управляемого удостоверения для ресурсов Azure](#use-managed-identities-for-azure-resources) раздел.

Дополнительные сведения о том, как настроить пример приложения с помощью директивы препроцессора (`#define`), см. в разделе <xref:index#preprocessor-directives-in-sample-code>.

## <a name="secret-storage-in-the-development-environment"></a>Хранилища секретов в среде разработки

Задайте секретами локально с помощью [средство Secret Manager](xref:security/app-secrets). При запуске примера приложения на локальном компьютере в среде разработки, секретные данные загружаются из локального хранилища менеджер секретов.

Средство Secret Manager требует `<UserSecretsId>` свойство в файле проекта приложения. Задайте значение свойства (`{GUID}`) для любого уникального идентификатора GUID:

```xml
<PropertyGroup>
  <UserSecretsId>{GUID}</UserSecretsId>
</PropertyGroup>
```

Секретные данные создаются в виде пар "имя значение". Использование иерархических значений (разделы конфигурации) `:` (двоеточие) как разделитель [конфигурации ASP.NET Core](xref:fundamentals/configuration/index) имен разделов.

Менеджер секретов используется в командной оболочке, открыт корневой каталог содержимого проекта, где `{SECRET NAME}` — это имя и `{SECRET VALUE}` значение:

```console
dotnet user-secrets set "{SECRET NAME}" "{SECRET VALUE}"
```

Выполните следующие команды в командной строке из содержимого корневого каталога проекта для задания секреты для примера приложения:

```console
dotnet user-secrets set "SecretName" "secret_value_1_dev"
dotnet user-secrets set "Section:SecretName" "secret_value_2_dev"
```

Когда эти секреты хранятся в хранилище ключей Azure в [хранилища секретов в рабочей среде с хранилищем ключей Azure](#secret-storage-in-the-production-environment-with-azure-key-vault) разделе `_dev` суффикс изменяется в `_prod`. Суффикс предоставляет визуальную подсказку, в выходных данных приложения, указывающий источник значения конфигурации.

## <a name="secret-storage-in-the-production-environment-with-azure-key-vault"></a>Хранилища секретов в рабочей среде с хранилищем ключей Azure

Инструкции, предоставленные [краткое руководство: Задание и получение секрета из хранилища ключей Azure с помощью Azure CLI](/azure/key-vault/quick-create-cli) разделе кратко перечислены ниже для создания хранилища ключей Azure и хранение секретов, используемых в примере приложения. См. в разделе для получения дополнительных сведений.

1. Откройте Azure Cloud shell, с помощью любого из следующих методов в [портала Azure](https://portal.azure.com/):

   * Выберите **попробовать** в правом верхнем углу блока кода. Используйте строку поиска «Интерфейс командной строки Azure» в текстовом поле.
   * Откройте Cloud Shell в браузере с **запуска Cloud Shell** кнопки.
   * Выберите **Cloud Shell** кнопку меню в правом верхнем углу портала Azure.

   Дополнительные сведения см. в разделе [интерфейса командной строки Azure (CLI)](/cli/azure/) и [Обзор Azure Cloud Shell](/azure/cloud-shell/overview).

1. Если вы еще не прошли аутентификацию, вход с помощью `az login` команды.

1. Создайте группу ресурсов, выполнив следующую команду, где `{RESOURCE GROUP NAME}` — имя группы ресурсов для новой группы ресурсов и `{LOCATION}` — регион Azure (datacenter):

   ```console
   az group create --name "{RESOURCE GROUP NAME}" --location {LOCATION}
   ```

1. Создание хранилища ключей в группе ресурсов, выполнив следующую команду, где `{KEY VAULT NAME}` — это имя для нового хранилища ключей и `{LOCATION}` — регион Azure (datacenter):

   ```console
   az keyvault create --name "{KEY VAULT NAME}" --resource-group "{RESOURCE GROUP NAME}" --location {LOCATION}
   ```

1. Создание секретов в хранилище ключей в виде пар "имя значение".

   Azure имена секретов Key Vault ограничены буквы, цифры и дефисы. Использование иерархических значений (разделы конфигурации) `--` (двух дефисов) в качестве разделителя. Имена, которые обычно используются для разделения разделе из подраздела в [конфигурации ASP.NET Core](xref:fundamentals/configuration/index), не разрешены в именах секрета хранилища ключей. Таким образом двух дефисов используются и поменять местами двоеточие, при загрузке секреты в конфигурацию приложения.

   Следующие секреты предназначены для использования с примером приложения. Значения включают `_prod` суффикс, чтобы отличать их от `_dev` суффикс значения, загруженных в среде разработки с секретами пользователей. Замените `{KEY VAULT NAME}` с именем хранилища ключей, созданный на предыдущем шаге:

   ```console
   az keyvault secret set --vault-name "{KEY VAULT NAME}" --name "SecretName" --value "secret_value_1_prod"
   az keyvault secret set --vault-name "{KEY VAULT NAME}" --name "Section--SecretName" --value "secret_value_2_prod"
   ```

## <a name="use-application-id-and-client-secret-for-non-azure-hosted-apps"></a>Используйте идентификатор приложения и секрет клиента для приложений без размещения Azure

Настройка Azure AD, Azure Key Vault и приложение для использования идентификатор приложения и пароль (секрет клиента) для проверки подлинности в хранилище ключей **когда приложение размещается за пределами Azure**.

> [!NOTE]
> Несмотря на то, что использование идентификатор приложения и пароль (секрет клиента) поддерживается для приложений, размещенных в Azure, мы рекомендуем использовать [управляемые удостоверения для ресурсов Azure](#use-managed-identities-for-azure-resources) при размещении приложения в Azure. Управляемые удостоверения не требует хранения учетных данных в приложение или его конфигурацию, поэтому считается более безопасный подход.

Пример приложения использует идентификатор приложения и пароль (секрет клиента) при `#define` инструкция в верхней части *Program.cs* для файла `Basic`.

1. Регистрация приложения в Azure AD и установить пароль (секрет клиента) для удостоверения приложения.
1. Store имя хранилища ключей, идентификатор приложения и пароль и секрет клиента приложения *appsettings.json* файла.
1. Перейдите к **хранилища ключей** на портале Azure.
1. Выберите хранилище ключей, созданный в [хранилища секретов в рабочей среде с хранилищем ключей Azure](#secret-storage-in-the-production-environment-with-azure-key-vault) раздел.
1. Выберите **политики доступа**.
1. Выберите **добавить**.
1. Выберите **Выбор субъекта** и выберите зарегистрированного приложения по имени. Выберите **выберите** кнопки.
1. Откройте **разрешения секретов** и укажите приложение с **получить** и **списка** разрешения.
1. Нажмите кнопку **ОК**.
1. Нажмите кнопку **Сохранить**.
1. Разверните приложение.

`Basic` Пример приложения получает свои значения конфигурации из `IConfigurationRoot` с тем же именем, что имя секрета:

* Не иерархическими значениями: Значение для `SecretName` получается с помощью `config["SecretName"]`.
* Иерархические значения (разделов): Используйте `:` нотации (двоеточие) или `GetSection` метода расширения. Чтобы получить значение конфигурации, следует используйте один из этих подходов:
  * `config["Section:SecretName"]`
  * `config.GetSection("Section")["SecretName"]`

Приложение вызывает `AddAzureKeyVault` с помощью значений, предоставленных *appsettings.json* файла:

[!code-csharp[](key-vault-configuration/sample/Program.cs?name=snippet1&highlight=11-14)]

Примеры значений:

* Имя хранилища ключей: `contosovault`
* Идентификатор приложения: `627e911e-43cc-61d4-992e-12db9c81b413`
* Пароль: `g58K3dtg59o1Pa+e59v2Tx829w6VxTB2yv9sv/101di=`

*appsettings.json*:

[!code-json[](key-vault-configuration/sample/appsettings.json)]

При запуске приложения, веб-страница показывает загруженные значения секрета. В среде разработки, загрузка значения секретов с помощью `_dev` суффикс. В рабочей среде, значения загружать данные с помощью `_prod` суффикс.

## <a name="use-managed-identities-for-azure-resources"></a>Использование управляемых удостоверений для ресурсов Azure

**Приложение, развернутое в Azure** можно воспользоваться преимуществами [управляемые удостоверения для ресурсов Azure](/azure/active-directory/managed-identities-azure-resources/overview), который позволяет приложению проверку подлинности с помощью Azure Key Vault с использованием проверки подлинности Azure AD без учетных данных (идентификатор приложения и Секрет Password/Client) хранящихся в приложении.

Пример приложения использует управляемые удостоверения для ресурсов Azure при `#define` инструкция в верхней части *Program.cs* для файла `Managed`.

Ввести имя хранилища в приложении *appsettings.json* файла. Пример приложения не требуется идентификатор приложения и пароль (секрет клиента), если значение `Managed` версии, поэтому вы можете игнорировать эти записи конфигурации. Приложение развертывается в Azure и Azure проверяет подлинность приложения для доступа к хранилищу ключей Azure, используя только имя хранилища хранятся в *appsettings.json* файла.

Развертывание примера приложения в службе приложений Azure.

Приложения в службе приложений Azure автоматически зарегистрированы в Azure AD, при создании службы. Получите идентификатор объекта из развертывания для использования в следующей команде. Идентификатор объекта отображается на портале Azure на **удостоверений** панель службы приложений.

С помощью интерфейса командной строки Azure и идентификатор объекта приложения, укажите приложение с `list` и `get` разрешения на доступ к хранилищу ключей:

```console
az keyvault set-policy --name '{KEY VAULT NAME}' --object-id {OBJECT ID} --secret-permissions get list
```

**Перезапустите приложение** с помощью Azure CLI, PowerShell или портала Azure.

Пример приложения.

* Создает экземпляр класса `AzureServiceTokenProvider` класс без строки подключения. Если не указано строку подключения, поставщик пытается получить маркер доступа с помощью управляемых удостоверений для ресурсов Azure.
* Новый `KeyVaultClient` создается с `AzureServiceTokenProvider` маркера экземпляр обратного вызова.
* `KeyVaultClient` С реализацией по умолчанию используется экземпляр `IKeyVaultSecretManager` , загружает все значения секретов и заменяет двойной тире (`--`) с запятой (`:`) в имена ключей.

[!code-csharp[](key-vault-configuration/sample/Program.cs?name=snippet2&highlight=13-21)]

При запуске приложения, веб-страница показывает загруженные значения секрета. В среде разработки, имеют значения секретов `_dev` суффикс, так как они предоставляются с секретами пользователей. В рабочей среде, значения загружать данные с помощью `_prod` суффикс, так как они предоставляются в хранилищем ключей Azure.

Если вы получили `Access denied` ошибку, убедитесь, что приложение будет зарегистрировано в Azure AD и получают доступ к хранилищу ключей. Убедитесь, что после перезагрузки службы в Azure.

## <a name="use-a-key-name-prefix"></a>Используйте префикс имени ключа

`AddAzureKeyVault` предоставляет перегрузку, которая принимает реализацию `IKeyVaultSecretManager`, который позволяет управлять ключевых секреты хранилища преобразуются в ключи конфигурации. Например можно реализовать интерфейс для загрузки значения секретов, исходя из значения префикса, указанные вами при запуске приложения. Это позволяет, например, загружать секреты, в зависимости от версии приложения.

> [!WARNING]
> Для размещения секреты для нескольких приложений в том же хранилище ключей или для размещения среды секреты не используйте префиксы секретных кодов хранилища ключей (например, *разработки* и *рабочей* секретов) в одну хранилище. Мы рекомендуем различных приложений и сред разработки, эксплуатации использовать отдельные хранилища ключей для изоляции среды приложений для обеспечения максимальной безопасности.

В следующем примере устанавливается секрет ключа хранилища (и используя средство Secret Manager для среды разработки) для `5000-AppSecret` (периоды не допускаются в именах секрета хранилища ключей). Этот секрет представляет секрет приложения для версии 5.0.0.0 приложения. Для другой версии приложения, 5.1.0.0, секрет добавляется к ключу хранилища (и используя средство Secret Manager) для `5100-AppSecret`. Каждая версия приложения загружает его с версиями секретное значение в его конфигурацию в качестве `AppSecret`, удаление версии при загрузке секрет.

`AddAzureKeyVault` вызывается с пользовательским `IKeyVaultSecretManager`:

[!code-csharp[](key-vault-configuration/sample_snapshot/Program.cs?name=snippet1&highlight=22)]

Предоставленные значения для имени хранилища ключей, идентификатор приложения и пароль (секрет клиента) *appsettings.json* файла:

[!code-json[](key-vault-configuration/sample/appsettings.json)]

Примеры значений:

* Имя хранилища ключей: `contosovault`
* Идентификатор приложения: `627e911e-43cc-61d4-992e-12db9c81b413`
* Пароль: `g58K3dtg59o1Pa+e59v2Tx829w6VxTB2yv9sv/101di=`

`IKeyVaultSecretManager` Реализации реагирует на префиксы версии секретов, чтобы загрузить правильный секрет в конфигурации:

[!code-csharp[](key-vault-configuration/sample_snapshot/Startup.cs?name=snippet1)]

`Load` Метод вызывается с помощью алгоритма поставщик, выполняющий итерацию секреты хранилища, чтобы найти те, которые имеют префикс версии. Найденный префикс версии с `Load`, алгоритм использует `GetKey` метод, чтобы вернуть имя конфигурации имя секрета. Она отсекает версии префикс из имени секрета и возвращает остальные имя секрета для загрузки в конфигурацию приложения пары "имя значение".

Если при реализации этого подхода:

1. Версия приложения, указанные в файле проекта приложения. В следующем примере версия приложения имеет значение `5.0.0.0`:

   ```xml
   <PropertyGroup>
     <Version>5.0.0.0</Version>
   </PropertyGroup>
   ```

1. Убедитесь, что `<UserSecretsId>` свойство присутствует в файле проекта приложения, где `{GUID}` представляет собой идентификатор GUID, предоставленный пользователем:

   ```xml
   <PropertyGroup>
     <UserSecretsId>{GUID}</UserSecretsId>
   </PropertyGroup>
   ```

   Сохранить следующие секреты локально с помощью [средство Secret Manager](xref:security/app-secrets):

   ```console
   dotnet user-secrets set "5000-AppSecret" "5.0.0.0_secret_value_dev"
   dotnet user-secrets set "5100-AppSecret" "5.1.0.0_secret_value_dev"
   ```

1. Секретные данные сохраняются в хранилище ключей Azure с помощью следующих команд Azure CLI:

   ```console
   az keyvault secret set --vault-name "{KEY VAULT NAME}" --name "5000-AppSecret" --value "5.0.0.0_secret_value_prod"
   az keyvault secret set --vault-name "{KEY VAULT NAME}" --name "5100-AppSecret" --value "5.1.0.0_secret_value_prod"
   ```

1. При запуске приложения, загружаются секретных кодов хранилища ключей. Строка секрета для `5000-AppSecret` сопоставляется версия приложения, указанные в файле проекта приложения (`5.0.0.0`).

1. Версии, `5000` (с dash), удаляются из имени ключа. В приложении, чтение конфигурации с ключом `AppSecret` загружает значение секрета.

1. Если версия приложения изменяется в файле проекта для `5.1.0.0` и снова запустите приложение, секрета возвращаемое значение `5.1.0.0_secret_value_dev` в среде разработки и `5.1.0.0_secret_value_prod` в рабочей среде.

> [!NOTE]
> Можно также предоставить собственную `KeyVaultClient` реализацию `AddAzureKeyVault`. Пользовательский клиент позволяет совместно использовать один экземпляр клиента приложения.

## <a name="authenticate-to-azure-key-vault-with-an-x509-certificate"></a>Проверку подлинности в Azure Key Vault с помощью сертификата X.509

Разработка приложения .NET Framework в среде, которая поддерживает сертификаты, можно выполнить в хранилище ключей Azure с использованием сертификата X.509. Закрытый ключ сертификата X.509 находится под управлением операционной системы. Дополнительные сведения см. в разделе [проверка подлинности с помощью сертификата вместо секрета клиента](/azure/key-vault/key-vault-use-from-web-application#authenticate-with-a-certificate-instead-of-a-client-secret). Используйте `AddAzureKeyVault` перегрузку, которая принимает `X509Certificate2` (`_env` в следующем примере:

```csharp
var builtConfig = config.Build();

var store = new X509Store(StoreLocation.CurrentUser);
store.Open(OpenFlags.ReadOnly);
var cert = store.Certificates
    .Find(X509FindType.FindByThumbprint, 
        config["CertificateThumbprint"], false);

config.AddAzureKeyVault(
    builtConfig["KeyVaultName"],
    builtConfig["AzureADApplicationId"],
    cert.OfType<X509Certificate2>().Single(),
    new EnvironmentSecretManager(context.HostingEnvironment.ApplicationName));

store.Close();
```

## <a name="bind-an-array-to-a-class"></a>Привязка массива к классу

Поставщик способный считывать значения конфигурации в массив для привязки к массиву POCO.

При чтении из источника конфигурации, который позволяет ключи содержат двоеточия (`:`) разделители, числового ключа сегмента используется для различения ключи, составляющие массив (`:0:`, `:1:`,... `:{n}:`). Дополнительные сведения см. в разделе [конфигурации: Привязка к классу массив](xref:fundamentals/configuration/index#bind-an-array-to-a-class).

Azure Key Vault ключи нельзя использовать двоеточие в качестве разделителя. Подход, описанный в этом разделе используются двойные тире (`--`) как разделитель для значений иерархической (разделов). Массив ключи хранятся в хранилище ключей Azure с double штрихов и числовых ключей сегментов (`--0--`, `--1--`,... `--{n}--`).

Рассмотрим следующую [Serilog](https://serilog.net/) конфигурация поставщика, предоставляемые JSON-файл журнала. Существуют два объектных литералов, определенные в `WriteTo` массива, который отражает две Serilog *приемников*, описывающих назначения для выходных данных ведения журнала:

```json
"Serilog": {
  "WriteTo": [
    {
      "Name": "AzureTableStorage",
      "Args": {
        "storageTableName": "logs",
        "connectionString": "DefaultEnd...ountKey=Eby8...GMGw=="
      }
    },
    {
      "Name": "AzureDocumentDB",
      "Args": {
        "endpointUrl": "https://contoso.documents.azure.com:443",
        "authorizationKey": "Eby8...GMGw=="
      }
    }
  ]
}
```

Конфигурации, представленной выше JSON-файл хранится в хранилище ключей Azure с помощью двойной штрих (`--`) нотации и числовые сегменты:

| Ключ | Значение |
| --- | ----- |
| `Serilog--WriteTo--0--Name` | `AzureTableStorage` |
| `Serilog--WriteTo--0--Args--storageTableName` | `logs` |
| `Serilog--WriteTo--0--Args--connectionString` | `DefaultEnd...ountKey=Eby8...GMGw==` |
| `Serilog--WriteTo--1--Name` | `AzureDocumentDB` |
| `Serilog--WriteTo--1--Args--endpointUrl` | `https://contoso.documents.azure.com:443` |
| `Serilog--WriteTo--1--Args--authorizationKey` | `Eby8...GMGw==` |

## <a name="reload-secrets"></a>Перезагрузить секретов

Секреты, кэшируются до `IConfigurationRoot.Reload()` вызывается. Истек, отключена, и обновленные секреты в хранилище ключей не учитываются в приложении до `Reload` выполняется.

```csharp
Configuration.Reload();
```

## <a name="disabled-and-expired-secrets"></a>Отключенные и истекшим сроком действия секретов

Отключенные и просроченные секреты throw `KeyVaultClientException`. Чтобы избежать возникновения в приложении, замените приложение или изменить секрет просроченного отключено.

## <a name="troubleshoot"></a>Устранение неполадок

Если приложение не удается загрузить конфигурацию с помощью поставщика, сообщение об ошибке записывается [инфраструктуры ведения журнала ASP.NET Core](xref:fundamentals/logging/index). Следующие условия не позволит конфигурации загрузки:

* Приложение не настроено правильно, в Azure Active Directory.
* Хранилище ключей не существует в хранилище ключей Azure.
* Приложение не имеет разрешения на доступ к хранилищу ключей.
* Политика доступа не включает `Get` и `List` разрешения.
* В хранилище ключей данные конфигурации (пара «имя значение») ошибочно названы, отсутствуют, отключена или истек срок действия.
* Приложение имеет имя неправильный хранилища ключей (`KeyVaultName`), идентификатор приложения Azure AD (`AzureADApplicationId`), или паролей Azure AD (секрет клиента) (`AzureADPassword`).
* Паролей Azure AD (секрет клиента) (`AzureADPassword`) срок действия истек.
* В приложении для значения, которое вы пытаетесь загрузить неправильный ключ конфигурации (имя).

## <a name="additional-resources"></a>Дополнительные ресурсы

* <xref:fundamentals/configuration/index>
* [Microsoft Azure: Хранилище ключей](https://azure.microsoft.com/services/key-vault/)
* [Microsoft Azure: Документация по хранилищу ключей](/azure/key-vault/)
* [Использование защищенных аппаратным модулем безопасности и их передача ключей для хранилища ключей Azure](/azure/key-vault/key-vault-hsm-protected-keys)
* [Класс KeyVaultClient](/dotnet/api/microsoft.azure.keyvault.keyvaultclient)
