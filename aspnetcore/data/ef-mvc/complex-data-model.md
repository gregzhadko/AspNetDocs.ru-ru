---
title: Учебник. Использование ASP.NET MVC с EF  Core. Создание сложной модели данных
description: В этом руководстве вы добавите дополнительные сущности и связи, а также настроите модель данных, указав правила форматирования, проверки и сопоставления.
author: rick-anderson
ms.author: tdykstra
ms.custom: mvc
ms.date: 02/05/2019
ms.topic: tutorial
uid: data/ef-mvc/complex-data-model
ms.openlocfilehash: c08fd6ff7c19c63161135b4c87609f6edd3edb80
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57036631"
---
# <a name="tutorial-create-a-complex-data-model---aspnet-mvc-with-ef-core"></a>Учебник. Использование ASP.NET MVC с EF  Core. Создание сложной модели данных

В предыдущих руководствах вы работали с простой моделью данных, состоящей из трех сущностей. В этом руководстве вы добавите дополнительные сущности и связи, а также настроите модель данных, указав правила форматирования, проверки и сопоставления базы данных.

По завершении работы классы сущностей сформируют готовую модель данных, приведенную на следующем рисунке:

![Схема сущностей](complex-data-model/_static/diagram.png)

В этом учебнике рассмотрены следующие задачи.

> [!div class="checklist"]
> * Настройка модели данных
> * Изменения сущности Student
> * Создание сущности Instructor
> * Создание сущности OfficeAssignment
> * Изменение сущности Course
> * Создание сущности Department
> * Изменение сущности Enrollment
> * Обновление контекста базы данных
> * Начальное заполнение базы данных тестовыми данными
> * Добавление миграции
> * Изменение строки подключения
> * Обновление базы данных

## <a name="prerequisites"></a>Предварительные требования

* [Использование функции миграций EF Core для ASP.NET Core в веб-приложении MVC](migrations.md)

## <a name="customize-the-data-model"></a>Настройка модели данных

В этом разделе вы узнаете, как настроить модель данных с помощью атрибутов, которые указывают правила форматирования, проверки и сопоставления базы данных. Затем в нескольких последующих разделах вы создаете всю модель данных School целиком, добавив атрибуты к уже созданным классам и создав классы для остальных типов сущностей в модели.

### <a name="the-datatype-attribute"></a>Атрибут DataType

Сейчас для дат зачисления студентов учащихся все веб-страницы отображают время и дату, хотя для этого поля достаточно одной даты. Используя атрибуты заметок к данным, вы можете внести в код одно изменение, позволяющее исправить формат отображения в каждом представлении, где отображаются эти данные. Чтобы рассмотреть соответствующий пример, вы добавите атрибут в свойство `EnrollmentDate` класса `Student`.

В *Models/Student.cs* добавьте оператор `using` для пространства имен `System.ComponentModel.DataAnnotations`, а также атрибуты `DataType` и `DisplayFormat` для свойства `EnrollmentDate`, как показано в следующем примере:

[!code-csharp[](intro/samples/cu/Models/Student.cs?name=snippet_DataType&highlight=3,12-13)]

Атрибут `DataType` позволяет указать тип данных с более точным определением по сравнению со встроенным типом базы данных. В этом случае требуется отслеживать только дату, а не дату и время. В перечислении `DataType` представлено множество типов данных, таких как Date, Time, PhoneNumber, Currency, EmailAddress и других. Атрибут `DataType` также обеспечивает автоматическое предоставление функций для определенных типов в приложении. Например, может быть создана ссылка `mailto:` для `DataType.EmailAddress`. Также в браузерах с поддержкой HTML5 может быть предоставлен селектор даты для `DataType.Date`. Атрибут `DataType` создает атрибуты HTML 5 `data-`, которые используются браузерами с поддержкой HTML 5. Атрибуты `DataType` не предназначены для проверки.

`DataType.Date` не задает формат отображаемой даты. По умолчанию поле данных отображается с использованием форматов, установленных в CultureInfo сервера.

С помощью атрибута `DisplayFormat` можно явно указать формат даты:

```csharp
[DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]
```

Параметр `ApplyFormatInEditMode` указывает, что формат также должен применяться при отображении значения в текстовом поле для редактирования. (В некоторых случаях такое поведение нежелательно. Например, в текстовом поле для редактирования денежных значений обычно не требуется отображать символ валюты.)

Атрибут `DisplayFormat` можно использовать отдельно, однако чаще всего его рекомендуется применять вместе с атрибутом `DataType`. Атрибут `DataType` передает семантику данных (в отличие от способа их вывода на экран) и дает следующие преимущества по сравнению с `DisplayFormat`:

* Поддержка функций HTML5 в браузере (отображение элемента управления календарем, соответствующего языковому стандарту символа валюты, ссылок электронной почты, проверки на стороне клиента и т. д.).

* По умолчанию формат отображения данных в браузере определяется в соответствии с установленным языковым стандартом.

Дополнительные сведения см. в документации по [вспомогательной функции тегов \<input>](../../mvc/views/working-with-forms.md#the-input-tag-helper).

Запустите приложение, перейдите на страницу индекса студентов учащихся и обратите внимание, что время для дат зачисления больше не отображается. Аналогичная ситуация будет наблюдаться в любом представлении, использующем модель Student.

![Страница указателя учащихся с датами без времени](complex-data-model/_static/dates-no-times.png)

### <a name="the-stringlength-attribute"></a>Атрибут StringLength

С помощью атрибутов также можно указать правила проверки данных и сообщения об ошибках проверки. Атрибут `StringLength` задает максимальную длину в базе данных и обеспечивает проверку на стороне клиента и на стороне сервера для ASP.NET Core MVC. В этом атрибуте также можно указать минимальную длину строки, но это минимальное значение не влияет на схему базы данных.

Предположим, вы хотите сделать так, чтобы пользователи не вводили больше 50 символов для имени. Чтобы задать это ограничение, добавьте атрибуты `StringLength` в свойства `LastName` и `FirstMidName`, как показано в следующем примере:

[!code-csharp[](intro/samples/cu/Models/Student.cs?name=snippet_StringLength&highlight=10,12)]

Атрибут `StringLength` не запрещает пользователю ввести пробел в качестве имени пользователя. Атрибут `RegularExpression` можно использовать для применения ограничений к входным данным. Например, следующий код требует, чтобы первый символ был прописной буквой, а остальные символы были буквенными:

```csharp
[RegularExpression(@"^[A-Z]+[a-zA-Z""'\s-]*$")]
```

Атрибут `MaxLength` предоставляет функциональность, аналогичную атрибуту `StringLength`, но не обеспечивает проверку на стороне клиента.

Модель базы данных изменилась до такой степени, что требуется изменение схемы базы данных. Миграции позволяют обновить схему без потери данных, которые вы могли добавить в базу данных с помощью пользовательского интерфейса приложения.

Сохраните изменения и выполните сборку проекта. Затем откройте командное окно в папке проекта и введите следующие команды:

```console
dotnet ef migrations add MaxLengthOnNames
```

```console
dotnet ef database update
```

Команда `migrations add` выдает предупреждение о возможной потере данных, так как это изменение сокращает максимальную длину для двух столбцов.  Функция миграций создает файл с именем *\<метка_времени>_MaxLengthOnNames.cs*. Он содержит в методе `Up` код, который обновит базу данных в соответствии с текущей моделью данных. Команда `database update` запустила этот код.

Метка времени, добавленная в качестве префикса к имени файла миграций, используется платформой Entity Framework для упорядочения миграций. Вы можете создать несколько миграций перед выполнением команды update-database, после чего все миграции применяются в порядке их создания.

Запустите приложение, выберите вкладку **Students** (Учащиеся), щелкните **Create New** (Создать) и попробуйте ввести любое имя длиннее 50 символов. Приложение должно отобразить ошибку. 

### <a name="the-column-attribute"></a>Атрибут Column

Вы также можете использовать атрибуты, чтобы управлять сопоставлением классов и свойств с базой данных. Предположим, что вы использовали имя `FirstMidName` для поля имени, так как это поле также может содержать отчество. Но вам нужно, чтобы столбец базы данных назывался `FirstName`, так как к этому имени привыкли пользователи, которые будут составлять нерегламентированные запросы к базе данных. Чтобы выполнить это сопоставление, можно использовать атрибут `Column`.

Атрибут `Column` указывает, что при создании базы данных столбец таблицы `Student`, сопоставляемый со свойством `FirstMidName`, будет называться `FirstName`. Другими словами, когда ваш код ссылается на `Student.FirstMidName`, данные будут браться из столбца `FirstName` таблицы `Student` или обновляться в нем. Если не указать имена столбцов, им назначается имя, совпадающее с именем свойства.

В файле *Student.cs* добавьте оператор `using` для `System.ComponentModel.DataAnnotations.Schema` и атрибут имени столбца в свойство `FirstMidName`, как показано в следующем выделенном коде:

[!code-csharp[](intro/samples/cu/Models/Student.cs?name=snippet_Column&highlight=4,14)]

Добавление атрибута `Column` изменяет модель для поддержки `SchoolContext`, поэтому она не будет соответствовать базе данных.

Сохраните изменения и выполните сборку проекта. Затем откройте командное окно в папке проекта и введите следующие команды, чтобы создать другую миграцию:

```console
dotnet ef migrations add ColumnFirstName
```

```console
dotnet ef database update
```

В **обозревателе объектов SQL Server** откройте конструктор таблиц учащихся, дважды щелкнув таблицу **Student** (Учащийся).

![Таблица учащихся в SSOX после миграций](complex-data-model/_static/ssox-after-migration.png)

До применения двух первых миграций столбцы имен имели тип nvarchar(MAX). Теперь они относятся к типу nvarchar(50), а имя столбца изменилось с FirstMidName на FirstName.

> [!Note]
> Если попытаться выполнить компиляцию до создания всех классов сущностей в следующих разделах, могут возникнуть ошибки компилятора.

## <a name="changes-to-student-entity"></a>Изменения сущности Student

![Сущность Student](complex-data-model/_static/student-entity.png)

В *Models/Student.cs* замените добавленный ранее код на приведенный ниже. Изменения выделены.

[!code-csharp[](intro/samples/cu/Models/Student.cs?name=snippet_BeforeInheritance&highlight=11,13,15,18,22,24-31)]

### <a name="the-required-attribute"></a>Атрибут Required

Атрибут `Required` делает свойства имен обязательными полями. Атрибут `Required` не нужен для типов, не допускающих значения null, например для типов значений (DateTime, int, double, float и т. д.). Типы, которые не могут принимать значение null, автоматически обрабатываются как обязательные поля.

Атрибут `Required` можно удалить и заменить параметром минимальной длины для атрибута `StringLength`:

```csharp
[Display(Name = "Last Name")]
[StringLength(50, MinimumLength=1)]
public string LastName { get; set; }
```

### <a name="the-display-attribute"></a>Атрибут Display

Атрибут `Display` указывает, что заголовки для текстовых полей должны иметь вид "First Name" (Имя), "Last Name" (Фамилия), "Full Name" (Полное имя) и "Enrollment Date" (Дата зачисления) вместо имени свойства в каждом экземпляре (в котором не используется пробел для разделения слов).

### <a name="the-fullname-calculated-property"></a>Вычисляемое свойство FullName

`FullName` — это вычисляемое свойство, которое возвращает значение, созданное путем объединения двух других свойств. Поэтому оно имеет только метод доступа get, и в базе данных не будет создан столбец `FullName`.

## <a name="create-instructor-entity"></a>Создание сущности Instructor

![Сущность Instructor](complex-data-model/_static/instructor-entity.png)

Создайте файл *Models/Instructor.cs*, заменив код шаблона следующим:

[!code-csharp[](intro/samples/cu/Models/Instructor.cs?name=snippet_BeforeInheritance)]

Обратите внимание, что некоторые свойства являются одинаковыми в сущностях Student и Instructor. В руководстве по [реализации наследования](inheritance.md) далее в этой серии вы выполните рефакторинг данного кода, чтобы устранить избыточность.

Несколько атрибутов можно расположить на одной строке, поэтому записать атрибуты `HireDate` можно следующим образом:

```csharp
[DataType(DataType.Date),Display(Name = "Hire Date"),DisplayFormat(DataFormatString = "{0:yyyy-MM-dd}", ApplyFormatInEditMode = true)]
```

### <a name="the-courseassignments-and-officeassignment-navigation-properties"></a>Свойства навигации CourseAssignments и OfficeAssignment

`CourseAssignments` и `OfficeAssignment` — это свойства навигации.

Преподаватель может проводить любое количество курсов, поэтому `CourseAssignments` определен как коллекция.

```csharp
public ICollection<CourseAssignment> CourseAssignments { get; set; }
```

Если свойство навигации может содержать несколько сущностей, оно должно иметь тип списка, допускающий добавление, удаление и обновление записей.  Вы можете указать тип `ICollection<T>` либо, например, тип `List<T>` или `HashSet<T>`. Если указан тип `ICollection<T>`, платформа EF по умолчанию создает коллекцию `HashSet<T>`.

Причина того, что это сущности `CourseAssignment`, описана ниже в разделе о связях многие ко многим.

Бизнес-правила университета Contoso указывают, что преподаватель может иметь не более одного кабинета, поэтому свойство `OfficeAssignment` содержит отдельную сущность OfficeAssignment (которая может иметь значение null, если кабинет не назначен).

```csharp
public OfficeAssignment OfficeAssignment { get; set; }
```

## <a name="create-officeassignment-entity"></a>Создание сущности OfficeAssignment

![Сущность OfficeAssignment](complex-data-model/_static/officeassignment-entity.png)

Создайте файл *Models/OfficeAssignment.cs* со следующим кодом:

[!code-csharp[](intro/samples/cu/Models/OfficeAssignment.cs)]

### <a name="the-key-attribute"></a>Атрибут Key

Между сущностями Instructor и OfficeAssignment действует связь один к нулю или к одному. Назначение кабинета существует только в связи с преподавателем, которому оно назначено, поэтому его первичный ключ также является внешним ключом для сущности Instructor. Однако Entity Framework не распознает InstructorID в качестве первичного ключа этой сущности автоматически, так как ее имя не соответствует соглашению об именовании ID или classnameID. Таким образом, атрибут `Key` используется для определения ее в качестве ключа:

```csharp
[Key]
public int InstructorID { get; set; }
```

Атрибут `Key` также можно использовать, если сущность имеет собственный первичный ключ, но нужно задать для свойства имя, отличное от classnameID или ID.

По умолчанию EF считает ключ созданным не базой данных, так как столбец предназначен для идентифицирующего отношения.

### <a name="the-instructor-navigation-property"></a>Свойство навигации Instructor

Сущность Instructor имеет свойство навигации `OfficeAssignment`, допускающее значение null (так как у преподавателя может не быть назначения кабинета), а сущность OfficeAssignment имеет свойство навигации `Instructor`, не допускающее значение null (так как назначение кабинета не может существовать без преподавателя — `InstructorID` не допускает значение null). Когда сущность Instructor имеет связанную сущность OfficeAssignment, каждая из них имеет ссылку на другую в своем свойстве навигации.

Можно поместить атрибут `[Required]` в свойство навигации Instructor, чтобы указать, что должен присутствовать связанный преподаватель, однако это необязательно, так как внешний ключ `InstructorID` (который также является ключом для этой таблицы) не допускает значение null.

## <a name="modify-course-entity"></a>Изменение сущности Course

![Сущность Course](complex-data-model/_static/course-entity.png)

В *Models/Course.cs* замените добавленный ранее код на приведенный ниже. Изменения выделены.

[!code-csharp[](intro/samples/cu/Models/Course.cs?name=snippet_Final&highlight=2,10,13,16,19,21,23)]

Сущность курса имеет свойство внешнего ключа `DepartmentID`, указывающее на связанную сущность Department, а также она имеет свойство навигации `Department`.

Платформа Entity Framework не требует добавлять свойство внешнего ключа в модель данных при наличии свойства навигации для связанной сущности.  EF автоматически создает внешние ключи в базе данных по мере необходимости, а также создает для них [теневые свойства](/ef/core/modeling/shadow-properties). Однако наличие внешнего ключа в модели данных позволяет сделать обновления проще и эффективнее. Например, при извлечении сущности Course для редактирования сущность Department имеет значение null, если вы ее не загружаете. Таким образом, при обновлении сущности Course вам потребуется сначала получить сущность Department. Если свойство внешнего ключа `DepartmentID` включено в модель данных, получать сущность Department перед обновлением не нужно.

### <a name="the-databasegenerated-attribute"></a>Атрибут DatabaseGenerated

Атрибут `DatabaseGenerated` с параметром `None` в свойстве `CourseID` указывает, что значения первичного ключа предоставлены пользователем, а не созданы базой данных.

```csharp
[DatabaseGenerated(DatabaseGeneratedOption.None)]
[Display(Name = "Number")]
public int CourseID { get; set; }
```

По умолчанию Entity Framework предполагает, что значения первичного ключа созданы базой данных. Именно это и требуется для большинства сценариев. Однако для сущностей Course вы будете использовать определяемый пользователем номер курса, например серия 1000 для одной кафедры, серия 2000 для другой и так далее.

Атрибут `DatabaseGenerated` также можно использовать для создания значения по умолчанию, как в случае, когда столбцы базы данных используются для записи даты, когда строка была создана или обновлена.  Дополнительные сведения см. в разделе [Созданные свойства](/ef/core/modeling/generated-properties).

### <a name="foreign-key-and-navigation-properties"></a>Свойства внешнего ключа и навигации

Свойства внешнего ключа (FK) и свойства навигации в сущности Course отражают следующие связи:

Курс назначается одной кафедре, поэтому по указанным выше причинам имеется внешний ключ `DepartmentID` и свойство навигации `Department`.

```csharp
public int DepartmentID { get; set; }
public Department Department { get; set; }
```

На курс может быть зачислено любое количество учащихся, поэтому свойство навигации `Enrollments` является коллекцией:

```csharp
public ICollection<Enrollment> Enrollments { get; set; }
```

Курс могут вести несколько преподавателей, поэтому свойство навигации `CourseAssignments` является коллекцией (тип `CourseAssignment` описан [ниже](#many-to-many-relationships)):

```csharp
public ICollection<CourseAssignment> CourseAssignments { get; set; }
```

## <a name="create-department-entity"></a>Создание сущности Department

![Сущность Department](complex-data-model/_static/department-entity.png)


Создайте файл *Models/Department.cs* со следующим кодом:

[!code-csharp[](intro/samples/cu/Models/Department.cs?name=snippet_Begin)]

### <a name="the-column-attribute"></a>Атрибут Column

Ранее атрибут `Column` использовался, чтобы изменить сопоставление имени столбца. В коде для сущности Department атрибут `Column` используется для изменения сопоставления типов данных SQL, поэтому столбец будет определяться с помощью типа money SQL Server в базе данных:

```csharp
[Column(TypeName="money")]
public decimal Budget { get; set; }
```

Сопоставление столбцов обычно не требуется, так как Entity Framework выбирает подходящий тип данных SQL Server на основе типа среды CLR, определяемого вами для свойства. Тип `decimal` среды CLR сопоставляется с типом `decimal` SQL Server. Но в этом случае вы знаете, что столбец будет содержать суммы в валюте, хотя для этого лучше подходит тип данных money.

### <a name="foreign-key-and-navigation-properties"></a>Свойства внешнего ключа и навигации

Свойства внешнего ключа и навигации отражают следующие связи:

Кафедра может иметь или не иметь администратора, и администратор всегда является преподавателем. Поэтому `InstructorID` свойство включается в качестве внешнего ключа в сущность Instructor, а после `int` обозначения типа добавляется знак вопроса, указывающий, что свойство допускает значение null. Свойство навигации называется `Administrator`, но содержит сущность Instructor:

```csharp
public int? InstructorID { get; set; }
public Instructor Administrator { get; set; }
```

Кафедра может иметь несколько курсов, поэтому доступно свойство навигации Courses:

```csharp
public ICollection<Course> Courses { get; set; }
```

> [!NOTE]
> По соглашению Entity Framework разрешает каскадное удаление для внешних ключей, не допускающих значение null, и связей многие ко многим. Это может привести к циклическим правилам каскадного удаления, которые вызывают исключение при попытке добавить миграцию. Например, если вы не определили свойство Department.InstructorID как допускающее значение null, EF настраивает правило каскадного удаления для удаления преподавателя при удалении кафедры, что вам не нужно. Если бизнес-правила требуют, чтобы свойство `InstructorID` не допускало значение null, используйте следующий оператор текучего API, чтобы отключить каскадное удаление для этой связи:
> ```csharp
> modelBuilder.Entity<Department>()
>    .HasOne(d => d.Administrator)
>    .WithMany()
>    .OnDelete(DeleteBehavior.Restrict)
> ```

## <a name="modify-enrollment-entity"></a>Изменение сущности Enrollment

![Сущность Enrollment](complex-data-model/_static/enrollment-entity.png)

В *Models/Enrollment.cs* замените добавленный ранее код на приведенный ниже:

[!code-csharp[](intro/samples/cu/Models/Enrollment.cs?name=snippet_Final&highlight=1-2,16)]

### <a name="foreign-key-and-navigation-properties"></a>Свойства внешнего ключа и навигации

Свойства внешнего ключа и навигации отражают следующие связи:

Запись зачисления предназначена для одного курса, поэтому доступно свойство первичного ключа `CourseID` и свойство навигации `Course`:

```csharp
public int CourseID { get; set; }
public Course Course { get; set; }
```

Запись зачисления предназначена для одного учащегося, поэтому доступно свойство первичного ключа `StudentID` и свойство навигации `Student`:

```csharp
public int StudentID { get; set; }
public Student Student { get; set; }
```

## <a name="many-to-many-relationships"></a>Связи "многие ко многим"

Между сущностями Student и Course имеется связь многие ко многим, а сущность Enrollment выступает в качестве таблицы соединения многие ко многим *с полезными данными* в базе данных. Фраза "с полезными данными" означает, что таблица Enrollment содержит дополнительные данные, кроме внешних ключей для присоединяемых таблиц (в данном случае — первичный ключ и свойство Grade).

На следующем рисунке показано, как выглядят эти связи на схеме сущностей. (Эта схема была создана с помощью Entity Framework Power Tools для EF 6.x. Создание схемы не является частью руководства, оно просто используется здесь в качестве примера.)

![Связь многие ко многим между Student и Course](complex-data-model/_static/student-course.png)

Каждая линия связи имеет 1 на одном конце и звездочку (*) на другом, указывая характер один ко многим.

Если таблица Enrollment не включала в себя сведения об оценках, ей потребуется содержать всего два внешних ключа (CourseID и StudentID). В данном случае это будет таблица соединения многие ко многим без полезных данных (ее также называют чистой таблицей соединения) в базе данных. Между сущностями Instructor и Course действует связь многие ко многим, и следующим шагом является создание класса сущности, выступающего в качестве таблицы соединения без полезных данных.

(EF 6.x поддерживает неявные таблицы соединения для связей многие ко многим, но EF Core — нет. Дополнительные сведения см. в [обсуждении в репозитории EF Core на сайте GitHub](https://github.com/aspnet/EntityFramework/issues/1368).)

## <a name="the-courseassignment-entity"></a>Сущность CourseAssignment

![Сущность CourseAssignment](complex-data-model/_static/courseassignment-entity.png)

Создайте файл *Models/CourseAssignment.cs* со следующим кодом:

[!code-csharp[](intro/samples/cu/Models/CourseAssignment.cs)]

### <a name="join-entity-names"></a>Имена для сущностей соединения

В базе данных для связи многие ко многим между Instructor и Courses нужна таблица соединения, которая должна быть представлена набором сущностей. Обычно для сущности соединения используется имя `EntityName1EntityName2`, которое в данном случае будет иметь значение `CourseInstructor`. Однако рекомендуется выбрать имя, которое описывает эту связь. Модели данных создаются простыми и разрастаются, а соединения без полезных данных часто начинают включать эти данные позднее. Если вначале задать описательное имя сущности, его не потребуется менять позднее. Оптимально, если сущность соединения имеет собственное естественное имя (возможно, из одного слова) в бизнес-среде. Например, Books и Customers можно связать через Ratings. Для этой связи `CourseAssignment` подходит лучше, чем `CourseInstructor`.

### <a name="composite-key"></a>Составной ключ

Так как внешние ключи не допускают значение null и совместно однозначно определяют каждую строку таблицы, отдельный первичный ключ не требуется. Свойства *InstructorID* и *CourseID* должны выступать в качестве составного первичного ключа. Единственным способом указать составные первичные ключи для EF является *текучий API* (с помощью атрибутов это сделать невозможно). Настройка составного первичного ключа описана в следующем разделе.

Составной ключ позволяет использовать несколько строк для одного курса и несколько строк для одного преподавателя, а также не позволяет использовать несколько строк для одного преподавателя и курса. Сущность соединения `Enrollment` определяет собственный первичный ключ, поэтому подобные дубликаты возможны. Для предотвращения таких повторяющихся значений добавьте уникальный индекс для полей внешнего ключа или настройте `Enrollment` с первичным составным ключом аналогично `CourseAssignment`. Дополнительные сведения см. в разделе [Индексы](/ef/core/modeling/indexes).

## <a name="update-the-database-context"></a>Обновление контекста базы данных

Добавьте выделенный ниже код в файл *Data/SchoolContext.cs*:

[!code-csharp[](intro/samples/cu/Data/SchoolContext.cs?name=snippet_BeforeInheritance&highlight=15-18,25-31)]

Этот код добавляет новые сущности и настраивает составной первичный ключ сущности CourseAssignment.

## <a name="about-a-fluent-api-alternative"></a>Сведения об альтернативе текучему API

Код в предыдущем методе `OnModelCreating` класса `DbContext` использует для настройки поведения EF *текучий API*. Этот API называется "текучим", так как часто используется для объединения серии вызовов методов в один оператор, как показано в этом примере из [документации по EF Core](/ef/core/modeling/#methods-of-configuration):

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>()
        .Property(b => b.Url)
        .IsRequired();
}
```

В этом руководстве текучий API используется только для сопоставления базы данных, которое невозможно выполнить с помощью атрибутов. Однако текучий API позволяет задать большинство правил форматирования, проверки и сопоставления, которые можно указать с помощью атрибутов. Некоторые атрибуты, такие как `MinimumLength`, невозможно применить с текучим API. Как упоминалось ранее, `MinimumLength` не изменяет схему, а лишь применяет правило проверки на стороне клиента и сервера.

Некоторые разработчики предпочитают использовать текучий API монопольно, чтобы оставить свои классы сущностей "чистыми". Атрибуты и текучий API можно смешивать, и существует несколько конфигураций, которые можно реализовать только с помощью текучего API. На практике рекомендуется выбрать один из этих двух подходов и использовать его максимально согласованно. Если вы используете оба, обратите внимание, что при любом конфликте текучий API переопределяет атрибуты.

Дополнительные сведения о сравнении атрибутов и текучего API см. в разделе [Методы конфигурации](/ef/core/modeling/#methods-of-configuration).

## <a name="entity-diagram-showing-relationships"></a>Схема сущностей, показывающая связи

Ниже показана схема, создаваемая средствами Entity Framework Power Tools для завершенной модели School.

![Схема сущностей](complex-data-model/_static/diagram.png)

Кроме линий связей один ко многим (1 к \*), здесь можно видеть линию связи один к нулю или к одному (1 к 0..1) между сущностями Instructor и OfficeAssignment, а также линию связи нуль или один ко многим (0..1 to *) между сущностями Instructor и Department.

## <a name="seed-database-with-test-data"></a>Начальное заполнение базы данных тестовыми данными

Замените код в файле *Data/DbInitializer.cs* на приведенный ниже, чтобы предоставить начальные данные для созданных вами сущностей.

[!code-csharp[](intro/samples/cu/Data/DbInitializer.cs?name=snippet_Final)]

Как можно было заметить в первом руководстве, основная часть кода просто создает объекты сущности и загружает демонстрационные данные в свойства для тестирования. Обратите внимание, как обрабатываются связи многие ко многим: код формирует связи, создавая сущности в наборах сущностей соединения `Enrollments` и `CourseAssignment`.

## <a name="add-a-migration"></a>Добавление миграции

Сохраните изменения и выполните сборку проекта. Затем откройте командное окно в папке проекта и введите команду `migrations add` (команду update-database пока не выполняйте):

```console
dotnet ef migrations add ComplexDataModel
```

Вы получаете предупреждение о возможной потере данных.

```text
An operation was scaffolded that may result in the loss of data. Please review the migration for accuracy.
Done. To undo this action, use 'ef migrations remove'
```

Если попытаться выполнить команду `database update` на этом этапе (пока этого делать не нужно), возникнет следующая ошибка:

> The ALTER TABLE statement conflicted with the FOREIGN KEY constraint "FK_dbo.Course_dbo.Department_DepartmentID". The conflict occurred in database "ContosoUniversity", table "dbo.Department", column 'DepartmentID'. (Оператор ALTER TABLE конфликтовал с ограничением FOREIGN KEY "FK_dbo.Course_dbo.Department_DepartmentID". Конфликт возник в столбце "DepartmentID" таблицы "dbo.Department" базы данных "ContosoUniversity".)

Иногда при выполнении миграций с существующими данными необходимо вставить данные-заглушки в базу данных для соблюдения ограничений внешнего ключа. Созданный код в методе `Up` добавляет внешний ключ DepartmentID, не допускающий значение null, в таблицу Course. Если при запуске кода в таблице Course уже имеются строки, операция `AddColumn` завершается неудачей, так как SQL Server не знает, какое значение поставить в столбце, который не допускает значение null. В этом учебнике вы запустите миграцию в новую базу данных, но в реальном приложении потребуется обеспечить обработку существующих данных в этой миграции, соответствующий пример приведен ниже.

Чтобы заставить эту миграцию работать с существующими данными, нужно изменить код, чтобы присвоить новому столбцу значение по умолчанию, а также создать кафедру-заглушку с именем "Temp" для использования по умолчанию. В результате существующие строки Course будут связаны с кафедрой "Temp" после выполнения метода `Up`.

* Откройте файл *{метка_времени}_ComplexDataModel.cs*.

* Закомментируйте строку кода, которая добавляет столбец DepartmentID в таблицу Course.

  [!code-csharp[](intro/samples/cu/Migrations/20170215234014_ComplexDataModel.cs?name=snippet_CommentOut&highlight=9-13)]

* Добавьте выделенный ниже код после кода, создающего таблицу Department:

  [!code-csharp[](intro/samples/cu/Migrations/20170215234014_ComplexDataModel.cs?name=snippet_CreateDefaultValue&highlight=22-32)]

В реальном приложении вам потребуется написать код или сценарии для добавления строк Department, а также для связи строк Course с новыми строками Department. После этого кафедра "Temp" и значение по умолчанию в столбце Course.DepartmentID вам больше не понадобятся.

Сохраните изменения и выполните сборку проекта.

## <a name="change-the-connection-string"></a>Изменение строки подключения

Теперь у вас есть новый код в классе `DbInitializer`, который добавляет начальные данные для новых сущностей в пустую базу данных. Чтобы велеть EF создать пустую базу данных, в файле *appsettings.json* измените имя базы данных в строке подключения на ContosoUniversity3 или другое имя, которое вы еще не использовали на компьютере, с которым работаете.

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=ContosoUniversity3;Trusted_Connection=True;MultipleActiveResultSets=true"
  },
```

Сохраните изменения в *appsettings.json*.

> [!NOTE]
> Вместо изменения имени базы данных можно удалить ее. Воспользуйтесь **обозревателем объектов SQL Server** (SSOX) или командой интерфейса командной строки `database drop`:
> ```console
> dotnet ef database drop
> ```

## <a name="update-the-database"></a>Обновление базы данных

После изменения имени базы данных или ее удаления запустите команду `database update` в командном окне, чтобы выполнить миграции.

```console
dotnet ef database update
```

Запустите приложение, чтобы метод `DbInitializer.Initialize` запустился и заполнил новую базу данных.

Откройте базу данных в SSOX, как уже делали это раньше, а затем разверните узел **Таблицы**, чтобы увидеть все созданные таблицы. (Если SSOX уже был открыт, нажмите кнопку **Обновить**.)

![Таблицы в SSOX](complex-data-model/_static/ssox-tables.png)

Запустите приложение, чтобы активировать код инициализатора, заполняющий базу данных.

Щелкните правой кнопкой мыши таблицу **CourseAssignment** и выберите пункт **Просмотреть данные**, чтобы убедиться в наличии данных.

![Данные CourseAssignment в SSOX](complex-data-model/_static/ssox-ci-data.png)

## <a name="get-the-code"></a>Получение кода

[Скачайте или ознакомьтесь с готовым приложением.](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-mvc/intro/samples/cu-final)

## <a name="next-steps"></a>Следующие шаги

В этом учебнике рассмотрены следующие задачи.

> [!div class="checklist"]
> * Настройка модели данных
> * Изменения сущности Student
> * Создание сущности Instructor
> * Создание сущности OfficeAssignment
> * Изменение сущности Course
> * Создание сущности Department
> * Изменение сущности Enrollment
> * Обновление контекста базы данных
> * Начальное заполнение базы данных тестовыми данными
> * Добавление миграции
> * Изменение строки подключения
> * Обновление базы данных

В следующем руководстве описано, как получить доступ к связанным данным.
> [!div class="nextstepaction"]
> [Получение доступа к связанным данным](read-related-data.md)
