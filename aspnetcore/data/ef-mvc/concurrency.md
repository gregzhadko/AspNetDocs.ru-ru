---
title: Учебник. Использование ASP.NET Core MVC с EF Core. Обработка параллелизма
description: Это руководство описывает, как обрабатывать конфликты, когда несколько пользователей одновременно изменяют одну сущность.
author: rick-anderson
ms.author: tdykstra
ms.custom: mvc
ms.date: 02/05/2019
ms.topic: tutorial
uid: data/ef-mvc/concurrency
ms.openlocfilehash: 7b18927d5d528ec2951087502e26b2b30214f389
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57049051"
---
# <a name="tutorial-handle-concurrency---aspnet-mvc-with-ef-core"></a>Учебник. Использование ASP.NET Core MVC с EF Core. Обработка параллелизма

В предыдущих учебниках вы узнали, как обновлять данные. Это руководство описывает, как обрабатывать конфликты, когда несколько пользователей одновременно изменяют одну сущность.

Вы создадите веб-страницы, которые работают с сущностью Department и обрабатывают ошибки параллелизма. На следующих рисунках показаны страницы "Edit" (Редактирование) и "Delete" (Удаление), включая некоторые сообщения, которые отображаются при возникновении конфликта параллелизма.

![Страница редактирования кафедры](concurrency/_static/edit-error.png)

![Страница удаления кафедры](concurrency/_static/delete-error.png)

В этом учебнике рассмотрены следующие задачи.

> [!div class="checklist"]
> * Дополнительные сведения о конфликтах параллелизма
> * Добавление свойства отслеживания
> * Создание представлений и контроллера кафедр
> * Обновление представления указателя
> * Обновление методов редактирования
> * Обновление представления редактирования
> * Тестирование конфликтов параллелизма
> * Обновление страницы удаления
> * Обновление представлений Details и Create

## <a name="prerequisites"></a>Предварительные требования

* [Обновление связанных данных с использованием EF Core в веб-приложении MVC ASP.NET Core](update-related-data.md)

## <a name="concurrency-conflicts"></a>Конфликты параллелизма

Конфликт параллелизма возникает, когда один пользователь отображает данные сущности, чтобы изменить их, а другой пользователь обновляет данные той же сущности до того, как изменение первого пользователя будет записано в базу данных. Если не включить обнаружение таких конфликтов, то пользователь, обновляющий базу данных последним, перезаписывает изменения другого пользователя. Во многих приложениях такой риск допустим: при небольшом числе пользователей или обновлений, а также в случае, если перезапись некоторых изменений не является критической, стоимость реализации параллелизма может перевесить его преимущества. В этом случае вам не нужно настраивать приложение для обработки конфликтов параллелизма.

### <a name="pessimistic-concurrency-locking"></a>Пессимистичный параллелизм (блокировка)

Если приложению нужно предотвратить случайную потерю данных в сценариях параллелизма, одним из способов сделать это являются блокировки базы данных. Это называется пессимистичным параллелизмом. Например, перед чтением строки из базы данных вы запрашиваете блокировку для доступа для обновления или только для чтения. Если заблокировать строку для обновления, другие пользователи не могут заблокировать ее для обновления или только для чтения, так как получат копию данных, которые находятся в процессе изменения. Если заблокировать строку только для чтения, другие пользователи также могут заблокировать ее только для чтения, но не для обновления.

Управление блокировками имеет недостатки. Оно может оказаться сложным с точки зрения программирования. Оно требует значительных ресурсов управления базами данных, а также может вызвать проблемы с производительностью по мере увеличения числа пользователей приложения. Поэтому не все системы управления базами данных поддерживают пессимистичный параллелизм. В Entity Framework Core нет встроенной поддержки этой функции, и данное руководство не рассказывает, как ее реализовать.

### <a name="optimistic-concurrency"></a>Оптимистическая блокировка

Альтернативой пессимистичному параллелизму является оптимистичный параллелизм (оптимистическая блокировка). Оптимистическая блокировка допускает появление конфликтов параллелизма, а затем обрабатывает их соответствующим образом. Например, Мария посещает страницу изменения кафедры и изменяет бюджет кафедры английской языка с 350 000,00 USD на 0,00 USD.

![Изменение бюджета на 0](concurrency/_static/change-budget.png)

Прежде чем Мария нажимает кнопку **Save** (Сохранить), Дмитрий заходит на ту же страницу и изменяет значение в поле "Start Date" (Дата начала) с 9/1/2007 на 9/1/2013.

![Изменение начальной даты на 2013 г.](concurrency/_static/change-date.png)

Сначала Мария нажимает кнопку **Save** (Сохранить) и видит свое изменение, когда браузер возвращается на страницу индекса.

![Бюджет изменен на нуль](concurrency/_static/budget-zero.png)

Затем Дмитрий нажимает кнопку **Save** (Сохранить) на странице редактирования, где все еще отображается бюджет 350 000,00 USD. Дальнейший ход событий определяется порядком обработки конфликтов параллелизма.

Некоторые параметры перечислены ниже:

* Вы можете отслеживать, для какого свойства пользователь изменил и обновил только соответствующие столбцы в базе данных.

     В этом примере сценария данные не будут потеряны, так как эти два пользователя обновляли разные свойства. Когда какой-либо пользователь просмотрит кафедру английского языка в следующий раз, он увидит изменения, внесенные как Марией, так и Дмитрием — дату начала 9/1/2013 и бюджет в нуль долларов США. Этот метод обновления помогает снизить число конфликтов, которые могут привести к потере данных, но не позволяет избежать такой потери, когда конкурирующие изменения вносятся в одно свойство сущности. То, работает ли Entity Framework в таком режиме, зависит от того, как вы реализуете код обновления. В веб-приложении это часто нецелесообразно, так как может потребоваться обрабатывать большой объем состояний, чтобы отслеживать все исходные значения свойств для сущности, а также новые значения. Обработка большого объема состояний может повлиять на производительность приложения, так как требует ресурсов сервера или должна быть включена непосредственно в веб-страницу (например, в скрытые поля) или файл cookie.

* Вы можете позволить изменению Дмитрия перезаписать изменение Марии.

     Когда какой-либо пользователь просмотрит кафедру английского языка в следующий раз, он увидит дату 9/1/2013 и восстановленное значение 350 000,00 USD. Такой подход называется *победой клиента* или *сохранением последнего внесенного изменения*. (Все значения из клиента имеют приоритет над данными в хранилище.) Как отмечено во введении к этому разделу, если вы не пишете код для обработки параллелизма, она выполняется автоматически.

* Вы можете запретить обновление изменения Дмитрия в базе данных.

     Как правило, следует отобразить сообщение об ошибке, показать текущее состояние данных и позволить ему повторно применить свои изменения, если они ему нужны. Это называется *победой хранилища*. (Значения в хранилище имеют приоритет над данными, передаваемыми клиентом.) В этом руководстве вы реализуете сценарий победы хранилища. Данный метод гарантирует, что никакие изменения не перезаписываются без оповещения пользователя о случившемся.

### <a name="detecting-concurrency-conflicts"></a>Обнаружение конфликтов параллелизма

Конфликты можно разрешать путем обработки исключений `DbConcurrencyException`, выдаваемых Entity Framework. Чтобы определить, когда именно нужно выдавать исключения, платформа Entity Framework должна быть в состоянии обнаруживать конфликты. Поэтому нужно соответствующим образом настроить базу данных и модель данных. Ниже приведены некоторые варианты для реализации обнаружения конфликтов:

* Включите в таблицу базы данных столбец отслеживания, который позволяет определять, когда была изменена строка. Затем можно настроить Entity Framework для включения этого столбца в предложение Where команд SQL Update или Delete.

     Типом данных для столбца отслеживания обычно является `rowversion`. Значение `rowversion` является последовательным номером, увеличивающимся при каждом обновлении строки. В команде Update или Delete предложение Where содержит исходное значение столбца отслеживания (исходную версию строки). Если обновляемая строка была изменена другим пользователем, значение в столбце `rowversion` отличается от исходного значения, поэтому оператору Update или Delete не удается найти строку для обновления из-за предложения Where. Когда платформа Entity Framework обнаруживает, что ни одна из строк не была обновлена с помощью команды Update или Delete (то есть число затронутых строк равно нулю), она интерпретирует это как конфликт параллелизма.

* Настройте Entity Framework для включения исходного значения каждого столбца таблицы в предложение Where команд Update и Delete.

     Как и в случае с первым вариантом, если с момента первого чтения в строке что-либо изменилось, предложение Where не возвращает строку для обновления, что платформа Entity Framework интерпретирует как конфликт параллелизма. Для таблиц базы данных со множеством столбцов этот подход может привести к очень большим предложениям Where и потребовать обрабатывать большой объем состояний. Как было указано ранее, обслуживание большого объема состояний может негативно повлиять на производительность приложения. Поэтому в общем случае данный подход не рекомендуется, кроме того, он не применяется и в этом руководстве.

     Если вы хотите реализовать этот подход к параллелизму, нужно пометить все свойства, не относящиеся к первичному ключу, в сущности, где требуется отслеживать параллелизм, добавив к ним атрибут `ConcurrencyCheck`. Это изменение позволяет Entity Framework включить все столбцы в предложение Where SQL операторов Update и Delete.

В оставшейся части этого руководства вам предстоит добавить свойство отслеживания `rowversion` в сущность Department, создать контроллер и представления, а также проверить правильность работы решения.

## <a name="add-a-tracking-property"></a>Добавление свойства отслеживания

В *Models/Department.cs* добавьте свойство отслеживания RowVersion:

[!code-csharp[](intro/samples/cu/Models/Department.cs?name=snippet_Final&highlight=26,27)]

Атрибут `Timestamp` указывает, что этот столбец будет включен в предложение Where команд Update и Delete, отправляемых в базу данных. Этот атрибут называется `Timestamp`, так как предыдущие версии SQL Server использовали тип данных `timestamp` SQL, пока его не сменил `rowversion`. Тип .NET для `rowversion` — это массив байтов.

Если вы предпочитаете использовать текучий API, можно воспользоваться методом `IsConcurrencyToken` (в *Data/SchoolContext.cs*), чтобы указать свойство отслеживания, как показано в следующем примере:

```csharp
modelBuilder.Entity<Department>()
    .Property(p => p.RowVersion).IsConcurrencyToken();
```

Добавив свойство, вы изменили модель базы данных, поэтому нужно выполнить еще одну миграцию.

Сохраните изменения, выполните сборку проекта и введите в командном окне следующие команды:

```console
dotnet ef migrations add RowVersion
```

```console
dotnet ef database update
```

## <a name="create-departments-controller-and-views"></a>Создание представлений и контроллера кафедр

Сформируйте шаблоны для контроллера кафедр и представлений, как делали это раньше для учащихся, курсов и преподавателей.

![Формирование шаблона кафедр](concurrency/_static/add-departments-controller.png)

В файле *DepartmentsController.cs* измените все четыре экземпляра "FirstMidName" на "FullName", чтобы раскрывающиеся списки для администратора кафедры содержали полное имя преподавателя, а не только фамилию.

[!code-csharp[](intro/samples/cu/Controllers/DepartmentsController.cs?name=snippet_Dropdown)]

## <a name="update-index-view"></a>Обновление представления указателя

Подсистема формирования шаблонов создала столбец RowVersion для представления индекса, однако это поле не должно отображаться.

Замените код в файле *Views/Departments/Index.cshtml* на приведенный ниже код.

[!code-html[](intro/samples/cu/Views/Departments/Index.cshtml?highlight=4,7,44)]

Он изменяет заголовок на "Departments" (Кафедры), удаляет столбец RowVersion и отображает администратору имя и фамилию, а не только имя.

## <a name="update-edit-methods"></a>Обновление методов редактирования

Добавьте `AsNoTracking` в оба метода — HttpGet `Edit` и `Details`. В методе HttpGet `Edit` добавьте безотложную загрузку для администратора.

[!code-csharp[](intro/samples/cu/Controllers/DepartmentsController.cs?name=snippet_EagerLoading&highlight=2,3)]

Замените существующий код в методе HttpPost`Edit` следующим кодом:

[!code-csharp[](intro/samples/cu/Controllers/DepartmentsController.cs?name=snippet_EditPost)]

Код начинает пытаться считать кафедру для обновления. Если метод `SingleOrDefaultAsync` возвращает значение null, кафедра была удалена другим пользователем. В этом случае код использует переданные значения из формы для создания сущности кафедры, чтобы страницу "Edit" (Редактирование) можно было отобразить повторно с сообщением об ошибке. Кроме того, повторно создать сущность кафедры не нужно, если вы выводите только сообщение об ошибке без повторного отображения полей кафедры.

Представление сохраняет исходное значение `RowVersion` в скрытом поле, а данный метод получает это значение в параметре `rowVersion`. Перед вызовом `SaveChanges` нужно поместить это исходное значение свойства `RowVersion` в коллекцию `OriginalValues` для сущности.

```csharp
_context.Entry(departmentToUpdate).Property("RowVersion").OriginalValue = rowVersion;
```

Когда позднее Entity Framework создает команду SQL UPDATE, она будет содержать предложение WHERE, которое ищет строку с исходным значением `RowVersion`. Если команда UPDATE не затрагивает никакие строки (нет строк, имеющих исходное значение `RowVersion`), Entity Framework выдает исключение `DbUpdateConcurrencyException`.

Код в блоке catch для этого исключения возвращает затронутую сущность Department, имеющую обновленные значения из свойства `Entries` в объекте исключения.

[!code-csharp[](intro/samples/cu/Controllers/DepartmentsController.cs?range=164)]

Коллекция `Entries` будет иметь всего один объект `EntityEntry`.  Вы можете использовать его для получения новых значений, введенных пользователем, и текущих значений в базе данных.

[!code-csharp[](intro/samples/cu/Controllers/DepartmentsController.cs?range=165-166)]

Код добавляет настраиваемое сообщение об ошибке для каждого столбца, для которого значения базы данных отличаются от введенных пользователем на странице "Edit" (Редактирование) (здесь для краткости показано всего одно поле).

[!code-csharp[](intro/samples/cu/Controllers/DepartmentsController.cs?range=174-178)]

Наконец, код задает для `RowVersion` объекта `departmentToUpdate` новое значение, полученное из базы данных. Это новое значение `RowVersion` будет сохранено в скрытом поле при повторном отображении страницы "Edit" (Редактирование). Когда пользователь в следующий раз нажимает кнопку **Save** (Сохранить), перехватываются только те ошибки параллелизма, которые возникли с момента повторного отображения страницы "Edit" (Редактирование).

[!code-csharp[](intro/samples/cu/Controllers/DepartmentsController.cs?range=199-200)]

Оператор `ModelState.Remove` является обязательным, так как `ModelState` имеет старое значение `RowVersion`. На представлении значение `ModelState` для поля имеет приоритет над значениями свойств модели, если они присутствуют вместе.

## <a name="update-edit-view"></a>Обновление представления редактирования

Внесите следующие изменения в файл *Views/Departments/Edit.cshtml*:

* Добавьте скрытое поле для сохранения значения свойства `RowVersion` сразу после скрытого поля для свойства `DepartmentID`.

* Добавьте пункт "Select Administrator" (Выбрать администратора) в раскрывающийся список.

[!code-html[](intro/samples/cu/Views/Departments/Edit.cshtml?highlight=16,34-36)]

## <a name="test-concurrency-conflicts"></a>Тестирование конфликтов параллелизма

Запустите приложение и перейдите на страницу индекса кафедр. Щелкните правой кнопкой мыши гиперссылку **Edit** (Изменить) для кафедры английского языка и выберите пункт **Открыть на новой вкладке**, а затем щелкните гиперссылку **Edit** (Изменить) для этой кафедры. Теперь на обеих вкладках браузера отображаются одинаковые сведения.

Измените поле на первой вкладке браузера и нажмите кнопку **Save** (Сохранить).

![Страница "Edit" (Редактирование) кафедры 1 после изменения](concurrency/_static/edit-after-change-1.png)

В браузере отображается страница индекса с измененным значением.

Измените поле на второй вкладке браузера.

![Страница "Edit" (Редактирование) кафедры 2 после изменения](concurrency/_static/edit-after-change-2.png)

Нажмите кнопку **Сохранить**. Отображается сообщение об ошибке:

![Сообщение об ошибке для страницы "Edit" (Редактирование) кафедры](concurrency/_static/edit-error.png)

Снова нажмите кнопку **Save** (Сохранить). Сохраняется значение, введенное на второй вкладке браузера. Сохраненные значения отображаются при открытии страницы индекса.

## <a name="update-the-delete-page"></a>Обновление страницы удаления

Для страницы "Delete" (Удаление) платформа Entity Framework обнаруживает конфликты параллелизма, вызванные схожим изменением кафедры. Когда метод HttpGet `Delete` отображает представление подтверждения, оно содержит исходное значение `RowVersion` в скрытом поле. Затем это значение становится доступным для метода HttpPost `Delete`, вызываемого при подтверждении удаления пользователем. Когда Entity Framework создает команду SQL DELETE, она включает предложение WHERE с исходным значением `RowVersion`. Если команда не затрагивает ни одной строки (подразумевается изменение строки после отображения страницы подтверждения удаления), возникает исключение параллелизма и вызывается метод HttpGet `Delete`, у которого для флага ошибки установлено значение true, чтобы повторно отобразить страницу подтверждения с сообщением об ошибке. Отсутствие затронутых строк также может быть вызвано тем, что строка была удалена другим пользователем, и в этом случае сообщение об ошибке не отображается.

### <a name="update-the-delete-methods-in-the-departments-controller"></a>Обновление методов Delete в контроллере кафедр

В файле *DepartmentsController.cs* замените код метода HttpGet `Delete` приведенным ниже кодом:

[!code-csharp[](intro/samples/cu/Controllers/DepartmentsController.cs?name=snippet_DeleteGet&highlight=1,10,14-17,21-29)]

Этот метод принимает необязательный параметр, который указывает, отображается ли страница повторно после ошибки параллелизма. Если этот флаг имеет значение true, а указанная кафедра больше не существует, она была удалена другим пользователем. В этом случае код выполняет перенаправление на страницу индекса.  Если этот флаг имеет значение true, а кафедра существует, она была изменена другим пользователем. В этом случае код отправляет сообщение об ошибке в представление, используя `ViewData`.

Замените код в методе HttpPost`Delete` (с именем `DeleteConfirmed`) следующим кодом:

[!code-csharp[](intro/samples/cu/Controllers/DepartmentsController.cs?name=snippet_DeletePost&highlight=1,3,5-8,11-18)]

В шаблонном коде, который вы только что заменили, этот метод принимал только идентификатор записи:

```csharp
public async Task<IActionResult> DeleteConfirmed(int id)
```

Вы изменили этот параметр на экземпляр Department, созданный связывателем модели. Это предоставляет EF доступ к значению свойства RowVersion в дополнение к ключу записи.

```csharp
public async Task<IActionResult> Delete(Department department)
```

Вы также изменили имя метода действия с `DeleteConfirmed` на `Delete`. Шаблонный код использовал имя `DeleteConfirmed`, чтобы предоставить методу HttpPost уникальную сигнатуру. (Среда CLR требует, чтобы перегруженные методы имели разные параметры метода.) Теперь, когда сигнатуры являются уникальными, можно придерживаться соглашения MVC и использовать одинаковое имя для методов delete HttpGet и HttpPost.

Если кафедра уже удалена, метод `AnyAsync` возвращает значение false, а приложение просто возвращается к методу Index.

При перехвате ошибки параллелизма код повторно отображает страницу подтверждения удаления и предоставляет флаг, указывающий, что нужно отобразить сообщение об ошибке параллелизма.

### <a name="update-the-delete-view"></a>Обновление представления удаления

В файле *Views/Departments/Delete.cshtml* замените шаблонный код приведенным ниже кодом, который добавляет поле сообщения об ошибке и скрытые поля для свойств DepartmentID и RowVersion. Изменения выделены.

[!code-html[](intro/samples/cu/Views/Departments/Delete.cshtml?highlight=9,38,44,45,48)]

Этот код вносит следующие изменения:

* Добавляет сообщение об ошибке между заголовками `h2` и `h3`.

* Заменяет FirstMidName на FullName в поле **Administrator** (Администратор).

* Удаляет поле RowVersion.

* Добавляет скрытое поле для свойства `RowVersion`.

Запустите приложение и перейдите на страницу индекса кафедр. Щелкните правой кнопкой мыши гиперссылку **Delete** (Удалить) для кафедры английского языка и выберите пункт **Открыть на новой вкладке**, а затем на первой вкладке щелкните гиперссылку **Edit** (Изменить) для этой кафедры.

В первом окне измените одно из значений и нажмите кнопку **Save** (Сохранить):

![Страница "Edit" (Редактирование) кафедры после изменения и до удаления](concurrency/_static/edit-after-change-for-delete.png)

На второй вкладке нажмите кнопку **Delete** (Удалить). Вы видите сообщение об ошибке параллелизма, а значения кафедры обновляются с использованием актуальных сведений из базы данных.

![Страница подтверждения удаления кафедры с ошибкой параллелизма](concurrency/_static/delete-error.png)

Если нажать кнопку **Delete** (Удалить) еще раз, вы будете перенаправлены на страницу индекса, которая показывает, что кафедра была удалена.

## <a name="update-details-and-create-views"></a>Обновление представлений Details и Create

При необходимости вы можете очистить шаблонный код в представлениях Details и Create.

Замените код в *Views/Departments/Details.cshtml*, чтобы удалить столбец RowVersion и отобразить полное имя администратора.

[!code-html[](intro/samples/cu/Views/Departments/Details.cshtml?highlight=35)]

Замените код в *Views/Departments/Create.cshtml*, чтобы добавить параметр "Select" (Выбрать) в раскрывающийся список.

[!code-html[](intro/samples/cu/Views/Departments/Create.cshtml?highlight=32-34)]

## <a name="get-the-code"></a>Получение кода

[Скачайте или ознакомьтесь с готовым приложением.](https://github.com/aspnet/Docs/tree/master/aspnetcore/data/ef-mvc/intro/samples/cu-final)

## <a name="additional-resources"></a>Дополнительные ресурсы

 Дополнительные сведения об обработке параллелизма в EF Core см. в разделе [Конфликты параллелизма](/ef/core/saving/concurrency).

## <a name="next-steps"></a>Следующие шаги

В этом учебнике рассмотрены следующие задачи.

> [!div class="checklist"]
> * Дополнительные сведения о конфликтах параллелизма
> * Добавление свойства отслеживания
> * Создание представлений и контроллера кафедр
> * Обновление представления указателя
> * Обновление методов редактирования
> * Обновление представления редактирования
> * Тестирование конфликтов параллелизма
> * Обновление страницы удаления
> * Обновление представлений сведений и создания

В следующем руководстве описано, как реализовать наследование "одна таблица на иерархию" для сущностей Instructor и Student.
> [!div class="nextstepaction"]
> [Реализация наследования типа "одна таблица на иерархию"](inheritance.md)
