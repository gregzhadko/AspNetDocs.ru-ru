---
title: Меньше, Sass и Font Awesome в ASP.NET Core
author: ardalis
description: Узнайте, как использовать меньше, Sass и Font Awesome в приложениях ASP.NET Core.
ms.author: tdykstra
ms.date: 10/14/2016
uid: client-side/less-sass-fa
ms.openlocfilehash: 2229c4e3b0238ff17c15e78f657b9acb10495c72
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57065561"
---
# <a name="less-sass-and-font-awesome-in-aspnet-core"></a>Меньше, Sass и Font Awesome в ASP.NET Core

Автор: [Стив Смит](https://ardalis.com/) (Steve Smith)

Пользователи веб-приложений имеют более высокий уровень ожиданий, когда дело доходит до применения стиля и в целом столкнуться. Современные веб-приложения часто используют большой набор средств и платформ для определения и управления их внешний вид согласованным способом. Платформы, такие как [Bootstrap](http://getbootstrap.com/) может сыграть относительно определения общего набора стили и параметры макета для веб-сайтов. Однако большинство сайтов нетривиальные также преимущества возможность эффективно определять и поддерживать стили и каскадные таблицы стилей (CSS), а также простой доступ к не изображения значков, которые сделают более интуитивно понятный интерфейс веб-узла. Именно здесь языки и инструменты, которые поддерживают [меньше](http://lesscss.org/) и [Sass](http://sass-lang.com/), и библиотеки, например [Font Awesome](http://fontawesome.io/), бывают.

## <a name="css-preprocessor-languages"></a>Языки препроцессора CSS

Языки, которые компилируются в других языках, чтобы улучшить возможности работы с базовый язык, называются препроцессорами. Существует два популярных препроцессорами для CSS: Менее и Sass.  Эти препроцессорами Добавление компонентов к CSS, например поддержка переменных и вложенные правила, которые для более удобного обслуживания больших и сложных таблиц стилей. CSS, как язык является очень простым, отсутствует поддержка даже такой простой, как переменные, и как правило, это сделать файлы CSS, повторяющихся и перегруженными. Добавление реальных языковых функций через препроцессорами может помочь сократить дублирование и обеспечить улучшенную организацию правил стилей. Visual Studio предоставляет встроенную поддержку обоих Less и Sass, а также расширения, которые можно улучшить процесс разработки, при работе с этими языками.

Рассмотрим краткий пример как препроцессорами повышает удобочитаемость и обслуживаемость информации о стилях CSS:

```css
.header {
    color: black;
    font-weight: bold;
    font-size: 18px;
    font-family: Helvetica, Arial, sans-serif;
}

.small-header {
    color: black;
    font-weight: bold;
    font-size: 14px;
    font-family: Helvetica, Arial, sans-serif;
}
```

С помощью меньше, это можно переписать, чтобы избавиться от дублирования, с помощью *примеси* (с разделителями «mix» позволяет свойства из одного класса или набор правил в другой):

```less
.header {
    color: black;
    font-weight: bold;
    font-size: 18px;
    font-family: Helvetica, Arial, sans-serif;
}

.small-header {
    .header;
    font-size: 14px;
}
```

## <a name="less"></a>меньше

CSS менее препроцессора выполняется с помощью Node.js. Чтобы установить, меньше, используйте диспетчер пакетов Node (npm) из командной строки (-g означает «глобальные»):

```console
npm install -g less
```

Если вы используете Visual Studio, вы можете начать работу с меньшими усилиями, добавив один или несколько меньше файлов в проект, а затем настроив Gulp или Grunt для обрабатывать их во время компиляции. Добавить *стили* папки в проект, а затем добавьте новый файл с именем Less *main.less* в эту папку.

![Добавьте файл less](less-sass-fa/_static/add-less-file.png)

После добавления структуры папок должна выглядеть следующим образом:

![Структура папок](less-sass-fa/_static/folder-structure.png)

Теперь можно добавить некоторые основные стили в файл, который будет скомпилирован в CSS и развернут в папку wwwroot, Gulp.

Изменить *main.less* для включения следующим содержимым, который создает простой цветовой палитрой из одного основного цвета.

```less
@base: #663333;
@background: spin(@base, 180);
@lighter: lighten(spin(@base, 5), 10%);
@lighter2: lighten(spin(@base, 10), 20%);
@darker: darken(spin(@base, -5), 10%);
@darker2: darken(spin(@base, -10), 20%);

body {
    background-color:@background;
}
.baseColor  {color:@base}
.bgLight    {color:@lighter}
.bgLight2   {color:@lighter2}
.bgDark     {color:@darker}
.bgDark2    {color:@darker2}
```

`@base` а другой @-prefixed элементы являются переменными. Каждый из них представляет цвет. За исключением `@base`, их можно установить с помощью функции цвета: Осветление, который затемняется и запустить. Осветление и который затемняется делать практически что вы ожидаете; Счетчик корректирует цветового тона цвета на число градусов (около цветовой круг). Меньше процессор может игнорировать переменные, которые не используются, чтобы продемонстрировать, как работают эти переменные, нам нужно где-нибудь их использовать. Классы `.baseColor`, и т.д. мы рассмотрим вычисляемые значения всех переменных в CSS-файл, который создается.

### <a name="get-started"></a>Начало работы

Создание **файл конфигурации npm** (*package.json*) в папке проекта и изменить его, чтобы ссылаться на `gulp` и `gulp-less`:

```json
{
  "version": "1.0.0",
  "name": "asp.net",
  "private": true,
  "devDependencies": {
    "gulp": "3.9.1",
    "gulp-less": "3.3.0"
  }
}
```

Установка зависимостей, либо в командной строке в папке проекта или в Visual Studio **обозревателе решений** (**зависимости > npm > восстановление пакетов**).

```console
npm install
```

![VS восстановление пакетов](less-sass-fa/_static/restore-packages.png)

В папке проекта создайте **файл конфигурации Gulp** (*gulpfile.js*) для определения автоматизированного процесса.  Добавьте переменную в верхней части файла для представления меньше и меньше выполнение задачи:

```javascript
var gulp = require("gulp"),
  fs = require("fs"),
  less = require("gulp-less");

gulp.task("less", function () {
  return gulp.src('Styles/main.less')
    .pipe(less())
    .pipe(gulp.dest('wwwroot/css'));
});
```

Откройте **Task Runner Explorer** (**представление > другие Windows > Task Runner Explorer**). Используемые задачами, вы должны увидеть новую задачу с именем `less`. Может потребоваться обновить окно.

Запустите `less` задач и вы увидите результат, аналогичный, как показано здесь:

![меньше запускатель задач](less-sass-fa/_static/less-task-runner.png)

*Wwwroot/css* папка теперь содержит новый файл, *main.css*:

![основной css создан](less-sass-fa/_static/main-css-created.png)

Откройте *main.css* и вы увидите примерно следующее:

```css
body {
    background-color: #336666;
}
.baseColor {
    color: #663333;
}
.bgLight {
    color: #884a44;
}
.bgLight2 {
    color: #aa6355;
}
.bgDark {
    color: #442225;
}
.bgDark2 {
    color: #221114;
}
```

Простую HTML-страницу, чтобы добавить *wwwroot* папки и ссылку *main.css* для просмотра цветовую палитру в действии.

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link href="css/main.css" rel="stylesheet" />
    <title></title>
</head>
<body>
    <div>
        <div class="baseColor">BaseColor</div>
        <div class="bgLight">Light</div>
        <div class="bgLight2">Light2</div>
        <div class="bgDark">Dark</div>
        <div class="bgDark2">Dark2</div>
    </div>
</body>
</html>
```

Вы увидите что 180 градусов вращаться во `@base` , использовавшихся для создания `@background` привело к цветовой круг противоположных цвет `@base`:

![Пример менее тестирования](less-sass-fa/_static/less-test-screenshot.png)

Меньше также поддерживает вложенные правила, а также вложенные медиа-запросами. Например определение вложенные иерархии как меню может привести к подробных правил CSS, такие как следующие:

```css
nav {
    height: 40px;
    width: 100%;
}
nav li {
    height: 38px;
    width: 100px;
}
nav li a:link {
    color: #000;
    text-decoration: none;
}
nav li a:visited {
    text-decoration: none;
    color: #CC3333;
}
nav li a:hover {
    text-decoration: underline;
    font-weight: bold;
}
nav li a:active {
    text-decoration: underline;
}
```

В идеале все правила стиля, связанных с будут располагаться друг с другом в CSS-файл, но на практике нет ничего применение этого правила, за исключением соглашение о вызовах и возможно комментариев блоке.

Определив эти же правила, используя меньше выглядит следующим образом:

```less
nav {
    height: 40px;
    width: 100%;
    li {
        height: 38px;
        width: 100px;
        a {
            color: #000;
            &:link { text-decoration:none}
            &:visited { color: #CC3333; text-decoration:none}
            &:hover { text-decoration:underline; font-weight:bold}
            &:active {text-decoration:underline}
        }
    }
}
```

Обратите внимание, что в этом случае все подчиненные элементы `nav` содержатся внутри своей области. Больше не все повторения родительских элементов (`nav`, `li`, `a`), и число строк, общее также (хотя некоторые из, является результатом размещения значений на те же строки во втором примере). Он может быть очень удобно, организационно, чтобы увидеть все правила для данного элемента пользовательского интерфейса в явно связанной области, в этом случае от остальной части файла, заключенные фигурные скобки.

`&` Синтаксис является компонентом селектор меньше с & представляющий родительский объект текущего выделения. В этом случае в пределах {...} блок, `&` представляет `a` тег и, следовательно, `&:link` эквивалентен `a:link`.

Медиа-запросами, очень полезна при создании отвечает архитектуре, могут также активно участвовать в работе повторения и сложности в CSS. Меньше позволяет запросам мультимедиа вкладываются в классы, таким образом, чтобы все определение класса не должно повторяться в пределах разных верхнего уровня `@media` элементов. Например вот CSS быстрые меню:

```css
.navigation {
    margin-top: 30%;
    width: 100%;
}
@media screen and (min-width: 40em) {
    .navigation {
        margin: 0;
    }
}
@media screen and (min-width: 62em) {
    .navigation {
        width: 960px;
        margin: 0;
    }
}
```

Это может быть лучше, определены в меньше как:

```less
.navigation {
    margin-top: 30%;
    width: 100%;
    @media screen and (min-width: 40em) {
        margin: 0;
    }
    @media screen and (min-width: 62em) {
        width: 960px;
        margin: 0;
    }
}
```

Другой особенностью меньше, мы уже видели является поддержка математических операций, позволяя атрибуты стиля были сконструированы из предварительно определенные переменные. В результате обновление связанных стили гораздо проще, так как базовый переменной может быть изменено, и все зависимые значения изменяются автоматически.

Файлы CSS, особенно для больших веб-узлов (и особенно в том случае, если используются медиа-запросами), привлекать довольно большим временем, что делает работу с ними громоздким. Less-файлы можно задать отдельно, затем извлечь их с помощью `@import` директивы. Меньше может также использоваться для импорта отдельных файлов CSS, а также при необходимости.

*Примеси* могут принимать параметры, а меньше поддерживает условную логику в виде из mixin условия, которые предоставляют декларативный способ определения, когда определенные примеси вступают в силу. Обычно для примеси условия используется для настройки цветов на основе света или является темный цвет источника. Учитывая примеси, который принимает параметр для цвета, примеси условие можно использовать для изменения примеси, на основе этого цвета:

```less
.box (@color) when (lightness(@color) >= 50%) {
    background-color: #000;
}
.box (@color) when (lightness(@color) < 50%) {
    background-color: #FFF;
}
.box (@color) {
    color: @color;
}

.feature {
    .box (@base);
}
```

Учитывая текущие `@base` значение `#663333`, меньше он создаст следующий код CSS:

```css
.feature {
    background-color: #FFF;
    color: #663333;
}
```

Меньше предоставляет ряд дополнительных функций, но она должна выдать некоторое представление о степени предварительной обработки языка.

## <a name="sass"></a>Sass

Sass аналогична меньше, предоставляя поддержку многих те же функции, но с немного другой синтаксис. Он создается с помощью Ruby, а не JavaScript и может разные параметры настройки. На исходном языке Sass не использовать фигурные скобки или точкой с запятой, но вместо определенные области с помощью пробелов и отступов. В версии 3 Sass, был представлен новый синтаксис, **SCSS** («Sassy CSS»). SCSS аналогична CSS уровней отступа и пробелы не учитываются, и вместо этого используется точка с запятой и фигурные скобки.

Чтобы установить Sass, обычно вы бы сначала установить Ruby (предварительно установлен в macOS) и выполните:

```console
gem install sass
```

Тем не менее если вы используете Visual Studio, вы можете получить работу с Sass во многом так же как это делается с меньшими усилиями. Откройте *package.json* и добавить пакет «gulp sass» `devDependencies`:

```json
"devDependencies": {
  "gulp": "3.9.1",
  "gulp-less": "3.3.0",
  "gulp-sass": "3.1.0"
}
```

Затем измените *gulpfile.js* Добавление переменной sass и задачи для компиляции файлов Sass и помещает результаты в папке wwwroot:

```javascript
var gulp = require("gulp"),
  fs = require("fs"),
  less = require("gulp-less"),
  sass = require("gulp-sass");

// other content removed

gulp.task("sass", function () {
  return gulp.src('Styles/main2.scss')
    .pipe(sass())
    .pipe(gulp.dest('wwwroot/css'));
});
```

Теперь можно добавить файл Sass *main2.scss* для *стили* папку в корневой папке проекта:

![Добавьте файл scss](less-sass-fa/_static/add-scss-file.png)

Откройте *main2.scss* и добавьте следующий код:

```sass
$base: #CC0000;
body {
    background-color: $base;
}
```

Сохраните все файлы. Теперь при обновлении **Task Runner Explorer**, вы увидите `sass` задачи. Запустите его, а в */wwwroot/css* папки. Теперь есть *main2.css* файл с таким содержимым:

```css
body {
    background-color: #CC0000;
}
```

Sass поддерживает вложение точно так же было меньше обозревателем, предоставляя аналогичные преимущества в отношении. Файлы можно разделить по функциям и включенных с использованием `@import` директивы:

```sass
@import 'anotherfile';
```

Sass поддерживает примеси, с помощью `@mixin` ключевое слово их определения и `@include` Чтобы включить их, как в следующем примере из [sass lang.com](http://sass-lang.com):

```sass
@mixin border-radius($radius) {
    -webkit-border-radius: $radius;
    -moz-border-radius: $radius;
    -ms-border-radius: $radius;
    border-radius: $radius;
}

.box { @include border-radius(10px); }
```

В дополнение к примеси Sass также поддерживает концепцию наследования, позволяя один класс для другого расширения. Он аналогичен примеси, но приводит к меньшим объемом кода CSS. Он выполняется с помощью `@extend` ключевое слово. Чтобы опробовать примеси, добавьте следующий код в ваш *main2.scss* файла:

```sass
@mixin alert {
    border: 1px solid black;
    padding: 5px;
    color: #333333;
}

.success {
    @include alert;
    border-color: green;
}

.error {
    @include alert;
    color: red;
    border-color: red;
    font-weight:bold;
}
```

Изучите выходные данные в *main2.css* после выполнения команды `sass` задачи в **Task Runner Explorer**:

```css
.success {
    border: 1px solid black;
    padding: 5px;
    color: #333333;
    border-color: green;
 }

.error {
    border: 1px solid black;
    padding: 5px;
    color: #333333;
    color: red;
    border-color: red;
    font-weight: bold;
}
```

Обратите внимание на то, что все общие свойства из mixin оповещения повторяются в каждом классе. Mixin аналогичную хорошие помогает исключить дублирование во время разработки, но он по-прежнему создает CSS с большим дублируются, размер которых превышает необходимые файлы CSS - потенциальные проблемы производительности в результате чего.

Теперь замените предупреждения примеси с `.alert` класса и измените `@include` для `@extend` (запоминание расширить `.alert`, а не `alert`):

```sass
.alert {
    border: 1px solid black;
    padding: 5px;
    color: #333333;
}

.success {
    @extend .alert;
    border-color: green;
}

.error {
    @extend .alert;
    color: red;
    border-color: red;
    font-weight:bold;
}
```

Еще раз выполните Sass и проверьте итоговый CSS:

```css
.alert, .success, .error {
    border: 1px solid black;
    padding: 5px;
    color: #333333;
}

.success {
    border-color: green;
}

.error {
    color: red;
    border-color: red;
    font-weight: bold;
}
```

Теперь свойства определяются только как необходимое число раз, и лучше создается CSS.

Sass также включает функции и операции условную логику, аналогичную меньше. На самом деле возможности два языка очень похожи.

## <a name="less-or-sass"></a>Менее или Sass?

По-прежнему не консенсус относительно будь то обычно лучше использовать меньше или Sass (или даже нужно ли предпочитать исходного Sass или новых правил синтаксиса SCSS в Sass). Наверное, наиболее важное решение — **используйте один из этих средств**, а не просто вручную кодировать файлов CSS. После внесения, принятия решений, оба Less и Sass хорошими вариантами являются.

## <a name="font-awesome"></a>Font Awesome

Помимо препроцессорами CSS еще один интересный ресурс для современных веб-приложений стиля замечательно шрифта. Font Awesome — это набор средств, который предоставляет более чем 500 масштабируемого векторного значки, которые могут свободно использоваться в веб-приложениях. Он был изначально разработаны для работы с помощью Bootstrap, но имеет не зависят от этой платформы или на любой библиотеки JavaScript.

Чтобы приступить к работе с Font Awesome проще всего добавить ссылку на него, с помощью своего расположения в общедоступных доставки содержимого сети (CDN):

```html
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
```

Его можно также добавить в проект Visual Studio, добавьте его в «зависимости» в *bower.json*:

```json
{
  "name": "ASP.NET",
  "private": true,
  "dependencies": {
    "bootstrap": "3.0.0",
    "jquery": "1.10.2",
    "jquery-validation": "1.11.1",
    "jquery-validation-unobtrusive": "3.2.2",
    "hammer.js": "2.0.4",
    "bootstrap-touch-carousel": "0.8.0",
    "Font-Awesome": "4.3.0"
  }
}
```

Получив ссылку на Font Awesome на странице, добавление значков для приложения, применяя классы Font Awesome, обычно начинаются с «fa-», чтобы элементов встроенного HTML (такие как `<span>` или `<i>`).  Например можно добавить значки для простых списков и меню, используя следующий код:

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title></title>
    <link href="lib/font-awesome/css/font-awesome.css" rel="stylesheet" />
</head>
<body>
    <ul class="fa-ul">
        <li><i class="fa fa-li fa-home"></i> Home</li>
        <li><i class="fa fa-li fa-cog"></i> Settings</li>
    </ul>
</body>
</html>
```

В результате получается следующий код в браузере, — обратите внимание на значок рядом с каждого элемента:

![значки списка перечислены](less-sass-fa/_static/list-icons-screenshot.png)

Можно просмотреть полный список доступных значков здесь:

http://fontawesome.io/icons/

## <a name="summary"></a>Сводка

Современных веб-приложений требуют все более быстро реагирующих гибких моделей, которые являются чистой, интуитивно понятный и простой в использовании из широкого спектра устройств. Управления, таблиц стилей CSS, необходимые для достижения этих целей лучше всего, менее с помощью препроцессора like или Sass. Кроме того наборы средств, таких как Font Awesome быстро предоставлять хорошо известных значков в меню навигации текстовое и кнопок, повышение общей пользователь работы приложения.
