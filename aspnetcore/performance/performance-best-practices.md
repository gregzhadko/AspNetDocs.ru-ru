---
title: Рекомендации по производительности ASP.NET Core
author: mjrousos
description: Советы для повышения производительности в приложениях ASP.NET Core и как избежать распространенных проблем производительности.
monikerRange: '>= aspnetcore-1.1'
ms.author: riande
ms.date: 1/9/2019
uid: performance/performance-best-practices
ms.openlocfilehash: 25aa4c1e22ead7db4775c6e5e81b6fd627c6d7a6
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57038211"
---
# <a name="aspnet-core-performance-best-practices"></a>Рекомендации по производительности ASP.NET Core

По [Майк Роусос](https://github.com/mjrousos)

В этом разделе приводятся инструкции по производительности рекомендации с помощью ASP.NET Core.

<a name="hot"></a> В этом документе ветви кода определяется как путь кода, который часто называют и где большую часть времени выполнения происходит. "Горячий" путей обычно ограничивают приложения масштабирования и производительности.

## <a name="cache-aggressively"></a>Кэшировать агрессивно

Кэширование обсуждается в нескольких частях этого документа. Дополнительные сведения см. в разделе <xref:performance/caching/response>.

## <a name="avoid-blocking-calls"></a>Избегайте блокирующих вызовов

Приложения ASP.NET Core должно уметь обрабатывать множество запросов одновременно. Асинхронные интерфейсы API позволяют небольшой пул потоков для обработки тысяч одновременных запросов, не ожидая на блокирования вызовов. Вместо того чтобы ожидание завершения выполнения задачи синхронной выполняющейся длительное время, поток может работать на другой запрос.

Распространенные проблемы с производительностью в приложениях ASP.NET Core блокирует вызовы, которые могут выполняться асинхронно. Многие синхронных вызовов блокировки приводит к [нехватка потоков пула](https://blogs.msdn.microsoft.com/vancem/2018/10/16/diagnosing-net-core-threadpool-starvation-with-perfview-why-my-service-is-not-saturating-all-cores-or-seems-to-stall/) и снижения времени отклика.

**Не**:

* Блокировать асинхронное выполнение путем вызова [Task.Wait](/dotnet/api/system.threading.tasks.task.wait) или [Task.Result](/dotnet/api/system.threading.tasks.task-1.result).
* Блокировки в общих путей кода. Приложения ASP.NET Core — это самых производительных, когда создано для запуска кода в параллельном режиме.

**Сделать**:

* Сделать [горячего пути кода](#hot) асинхронной.
* Асинхронный вызов доступа к данным и длительных операций API-интерфейсы.
* Сделать контроллер/Razor действия страницы асинхронным. Весь стек вызовов должен выполняться асинхронно, чтобы использовать преимущества [async/await](/dotnet/csharp/programming-guide/concepts/async/) шаблонов.

Профилировщик, такие как [PerfView](https://github.com/Microsoft/perfview) может использоваться для поиска для потоков часто, добавляемый [пула потоков](/windows/desktop/procthread/thread-pool). `Microsoft-Windows-DotNETRuntime/ThreadPoolWorkerThread/Start` Указывает поток, добавляемые в пул потоков. <!--  For more information, see [async guidance docs](TBD-Link_To_Davifowl_Doc  -->

## <a name="minimize-large-object-allocations"></a>Свести к минимуму распределения больших объектов

<!-- TODO review Bill - replaced original .NET language below with .NET Core since this targets .NET Core --> [Сборщик мусора .NET Core](/dotnet/standard/garbage-collection/) управляет выделением и освобождением памяти автоматически в приложениях ASP.NET Core. Автоматическая сборка мусора обычно означает, что разработчикам не нужно беспокоиться о способе и времени память освобождается. Тем не менее, очистка неиспользуемых объектов требует затрат Процессорного времени, поэтому разработчики должны свести к минимуму выделения объектов в [горячего пути кода](#hot). Сборка мусора является особенно сильно на больших объектов (в байтах > 85 КБ). Большие объекты хранятся на [кучи больших объектов](/dotnet/standard/garbage-collection/large-object-heap) и требуют полной (поколение 2) сбора мусора для очистки. В отличие от поколения 0 и 1 поколения поколения 2 требуется временно приостановить выполнение приложения. Частые о выделении и освобождении больших объектов может привести к нестабильной работе.

Рекомендуемые действия.

* **Сделать** предусмотреть кэширование больших объектов, которые часто используются. Кэширование больших объектов не позволяет дорогостоящие выделения.
* **Сделать** пула буферов с помощью [ `ArrayPool<T>` ](/dotnet/api/system.buffers.arraypool-1) для хранения больших массивов.
* **Не** распределить коротким сроком существования, многие большие объекты на [горячего пути кода](#hot).

Проблемы с памятью, как приведенный выше можно диагностировать, просмотрев статистика сборки мусора (GC) коллекции в [PerfView](https://github.com/Microsoft/perfview) и изучив:

* Время приостановки сбора мусора.
* Какой процент времени процессора, затраченное на сборку мусора.
* Количество сборок мусора — поколение 0, 1 и 2.

Дополнительные сведения см. в разделе [мусора и производительность](/dotnet/standard/garbage-collection/performance).

## <a name="optimize-data-access"></a>Оптимизация доступа к данным

Взаимодействие с хранилищем данных и других удаленных служб зачастую в самые медленные части приложения ASP.NET Core. Чтение и запись данных эффективно крайне важно для высокой производительности.

Рекомендуемые действия.

* **Сделать** асинхронный вызов доступа ко всем данным API-интерфейсы.
* **Не** получить больше данных, чем необходимо. Написать запросы для получения только данные, необходимые для текущего HTTP-запроса.
* **Сделать** рассмотрим кэширование часто запрашиваемых данных, полученных из базы данных или удаленной службы, если это допустимо для данных, которые требуется немного устарела. В зависимости от сценария, можно использовать [MemoryCache](xref:performance/caching/memory) или [DistributedCache](xref:performance/caching/distributed). Дополнительные сведения см. в разделе <xref:performance/caching/response>.
* Свести к минимуму сетевой циклами. Целью является для получения всех данных, которые потребуются в одном вызове, а не несколько вызовов.
* **Сделать** использовать [Отключение отслеживания запросов](/ef/core/querying/tracking#no-tracking-queries) в Entity Framework Core, при доступе к данным в целях только для чтения. EF Core может возвращать результаты Отключение отслеживания запросов более эффективно.
* **Сделать** фильтра и объединение запросов LINQ (с `.Where`, `.Select`, или `.Sum` инструкций, например), которая выполняется в базе данных.
* **Сделать** учитывать, что EF Core разрешает некоторые операторы запроса на клиенте, что может привести к выполнению неэффективным. Дополнительные сведения см. в разделе [проблем с производительностью оценки клиента](/ef/core/querying/client-eval#client-evaluation-performance-issues)
* **Не** использовать запросы проекции для коллекций, что может привести выполнение «N + 1» SQL-запросов. Дополнительные сведения см. в разделе [оптимизация коррелированных вложенных запросов](/ef/core/what-is-new/ef-core-2.1#optimization-of-correlated-subqueries).

См. в разделе [EF высокопроизводительных](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries) для подходы, которые могут повысить производительность в крупномасштабных приложениях:

* [Создание пулов DbContext](/ef/core/what-is-new/ef-core-2.0#dbcontext-pooling)
* [Явным образом скомпилированные запросы](/ef/core/what-is-new/ef-core-2.0#explicitly-compiled-queries)

Мы рекомендуем оценить результаты предыдущего подхода высокой производительности перед фиксацией в базе данных кода. Дополнительные сложности скомпилированных запросов может не оправдать повышение производительности.

Запрос, могут быть обнаружены проблемы, просмотрев время, затраченное на доступ к данным с помощью [Application Insights](/azure/application-insights/app-insights-overview) или с помощью средств профилирования. Большинство баз данных также доступна статистика о частых запросов.

## <a name="pool-http-connections-with-httpclientfactory"></a>Пул HTTP-подключений с HttpClientFactory

Несмотря на то что [HttpClient](/dotnet/api/system.net.http.httpclient?view=netstandard-2.0) реализует `IDisposable` интерфейс, она создана для повторного использования. Закрыто `HttpClient` экземпляров не закрывайте сокетов в `TIME_WAIT` состояния на короткое время. Следовательно Если путь кода, который создает и удаляет `HttpClient` объекты часто используется, приложение может исчерпать все доступные сокетов. [HttpClientFactory](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) появилась в ASP.NET Core 2.1 в качестве решения этой проблемы. Он обрабатывает регулирования количества запросов HTTP-подключения для оптимизации производительности и надежности.

Рекомендуемые действия.

* **Не** создания и удаления объекта `HttpClient` экземпляры напрямую.
* **Сделать** использовать [HttpClientFactory](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests) извлекаемого `HttpClient` экземпляров. Дополнительные сведения см. в разделе [HttpClientFactory использования для реализации устойчивой HTTP-запросы](/dotnet/standard/microservices-architecture/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests).

## <a name="keep-common-code-paths-fast"></a>Хранить быстро общих путей кода

Требуется, весь код требуется высокая скорость работы, но часто вызываемой путей наиболее важны для оптимизации:

* Компоненты промежуточного слоя в конвейере обработки запросов приложения, особенно по промежуточного слоя для запуска на раннем этапе конвейера. Эти компоненты имеют значительное влияние на производительность.
* Код, выполняемый для каждого запроса несколько раз или на один запрос. Например настраиваемое протоколирование, обработчики авторизации или инициализации временных служб.

Рекомендуемые действия.

* **Не** использовать компоненты пользовательского по промежуточного слоя с длительно выполняемых задач.
* **Сделать** использовать средства профилирования производительности (такие как [средств диагностики Visual Studio](/visualstudio/profiling/profiling-feature-tour) или [PerfView](https://github.com/Microsoft/perfview)) для идентификации [горячего пути кода](#hot).

## <a name="complete-long-running-tasks-outside-of-http-requests"></a>Завершить долго выполняющихся задач вне HTTP-запросов

Большинство запросов для приложения ASP.NET Core могут быть обработаны контроллера или модели страницы, вызывая необходимые службы и возвращает ответ HTTP. Для некоторых запросов, включающих длительно выполняемых задач лучше сделать асинхронный процесс весь запрос ответ.

Рекомендуемые действия.

* **Не** ожидания длительные задачи, выполняемые как часть обычных обработки HTTP-запроса.
* **Сделать** рассмотрите возможность обработки длительных запросов с [фоновых служб](/aspnet/core/fundamentals/host/hosted-services) или вне процесса с [Azure функция](/azure/azure-functions/). Завершение работы вне процесса особенно удобна для задач, интенсивно использующие ЦП.
* **Сделать** вариантов взаимодействия в режиме реального времени, как использовать [SignalR](xref:signalr/introduction) для асинхронного взаимодействия с клиентами.

## <a name="minify-client-assets"></a>Уменьшить размер активы клиента

Приложений ASP.NET Core с помощью сложных интерфейсов часто служат многих JavaScript, CSS или файлы изображений. Можно повысить производительность запросов начальной загрузки:

* Объединение, который объединяет несколько файлов в один.
* Уменьшения, что уменьшает размер файлов.

Рекомендуемые действия.

* **Сделать** использовать ASP.NET Core [встроенную поддержку](xref:client-side/bundling-and-minification) для объединение и Минификация активов клиента.
* **Сделать** рассмотрим другие сторонние средства, такие как [Gulp](uid:client-side/bundling-and-minification#consume-bundleconfigjson-from-gulp) или [Webpack](https://webpack.js.org/) для более сложных управление ресурсами клиента.

## <a name="compress-responses"></a>Сжатия ответов

 Уменьшение размера ответа обычно часто значительно увеличивается скорость реагирования приложения. Для сжатия ответов приложения является одним из способов уменьшить размеры полезной нагрузки. Дополнительные сведения см. в разделе [сжатия отклика](xref:performance/response-compression).

## <a name="use-the-latest-aspnet-core-release"></a>Используйте последний выпуск ASP.NET Core

Каждый новый выпуск ASP.NET включает в себя повышение производительности. Оптимизации в .NET Core и ASP.NET Core означает, что более новые версии будут более эффективны, чем предыдущие версии. Например, .NET Core 2.1 добавлена поддержка для скомпилированные регулярные выражения и использует преимущества [ `Span<T>` ](https://msdn.microsoft.com/magazine/mt814808.aspx). ASP.NET Core 2.2 добавлена поддержка HTTP/2. Если важна производительность, рассмотрите возможность обновления до последней версии ASP.NET Core.

<!-- TODO review link and taking advantage of new [performance features](#TBD)
Maybe skip this TBD link as each version will have perf improvements -->

## <a name="minimize-exceptions"></a>Свести к минимуму исключения

Исключения должны быть редко. Создание и перехват исключений работает медленно относительно других шаблонов потока кода. По этой причине исключения не должен использоваться для управления выполнением программы в обычном режиме.

Рекомендуемые действия.

* **Не** используйте Создание или перехват исключений с точки зрения нормального выполнения программы, особенно в пути кода "Горячий".
* **Сделать** включить логику в приложении, чтобы обнаружить и обработать условия возникновения исключения.
* **Сделать** выдать или перехватить исключения для нестандартных или непредвиденных условий.

Средства диагностики приложений (например, Application Insights) может помочь определить общие исключения в приложении, что может повлиять на производительность.
