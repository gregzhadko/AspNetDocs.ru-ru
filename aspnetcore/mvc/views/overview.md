---
title: Представления в ASP.NET Core MVC
author: ardalis
description: Узнайте, как представления обеспечивают отображение данных приложения и взаимодействие с пользователем в ASP.NET Core MVC.
ms.author: riande
ms.date: 12/12/2017
uid: mvc/views/overview
ms.openlocfilehash: 6c5b4d7b89ac07a85b5aad626e37855de98064eb
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57036101"
---
# <a name="views-in-aspnet-core-mvc"></a>Представления в ASP.NET Core MVC

Авторы: [Стив Смит](https://ardalis.com/) (Steve Smith) и [Люк Лэтем](https://github.com/guardrex) (Luke Latham)

В этом документе описываются представления, используемые в приложениях ASP.NET Core MVC. Сведения о Razor Pages см. в статье [Введение в Razor Pages](xref:razor-pages/index).

В шаблоне MVC (Model-View-Controller, модель — представление — контроллер) *представление* отвечает за отображение данных приложения и взаимодействие с пользователем. Представление — это шаблон HTML с внедренной [разметкой Razor](xref:mvc/views/razor). Разметка Razor — это код, который взаимодействует с разметкой HTML для создания веб-страницы, отправляемой клиенту.

В ASP.NET Core MVC представления — это файлы *CSHTML*, в которых используется [язык программирования C#](/dotnet/csharp/) в разметке Razor. Как правило, файлы представлений объединяются в папки с именами, соответствующими отдельным [контроллерам](xref:mvc/controllers/actions) приложения. Эти папки находятся в папке *Views* в корне приложения.

![Папка Views в обозревателе решений Visual Studio с открытой вложенной папкой Home, содержащей файлы About.cshtml, Contact.cshtml и Index.cshtml](overview/_static/views_solution_explorer.png)

Контроллер *Home* представлен папкой *Home* в папке *Views*. Папка *Home* (Домашняя страница) содержит представления для веб-страниц *About* (Информация), *Contact* (Контакты) и *Index* (Указатель). Когда пользователь запрашивает одну из этих трех веб-страниц, действия контроллера *Home* определяют, какое из трех представлений используется для создания и отправки веб-страницы пользователю.

[Макеты](xref:mvc/views/layout) позволяют создавать единообразные разделы веб-страниц и сократить повторы в коде. Они часто содержат верхний и нижний колонтитулы, а также элементы навигации и меню. Колонтитулы обычно содержат стандартную разметку для многих элементов метаданных и ссылки на ресурсы скриптов и стилей. Макеты позволяют избежать использования этой стандартной разметки в представлениях.

[Частичные представления](xref:mvc/views/partial) сокращают дублирование кода, обеспечивая управление многократно используемыми частями представлений. Например, частичное представление будет полезным для биографии автора, которая присутствует в нескольких представлениях на веб-сайте блога. Биография автора — это обычное содержимое представления, которое не требует выполнения кода для формирования содержимого веб-страницы. Для доступа к содержимому биографии автора представлению достаточно привязки модели, поэтому частичное представление идеально подходит для такого типа содержимого.

[Компоненты представления](xref:mvc/views/view-components) похожи на частичные представления тем, что они также позволяют сократить повторы кода, однако они подходят для содержимого представления, которое требует выполнения кода на сервере для преобразования веб-страницы для просмотра. Компоненты представления полезны в тех случаях, когда для подготовки содержимого для просмотра требуется взаимодействие с базой данных, например для корзины на веб-сайте электронного магазина. При формировании выходных данных веб-страницы компоненты представления не ограничены привязкой модели.

## <a name="benefits-of-using-views"></a>Преимущества использования представлений

Представления помогают реализовать [разделение задач](/dotnet/standard/modern-web-apps-azure-architecture/architectural-principles#separation-of-concerns) в приложении MVC, изолируя разметку пользовательского интерфейса от других частей приложения. Соблюдение принципа SoC делает приложение модульным, что дает несколько преимуществ.

* Приложение проще обслуживать, так как оно лучше организовано. Представления, как правило, группируются по функциональным возможностям приложения. Это упрощает поиск связанных представлений при работе над определенной функцией.
* Части приложения слабо связаны друг с другом. Вы можете разрабатывать и обновлять представления приложения отдельно от компонентов бизнес-логики и доступа к данным. При обновлении представлений приложения не обязательно обновлять другие его части.
* Части пользовательского интерфейса проще тестировать, так как представления являются отдельными модулями.
* Благодаря более упорядоченной структуре меньше вероятность того, что разделы пользовательского интерфейса будут случайно повторяться.

## <a name="creating-a-view"></a>Создание представления

Представления, относящиеся к определенному контроллеру, создаются в папке *Views/[имя_контроллера]*. Представления, используемые разными контроллерами, помещаются в папку *Views/Shared*. Чтобы создать представление, добавьте новый файл и присвойте ему имя связанного действия контроллера с расширением *CSHTML*. Чтобы создать представление, соответствующее действию *About* контроллера *Home*, создайте файл *About.cshtml* в папке *Views/Home*.

[!code-cshtml[](../../common/samples/WebApplication1/Views/Home/About.cshtml)]

Разметка *Razor* начинается с символа `@`. Для выполнения операторов C# поместите код C# в [блоки кода Razor](xref:mvc/views/razor#razor-code-blocks), заключенные в фигурные скобки (`{ ... }`). Примером может служить приведенный выше оператор присвоения значения "About" свойству `ViewData["Title"]`. Для отображения значений в коде HTML можно просто ссылаться на них с помощью символа `@`. См. содержимое элементов `<h2>` и `<h3>` выше.

Показанное выше содержимое представления — это всего лишь часть веб-страницы, отображаемой для пользователя. Остальная часть макета страницы и другие стандартные аспекты представления определяются в других файлах представления. Дополнительные сведения см. в статье [Макет](xref:mvc/views/layout).

## <a name="how-controllers-specify-views"></a>Указание представлений в контроллерах

Представления, как правило, возвращаются из действий в виде объекта [ViewResult](/dotnet/api/microsoft.aspnetcore.mvc.viewresult), который является разновидностью объекта [ActionResult](/dotnet/api/microsoft.aspnetcore.mvc.actionresult). Метод действия может создавать и возвращать объект `ViewResult` напрямую, однако обычно так не делается. Так как большинство контроллеров наследуются от класса [Controller](/dotnet/api/microsoft.aspnetcore.mvc.controller), для возврата объекта `ViewResult` можно просто использовать вспомогательный метод `View`:

*HomeController.cs*

[!code-csharp[](../../common/samples/WebApplication1/Controllers/HomeController.cs?highlight=5&range=16-21)]

Когда это действие возвращает управление, представление *About.cshtml*, приведенное в предыдущем разделе, отрисовывается в виде следующей веб-страницы:

![Страница About в браузере Microsoft Edge](overview/_static/about-page.png)

Вспомогательный метод `View` имеет несколько перегрузок. Вы можете дополнительно указать:

* Представление, которое нужно вернуть, явным образом:

  ```csharp
  return View("Orders");
  ```
* [Модель](xref:mvc/models/model-binding), которую нужно передать в представление:

  ```csharp
  return View(Orders);
  ```
* Представление и модель:

  ```csharp
  return View("Orders", Orders);
  ```

### <a name="view-discovery"></a>Обнаружение представления

Когда действие возвращает представление, происходит процесс, который называется *обнаружением представления*. Он служит для определения используемого файла представления на основе имени представления. 

Метод `View` (`return View();`) по умолчанию возвращает представление с тем же именем, что и у метода действия, из которого он был вызван. Например, имя метода `ActionResult` действия *About* контроллера служит для поиска файла представления с именем *About.cshtml*. Сначала среда выполнения ищет представление в папке *Views/[имя_контроллера]*. Если подходящее представление в ней не найдено, поиск производится в папке *Shared*.

Не имеет значения, возвращается ли объект `ViewResult` неявно с помощью метода `return View();` или имя представления явно передается в метод `View` с помощью `return View("<ViewName>");`. В обоих случаях обнаружение подходящего файла представления происходит в следующем порядке:

   1. *Views/\[ControllerName]/\[ViewName].cshtml*
   1. *Views/Shared/\[ViewName].cshtml*

Вместо имени файла можно предоставить путь к файлу представления. При использовании абсолютного пути, начинающегося с корня приложения (может начинаться с символов "/" или "~/"), необходимо указывать расширение *CSHTML*:

```csharp
return View("Views/Home/About.cshtml");
```

Для указания представлений в разных каталогах можно также использовать относительный путь без расширения *CSHTML*. Внутри `HomeController` можно вернуть представление *Index* из папки *Manage* с помощью следующего относительного пути:

```csharp
return View("../Manage/Index");
```

Аналогичным образом, можно указать каталог текущего контроллера с помощью префикса "./":

```csharp
return View("./About");
```

[Частичные представления](xref:mvc/views/partial) и [компоненты представлений](xref:mvc/views/view-components) используют похожие (но не одинаковые) механизмы обнаружения.

Настроить соглашение по умолчанию, определяющее способ поиска представлений в приложении, можно с помощью пользовательской реализации [IViewLocationExpander](/dotnet/api/microsoft.aspnetcore.mvc.razor.iviewlocationexpander).

Обнаружение представлений предусматривает поиск файлов представлений по имени. Если в базовой файловой системе учитывается регистр символов, то он, скорее всего, будет учитываться и в именах представлений. В целях совместимости в разных операционных системах следует соблюдать одинаковый реестр символов в именах контроллеров и действий с одной стороны и в соответствующих именах файлов и папок представлений с другой. Если при работе в файловой системе, в которой учитывается регистр символов, возникает ошибка, связанная с тем, что не удается найти файл представления, проверьте, совпадает ли регистр символов в запрошенном и фактическом именах файлов представлений.

Для удобства и простоты работы следуйте рекомендациям по организации структуры файлов представлений, которая должна отражать взаимосвязи между контроллерами, действиями и представлениями.

## <a name="passing-data-to-views"></a>Передача данных в представления

Существует несколько подходов к передаче данных в представления:

* Строго типизированные данные: viewmodel
* Слабо типизированные данные
  * `ViewData` (`ViewDataAttribute`)
  * `ViewBag`

### <a name="strongly-typed-data-viewmodel"></a>Строго типизированные данные (viewmodel)

Наиболее надежный подход — указание типа [модели](xref:mvc/models/model-binding) в представлении. Такая модель называется *viewmodel*. Экземпляр типа viewmodel передается в представление из действия.

Использование viewmodel для передачи данных в представление позволяет ему применять *строгую* проверку типов. Термин *строгая типизация* (или *строго типизированный*) означает, что каждая переменная и константа имеет явным образом определенный тип (например, `string`, `int` или `DateTime`). Допустимость типов, используемых в представлении, проверяется во время компиляции.

В [Visual Studio](https://www.visualstudio.com/vs/) и [Visual Studio Code](https://code.visualstudio.com/) строго типизированные члены классов перечисляются с помощью функции [IntelliSense](/visualstudio/ide/using-intellisense). Чтобы просмотреть свойства viewmodel, введите имя переменной viewmodel с точкой (`.`) после него. Это позволяет писать код быстрее, допуская меньше ошибок.

Укажите модель с помощью директивы `@model`. Используйте модель с `@Model`:

```cshtml
@model WebApplication1.ViewModels.Address

<h2>Contact</h2>
<address>
    @Model.Street<br>
    @Model.City, @Model.State @Model.PostalCode<br>
    <abbr title="Phone">P:</abbr> 425.555.0100
</address>
```

Чтобы предоставить модель для представления, контроллер передает ее в качестве параметра:

```csharp
public IActionResult Contact()
{
    ViewData["Message"] = "Your contact page.";

    var viewModel = new Address()
    {
        Name = "Microsoft",
        Street = "One Microsoft Way",
        City = "Redmond",
        State = "WA",
        PostalCode = "98052-6399"
    };

    return View(viewModel);
}
```

В отношении типов моделей, которые можно предоставлять для представления, ограничений нет. Мы рекомендуем использовать модели представлений POCO, которые позволяют определять минимум методов или не определять их вовсе. Как правило, классы viewmodel хранятся либо в папке *Models*, либо в отдельной папке *ViewModels* в корне приложения. Модель представления *Address*, используемая в приведенном выше примере, — это модель POCO, хранящаяся в файле с именем *Address.cs*:

```csharp
namespace WebApplication1.ViewModels
{
    public class Address
    {
        public string Name { get; set; }
        public string Street { get; set; }
        public string City { get; set; }
        public string State { get; set; }
        public string PostalCode { get; set; }
    }
}
```

Ничто не мешает вам использовать одни и те же классы как для типов viewmodel, так и для типов бизнес-модели. Однако применение отдельных моделей позволяет изменять представления независимо от компонентов бизнес-логики и доступа к данным в приложении. Разделение моделей и моделей представлений также предоставляет преимущества в плане безопасности, когда модели используют [привязку модели](xref:mvc/models/model-binding) и [проверку](xref:mvc/models/validation) для данных, отправляемых в приложение пользователем.

<a name="VD_VB"></a>

### <a name="weakly-typed-data-viewdata-viewdata-attribute-and-viewbag"></a>Нестрого типизированные данные (ViewData, атрибут ViewData и ViewBag)

`ViewBag`Свойство  *недоступно в Razor Pages.*

Помимо строго типизированных представлений, представления имеют доступ к *нестрого типизированной* (*слабо типизированной*) коллекции данных. В отличие от строгих типов, *нестрогие типы* (или *слабые типы*) предполагают, что тип используемых данных не объявляется явным образом. Коллекцию нестрого типизированных данных можно использовать для передачи небольших объемов данных в контроллеры и представления или из них.

| Передача данных между...                        | Пример                                                                        |
| ------------------------------------------------- | ------------------------------------------------------------------------------ |
| Контроллером и представлением                             | Заполнение раскрывающегося списка данными.                                          |
| Представлением и [представлением макета](xref:mvc/views/layout)   | Задание содержимого элемента **\<title>** в представлении макета из файла представления.  |
| [Частичным представлением](xref:mvc/views/partial) и представлением | Мини-приложение, в котором данные выводятся на основе запрошенной пользователем веб-страницы.      |

На эту коллекцию можно ссылаться в контроллерах и представлениях посредством свойства `ViewData` или `ViewBag`. Свойство `ViewData` представляет собой словарь нестрого типизированных объектов. Свойство `ViewBag` представляет собой оболочку для свойства `ViewData`, которая предоставляет динамические свойства для базовой коллекции `ViewData`.

Свойства `ViewData` и `ViewBag` разрешаются динамически во время выполнения. Так как они не обеспечивают проверку во время компиляции, их использование обычно приводит к большему числу ошибок, чем использование viewmodel. По этой причине некоторые разработчики предпочитают как можно реже использовать свойства `ViewData` и `ViewBag` или не использовать их вовсе.

<a name="VD"></a>

**ViewData**

`ViewData` — это объект [ViewDataDictionary](/dotnet/api/microsoft.aspnetcore.mvc.viewfeatures.viewdatadictionary), доступ к которому осуществляется посредством ключей `string`. Строковые данные можно сохранять и использовать напрямую без приведения, однако при извлечении других значений объекта `ViewData` их необходимо приводить к соответствующим типам. С помощью свойства `ViewData` можно передавать данные, включая [частичные представления](xref:mvc/views/partial) и [макеты](xref:mvc/views/layout), из контроллеров в представления и внутри представлений.

Ниже приведен пример, в котором с помощью свойства `ViewData` в действии задаются значения для приветствия и адреса.

```csharp
public IActionResult SomeAction()
{
    ViewData["Greeting"] = "Hello";
    ViewData["Address"]  = new Address()
    {
        Name = "Steve",
        Street = "123 Main St",
        City = "Hudson",
        State = "OH",
        PostalCode = "44236"
    };

    return View();
}
```

Работа с данными в представлении:

```cshtml
@{
    // Since Address isn't a string, it requires a cast.
    var address = ViewData["Address"] as Address;
}

@ViewData["Greeting"] World!

<address>
    @address.Name<br>
    @address.Street<br>
    @address.City, @address.State @address.PostalCode
</address>
```

::: moniker range=">= aspnetcore-2.1"

**Атрибут ViewData**

Другой подход, который использует [ViewDataDictionary](/dotnet/api/microsoft.aspnetcore.mvc.viewfeatures.viewdatadictionary), — [ViewDataAttribute](/dotnet/api/microsoft.aspnetcore.mvc.viewdataattribute). Свойства на контроллерах или моделях страниц Razor, отмеченные атрибутом `[ViewData]`, обладают своими собственными значениями, загружаемыми из словаря.

В следующем примере контроллер Home содержит свойство `Title`, отмеченное атрибутом `[ViewData]`. Метод `About` задает заголовок для представления About:

```csharp
public class HomeController : Controller
{
    [ViewData]
    public string Title { get; set; }

    public IActionResult About()
    {
        Title = "About Us";
        ViewData["Message"] = "Your application description page.";

        return View();
    }
}
```

В представлении About доступ к свойству `Title` осуществляется как доступ к свойству модели:

```cshtml
<h1>@Model.Title</h1>
```

В макете заголовок считывается из словаря ViewData.

```cshtml
<!DOCTYPE html>
<html lang="en">
<head>
    <title>@ViewData["Title"] - WebApplication</title>
    ...
```

::: moniker-end

**ViewBag**

`ViewBag`Свойство  *недоступно в Razor Pages.*

`ViewBag` — это объект [DynamicViewData](/dotnet/api/microsoft.aspnetcore.mvc.viewfeatures.internal.dynamicviewdata), который обеспечивает динамический доступ к объектам, хранящимся в `ViewData`. Работать со свойством `ViewBag` может быть удобнее, так как оно не требует приведения. В приведенном ниже примере демонстрируется использование свойства `ViewBag` с тем же результатом, что и свойства `ViewData` ранее.

```csharp
public IActionResult SomeAction()
{
    ViewBag.Greeting = "Hello";
    ViewBag.Address  = new Address()
    {
        Name = "Steve",
        Street = "123 Main St",
        City = "Hudson",
        State = "OH",
        PostalCode = "44236"
    };

    return View();
}
```

```cshtml
@ViewBag.Greeting World!

<address>
    @ViewBag.Address.Name<br>
    @ViewBag.Address.Street<br>
    @ViewBag.Address.City, @ViewBag.Address.State @ViewBag.Address.PostalCode
</address>
```

**Одновременное использование ViewData и ViewBag**

`ViewBag`Свойство  *недоступно в Razor Pages.*

Так как свойства `ViewData` и `ViewBag` ссылаются на одну и ту же базовую коллекцию `ViewData`, вы можете использовать `ViewData` и `ViewBag` вместе в различных сочетаниях при чтении и записи значений.

Например, задайте заголовок с помощью свойства `ViewBag`, а описание с помощью свойства `ViewData` в начале представления *About.cshtml*:

```cshtml
@{
    Layout = "/Views/Shared/_Layout.cshtml";
    ViewBag.Title = "About Contoso";
    ViewData["Description"] = "Let us tell you about Contoso's philosophy and mission.";
}
```

В этом примере свойства считываются, причем очередность использования свойств `ViewData` и `ViewBag` обратная. В файле *_Layout.cshtml* получите заголовок с помощью свойства `ViewData`, а описание с помощью свойства `ViewBag`:

```cshtml
<!DOCTYPE html>
<html lang="en">
<head>
    <title>@ViewData["Title"]</title>
    <meta name="description" content="@ViewBag.Description">
    ...
```

Помните, что строки не требуют приведения значения `ViewData`. `@ViewData["Title"]` можно использовать без приведения.

Свойства `ViewData` и `ViewBag` можно использовать одновременно в различных сочетаниях для считывания и записи значений. Следующая разметка будет обработана:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>About Contoso</title>
    <meta name="description" content="Let us tell you about Contoso's philosophy and mission.">
    ...
```

**Сводка различий между ViewData и ViewBag**

 Свойство `ViewBag` недоступно в Razor Pages.

* `ViewData`
  * Является производным от [ViewDataDictionary](/dotnet/api/microsoft.aspnetcore.mvc.viewfeatures.viewdatadictionary), поэтому имеет свойства словаря, которые могут быть полезны, например `ContainsKey`, `Add`, `Remove` и `Clear`.
  * Ключи в словаре представляют собой строки, поэтому пробел допустим. Пример: `ViewData["Some Key With Whitespace"]`
  * Любой тип, кроме `string`, должен быть приведен в представлении так, чтобы он мог использоваться в `ViewData`.
* `ViewBag`
  * Является производным от [DynamicViewData](/dotnet/api/microsoft.aspnetcore.mvc.viewfeatures.internal.dynamicviewdata), поэтому позволяет создавать динамические свойства с помощью точечной нотации (`@ViewBag.SomeKey = <value or object>`); приведение не требуется. Синтаксис свойства `ViewBag` позволяет быстрее добавлять его в контроллеры и представления.
  * Проще проверять значение NULL. Пример: `@ViewBag.Person?.Name`

**Выбор между ViewData и ViewBag**

Свойства `ViewData` и `ViewBag` в равной степени подходят для передачи небольших объемов данных между контроллерами и представлениями. Выбор одного из них зависит от предпочтений. Вы можете сочетать объекты `ViewData` и `ViewBag`, однако код будет проще для восприятия и обслуживания при последовательном применении одного подхода. Оба свойства разрешаются динамически во время выполнения и поэтому могут приводить к ошибкам во время выполнения. Некоторые команды разработчиков избегают их использования.

### <a name="dynamic-views"></a>Динамические представления

Представления, в которых тип модели не объявляется с помощью `@model`, но в которые вместо этого передается экземпляр модели (например, `return View(Address);`), могут ссылаться на свойства экземпляра динамически.

```cshtml
<address>
    @Model.Street<br>
    @Model.City, @Model.State @Model.PostalCode<br>
    <abbr title="Phone">P:</abbr> 425.555.0100
</address>
```

Эта возможность повышает гибкость, но не обеспечивает защиту компиляции или функцию IntelliSense. Если свойство не существует, создание веб-страницы завершается сбоем во время выполнения.

## <a name="more-view-features"></a>Дополнительные возможности представлений

[Вспомогательные функции тегов](xref:mvc/views/tag-helpers/intro) упрощают реализацию поведения на стороне сервера в существующих HTML-тегах. Их применение избавляет от необходимости писать пользовательский код или вспомогательные функции в представлениях. Вспомогательные функции тегов применяются к элементам HTML как атрибуты и игнорируются редакторами, которые не поддерживают их. Это позволяет редактировать и подготавливать разметку представлений для просмотра в различных средствах.

Пользовательская HTML-разметка может формироваться с помощью множества встроенных вспомогательных функций HTML. Более сложная логика пользовательского интерфейса может обрабатываться [компонентами представлений](xref:mvc/views/view-components). Компоненты представлений предоставляют те же возможности SoC, что и контроллеры и представления. Они могут устранить необходимость в действиях и представлениях, предназначенных для работы с данными, которые используются общими элементами пользовательского интерфейса.

Как и многие другие аспекты ASP.NET Core, представления поддерживают [внедрение зависимостей](xref:fundamentals/dependency-injection), которое позволяет [внедрять службы в представления](xref:mvc/views/dependency-injection).
