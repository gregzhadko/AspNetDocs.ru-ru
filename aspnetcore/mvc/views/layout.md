---
title: Макет в ASP.NET Core
author: ardalis
description: Узнайте, как использовать общие макеты, директивы и как выполнять общий код перед преобразованием представлений для просмотра в приложении ASP.NET Core.
ms.author: riande
ms.date: 02/26/2019
uid: mvc/views/layout
ms.openlocfilehash: 7a60ee15e688d6f0e531302457604fa759213758
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57036091"
---
# <a name="layout-in-aspnet-core"></a>Макет в ASP.NET Core

Авторы: [Стив Смит](https://ardalis.com/) (Steve Smith) и [Дейв Брок](https://twitter.com/daveabrock) (Dave Brock)

На страницах и в представлениях часто есть общие визуальные и программные элементы. В этой статье демонстрируются следующие возможности.

* Использование общих макетов.
* Совместное использование директив.
* Запуск общего кода до отрисовки страниц или представлений.

В этом документе рассматриваются макеты для двух разных подходов к ASP.NET Core MVC: Razor Pages и контроллеры с представлениями. С этой точки зрения различия минимальны:

* Razor Pages находятся в папке *Pages*.
* Контроллеры с представлениями используют папку *Views* для представлений.

## <a name="what-is-a-layout"></a>Что такое макет

Большинство веб-приложений имеют общий макет, который обеспечивает согласованный пользовательский интерфейс при переходе между страницами. Макет, как правило, включает в себя общие элементы пользовательского интерфейса, такие как верхний и нижний колонтитулы, а также элементы навигации или меню.

![Пример макета страницы](layout/_static/page-layout.png)

Общие структуры HTML, такие как скрипты и таблицы стилей, также часто используются разными страницами приложения. Все эти общие элементы могут определяться в файле *макета*, на который затем может ссылаться на любое представление в приложении. Макеты сокращают повторы кода в представлениях.

В соответствии с соглашением макет по умолчанию для приложения ASP.NET Core имеет имя *_Layout.cshtml*. Файл макета для новых проектов ASP.NET Core, созданных с помощью шаблонов:

* Razor Pages: *Pages/Shared/_Layout.cshtml*

  ![в обозревателе решений](layout/_static/rp-web-project-views.png)

* Контроллер с представлениями: *Views/Shared/_Layout.cshtml*

 ![Папка Views в обозревателе решений](layout/_static/mvc-web-project-views.png)

Макет определяет шаблон верхнего уровня для представлений в приложении. Приложения не требуют макета. В приложении может определяться несколько макетов для разных представлений.

В следующем коде показан файл макета для проекта, созданного по шаблону, с контроллером и представлениями:

[!code-cshtml[](~/common/samples/WebApplication1/Views/Shared/_Layout.cshtml?highlight=44,72)]

## <a name="specifying-a-layout"></a>Указание макета

Представления Razor имеют свойство `Layout`. С его помощью указывается макет в отдельных представлениях:

[!code-cshtml[](../../common/samples/WebApplication1/Views/_ViewStart.cshtml?highlight=2)]

Указанный макет может использовать полный путь (например, */Pages/Shared/_Layout.cshtml* или */Views/Shared/_Layout.cshtml*) или частичное имя (например, `_Layout`). Если указано частичное имя, подсистема представлений Razor ищет файл макета, используя стандартный процесс обнаружения. Сначала поиск выполняется в папке, где существует метод обработчика (или контроллер), а затем в папке *Shared*. Процесс обнаружения аналогичен тому, который применяется для поиска [частичных представлений](xref:mvc/views/partial#partial-view-discovery).

По умолчанию каждый макет должен вызывать метод `RenderBody`. При каждом вызове `RenderBody` содержимое представления будет преобразовываться для просмотра.

<a name="layout-sections-label"></a>

### <a name="sections"></a>Разделы

Макет может при необходимости ссылаться на один или несколько *разделов*, вызывая метод `RenderSection`. Разделы — это средство для упорядочения размещения определенных элементов на странице. В каждом вызове `RenderSection` можно указывать, является ли раздел обязательным или необязательным:

```html
@section Scripts {
    @RenderSection("Scripts", required: false)
}
```

Если обязательный раздел не найден, создается исключение. В отдельных представлениях содержимое раздела, которое необходимо преобразовать для просмотра, указывается с помощью синтаксиса Razor `@section`. Если на странице или в представлении определяется раздел, он должен быть преобразован для просмотра (в противном случае произойдет ошибка).

Пример определения `@section` в представлении Razor Pages:

```html
@section Scripts {
     <script type="text/javascript" src="/scripts/main.js"></script>
}
```

В приведенном выше коде *scripts/main.js* добавляется в раздел `scripts` на странице или в представлении. Другие страницы или представления в одном приложении могут не требовать этот скрипт и не определять раздел скриптов.

Следующая разметка использует [вспомогательную функция тега частичного представления](xref:mvc/views/tag-helpers/builtin-th/partial-tag-helper) для подготовки к просмотру *_ValidationScriptsPartial.cshtml*:

```html
@section Scripts {
    <partial name="_ValidationScriptsPartial" />
}
```

Предыдущая разметка создана с помощью [формирования шаблонов удостоверений](xref:security/authentication/scaffold-identity).

Разделы, определенные на странице или в представлении, доступны только непосредственно на странице макета. На них нельзя ссылаться из частичных представлений, компонентов представлений или других частей системы представлений.

### <a name="ignoring-sections"></a>Пропуск разделов

По умолчанию тело и все разделы страницы содержимого должны преобразовываться для просмотра страницей макета. Подсистема представлений Razor обеспечивает выполнение этого требования, следя за тем, были ли преобразованы для просмотра тело и каждый раздел.

Чтобы подсистема представлений пропустила тело или разделы, вызовите методы `IgnoreBody` и `IgnoreSection`.

Тело и каждый раздел на странице Razor должны либо преобразовываться для просмотра, либо пропускаться.

<a name="viewimports"></a>

## <a name="importing-shared-directives"></a>Импорт общих директив

Представления и страницы могут использовать директивы Razor для импорта пространств имен и использования [внедрения зависимостей](dependency-injection.md). Директивы, используемые несколькими представлениями, можно указать в общем файле *_ViewImports.cshtml*. Файл `_ViewImports` поддерживает следующие директивы:

* `@addTagHelper`
* `@removeTagHelper`
* `@tagHelperPrefix`
* `@using`
* `@model`
* `@inherits`
* `@inject`

Этот файл не поддерживает другие возможности Razor, такие как функции и определения разделов.

Пример файла `_ViewImports.cshtml`:

[!code-cshtml[](../../common/samples/WebApplication1/Views/_ViewImports.cshtml)]

Файл *_ViewImports.cshtml* для приложения ASP.NET Core MVC обычно находится в папке *Pages* (или *Views*). Файл *_ViewImports.cshtml* можно поместить в любую папку, но в этом случае он будет применяться только к страницам или представлениям в этой папке и вложенных в нее папках. Файлы `_ViewImports` обрабатываются начиная с корневого уровня, а затем для каждой папки вплоть до расположения самой страницы или представления. Параметры `_ViewImports`, заданные на корневом уровне, можно переопределить на уровне папки.

Например, предположим, что:

* Файл корневого уровня *_ViewImports.cshtml* включает `@model MyModel1` и `@addTagHelper *, MyTagHelper1`.
* Файл вложенной папки *_ViewImports.cshtml* включает `@model MyModel2` и `@addTagHelper *, MyTagHelper2`.

Страницы и представления во вложенной папке будут иметь доступ к вспомогательным функциям тегов и модели `MyModel2`.

Если в иерархии файлов найдено несколько файлов *_ViewImports.cshtml*, директивы ведут себя следующим образом:

* `@addTagHelper`, `@removeTagHelper`: выполняются все директивы по порядку;
* `@tagHelperPrefix`: ближайшая к представлению директива переопределяет все остальные;
* `@model`: ближайшая к представлению директива переопределяет все остальные;
* `@inherits`: ближайшая к представлению директива переопределяет все остальные;
* `@using`: включаются все директивы, повторяющиеся пропускаются;
* `@inject`: для каждого свойства ближайшая к представлению директива переопределяет все остальные директивы с тем же именем свойства.

<a name="viewstart"></a>

## <a name="running-code-before-each-view"></a>Выполнение кода перед каждым представлением

Код, который должен быть запущен перед каждым представлением или страницей, нужно поместить в файл *_ViewStart.cshtml*. По соглашению файл *_ViewStart.cshtml* находится в папке *Pages* (или *Views*). Операторы, перечисленные в файле *_ViewStart.cshtml*, выполняются перед каждым полным представлением (но не перед макетами и не перед частичными представлениями). Так же как файлы [ViewImports.cshtml](xref:mvc/views/layout#viewimports), файлы *_ViewStart.cshtml* являются иерархическими. Если файл *_ViewStart.cshtml* определен в папке представлений или страниц, он будет применяться после определенного в корне папки *Pages* (или *Views*) (при его наличии).

Пример файла *_ViewStart.cshtml*:

[!code-cshtml[](../../common/samples/WebApplication1/Views/_ViewStart.cshtml)]

Приведенный файл предписывает всем представлениям использовать макет *_Layout.cshtml*.

*_ViewStart.cshtml* и *_ViewImports.cshtml* обычно **не** помещаются в папку */Pages/Shared* (или */Views/Shared*). Версии этих файлов, которые должны действовать на уровне приложения, следует помещать непосредственно в папку */Pages* (или */Views*).
