---
title: Фильтры в ASP.NET Core
author: ardalis
description: Узнайте, как работают фильтры и как использовать их в ASP.NET Core MVC.
ms.author: riande
ms.custom: mvc
ms.date: 02/08/2019
uid: mvc/controllers/filters
ms.openlocfilehash: a9081a9938d56b7612bba13937eba384ff02455b
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57035251"
---
# <a name="filters-in-aspnet-core"></a>Фильтры в ASP.NET Core

Авторы: [Рик Андерсон](https://twitter.com/RickAndMSFT) (Rick Anderson), [Том Дайкстра](https://github.com/tdykstra/) (Tom Dykstra) и [Стив Смит](https://ardalis.com/) (Steve Smith)

*Фильтры* в ASP.NET Core MVC позволяют выполнять код до или после определенных стадий в конвейере обработки запросов.

 Встроенные фильтры обрабатывают следующие задачи:

 * Авторизация (предотвращение несанкционированного доступа к ресурсам).
 * Гарантия использования HTTPS во всех запросах.
 * Кэширование откликов (замыкание конвейера обработки запросов для возврата кэшированного ответа). 

Для обработки сквозной функциональности можно создавать настраиваемые фильтры. Фильтры могут предотвратить дублирование кода в действиях. Например, можно объединить обработку ошибок с помощью фильтра исключений обработки ошибок.

[Просмотреть или скачать образец с GitHub](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/filters/sample).

## <a name="how-filters-work"></a>Как работают фильтры

Фильтры выполняются в рамках *конвейера вызова действий MVC*, который иногда называют *конвейером фильтров*.  Конвейер фильтров запускается после того, как платформа MVC выбирает выполняемое действие.

![Запрос обрабатывается посредством прочего ПО промежуточного слоя, ПО промежуточного слоя маршрутизации, выбора действия и конвейера вызова действий MVC. Обработка запроса продолжается в обратном порядке посредством выбора действия, ПО промежуточного слоя маршрутизации и прочего ПО промежуточного слоя, пока не будет получен запрос, отправляемый клиенту.](filters/_static/filter-pipeline-1.png)

### <a name="filter-types"></a>Типы фильтров

Фильтр каждого типа выполняется на определенном этапе конвейера фильтров.

* [Фильтры авторизации](#authorization-filters) применяются в первую очередь и служат для определения того, авторизован ли пользователь для текущего запроса. Они не могут замкнуть конвейер, если запрос не авторизован. 

* [Фильтры ресурсов](#resource-filters) первыми обрабатывают запрос после авторизации.  Они могут выполнять код до и после выполнения остальной части конвейера фильтров. С их помощью можно реализовывать кэширование или замыкать конвейер фильтров иным образом с целью повышения производительности. Они выполняются до привязки модели, поэтому могут повлиять на привязку.

* [Фильтры действий](#action-filters) могут выполнять код непосредственно до и после вызова отдельного метода действия. С их помощью можно управлять аргументами, передаваемыми в действие, и возвращаемым из него результатом. Фильтры действий не поддерживаются в Razor Pages.

* [Фильтры исключений](#exception-filters) служат для применения глобальных политик к необработанным исключениям, которые происходят до записи данных в тело ответа.

* [Фильтры результатов](#result-filters) могут выполнять код непосредственно до и после выполнения результатов отдельного действия. Они выполняются только в том случае, если метод действия выполнен успешно. Они полезны для логики, которая должна включать исключения для представлений или модуля форматирования.

На приведенной ниже схеме показано, как эти типы фильтров взаимодействуют друг с другом в рамках конвейера фильтров.

![Запрос обрабатывается посредством фильтров авторизации, фильтров ресурсов, привязки модели, фильтров действий, выполнения действия и преобразования результата действия, фильтров исключений, фильтров результатов и выполнения результатов. На обратном пути запрос обрабатывается только фильтрами результатов и фильтрами ресурсов, прежде чем стать ответом, отправляемым клиенту.](filters/_static/filter-pipeline-2.png)

## <a name="implementation"></a>Реализация

Фильтры поддерживают как синхронные, так и асинхронные реализации посредством различных определений интерфейсов. 

Синхронные фильтры, которые могут выполнять код как до, так и после этапа конвейера, определяют методы On*Stage*Executing и On*Stage*Executed. Например, метод `OnActionExecuting` вызывается перед вызовом метода действия, а метод `OnActionExecuted` — после возврата управления из метода действия.

[!code-csharp[](./filters/sample/src/FiltersSample/Filters/SampleActionFilter.cs?name=snippet1)]

Асинхронные фильтры определяют единственный метод On*Stage*ExecutionAsync. Этот метод принимает делегат *ТипФильтра*ExecutionDelegate, который выполняет этап конвейера фильтра. Например, `ActionExecutionDelegate` вызывает метод действия или следующий фильтр действий, и вы можете выполнять код до и после его вызова.

[!code-csharp[](./filters/sample/src/FiltersSample/Filters/SampleAsyncActionFilter.cs?highlight=6,8-10,13)]

Реализовать интерфейсы для нескольких этапов фильтра можно в одном классе. Например, класс <xref:Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute> реализует интерфейсы `IActionFilter` и `IResultFilter`, а также их асинхронные эквиваленты.

> [!NOTE]
> Реализуйте **либо** синхронный, либо асинхронный вариант интерфейса фильтра, но не оба варианта. Платформа сначала проверяет, реализует ли фильтр асинхронный интерфейс. Если да, вызывается он. В противном случае вызываются методы синхронного интерфейса. Если бы в одном классе были реализованы оба интерфейса, вызывался бы только асинхронный метод. При использовании абстрактных классов, таких как <xref:Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute>, следует переопределять только синхронные методы или асинхронный метод каждого типа фильтра.

### <a name="ifilterfactory"></a>IFilterFactory

[IFilterFactory](/dotnet/api/microsoft.aspnetcore.mvc.filters.ifilterfactory) реализует <xref:Microsoft.AspNetCore.Mvc.Filters.IFilterMetadata>. Поэтому экземпляр `IFilterFactory` можно использовать в качестве экземпляра `IFilterMetadata` в любом месте конвейера фильтров. Когда платформа готовится вызвать фильтр, она пытается привести его к `IFilterFactory`. Если приведение проходит успешно, вызывается метод [CreateInstance](/dotnet/api/microsoft.aspnetcore.mvc.filters.ifilterfactory.createinstance) для создания вызываемого экземпляра `IFilterMetadata`. Это обеспечивает высокую степень гибкости, так как при запуске приложения нет необходимости в явном и точном определении конвейера фильтров.

Еще один подход к созданию фильтров заключается в реализации интерфейса `IFilterFactory` для собственных атрибутов.

[!code-csharp[](./filters/sample/src/FiltersSample/Filters/AddHeaderWithFactoryAttribute.cs?name=snippet_IFilterFactory&highlight=1,4,5,6,7)]

### <a name="built-in-filter-attributes"></a>Встроенные атрибуты фильтров

Платформа включает в себя фильтры на основе встроенных атрибутов, на основе которых можно создавать подклассы и которые можно настраивать. Например, приведенный ниже фильтр результатов добавляет заголовок к ответу.

<a name="add-header-attribute"></a>

[!code-csharp[](./filters/sample/src/FiltersSample/Filters/AddHeaderAttribute.cs?highlight=5,16)]

Атрибуты позволяют фильтрам принимать аргументы, как показано в примере выше. Этот атрибут следует добавить в метод контроллера или действия и указать имя и значение заголовка HTTP:

[!code-csharp[](./filters/sample/src/FiltersSample/Controllers/SampleController.cs?name=snippet_AddHeader&highlight=1)]

Результат действия `Index` показан ниже. Заголовки ответа представлены внизу справа.

![Средства для разработчиков Microsoft Edge, в которых показаны заголовки ответа, включая автора Стива Смита (Steve Smith) @ardalis](filters/_static/add-header.png)

Некоторые интерфейсы фильтров имеют соответствующие атрибуты, которые можно использовать как базовые классы для пользовательских реализаций.

Атрибуты фильтров:

* `ActionFilterAttribute`
* `ExceptionFilterAttribute`
* `ResultFilterAttribute`
* `FormatFilterAttribute`
* `ServiceFilterAttribute`
* `TypeFilterAttribute`

Атрибуты `TypeFilterAttribute` и `ServiceFilterAttribute` рассматриваются [далее в этой статье](#dependency-injection).

## <a name="filter-scopes-and-order-of-execution"></a>Области и порядок выполнения фильтров

Фильтр можно добавить в конвейер в одной из трех *областей*. Фильтр можно добавить в определенный метод действия или класс контроллера с помощью атрибута. Или можно зарегистрировать фильтр глобально для всех контроллеров и действий. Фильтры добавляются глобально путем добавления в коллекцию `MvcOptions.Filters` в `ConfigureServices`:

[!code-csharp[](./filters/sample/src/FiltersSample/Startup.cs?name=snippet_ConfigureServices&highlight=5-8)]

### <a name="default-order-of-execution"></a>Порядок выполнения по умолчанию

Если для определенного этапа конвейера имеется несколько фильтров, область определяет порядок их выполнения по умолчанию.  Глобальные фильтры заключают в себя фильтры классов, которые, в свою очередь, заключают в себя фильтры методов. Иногда это называют вложением по принципу [матрешки](https://wikipedia.org/wiki/Matryoshka_doll), так как каждая более широкая область служит оболочкой для предыдущей области. Как правило, добиться правильного переопределения можно, не прибегая к явному указанию порядка.

В результате такого вложения *последующий* код фильтров выполняется в порядке, обратном выполнению *предшествующего* кода. Последовательность выглядит так:

* *предшествующий* код фильтров, применяемых глобально;
  * *предшествующий* код фильтров, применяемых к контроллерам;
    * *предшествующий* код фильтров, применяемых к методам действий;
    * *последующий* код фильтров, применяемых к методам действий;
  * *последующий* код фильтров, применяемых к контроллерам;
* *последующий* код фильтров, применяемых глобально.
  
Ниже представлен пример, демонстрирующий порядок вызова методов фильтров для синхронных фильтров действий.

| Sequence | Область фильтра | Метод фильтра |
|:--------:|:------------:|:-------------:|
| 1 | Global | `OnActionExecuting` |
| 2 | Контроллер | `OnActionExecuting` |
| 3 | Метод | `OnActionExecuting` |
| 4 | Метод | `OnActionExecuted` |
| 5 | Контроллер | `OnActionExecuted` |
| 6 | Global | `OnActionExecuted` |

Эта последовательность показывает:

* Метод фильтра вкладывается в фильтр контроллера.
* Фильтр контроллера вкладывается в глобальный фильтр. 

Иными словами, внутри метода On*Stage*ExecutionAsync асинхронного фильтра выполняются все фильтры с более узкой областью, пока код находится в стеке.

> [!NOTE]
> Каждый контроллер, наследуемый от базового класса `Controller`, включает методы `OnActionExecuting` и `OnActionExecuted`. Эти методы служат оболочкой для фильтров, выполняемых для данного действия: `OnActionExecuting` вызывается перед всеми фильтрами, а `OnActionExecuted` — после всех фильтров.

### <a name="overriding-the-default-order"></a>Переопределение порядка по умолчанию

Чтобы переопределить порядок выполнения по умолчанию, можно реализовать интерфейс `IOrderedFilter`. Этот интерфейс предоставляет свойство `Order`, которое имеет приоритет над областью и определяет порядок выполнения. Если фильтр имеет меньшее значение `Order`, его *предшествующий* код выполняется перед соответствующим кодом фильтра с большим значением `Order`. Если фильтр имеет меньшее значение `Order`, его *последующий* код выполняется после соответствующего кода фильтра с большим значением `Order`. Свойство `Order` можно задать с помощью параметра конструктора:

```csharp
[MyFilter(Name = "Controller Level Attribute", Order=1)]
```

Если имеются те же 3 фильтра действий, что и в предыдущем примере, но свойству `Order` фильтра контроллера и глобального фильтра присвоены значения 1 и 2 соответственно, порядок выполнения будет обратным.

| Sequence | Область фильтра | Свойство `Order` | Метод фильтра |
|:--------:|:------------:|:-----------------:|:-------------:|
| 1 | Метод | 0 | `OnActionExecuting` |
| 2 | Контроллер | 1  | `OnActionExecuting` |
| 3 | Global | 2  | `OnActionExecuting` |
| 4 | Global | 2  | `OnActionExecuted` |
| 5 | Контроллер | 1  | `OnActionExecuted` |
| 6 | Метод | 0  | `OnActionExecuted` |

Свойство `Order` имеет приоритет над областью при определении порядка выполнения фильтров. Фильтры сначала сортируются по порядку, а затем очередность окончательно определяется по области. Все встроенные фильтры реализуют `IOrderedFilter` и задают значение по умолчанию `Order`, равное 0. Во встроенных фильтрах область определяет порядок, если не задать отличное от нуля значение `Order`.

## <a name="cancellation-and-short-circuiting"></a>Отмена и замыкание

Вы можете замкнуть конвейер фильтров на любом этапе, задав свойство `Result` для параметра `context`, передаваемого в метод фильтра. Например, приведенный ниже фильтр ресурсов предотвращает выполнение остальной части конвейера.

<a name="short-circuiting-resource-filter"></a>

[!code-csharp[](./filters/sample/src/FiltersSample/Filters/ShortCircuitingResourceFilterAttribute.cs?highlight=12,13,14,15)]

В приведенном ниже коде как фильтр `ShortCircuitingResourceFilter`, так и фильтр `AddHeader` нацелены на метод действия `SomeResource`. `ShortCircuitingResourceFilter`:

* Выполняется первым, поскольку это фильтр ресурсов, а `AddHeader` — фильтр действий.
* Замыкает оставшуюся часть конвейера.

Поэтому фильтр `AddHeader` никогда не выполняется для действия `SomeResource`. Поведение будет аналогичным при применении обоих фильтров на уровне метода действия при условии, что фильтр `ShortCircuitingResourceFilter` выполняется первым. Фильтр `ShortCircuitingResourceFilter` выполняется в первую очередь из-за его типа или в связи с явным указанием свойства `Order`.

[!code-csharp[](./filters/sample/src/FiltersSample/Controllers/SampleController.cs?name=snippet_AddHeader&highlight=1,9)]

## <a name="dependency-injection"></a>Внедрение зависимостей

Фильтры можно добавлять по типу или экземпляру. При добавлении экземпляра он используется для каждого запроса. При добавлении типа он является активированным. Это означает, что экземпляр создается для каждого запроса, а зависимости конструктора заполняются посредством [внедрения зависимостей](../../fundamentals/dependency-injection.md). Добавление фильтра по типу равносильно вызову метода `filters.Add(new TypeFilterAttribute(typeof(MyFilter)))`.

Фильтры, которые реализуются как атрибуты и добавляются непосредственно в классы контроллеров или методы действий, не могут иметь зависимости конструктора, предоставленные посредством [внедрения зависимостей](../../fundamentals/dependency-injection.md). Связано это с тем, что параметры конструктора должны предоставляться для атрибутов в месте их применения. Это ограничение, налагаемое на использование атрибутов.

Если фильтры имеют зависимости, доступ к которым должен предоставляться посредством внедрения зависимостей, возможны несколько подходов. Вы можете применить фильтр к классу или методу действия с помощью одного из следующих средств:

* `ServiceFilterAttribute`
* `TypeFilterAttribute`
* Интерфейс `IFilterFactory`, реализованный для атрибута.

> [!NOTE]
> Одной из зависимостей, которые могут предоставляться посредством внедрения зависимостей, является средство ведения журнала. Однако следует избегать создания и использования фильтров исключительно в целях ведения журнала, так как [встроенные функции платформы для ведения журнала](xref:fundamentals/logging/index) уже могут предоставлять нужные возможности. Если вы планируете добавить возможности ведения журнала к фильтрам, они должны быть ориентированы на предметную область или особенности работы фильтров, а не на действия MVC или другие события платформы.

### <a name="servicefilterattribute"></a>ServiceFilterAttribute

Типы реализации фильтра службы регистрируются во внедрении зависимостей. Атрибут `ServiceFilterAttribute` извлекает экземпляр фильтра из внедрения зависимостей. Добавьте `ServiceFilterAttribute` в контейнер в методе `Startup.ConfigureServices` и ссылайтесь на него в атрибуте `[ServiceFilter]`:

[!code-csharp[](./filters/sample/src/FiltersSample/Startup.cs?name=snippet_ConfigureServices&highlight=11)]

[!code-csharp[](../../mvc/controllers/filters/sample/src/FiltersSample/Controllers/HomeController.cs?name=snippet_ServiceFilter&highlight=1)]

При использовании `ServiceFilterAttribute` задание `IsReusable` является указанием, что экземпляр фильтра *можно* многократно использовать за пределами области запроса, в которой он был создан. Платформа не предоставляет никаких гарантий, что будет создан хоть один экземпляр фильтра или фильтр не будет повторно запрошен из контейнера внедрения зависимостей позднее. Старайтесь не использовать `IsReusable` при использовании фильтра, который зависит от служб со временем существования, кроме singleton.

Использование атрибута `ServiceFilterAttribute` без регистрации типа фильтра приводит к исключению:

```
System.InvalidOperationException: No service for type
'FiltersSample.Filters.AddHeaderFilterWithDI' has been registered.
```

Объект `ServiceFilterAttribute` реализует интерфейс `IFilterFactory`. `IFilterFactory` предоставляет метод `CreateInstance` для создания экземпляра `IFilterMetadata`. Метод `CreateInstance` загружает указанный тип из контейнера служб (внедрение зависимостей).

### <a name="typefilterattribute"></a>TypeFilterAttribute

Атрибут `TypeFilterAttribute` похож на `ServiceFilterAttribute`, но его тип не разрешается напрямую из контейнера внедрения зависимостей. Он создает экземпляр типа с помощью `Microsoft.Extensions.DependencyInjection.ObjectFactory`.

Из-за этого отличия:

* Типы, на которые ссылаются с помощью `TypeFilterAttribute`, не нужно сначала регистрировать в контейнере.  Их зависимости выполняются контейнером. 
* Атрибут `TypeFilterAttribute` может также принимать аргументы конструктора для типа.

При использовании `TypeFilterAttribute` задание `IsReusable` является указанием, что экземпляр фильтра *можно* многократно использовать за пределами области запроса, в которой он был создан. Платформа не предоставляет никаких гарантий, что будет создан хотя бы один экземпляр фильтра. Старайтесь не использовать `IsReusable` при использовании фильтра, который зависит от служб со временем существования, кроме singleton.

В приведенном ниже примере показано, как передавать аргументы в тип с помощью `TypeFilterAttribute`.

[!code-csharp[](../../mvc/controllers/filters/sample/src/FiltersSample/Controllers/HomeController.cs?name=snippet_TypeFilter&highlight=1,2)]
[!code-csharp[](../../mvc/controllers/filters/sample/src/FiltersSample/Filters/LogConstantFilter.cs?name=snippet_TypeFilter_Implementation&highlight=6)]

### <a name="ifilterfactory-implemented-on-your-attribute"></a>Интерфейс IFilterFactory, реализованный в атрибуте

Если у вас есть фильтр, который:

* не требует аргументов;
* содержит зависимости конструктора, которые должны выполняться внедрением зависимостей,

вы можете использовать собственный именованный атрибут в классах и методах вместо `[TypeFilter(typeof(FilterType))]`). Ниже показан фильтр, в котором реализуется эта возможность.

[!code-csharp[](./filters/sample/src/FiltersSample/Filters/SampleActionFilterAttribute.cs?name=snippet_TypeFilterAttribute&highlight=1,3,7)]

Этот фильтр можно применять к классам и методам с помощью синтаксиса `[SampleActionFilter]` вместо использования `[TypeFilter]` или `[ServiceFilter]`.

## <a name="authorization-filters"></a>Фильтры авторизации

*Фильтры авторизации*:

* Контролируют доступ к методам действий.
* Выполняются в первую очередь в конвейере фильтров. 
* Имеют предшествующий, но не последующий метод. 

Создавать пользовательский фильтр авторизации следует только в том случае, если вы разрабатываете собственную платформу авторизации. Настройка политик авторизации или определение пользовательской политики авторизации предпочтительнее создания пользовательского фильтра. Встроенная реализация фильтра отвечает только за вызов системы авторизации.

В фильтрах авторизации не следует вызывать исключения, поскольку они никак не будут обрабатываться (фильтры исключений не будут обрабатывать их). Возможно, при возникновении исключения следует создать вызов.

Дополнительные сведения об [авторизации](xref:security/authorization/introduction).

## <a name="resource-filters"></a>Фильтры ресурсов

* Реализуют либо интерфейс `IResourceFilter`, либо интерфейс `IAsyncResourceFilter`.
* Их выполнение охватывает большую часть конвейера фильтров. 
* До фильтров ресурсов применяются только [фильтры авторизации](#authorization-filters).

Фильтры ресурсов полезны, если необходимо избежать большей части работы, выполняемой запросом. Например, фильтр кэширования может избежать выполнения остальной части конвейера, если ответ имеется в кэше.

Приведенный ранее [замыкающий фильтр ресурсов](#short-circuiting-resource-filter) — это один из примеров фильтров ресурсов. Еще один пример — [DisableFormValueModelBindingAttribute](https://github.com/aspnet/Entropy/blob/rel/1.1.1/samples/Mvc.FileUpload/Filters/DisableFormValueModelBindingAttribute.cs):

* Он предотвращает доступ привязки модели к данным формы. 
* Он полезен для загрузки больших файлов, если необходимо предотвратить считывание формы в память.

## <a name="action-filters"></a>Фильтры действий

> [!IMPORTANT]
> Фильтры действий **неприменимы** к Razor Pages. Razor Pages поддерживает <xref:Microsoft.AspNetCore.Mvc.Filters.IPageFilter> и <xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncPageFilter>. Дополнительные сведения см. в разделе [Методы фильтрации для Razor Pages](xref:razor-pages/filter).

*Фильтры действий*:

* Реализуют либо интерфейс `IActionFilter`, либо интерфейс `IAsyncActionFilter`.
* Их выполнение охватывает выполнение методов действия.

Вот пример фильтра действий:

[!code-csharp[](./filters/sample/src/FiltersSample/Filters/SampleActionFilter.cs?name=snippet_ActionFilter)]

<xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutingContext> предоставляет следующие свойства:

* `ActionArguments` позволяет управлять входными данными действия;
* `Controller` позволяет управлять экземпляром контроллера; 
* `Result` — задание этого свойства позволяет избежать выполнения метода действия и последующих фильтров действий. Вызов исключения также предотвращает выполнение метода действия и последующих фильтров, однако рассматривается как сбой, а не успешный результат.

<xref:Microsoft.AspNetCore.Mvc.Filters.ActionExecutedContext> предоставляет `Controller` и `Result`, а также следующие свойства:

* `Canceled` — будет иметь значение true, если выполнение действия было сокращено другим фильтром;
* `Exception` — будет иметь отличное от NULL значение, если действие или последующий фильтр действий вызвали исключение. Если этому свойству присвоено значение NULL, исключение обрабатывается и объект `Result` выполняется так, как если бы он был возвращен методом действия обычным образом.

Для `IAsyncActionFilter` вызов `ActionExecutionDelegate`:

* Приводит к выполнению последующих фильтров действий и метода действия.
* Возвращает `ActionExecutedContext`. 

Чтобы избежать их выполнения, присвойте `ActionExecutingContext.Result` экземпляру результата и не вызывайте `ActionExecutionDelegate`.

Платформа предоставляет абстрактный класс `ActionFilterAttribute`, подклассы которого можно создавать. 

Вы можете использовать фильтр действий для проверки состояния модели и возврата ошибок, если состояние недопустимо.

[!code-csharp[](./filters/sample/src/FiltersSample/Filters/ValidateModelAttribute.cs)]

Метод `OnActionExecuted` выполняется после метода действия. Он имеет доступ к результатам действия и может управлять ими посредством свойства `ActionExecutedContext.Result`. `ActionExecutedContext.Canceled` будет иметь значение true, если выполнение действия было сокращено другим фильтром. `ActionExecutedContext.Exception` будет иметь отличное от NULL значение, если действие или последующий фильтр действий вызвали исключение. Если установить для `ActionExecutedContext.Exception` значение NULL:

* Будет эффективно обрабатываться исключение.
* `ActionExecutedContext.Result` будет выполняться так, как если бы метод действия вернул его обычным образом.

## <a name="exception-filters"></a>Фильтры исключений

*Фильтры исключений* реализуют либо интерфейс `IExceptionFilter`, либо интерфейс `IAsyncExceptionFilter`. С их помощью можно реализовывать политики обработки стандартных ошибок для приложения. 

Приведенный ниже пример фильтра исключений использует пользовательское представление ошибок для разработчика для вывода подробных сведений об исключениях, которые происходят во время разработки приложения:

[!code-csharp[](./filters/sample/src/FiltersSample/Filters/CustomExceptionFilterAttribute.cs?name=snippet_ExceptionFilter&highlight=1,14)]

Фильтры исключений:

* Не имеют предшествующих и последующих событий. 
* Реализуют `OnException` или `OnExceptionAsync`. 
* Обрабатывают необработанные исключения, которые происходят при создании контроллера, в [привязке модели](../models/model-binding.md), фильтрах действий или методах действий. 
* Не перехватывают исключения, которые происходят в фильтрах ресурсов, фильтрах результатов или при выполнении результата MVC.

Для обработки исключения присвойте свойству `ExceptionContext.ExceptionHandled` значение true или напишите ответ. Это предотвратит распространение исключения. Фильтр исключений не может преобразовать исключение в успешное выполнение. Это может сделать только фильтр действий.

> [!NOTE]
> В ASP.NET Core 1.1 ответ не отправляется, если вы присваиваете свойству `ExceptionHandled` значение true **и** пишете ответ. В аналогичной ситуации в ASP.NET Core 1.0 ответ отправляется, а в ASP.NET Core 1.1.2 применяется поведение, принятое в версии 1.0. Дополнительные сведения см. в описании [проблемы № 5594](https://github.com/aspnet/Mvc/issues/5594) в репозитории GitHub. 

Фильтры исключений:

* Хорошо подходят для перехвата исключений, возникающих в действиях MVC.
* Не обладает такой гибкостью, как ПО промежуточного слоя обработки ошибок. 

ПО промежуточного слоя хорошо подходит для обработки исключений. Используйте фильтры исключений только тогда, когда обработка ошибок должна осуществляться *по-разному* в зависимости от выбранного действия MVC. Например, в приложении могут быть методы действий как для конечных точек API, так и для представлений или HTML. Конечные точки API могут возвращать сведения об ошибках в формате JSON, в то время как действия на основе представлений могут возвращать страницу ошибки в формате HTML.

`ExceptionFilterAttribute` может иметь подклассы. 

## <a name="result-filters"></a>Фильтры результатов

* Реализация интерфейса:
  * `IResultFilter` или `IAsyncResultFilter`.
  * `IAlwaysRunResultFilter` или `IAsyncAlwaysRunResultFilter`
* Их выполнение охватывает выполнение результатов действий. 

### <a name="iresultfilter-and-iasyncresultfilter"></a>IResultFilter и IAsyncResultFilter

Вот пример фильтра результатов, который добавляет заголовок HTTP.

[!code-csharp[](./filters/sample/src/FiltersSample/Filters/LoggingAddHeaderFilter.cs?name=snippet_ResultFilter)]

Тип выполняемого результата зависит от соответствующего действия. Действие MVC, возвращающее представление, будет включать в себя всю обработку Razor в рамках выполняемого объекта `ViewResult`. В процессе выполнения результата метод API может производить сериализацию. Дополнительные сведения о [результатах действий](actions.md)

Фильтры результатов выполняются только в случае успешных результатов — когда действие или фильтры действий предоставляют результат действия. Фильтры результатов не выполняются, когда фильтры исключений обрабатывают исключение.

Метод `OnResultExecuting` может сокращать выполнение результата действия и последующих фильтров результатов, присваивая свойству `ResultExecutingContext.Cancel` значение true. При сокращении выполнения, как правило, следует производить запись в объект ответа, чтобы избежать формирования пустого ответа. Вызов исключения:

* Предотвращает выполнение результата действия и последующих фильтров.
* Рассматривается как сбой, а не успешный результат.

При выполнении метода `OnResultExecuted` ответ, скорее всего, был отправлен клиенту и больше не доступен для изменения (если только не было вызвано исключение). `ResultExecutedContext.Canceled` будет иметь значение true, если выполнение результата действия было сокращено другим фильтром.

`ResultExecutedContext.Exception` будет иметь отличное от NULL значение, если результат действия или последующий фильтр результатов вызвали исключение. Присвоение `Exception` значения NULL приводит к обработке исключения и предотвращает его последующий вызов платформой MVC на дальнейших этапах конвейера. Если исключение обрабатывается в фильтре результатов, запись данных в ответ может оказаться невозможной. Если результат действия вызывает исключение в процессе выполнения и заголовки уже были переданы в клиент, надежного механизма отправки кода сбоя не существует.

Для `IAsyncResultFilter` вызов `await next` для `ResultExecutionDelegate` приводит к выполнению последующих фильтров результатов и результата действия. Чтобы сократить выполнение, присвойте `ResultExecutingContext.Cancel` значение true и не вызывайте `ResultExectionDelegate`.

Платформа предоставляет абстрактный класс `ResultFilterAttribute`, подклассы которого можно создавать. Представленный ранее класс [AddHeaderAttribute](#add-header-attribute) — это пример атрибута фильтра результатов.

### <a name="ialwaysrunresultfilter-and-iasyncalwaysrunresultfilter"></a>IAlwaysRunResultFilter и IAsyncAlwaysRunResultFilter

Интерфейсы <xref:Microsoft.AspNetCore.Mvc.Filters.IAlwaysRunResultFilter> и <xref:Microsoft.AspNetCore.Mvc.Filters.IAsyncAlwaysRunResultFilter> объявляют реализацию <xref:Microsoft.AspNetCore.Mvc.Filters.IResultFilter>, которая выполняется для результатов действий. К результату действия применяется фильтр, если <xref:Microsoft.AspNetCore.Mvc.Filters.IExceptionFilter> или <xref:Microsoft.AspNetCore.Mvc.Filters.IAuthorizationFilter> не применяются и не игнорируют ответ.

Другими словами, эти фильтры выполняются всегда, кроме случаев, когда фильтр исключений или авторизации игнорирует их. Фильтры, отличающиеся от `IExceptionFilter` и `IAuthorizationFilter`, не игнорируют всегда выполняющиеся фильтры.

Например, следующий фильтр всегда выполняется, задавая результат действия (<xref:Microsoft.AspNetCore.Mvc.ObjectResult>) с кодом состояния *422 Unprocessable Entity* при сбое согласования содержимого:

```csharp
public class UnprocessableResultFilter : Attribute, IAlwaysRunResultFilter
{
    public void OnResultExecuting(ResultExecutingContext context)
    {
        if (context.Result is StatusCodeResult statusCodeResult &&
            statusCodeResult.StatusCode == 415)
        {
            context.Result = new ObjectResult("Can't process this!")
            {
                StatusCode = 422,
            };
        }
    }

    public void OnResultExecuted(ResultExecutedContext context)
    {
    }
}
```

## <a name="using-middleware-in-the-filter-pipeline"></a>Использование ПО промежуточного слоя в конвейере фильтров

Фильтры ресурсов по принципу работы похожи на [ПО промежуточного слоя](xref:fundamentals/middleware/index) тем, что они заключают в себя выполнение всех объектов, находящихся далее в конвейере. Однако фильтры отличаются от ПО промежуточного слоя тем, что они являются частью MVC, а значит, имеют доступ к контексту и конструкциям MVC.

В ASP.NET Core 1.1 можно использовать ПО промежуточного слоя в конвейере фильтров. Это может потребоваться, если имеется компонент ПО промежуточного слоя, которому требуется доступ к данным маршрутов MVC либо который должен выполняться только для определенных контроллеров или действий.

Чтобы использовать ПО промежуточного слоя в качестве фильтра, создайте тип с методом `Configure`, определяющим ПО промежуточного слоя, которое нужно внедрить в конвейер фильтров. Вот пример, в котором ПО промежуточного слоя локализации применяется для определения текущих языка и региональных параметров для запроса:

[!code-csharp[](./filters/sample/src/FiltersSample/Filters/LocalizationPipeline.cs?name=snippet_MiddlewareFilter&highlight=3,21)]

Затем можно использовать `MiddlewareFilterAttribute` для выполнения ПО промежуточного слоя для выбранного контроллера или действия либо на глобальном уровне:

[!code-csharp[](./filters/sample/src/FiltersSample/Controllers/HomeController.cs?name=snippet_MiddlewareFilter&highlight=2)]

Фильтры ПО промежуточного слоя выполняются на том же этапе конвейера фильтров, что и фильтры ресурсов, перед привязкой модели и после остальной части конвейера.

## <a name="next-actions"></a>Дальнейшие действия

* Дополнительные сведения см. в статье [Filter methods for Razor Pages in ASP.NET Core](xref:razor-pages/filter) (Методы фильтрации для Razor Pages в ASP.NET Core).
* Чтобы поэкспериментировать с фильтрами, [скачайте, протестируйте и измените образец GitHub](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/filters/sample).
