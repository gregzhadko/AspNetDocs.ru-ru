---
title: Использование центров в ASP.NET Core SignalR
author: bradygaster
description: Узнайте, как использовать центры в ASP.NET Core SignalR.
monikerRange: '>= aspnetcore-2.1'
ms.author: bradyg
ms.custom: mvc
ms.date: 11/20/2018
uid: signalr/hubs
ms.openlocfilehash: 9bc74079235338c75c47e06bde2b78dc1c466bd6
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57030251"
---
# <a name="use-hubs-in-signalr-for-aspnet-core"></a>Использование центров в SignalR для ASP.NET Core

По [Рейчел Аппель](https://twitter.com/rachelappel) и [Кевин Гриффин](https://twitter.com/1kevgriff)

[Просмотреть или скачать образец кода](https://github.com/aspnet/Docs/tree/master/aspnetcore/signalr/hubs/sample/ ) [(способ загрузки)](xref:index#how-to-download-a-sample)

## <a name="what-is-a-signalr-hub"></a>Что такое концентратор SignalR

API концентраторов SignalR позволяет вызывать методы для подключенных клиентов с сервера. В серверном коде определить методы, вызываемые клиентом. В клиентском коде определить методы, вызываемые с сервера. SignalR отвечает за все за кулисами, позволяет в режиме реального времени связи клиент сервер и сервер клиент.

## <a name="configure-signalr-hubs"></a>Настройка концентраторов SignalR

По промежуточного слоя SignalR требует некоторых служб, которые настраиваются путем вызова `services.AddSignalR`.

[!code-csharp[Configure service](hubs/sample/startup.cs?range=38)]

При добавлении приложения ASP.NET Core SignalR функциональные возможности, настроить маршруты SignalR путем вызова `app.UseSignalR` в `Startup.Configure` метод.

[!code-csharp[Configure routes to hubs](hubs/sample/startup.cs?range=57-60)]

## <a name="create-and-use-hubs"></a>Создание и использование концентраторов

Создать концентратор, объявляя класс, наследуемый от `Hub`и добавьте в него открытые методы. Клиенты могут вызывать методы, которые определены как `public`.

```csharp
public class ChatHub : Hub
{
    public Task SendMessage(string user, string message)
    {
        return Clients.All.SendAsync("ReceiveMessage", user, message);
    }
}
```

Можно указать тип возвращаемого значения и параметры, включая сложные типы и массивы, как это делается в любом методе C#. SignalR обрабатывает сериализации и десериализации сложных объектов и массивов в параметрах и возвращаемых значений.

> [!NOTE]
> Концентраторы являются временными:
> * Не храните состояние в свойство класса концентратора. Каждый вызов метода концентратора выполняется с использованием нового экземпляра концентратора.  
> * Используйте `await` при вызове асинхронных методов, которые зависят от концентратора, остаются в активном состоянии. Например, метода, такого как `Clients.All.SendAsync(...)` может завершиться ошибкой, если он вызывается без `await` и завершения метода концентратора, прежде чем `SendAsync` завершения.

## <a name="the-context-object"></a>Объект контекста

`Hub` Класс имеет `Context` свойство, которое содержит следующие свойства, используя сведения о подключении:

| Свойство. | Описание |
| ------ | ----------- |
| `ConnectionId` | Получает уникальный идентификатор для подключения, назначенный SignalR. Есть один идентификатор подключения для каждого подключения.|
| `UserIdentifier` | Получает [идентификатор пользователя](xref:signalr/groups). По умолчанию использует SignalR `ClaimTypes.NameIdentifier` из `ClaimsPrincipal` связан с соединением в качестве идентификатора пользователя. |
| `User` | Получает `ClaimsPrincipal` связанный с текущим пользователем. |
| `Items` | Получает коллекцию ключей и значений, можно использовать для совместного использования данных в рамках этого подключения. Данные могут храниться в этой коллекции и будет сохраняться для подключения через вызовы методов концентратора на другой. |
| `Features` | Получает коллекцию функций, доступных для соединения. Сейчас этой коллекции не требуется в большинстве сценариев, поэтому он не подробно задокументированы в еще. |
| `ConnectionAborted` | Получает `CancellationToken` , уведомляет, когда подключение будет прервано. |

`Hub.Context` также содержит следующие методы:

| Метод | Описание: |
| ------ | ----------- |
| `GetHttpContext` | Возвращает `HttpContext` подключения или `null` Если соединение не ассоциировано с HTTP-запроса. Для подключений по протоколу HTTP можно использовать этот метод для получения сведений, таких как HTTP-заголовки и строки запросов. |
| `Abort` | Прерывает подключение. |

## <a name="the-clients-object"></a>Объект клиентов

`Hub` Класс имеет `Clients` свойство, которое содержит следующие свойства для обмена данными между сервером и клиентом:

| Свойство. | Описание: |
| ------ | ----------- |
| `All` | Вызывает метод на все подключенные клиенты |
| `Caller` | Вызывает метод на стороне клиента, вызвавшему метод концентратора |
| `Others` | Вызывает метод на все подключенные клиенты, кроме клиента, который вызывает метод |

`Hub.Clients` также содержит следующие методы:

| Метод | Описание: |
| ------ | ----------- |
| `AllExcept` | Вызывает метод на все подключенные клиенты, за исключением указанного соединений |
| `Client` | Вызывает метод для определенного подключенного клиента |
| `Clients` | Вызывает метод для конкретных подключенных клиентов |
| `Group` | Вызывает метод для всех подключений в указанной группе  |
| `GroupExcept` | Вызывает метод для всех подключений, в состав указанной группы, за исключением указанным подключениям |
| `Groups` | Вызывает метод на несколько групп соединений  |
| `OthersInGroup` | Вызывает метод группы соединений, за исключением клиента, вызвавшему метод концентратора  |
| `User` | Вызывает метод для всех подключений, связанных с конкретным пользователем |
| `Users` | Вызывает метод для всех подключений, связанных с определенными пользователями |

Каждого свойства или метода в таблицах выше возвращает объект с `SendAsync` метод. `SendAsync` Метод позволяет указать имя и параметры метода для вызова клиента.

## <a name="send-messages-to-clients"></a>Отправить сообщения клиентам

Чтобы выполнять вызовы для конкретных клиентов, используйте свойства `Clients` объекта. В следующем примере существует три метода концентратора:

* `SendMessage` отправляет сообщение всем подключенным клиентам, с помощью `Clients.All`.
* `SendMessageToCaller` отправляет сообщение обратно в вызывающий объект, с помощью `Clients.Caller`.
* `SendMessageToGroups` отправляет сообщение всем клиентам в `SignalR Users` группы.

[!code-csharp[Send messages](hubs/sample/hubs/chathub.cs?name=HubMethods)]

## <a name="strongly-typed-hubs"></a>Строго типизированные концентраторов

Недостаток использования `SendAsync` — что оно полагается на магической строки для указания метода клиента для вызова. При этом остается открытым кодом для ошибки времени выполнения, если неправильно указано имя метода или отсутствует от клиента.

Альтернативой использованию `SendAsync` — для задания строго типизированных `Hub` с <xref:Microsoft.AspNetCore.SignalR.Hub`1>. В следующем примере `ChatHub` методы клиента были извлечены out в интерфейсе `IChatClient`.  

[!code-csharp[Interface for IChatClient](hubs/sample/hubs/ichatclient.cs?name=snippet_IChatClient)]

Этот интерфейс можно использовать рефакторинг предыдущих `ChatHub` пример.

[!code-csharp[Strongly typed ChatHub](hubs/sample/hubs/StronglyTypedChatHub.cs?range=8-18,36)]

С помощью `Hub<IChatClient>` позволяет клиентских методов проверки во время компиляции. Это позволяет предотвратить проблемы, из-за применение магических строк, так как `Hub<T>` только обеспечить доступ к методам, определенным в интерфейсе.

С помощью строго типизированного `Hub<T>` отключает возможность использования `SendAsync`. Любые методы, определенные в интерфейсе по-прежнему могут быть определены как асинхронные. На самом деле, каждый из этих методов должна возвращать `Task`. Так как он является интерфейсом, не используйте `async` ключевое слово. Пример:

```csharp
public interface IClient
{
    Task ClientMethod();
}
```

> [!NOTE]
> `Async` Суффикс не удаляются из имени метода. Если не использовать метод клиентов определяется с помощью `.on('MyMethodAsync')`, не следует использовать `MyMethodAsync` как имя.

## <a name="change-the-name-of-a-hub-method"></a>Измените имя метода концентратора

По умолчанию имя сервера центра метод является имя метода .NET. Тем не менее, можно использовать [HubMethodName](xref:Microsoft.AspNetCore.SignalR.HubMethodNameAttribute) атрибут, чтобы изменить это значение по умолчанию и вручную указывать имя метода. Клиент должен использовать это имя вместо имени метода в .NET, при вызове метода.

[!code-csharp[HubMethodName attribute](hubs/sample/hubs/chathub.cs?name=HubMethodName&highlight=1)]

## <a name="handle-events-for-a-connection"></a>Обработка событий для подключения

Предоставляет API концентраторов SignalR `OnConnectedAsync` и `OnDisconnectedAsync` виртуальные методы для управления и отслеживания подключений. Переопределить `OnConnectedAsync` виртуальный метод для выполнения действий, когда клиент подключается к центру, таких как добавление его в группу.

[!code-csharp[Handle connection](hubs/sample/hubs/chathub.cs?name=OnConnectedAsync)]

Переопределить `OnDisconnectedAsync` виртуальный метод для выполнения действий при отключении клиента. Если клиент отключается намеренно (путем вызова `connection.stop()`, например), `exception` параметр будет иметь `null`. Тем не менее, если клиент отключен из-за ошибки (например, сбой сети), `exception` параметр будет содержать исключение, описывающие неудачу.

[!code-csharp[Handle disconnection](hubs/sample/hubs/chathub.cs?name=OnDisconnectedAsync)]

## <a name="handle-errors"></a>Обработка ошибок

Исключения, возникшие в методах hub отправляются клиенту, вызвавшему метод. На стороне клиента JavaScript `invoke` возвращает [обещание JavaScript](https://developer.mozilla.org/docs/Web/JavaScript/Guide/Using_promises). Когда клиент получает ошибку с обработчиком подключенных к promise с помощью `catch`, он вызывается и передан в качестве JavaScript `Error` объекта.

[!code-javascript[Error](hubs/sample/wwwroot/js/chat.js?range=23)]

При возникновении исключения в концентраторе, подключения не закрыты. По умолчанию SignalR возвращает сообщения об ошибке клиенту. Пример:

```
Microsoft.AspNetCore.SignalR.HubException: An unexpected error occurred invoking 'MethodName' on the server.
```

Непредвиденные исключения часто содержат конфиденциальные сведения, такие как имя сервера базы данных в исключение, возникающее при сбое подключения к базе данных. SignalR не предоставляет эти подробные сообщения об ошибках по умолчанию, из соображений безопасности. См. в разделе [статья рекомендации по безопасности](xref:signalr/security#exceptions) Дополнительные сведения о том, почему подавляются сведения об исключении.

Если у вас есть исключительных условий вы *сделать* потребоваться распространить клиенту, можно использовать `HubException` класса. Если вызывается `HubException` из своего метода концентратора, SignalR **будет** отправлять все сообщение клиенту, без изменений.

[!code-csharp[ThrowHubException](hubs/sample/hubs/chathub.cs?name=ThrowHubException&highlight=3)]

> [!NOTE]
> Отправляет только SignalR `Message` свойство исключения клиенту. Трассировка стека и другими свойствами исключение не доступны клиенту.

## <a name="related-resources"></a>Связанные ресурсы

* [Введение в ASP.NET Core SignalR](xref:signalr/introduction)
* [Клиент JavaScript](xref:signalr/javascript-client)
* [Публикация в Azure](xref:signalr/publish-to-azure-web-app)
