---
title: Вопросы безопасности в ASP.NET Core SignalR
author: bradygaster
description: Узнайте, как использовать проверку подлинности и авторизации в ASP.NET Core SignalR.
monikerRange: '>= aspnetcore-2.1'
ms.author: anurse
ms.custom: mvc
ms.date: 11/06/2018
uid: signalr/security
ms.openlocfilehash: 6e9f849ed856cf1cbf989b8b16cab5209c465471
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57059931"
---
# <a name="security-considerations-in-aspnet-core-signalr"></a>Вопросы безопасности в ASP.NET Core SignalR

По [Andrew Stanton медсестра](https://twitter.com/anurse)

В этой статье сведения об обеспечении безопасности SignalR.

## <a name="cross-origin-resource-sharing"></a>Общий доступ к ресурсам независимо от источника

[Кросс-совместного использования ресурсов (CORS)](https://www.w3.org/TR/cors/) может использоваться для подключений SignalR независимо от источника в браузере. Если код JavaScript размещается в домене, отличном от приложения SignalR, [по промежуточного слоя CORS](xref:security/cors) необходимо включить, чтобы разрешить JavaScript для подключения к приложению SignalR. Разрешить запросы независимо от источника только из доменов, которым вы доверяете или элемента управления. Пример:

* На узле размещается на `http://www.example.com`
* SignalR приложение размещено на `http://signalr.example.com`

CORS необходимо настроить в приложении SignalR, разрешая только источник `www.example.com`.

Дополнительные сведения о настройке CORS см. в разделе [Включение запросов независимо от источника (CORS)](xref:security/cors). SignalR **требует** следующие политики CORS:

* Разрешить определенные ожидаемые источников. Позволяя любого источника возможна, но является **не** безопасное или рекомендуемые.
* Методы HTTP `GET` и `POST` должны быть разрешены.
* Необходимо включить учетные данные, даже в том случае, если не используется проверка подлинности.

Например, следующая политика CORS позволяет клиенту браузера SignalR, размещенных на `https://example.com` для доступа к приложению SignalR, размещенных на `https://signalr.example.com`:

[!code-csharp[Main](security/sample/Startup.cs?name=snippet1)]

> [!NOTE]
> SignalR не совместим с встроенной функции CORS в службе приложений Azure.

## <a name="websocket-origin-restriction"></a>Ограничение WebSocket Origin

::: moniker range=">= aspnetcore-2.2"

Варианты защиты, предоставляемые CORS, не применяются к WebSocket. Origin ограничение на WebSockets, чтение [WebSockets origin ограничение](xref:fundamentals/websockets#websocket-origin-restriction).

::: moniker-end

::: moniker range="< aspnetcore-2.2"

Варианты защиты, предоставляемые CORS, не применяются к WebSocket. Браузеры **не** поддерживают следующие задачи:

* выполнение предварительных запросов CORS;
* использование ограничений, указанных в заголовках `Access-Control`, при выполнении запросов WebSocket.

Однако браузеры отправляют заголовок `Origin` при выпуске запросов WebSocket. Приложения должны быть настроены для проверки этих заголовков, чтобы использовались только WebSocket из ожидаемых источников.

В ASP.NET Core 2.1 и более поздних версиях проверка заголовков можно добиться, используя пользовательские по промежуточного слоя поместить **перед `UseSignalR`и по промежуточного слоя проверки подлинности** в `Configure`:

[!code-csharp[Main](security/sample/Startup.cs?name=snippet2)]

> [!NOTE]
> Заголовок `Origin` контролируется клиентом и, как и заголовок `Referer`, может быть подделан. Эти заголовки должен **не** использоваться в качестве механизма проверки подлинности.

::: moniker-end

## <a name="access-token-logging"></a>Ведение журнала для маркера доступа

При использовании WebSockets или Server-Sent события, браузер клиент отправляет маркер доступа в строке запроса. Получение маркера доступа с помощью строки запроса является обычно так безопасен, как с помощью стандарта `Authorization` заголовка. Следует всегда использовать протокол HTTPS, чтобы обеспечить безопасное подключение между клиентом и сервером end-to-end. Многие веб-серверы входа URL-адрес для каждого запроса, включая строку запроса. Ведение журнала URL-адреса могут вносить в журнал маркер доступа. ASP.NET Core регистрирует URL-адрес для каждого запроса по умолчанию, который будет включать строку запроса. Пример:

```
info: Microsoft.AspNetCore.Hosting.Internal.WebHost[1]
      Request starting HTTP/1.1 GET http://localhost:5000/myhub?access_token=1234
```

Если у вас есть вопросы о ведении журнала эти данные с сервера журналов, можно отключить ведение журнала полностью, настроив `Microsoft.AspNetCore.Hosting` средство ведения журнала `Warning` уровне или выше (эти сообщения записываются в `Info` уровень). См. в документации на [фильтрации журнала](xref:fundamentals/logging/index#log-filtering) Дополнительные сведения. Если вы хотите по-прежнему журнал определенные сведения запроса, вы можете [записи по промежуточного слоя](xref:fundamentals/middleware/write) данные требовать и отфильтровать `access_token` значения строки запроса (при его наличии).

## <a name="exceptions"></a>Исключения

Сообщения об исключениях, как правило, являются конфиденциальных данных, которые не следует раскрывать для клиента. По умолчанию SignalR не отправляет сведения о исключения, вызванного метода концентратора клиенту. Вместо этого клиент получает универсальное сообщение, указывающее, что произошла ошибка. Доставка сообщений исключения клиенту может быть заменено (например в среде разработки или тестирования) [ `EnableDetailedErrors` ](xref:signalr/configuration#configure-server-options). Сообщения об исключениях не должны предоставляться клиенту в рабочих приложениях.

## <a name="buffer-management"></a>Управление буферами

SignalR использует буферы подключения для управления входящих и исходящих сообщений. По умолчанию SignalR ограничивает эти буферы, до 32 КБ. Наибольшее сообщение, которое клиент или сервер может отправить составляет 32 КБ. Максимальная память, занятая подключение для сообщений составляет 32 КБ. Если сообщения всегда меньше 32 КБ, можно уменьшить предел, который:

* Запрещает клиента отправлять сообщения большего размера.
* Сервер никогда не потребуется выделить большие буферы для приема сообщений.

Если сообщения превышает 32 КБ, можно увеличить предел. Увеличение этого значения означает, что:

* Клиент может вызвать сервер должен выделить большие буферы памяти.
* Распределение Server больших буферов может уменьшить количество одновременных подключений.

Существуют ограничения для входящих и исходящих сообщений, как можно настроить на [ `HttpConnectionDispatcherOptions` ](xref:signalr/configuration#configure-server-options) объект, настроенный в `MapHub`:

* `ApplicationMaxBufferSize` Представляет максимальное число байтов от клиента, буферы сервера. Если клиент пытается отправить сообщение, размер которых превышает этот предел, соединение может быть закрыт.
* `TransportMaxBufferSize` Представляет максимальное число байтов, которые сервер может отправлять. Если сервер пытается отправить сообщение (включая возвращаемые значения методов концентратора), размер которых превышает этот предел, будет вызвано исключение.

Если установленное `0` отключает ограничение. Удаление ограничения позволяет клиенту отправлять сообщения из любого размера. Вредоносные клиенты при отправке больших сообщений может привести к памяти для выделения. Использование памяти может значительно снизить количество одновременных подключений.
