---
uid: single-page-application/overview/introduction/knockoutjs-template
title: Одностраничное приложение. Шаблон KnockoutJS | Документация Майкрософт
author: MikeWasson
description: Шаблон Knockout
ms.author: riande
ms.date: 01/30/2013
ms.assetid: f9c07af0-4b20-4b08-af8f-47fc3df169a2
msc.legacyurl: /single-page-application/overview/introduction/knockoutjs-template
msc.type: authoredcontent
ms.openlocfilehash: 20d2d4412345399acdde1535447cc18b6611b572
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59412857"
---
# <a name="single-page-application-knockoutjs-template"></a>Одностраничное приложение. Шаблон KnockoutJS

по [Майк Уоссон](https://github.com/MikeWasson)

> Шаблон MVC Knockout является частью ASP.NET и веб-инструментами 2012.2
> 
> [Скачать ASP.NET и веб-инструменты 2012.2](https://go.microsoft.com/fwlink/?LinkId=282650)


Обновления ASP.NET и веб-инструментами 2012.2 содержит шаблон одностраничного приложения (SPA) для ASP.NET MVC 4. Этот шаблон предназначен для начала работы, быстрого создания интерактивных клиентского веб-приложений.

«Одностраничного приложения» (SPA) — это общий термин для веб-приложения, который загружает единственную HTML-страницу и затем обновляет страницу динамически, вместо загрузки новых страниц. После загрузки начальной страницы SPA взаимодействует с сервером с помощью запросов AJAX.

![](knockoutjs-template/_static/image1.png)

AJAX нет ничего нового, но на сегодняшний день существует платформ JavaScript, которые упрощают создание и обслуживание большого сложные приложения SPA. Кроме того HTML 5 и CSS3 что облегчает создание многофункциональных пользовательских интерфейсов.

Чтобы приступить к работе, SPA шаблон создает образец приложения «Список дел». В этом руководстве мы рассмотрим демонстрацию шаблона. Сначала мы будем рассмотрим само приложение списка дел, а затем проверьте примеров технологий, которые делают это в действии.

## <a name="create-a-new-spa-template-project"></a>Создание нового шаблона проекта SPA

Требования:

- Visual Studio 2012 или Visual Studio Express 2012 для Web
- Обновление средств ASP.NET Web 2012.2. Можно установить обновление [здесь](https://www.microsoft.com/web/handlers/webpi.ashx?command=getinstallerredirect&appid=ASPDOTNETandWebTools2012_2).

Запустите Visual Studio и выберите **новый проект** с начальной страницы. Или с **файл** меню, выберите **New** и затем **проекта**.

В **шаблоны** области выберите **установленные шаблоны** и разверните **Visual C#** узла. В разделе **Visual C#** выберите **Web**. В списке шаблонов проектов выберите **веб-приложение ASP.NET MVC 4**. Имя проекта и нажмите кнопку **ОК**.

![](knockoutjs-template/_static/image2.png)

В **новый проект** мастера выберите **одностраничного приложения**.

![](knockoutjs-template/_static/image3.png)

Нажмите клавишу F5, чтобы выполнить сборку приложения и запустить его. При первом запуске приложения отображается экран входа.

![](knockoutjs-template/_static/image4.png)

Нажмите кнопку &quot;зарегистрироваться&quot; связать и создать нового пользователя.

![](knockoutjs-template/_static/image5.png)

После входа в приложение создает список Todo по умолчанию с двумя элементами. Нажмите кнопку «Добавить список дел» для добавления нового списка.

![](knockoutjs-template/_static/image6.png)

Список переименования, добавление элементов в списке и снимите флажок. Кроме того, можно удалить элементы или удалять весь список. Эти изменения автоматически сохраняются в базу данных на сервере (фактически LocalDB на этом этапе, так как приложение выполняется локально).

![](knockoutjs-template/_static/image7.png)

## <a name="architecture-of-the-spa-template"></a>Архитектура шаблона одностраничного приложения

На этой диаграмме показаны основные строительные блоки для приложения.

![](knockoutjs-template/_static/image8.png)

На стороне сервера ASP.NET MVC служит HTML, а также обрабатывает проверку подлинности на основе форм.

Веб-API ASP.NET обрабатывает все запросы, относящиеся к ToDoLists и ToDoItems, включая получение, создание, обновление и удаление. Клиент обменивается данными с веб-API в формате JSON.

Entity Framework (EF) — уровень объектно-реляционное отображение. Он служит посредником между объектно ориентированном мире ASP.NET и базы данных. База данных использует LocalDB, но это можно изменить в файле Web.config. Обычно вы будет использовать LocalDB для локальной разработки и затем развернуть в базе данных SQL на сервере, используя миграцию на EF code first.

На стороне клиента библиотека Knockout.js обрабатывает обновления страниц из запросов AJAX. Knockout использует привязку данных для синхронизации на странице с последними данными. Таким образом, не нужно писать код, который поможет выполнить данные JSON и обновляет DOM. Вместо этого вы поместите декларативных атрибутов в код HTML, сообщите Knockout, как для представления данных.

Большим преимуществом этой архитектуры является то, что он отделяет слой представления от логики приложения. Можно создать часть веб-API, не зная ничего о том, как будет выглядеть веб-страницы. На стороне клиента, созданной «модель представления» для представления данных и модель представления использует Knockout для привязки к HTML-код. Который позволяет легко изменять HTML-код без изменения модели представления. (Мы рассмотрим Knockout чуть позже.)

## <a name="models"></a>Модели

В проекте Visual Studio в папку Models содержит модели, используемые на стороне сервера. (На стороне клиента также существуют модели мы коснемся тех.)

![](knockoutjs-template/_static/image9.png)

**TodoItem, TodoList**

Это базы данных модели Entity Framework Code First. Обратите внимание на то, что эти модели имеют свойства, указывающие на друг с другом. `ToDoList` содержит коллекцию элементов ToDoItems, при этом каждая `ToDoItem` ссылающимся обратно к его родительскому элементу ToDoList. Эти свойства называются свойствами навигации, и они представляют отношения один ко многим, список задач с элементами списка дел.

`ToDoItem` Класс также использует **[ForeignKey]** атрибут, чтобы указать, что `ToDoListId` является внешним ключом в `ToDoList` таблицы. Это сообщает EF, чтобы добавить ограничение внешнего ключа к базе данных.

[!code-csharp[Main](knockoutjs-template/samples/sample1.cs)]

**TodoItemDto TodoListDto**

Эти классы определяют данные, которые будут отправляться клиенту. «DTO» означает «объект передачи данных». DTO определяет, каким образом сущности будет сериализовано в JSON. Вообще говоря существует несколько причин для использования DTO:

- Чтобы контролировать, какие свойства сериализуются. Объект передачи данных может содержать подмножество свойств из модели домена. Это можно сделать по соображениям безопасности (Скрыть конфиденциальные данные) или просто для уменьшения объема данных, отправляемых.
- Чтобы изменить форму данных — например в плоскую структуру более сложную структуру данных.
- Чтобы сохранить все бизнес-логику из DTO (Разделение областей ответственности).
- If your domain models cannot be serialized for some reason. Например, циклические ссылки может вызвать проблемы при сериализации объекта, существуют способы устранения этой проблемы в веб-API (см. в разделе [обработка циклические ссылки объекта](../../../web-api/overview/formats-and-model-binding/json-and-xml-serialization.md#handling_circular_object_references)); но с использованием DTO просто помогает избежать проблемы полностью.

В шаблоне SPA DTO содержит те же данные, как модели домена. Тем не менее они по-прежнему полезны, так как их избежать циклических ссылок из свойства навигации, и они показывают общий шаблон DTO.

**AccountModels.cs**

Этот файл содержит модели для членством на сайте. `UserProfile` Класс определяет схему для профилей пользователей в членство DB. (В этом случае единственные сведения — это идентификатор пользователя и имя пользователя.) Другие классы модели в этом файле используются для создания формы регистрации и входа пользователя.

## <a name="entity-framework"></a>Entity Framework

Шаблон одностраничного приложения использует EF Code First. В шаблона разработки Code First сначала определяют модели в коде и затем EF использует модель для создания базы данных. Можно также использовать EF с существующей базы данных ([Database First](https://msdn.microsoft.com/data/jj206878.aspx)).

`TodoItemContext` Класс в папку Models является производным от **DbContext**. Этот класс предоставляет между моделями и EF «glue». `TodoItemContext` Содержит `ToDoItem` коллекции и `TodoList` коллекции. Запросить базу данных, просто написать запрос LINQ к этих коллекций. Например Вот как можно выбрать все списки дел для пользователя «Alice»:

[!code-csharp[Main](knockoutjs-template/samples/sample2.cs)]

Можно также добавлять новые элементы в коллекцию, обновлять элементы, или удалять элементы из коллекции и сохранения изменений в базу данных.

## <a name="aspnet-web-api-controllers"></a>Контроллеры веб-API ASP.NET

В веб-API ASP.NET контроллеры — это объекты, которые обрабатывают запросы HTTP. Как уже упоминалось, SPA шаблон использует веб-API для операций CRUD в `ToDoList` и `ToDoItem` экземпляров. Контроллеры, находятся в папке Controllers решения.

![](knockoutjs-template/_static/image10.png)

- `TodoController`: Обрабатывает HTTP-запросы для элементов списка дел
- `TodoListController`: Обрабатывает HTTP-запросов для списков задач.

Эти имена являются более важными, так как веб-API соответствует пути URI к имени контроллера. (Чтобы узнать, как веб-API направляет HTTP-запросы к контроллерам, см. в разделе [маршрутизации в ASP.NET Web API](../../../web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api.md).)

Давайте взглянем на `ToDoListController` класса. Он содержит член данных:

[!code-csharp[Main](knockoutjs-template/samples/sample3.cs)]

`TodoItemContext` Используется для взаимодействия с EF, как описано выше. Методы контроллера реализовать операции CRUD. Веб-API сопоставляют запросы HTTP от клиента для методов контроллера, следующим образом:

| HTTP-запроса | Метод контроллера | Описание |
| --- | --- | --- |
| GET/api/todo | `GetTodoLists` | Получает коллекцию списков задач. |
| GET/API/todo/*идентификатор* | `GetTodoList` | Получает список дел по Идентификатору |
| PUT/API/todo/*идентификатор* | `PutTodoList` | Обновляет список дел. |
| POST/api/todo | `PostTodoList` | Создает новый список дел. |
| DELETE/API/todo/*идентификатор* | `DeleteTodoList` | Удаляет список TODO. |

Обратите внимание, что URI для некоторых операций содержат заполнители для значение идентификатора. Например, можно удалить в список с Идентификатором 42, URI не `/api/todo/42`.

Дополнительные сведения об использовании веб-API для операций CRUD, см. в разделе [Создание веб-API, поддерживает операции CRUD](../../../web-api/overview/older-versions/creating-a-web-api-that-supports-crud-operations.md). Код для данного контроллера вполне очевиден. Ниже приведены некоторые интересные моменты:

- `GetTodoLists` Метод использует запрос LINQ для фильтрации результатов по Идентификатору пользователя, вошедшего в систему. Таким образом, пользователь видит только данные, к которой принадлежит ему. Кроме того, обратите внимание, что инструкция Select используется для преобразования `ToDoList` экземпляров в `TodoListDto` экземпляров.
- Методы PUT и POST Проверьте состояние модели перед изменением базы данных. Если **ModelState.IsValid** имеет значение false, эти методы возвращают HTTP 400 Неверный запрос. Дополнительные сведения о проверке модели в веб-API в [проверки модели](../../../web-api/overview/formats-and-model-binding/model-validation-in-aspnet-web-api.md).
- Класс контроллера дополняется также **[Authorize]** атрибута. Этот атрибут проверяет, прошел ли HTTP-запроса. Если запрос не прошел проверку подлинности, клиент получает HTTP 401 не санкционировано. Дополнительные сведения о проверки подлинности в [проверки подлинности и авторизации в веб-API ASP.NET](../../../web-api/overview/security/authentication-and-authorization-in-aspnet-web-api.md).

`TodoController` Класс очень похож на `TodoListController`. Главное отличие состоит в том, что он не определяет никакие методы GET, так как клиент получит элементы списка дел, а также каждого списка дел.

## <a name="mvc-controllers-and-views"></a>Контроллеров и представлений MVC

Контроллеры MVC также расположены в папке Controllers решения. `HomeController` Отображает основные HTML для приложения. Для контроллера Home оно определено в Views/Home/Index.cshtml. Домашняя страница отображает другое содержимое в зависимости от того, вошел ли пользователь:

[!code-cshtml[Main](knockoutjs-template/samples/sample4.cshtml)]

Когда пользователи находятся в системе, они видят основной пользовательский Интерфейс. В противном случае они увидят панель входа. Обратите внимание, что этот условный рендеринг происходит на стороне сервера. Никогда не пытаются скрываться конфиденциального содержимого на стороне клиента&#8212;все, что вы отправляете HTTP-ответа является видимым для человек, который отслеживается необработанными сообщениями HTTP.

## <a name="client-side-javascript-and-knockoutjs"></a>JavaScript на стороне клиента и Knockout.js

Теперь давайте рассмотрим из серверной части приложения на клиент. В шаблоне SPA используется сочетание jQuery и Knockout.js создать smooth, интерактивный пользовательский Интерфейс. Knockout.js — это библиотека JavaScript, которая позволяет легко выполнить привязку к данным HTML. Knockout.js использует шаблон под названием «Model-View-ViewModel».

- Модель представляет данные домена (списки дел и элементы списка дел).
- Это представление является HTML-документа.
- Модель представления является объект JavaScript, которая содержит данные модели. Модель представления — это абстракция код пользовательского интерфейса. Он не имеет сведений о представление HTML. Вместо этого он представляет абстрактный функции представления, например «список дел».

Представление данных привязан к модели представления. Обновления для модели представления автоматически отражаются в представлении. Привязки работают в другом направлении. События в модели DOM (например, нажимает) привязаны к функциям в модели представления, которые активировать вызовы AJAX.

Шаблон одностраничного приложения JavaScript на стороне клиента организованы по три уровня:

- todo.datacontext.js: Отправляет запросы AJAX.
- todo.model.js: Определяет моделей.
- todo.viewmodel.js: Определяет модель представления.

![](knockoutjs-template/_static/image11.png)

Эти файлы расположены в папке приложения или сценарии решения.

![](knockoutjs-template/_static/image12.png)

**TODO.DataContext** обрабатывает все вызовы AJAX к контроллерам веб-API. (Вызовы AJAX для входа в систему определены в другом месте, ajaxlogin.js.)

**TODO.Model.js** определяет модели (браузер) на стороне клиента для списков задач. Существует два класса модели: todoItem и todoList.

Многие свойства в классах модели имеют тип «ko.observable». Наблюдаемые объекты являются, каким образом Knockout творить чудеса. Из [Knockout документации](http://knockoutjs.com/documentation/introduction.html): Наблюдаемый объект — «объект JavaScript, можно уведомлять подписчиков об изменениях.» При изменении значения наблюдаемого, Knockout обновляет HTML-элементов, связанных с этими наблюдаемые объекты. Например todoItem имеет наблюдаемые объекты для свойств title и isDone:

[!code-javascript[Main](knockoutjs-template/samples/sample5.js)]

Кроме того, можно также подписаться на наблюдаемый объект в коде. Например класс todoItem подписывается на изменения в свойствах «isDone» и «title»:

[!code-javascript[Main](knockoutjs-template/samples/sample6.js)]

**Модель представления**

Модель представления определяется в todo.viewmodel.js. Модель представления является центральной точки, где приложение связывает элементы HTML страницы данных домена. В шаблоне SPA модель представления содержит массив наблюдаемый todoLists. Следующий код в модели представления, сообщает Knockout для применения привязки:

[!code-javascript[Main](knockoutjs-template/samples/sample7.js)]

## <a name="html-and-data-binding"></a>HTML и привязки данных

Основной код HTML для страницы определяется в Views/Home/Index.cshtml. Так как мы используем привязку данных, код HTML является лишь шаблон для что фактически Получает отображаемое. Использует Knockout *декларативной* привязки. Элементы страницы привязку к данным, путем добавления атрибута «data-bind» к элементу. Ниже приведен очень простой пример, взяты из документации по Knockout:

[!code-html[Main](knockoutjs-template/samples/sample8.html)]

В этом примере Knockout обновляет содержимое **&lt;span&gt;** со значением, равным `myItems.count()`. Каждый раз, когда это значение изменяется, Knockout обновляет документа.

Knockout предоставляет ряд различными типами привязок. Ниже приведены некоторые из привязок, используемые в шаблоне SPA.

- **по каждому элементу**: Позволяет выполнять итерации по циклу и применить одну разметку для каждого элемента в списке. Это позволяет отображать списки дел и элементы списка дел. В рамках **foreach**, привязок, применяются к элементам списка.
- **отображается**: Используемая для переключения видимости. Скрыть разметки, когда коллекция пуста или отобразить сообщение об ошибке.
- **Значение**: Используется для заполнения значения формы.
- **Нажмите кнопку**: Привязывает событие щелчка на функцию в модели представления.

## <a name="anti-csrf-protection"></a>Защита Anti-CSRF

Подделки межсайтовых запросов (CSRF) — это атака, при которой вредоносный сайт отправляет запрос на уязвимом сайте, где пользователь вошел в. Для предотвращения атак CSRF, ASP.NET MVC использует *маркеров защиты от подделки*, также называется запрос проверки токенов. Идея состоит в том, что сервер переводит случайным образом созданный маркер в веб-страницу. Когда клиент отправляет данные на сервер, она должна содержать это значение в сообщении запроса.

Маркеры защиты от подделки работать, поскольку вредоносной страницы не удается считать маркеры пользователя, из-за политики одного источника. (Политика одного источника не документов, размещенные на двух разных сайтах, доступ к содержимому друг друга).

ASP.NET MVC предоставляет встроенную поддержку для маркеров защиты от подделки через [защиты от подделки](https://msdn.microsoft.com/library/system.web.helpers.antiforgery.aspx) класс и [[ValidateAntiForgeryToken]](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute.aspx) атрибута. В настоящее время эта функция не встроена в веб-API. Однако шаблон одностраничного приложения включает пользовательскую реализацию для веб-API. Этот код определен в `ValidateHttpAntiForgeryTokenAttribute` класс, который находится в папке фильтры решения. Дополнительные сведения о anti-CSRF, в веб-API, см. в разделе [атак предотвращения межсайтовых подделкой запросов (CSRF)](../../../web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks.md).

## <a name="conclusion"></a>Заключение

Чтобы приступить к работе, быстро написания современные интерактивные веб-приложений предназначен данный шаблон одностраничного приложения. Он использует библиотеку Knockout.js возможность отделить представление (HTML-разметка) из данных и приложений логики. Но Knockout не только библиотеки JavaScript, которые можно использовать для создания SPA. Если вы хотите изучить некоторые другие параметры, взгляните на [созданных сообществом шаблонов одностраничных ПРИЛОЖЕНИЙ](../templates/index.md).
