---
uid: signalr/overview/getting-started/tutorial-server-broadcast-with-signalr
title: Учебник. широковещательная рассылка сервера с помощью SignalR 2 | Документация Майкрософт
author: tdykstra
description: В этом руководстве показано, как создать веб-приложение, использующее ASP.NET SignalR 2 для предоставления функций серверной широковещательной рассылки.
ms.author: bradyg
ms.date: 01/02/2019
ms.topic: tutorial
ms.assetid: 1568247f-60b5-4eca-96e0-e661fbb2b273
msc.legacyurl: /signalr/overview/getting-started/tutorial-server-broadcast-with-signalr
msc.type: authoredcontent
ms.openlocfilehash: 14924109fff8db3e537e6bc08b6dc868792ee660
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78431244"
---
# <a name="tutorial-server-broadcast-with-signalr-2"></a>Учебник. серверное вещание с SignalR 2

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

В этом руководстве показано, как создать веб-приложение, использующее ASP.NET SignalR 2 для предоставления функций серверной широковещательной рассылки. Серверное вещание означает, что сервер запускает обмен данными, отправляемый клиентам.

Приложение, которое будет создано в этом учебнике, имитирует биржевое биржевое, типичный сценарий для серверной функции вещания. Периодически сервер обновляет цены на акции и передает обновления на все подключенные клиенты. В браузере числа и символы в столбцах **Change** и **%** динамически изменяются в ответ на уведомления с сервера. Если открыть дополнительные браузеры для одного и того же URL-адреса, все они будут отображать одни и те же данные и одни и те же изменения данных одновременно.

![Создание веб-сайта](tutorial-server-broadcast-with-signalr/_static/image1.png)

Изучив это руководство, вы:

> [!div class="checklist"]
> * Создание проекта
> * Настройка кода сервера
> * Проверка серверного кода
> * Настройка клиентского кода
> * Изучение кода клиента
> * Тестирование приложения
> * Включение ведения журналов

> [!IMPORTANT]
> Если вы не хотите поработать с этапами создания приложения, можно установить пакет SignalR. Sample в новом пустом проекте веб-приложения ASP.NET. Если пакет NuGet устанавливается без выполнения действий, описанных в этом руководстве, необходимо выполнить инструкции из файла *readme. txt* . Чтобы запустить пакет, необходимо добавить класс запуска OWIN, который вызывает метод `ConfigureSignalR` в установленном пакете. Если не добавить класс запуска OWIN, появится сообщение об ошибке. См. раздел [Установка образца стокктиккер в](#install-the-stockticker-sample) этой статье.

## <a name="prerequisites"></a>предварительные требования

* [Visual Studio 2017](https://visualstudio.microsoft.com/downloads/) с рабочей нагрузкой **ASP.NET и веб-разработка**.

## <a name="create-the-project"></a>Создание проекта

В этом разделе показано, как с помощью Visual Studio 2017 создать пустое веб-приложение ASP.NET.

1. В Visual Studio создайте веб-приложение ASP.NET.

    ![Создание веб-сайта](tutorial-server-broadcast-with-signalr/_static/image2.png)

1. В окне **New ASP.NET Web Application-SignalR. стокктиккер** оставьте **пустым** выбранным и нажмите кнопку **ОК**.

## <a name="set-up-the-server-code"></a>Настройка кода сервера

В этом разделе вы настроите код, который выполняется на сервере.

### <a name="create-the-stock-class"></a>Создание класса акции

Начнем с создания класса « *складская* модель», который будет использоваться для хранения и передачи информации о акции.

1. В **Обозреватель решений**щелкните правой кнопкой мыши проект и выберите **Добавить** > **класс**.

1. Назовите класс *фондовой* и добавьте его в проект.

1. Замените код в файле *Stock.CS* следующим кодом:

    [!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample1.cs)]

    Два свойства, которые вы задаете при создании акций, `Symbol` (например, MSFT для Майкрософт) и `Price`. Другие свойства зависят от того, как и когда задается `Price`. При первом задании `Price`значение распространяется на `DayOpen`. После этого при установке `Price`приложение вычисляет значения свойств `Change` и `PercentChange` на основе разницы между `Price` и `DayOpen`.

### <a name="create-the-stocktickerhub-and-stockticker-classes"></a>Создание классов Стокктиккерхуб и Стокктиккер

Для обработки взаимодействия "сервер-клиент" вы будете использовать API концентратора SignalR. Класс `StockTickerHub`, производный от класса SignalR `Hub`, будет выполнять получение подключений и вызовов методов от клиентов. Также необходимо сохранить данные на бирже и запустить объект `Timer`. Объект `Timer` периодически будет запускать обновления цен независимо от клиентских подключений. Эти функции нельзя разместить в `Hub` классе, так как концентраторы являются временными. Приложение создает `Hub` экземпляр класса для каждой задачи в концентраторе, например соединения и вызовы от клиента к серверу. Таким образом, механизм, который хранит данные на бирже, обновляет цены и выполняет широковещательную рассылку, должен выполняться в отдельном классе. Класс будет назван `StockTicker`.

![Вещание от Стокктиккер](tutorial-server-broadcast-with-signalr/_static/image3.png)

Необходимо, чтобы на сервере выполнялся только один экземпляр `StockTicker` класса, поэтому необходимо настроить ссылку из каждого экземпляра `StockTickerHub` на одноэлементный экземпляр `StockTicker`. Класс `StockTicker` должен выполнять широковещательную рассылку на клиентах, так как он содержит данные о акции и инициирует обновления, но `StockTicker` не является `Hub`ным классом. Класс `StockTicker` должен получить ссылку на объект контекста подключения концентратора SignalR. Затем он может использовать объект контекста подключения SignalR для передачи клиентам.

#### <a name="create-stocktickerhubcs"></a>Создание StockTickerHub.cs

1. В **Обозреватель решений**щелкните правой кнопкой мыши проект и выберите **Добавить** > **новый элемент**.

1. В окне **Добавить новый элемент-SignalR. стокктиккер**выберите **установлено** > **Visual C#**  > **Web** > **SignalR** , а затем выберите **класс концентратора SignalR (v2)** .

1. Назовите класс *стокктиккерхуб* и добавьте его в проект.

    На этом шаге создается файл класса *StockTickerHub.CS* . Одновременно он добавляет набор файлов скриптов и ссылок на сборки, которые поддерживают SignalR для проекта.

1. Замените код в файле *StockTickerHub.CS* следующим кодом:

    [!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample2.cs)]

1. Сохраните файл.

Приложение использует класс [Hub](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hub(v=vs.111).aspx) для определения методов, которые клиенты могут вызывать на сервере. Вы определяете один метод: `GetAllStocks()`. Когда клиент изначально подключается к серверу, он вызывает этот метод, чтобы получить список всех акций с текущими ценами. Метод может выполняться синхронно и возвращать `IEnumerable<Stock>`, так как он возвращает данные из памяти.

Если методу пришлось бы получать данные, выполняя что-либо, которое может привести к ожиданиям, например при поиске базы данных или вызове веб-службы, необходимо указать `Task<IEnumerable<Stock>>` как возвращаемое значение, чтобы включить асинхронную обработку. Дополнительные сведения см. [в разделе ASP.NET SignalR Hubs Guide-Server-on to Execute On асинхронное выполнение](../guide-to-the-api/hubs-api-guide-server.md#asyncmethods).

Атрибут `HubName` указывает, как приложение будет ссылаться на концентратор в коде JavaScript на клиенте. Имя по умолчанию на клиенте, если этот атрибут не используется, является camelCase версией имени класса, которая в данном случае будет `stockTickerHub`.

Как вы увидите позже при создании класса `StockTicker`, приложение создает одноэлементный экземпляр этого класса в его статическом свойстве `Instance`. Этот одноэлементный экземпляр `StockTicker` находится в памяти независимо от того, сколько клиентов подключается или отключается. Этот экземпляр использует метод `GetAllStocks()` для возврата текущих данных об акциях.

#### <a name="create-stocktickercs"></a>Создание StockTicker.cs

1. В **Обозреватель решений**щелкните правой кнопкой мыши проект и выберите **Добавить** > **класс**.

1. Назовите класс *стокктиккер* и добавьте его в проект.

1. Замените код в файле *StockTicker.CS* следующим кодом:

    [!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample3.cs)]

Так как все потоки будут выполнять один и тот же экземпляр Стокктиккер кода, класс Стокктиккер должен быть потокобезопасным.

### <a name="examine-the-server-code"></a>Проверка серверного кода

При изучении серверного кода он поможет понять, как работает приложение.

#### <a name="storing-the-singleton-instance-in-a-static-field"></a>Сохранение одноэлементного экземпляра в статическом поле

Код инициализирует статическое поле `_instance`, которое выполняет резервное копирование свойства `Instance` с помощью экземпляра класса. Поскольку конструктор является частным, единственным экземпляром класса, который может создать приложение. Приложение использует [отложенную инициализацию](/dotnet/framework/performance/lazy-initialization) для поля `_instance`. Это не из соображений производительности. Необходимо убедиться, что создание экземпляра является потокобезопасным.

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample4.cs)]

Каждый раз, когда клиент подключается к серверу, новый экземпляр класса Стокктиккерхуб, выполняющийся в отдельном потоке, получает одноэлементный экземпляр Стокктиккер из статического свойства `StockTicker.Instance`, как было показано ранее в классе `StockTickerHub`.

#### <a name="storing-stock-data-in-a-concurrentdictionary"></a>Хранение данных о акции в ConcurrentDictionary

Конструктор инициализирует `_stocks` коллекцию с помощью некоторых примеров биржевых данных, а `GetAllStocks` возвращает акции. Как было показано ранее, эта коллекция акций возвращается с помощью `StockTickerHub.GetAllStocks`, который является серверным методом в классе `Hub`, который может вызываться клиентами.

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample5.cs)]

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample6.cs)]

Коллекция Stocks определяется как тип [ConcurrentDictionary](https://msdn.microsoft.com/library/dd287191.aspx) для потокобезопасности. В качестве альтернативы можно использовать объект [Dictionary](https://msdn.microsoft.com/library/xfhwa508.aspx) и явным образом заблокировать словарь при внесении в него изменений.

Для этого примера приложения можно сохранить данные приложения в памяти и потерять данные, когда приложение уничтожает экземпляр `StockTicker`. В реальном приложении вы бы работали с внутренним хранилищем данных, например с базой данных.

#### <a name="periodically-updating-stock-prices"></a>Периодическое обновление цен на акции

Конструктор запускает `Timer` объект, который периодически вызывает методы, которые обновляют цены на акции на случайном уровне.

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample7.cs)]

 `Timer` вызывает `UpdateStockPrices`, который в параметре state передает значение null. Перед обновлением цен приложение принимает блокировку на объект `_updateStockPricesLock`. Код проверяет, обновил ли другой поток цены, а затем вызывает `TryUpdateStockPrice` для каждой акции в списке. Метод `TryUpdateStockPrice` определяет, следует ли изменить цену акции и сколько ее изменить. Если цена акций изменяется, приложение вызывает `BroadcastStockPrice`, чтобы транслировать изменение цены акций на все подключенные клиенты.

Флаг `_updatingStockPrices`, обозначенный как [volatile](https://msdn.microsoft.com/library/x13ttww7.aspx) , чтобы обеспечить потокобезопасность.

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample8.cs)]

В реальном приложении метод `TryUpdateStockPrice` вызовет веб-службу для поиска цены. В этом коде приложение использует генератор случайных чисел для внесения изменений случайным образом.

#### <a name="getting-the-signalr-context-so-that-the-stockticker-class-can-broadcast-to-clients"></a>Получение контекста SignalR, чтобы класс Стокктиккер мог выполнить широковещательную рассылку клиентам

Поскольку изменения цен происходят в объекте `StockTicker`, это объект, который должен вызывать метод `updateStockPrice` на всех подключенных клиентах. В `Hub` классе имеется API для вызова клиентских методов, но `StockTicker` не является производным от класса `Hub` и не имеет ссылки на какой-либо объект `Hub`. Для вещания подключенным клиентам класс `StockTicker` должен получить экземпляр контекста SignalR для `StockTickerHub` класса и использовать его для вызова методов на клиентах.

Код получает ссылку на контекст SignalR при создании экземпляра одноэлементного класса, передает эту ссылку конструктору, а конструктор помещает его в свойство `Clients`.

Существует две причины, по которым вы хотите получить контекст только один раз: Получение контекста является дорогостоящей задачей и получение ее после однократное обеспечение того, что приложение сохраняет предполагаемый порядок сообщений, отправляемых клиентам.

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample9.cs)]

Получение свойства `Clients` контекста и помещение его в свойство `StockTickerClient` позволяет написать код для вызова методов клиента, которые выглядят так же, как в классе `Hub`. Например, чтобы выполнить вещание на всех клиентах, можно написать `Clients.All.updateStockPrice(stock)`.

Метод `updateStockPrice`, который вы вызываете в `BroadcastStockPrice`, еще не существует. Он будет добавлен позже при написании кода, выполняемого на клиенте. Ссылку на `updateStockPrice` можно найти в этом разделе, поскольку `Clients.All` является динамическим. Это означает, что приложение будет оценивать выражение во время выполнения. При выполнении этого вызова метода SignalR отправляет клиенту имя метода и значение параметра, а если у клиента есть метод с именем `updateStockPrice`, приложение будет вызывать этот метод и передавать ему значение параметра.

`Clients.All` означает отправку на все клиенты. SignalR предоставляет другие возможности для указания клиентов или групп клиентов для отправки. Дополнительные сведения см. в разделе [хубконнектионконтекст](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.hubconnectioncontext(v=vs.111).aspx).

### <a name="register-the-signalr-route"></a>Регистрация маршрута SignalR

Серверу необходимо указать, какой URL-адрес следует перехватить, и направить его в SignalR. Для этого добавьте класс запуска OWIN:

1. В **Обозреватель решений**щелкните правой кнопкой мыши проект и выберите **Добавить** > **новый элемент**.

1. В окне **Добавление нового элемента-SignalR. стокктиккер** выберите **установленный** > **Visual C#**  > **Web** , а затем выберите **класс запуска OWIN**.

1. Назовите класс *Startup* и нажмите кнопку **ОК**.

1. Замените код по умолчанию в файле *Startup.CS* следующим кодом:

    [!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample10.cs)]

Настройка кода сервера завершена. В следующем разделе вы настроите клиент.

## <a name="set-up-the-client-code"></a>Настройка клиентского кода

В этом разделе вы настроите код, который выполняется на клиенте.

### <a name="create-the-html-page-and-javascript-file"></a>Создание HTML-страницы и файла JavaScript

На странице HTML будут отображены данные, а в файле JavaScript будут упорядочены данные.

#### <a name="create-stocktickerhtml"></a>Создание Стокктиккер. HTML

Сначала нужно добавить HTML-клиент.

1. В **Обозреватель решений**щелкните правой кнопкой мыши проект и выберите **Добавить** > **HTML-страницу**.

1. Назовите файл *стокктиккер* и нажмите кнопку **ОК**.

1. Замените код по умолчанию в файле *стокктиккер. HTML* следующим кодом:

    [!code-html[Main](tutorial-server-broadcast-with-signalr/samples/sample11.html?highlight=40-43)]

    HTML создает таблицу с пятью столбцами, строкой заголовка и строкой данных с одной ячейкой, охватывающей все пять столбцов. В строке данных отображается "Загрузка..." моментально при запуске приложения. Код JavaScript удалит эту строку и добавит в нее строки с данными, полученными с сервера.

    Теги скрипта определяют:

    * Файл скрипта jQuery.

    * Основной файл скрипта SignalR.

    * Файл скрипта прокси SignalR.

    * Файл скрипта Стокктиккер, который будет создан позже.

    Приложение динамически создает файл скрипта прокси-сервера SignalR. Он указывает URL-адрес "/сигналр/хубс" и определяет методы прокси для методов в классе Hub, в данном случае для `StockTickerHub.GetAllStocks`. При желании этот файл JavaScript можно создать вручную с помощью [служебных программ SignalR](http://nuget.org/packages/Microsoft.AspNet.SignalR.Utils/). Не забудьте отключить динамическое создание файлов при вызове метода `MapHubs`.

1. В **Обозреватель решений**разверните узел **сценарии**.

    Библиотеки скриптов для jQuery и SignalR отображаются в проекте.

    > [!IMPORTANT]
    > Диспетчер пакетов установит более позднюю версию сценариев SignalR.

1. Обновите ссылки на скрипт в блоке кода, чтобы они соответствовали версиям файлов скриптов в проекте.

1. В **Обозреватель решений**щелкните правой кнопкой мыши *стокктиккер. HTML*и выберите **задать в качестве начальной страницы**.

#### <a name="create-stocktickerjs"></a>Создание Стокктиккер. js

Теперь создайте файл JavaScript.

1. В **Обозреватель решений**щелкните правой кнопкой мыши проект и выберите **Добавить** > **файл JavaScript**.

1. Назовите файл *стокктиккер* и нажмите кнопку **ОК**.

1. Добавьте следующий код в файл *стокктиккер. js* :

    [!code-javascript[Main](tutorial-server-broadcast-with-signalr/samples/sample12.js)]

### <a name="examine-the-client-code"></a>Изучение кода клиента

Если изучить клиентский код, он поможет узнать, как клиентский код взаимодействует с серверным кодом, чтобы обеспечить работу приложения.

#### <a name="starting-the-connection"></a>Идет запуск подключения

`$.connection` ссылается на прокси-серверы SignalR. Код получает ссылку на прокси-сервер для класса `StockTickerHub` и помещает его в переменную `ticker`. Имя прокси-сервера — это имя, заданное атрибутом `HubName`:

[!code-javascript[Main](tutorial-server-broadcast-with-signalr/samples/sample13.js)]

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample14.cs)]

После определения всех переменных и функций последняя строка кода в файле инициализирует подключение SignalR, вызывая функцию SignalR `start`. Функция `start` выполняется асинхронно и возвращает [отложенный объект jQuery](http://api.jquery.com/category/deferred-object/). Функцию done можно вызвать, чтобы указать функцию, вызываемую при завершении асинхронного действия приложением.

[!code-javascript[Main](tutorial-server-broadcast-with-signalr/samples/sample15.js)]

#### <a name="getting-all-the-stocks"></a>Получение всех акций

Функция `init` вызывает функцию `getAllStocks` на сервере и использует сведения, возвращаемые сервером для обновления таблицы запасов. Обратите внимание, что по умолчанию необходимо использовать Камелкасинг на клиенте, даже если на сервере используется имя метода Pascal. Правило Камелкасинг применяется только к методам, а не к объектам. Например, вы ссылаетесь на `stock.Symbol` и `stock.Price`, а не на `stock.symbol` или `stock.price`.

[!code-javascript[Main](tutorial-server-broadcast-with-signalr/samples/sample16.js)]

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample17.cs)]

В методе `init` приложение создает HTML для строки таблицы для каждого объекта, полученного с сервера, вызывая `formatStock` для форматирования свойств объекта `stock`, а затем вызывая `supplant` для замены заполнителей в переменной `rowTemplate` значениями свойства `stock` объекта. Затем полученный код HTML добавляется в таблицу запасов.

> [!NOTE]
> Вызовите `init`, передав его в качестве функции `callback`, которая выполняется после завершения асинхронной функции `start`. Если вы вызывали `init` как отдельную инструкцию JavaScript после вызова `start`, функция завершится ошибкой, так как она будет выполняться немедленно, не дожидаясь завершения установки соединения функцией start. В этом случае функция `init` будет пытаться вызвать функцию `getAllStocks`, прежде чем приложение установит соединение с сервером.

#### <a name="getting-updated-stock-prices"></a>Получение обновленных цен на акции

Когда сервер изменяет цену на акцию, он вызывает `updateStockPrice` на подключенных клиентах. Приложение добавляет функцию в свойство клиента прокси-сервера `stockTicker`, чтобы сделать его доступным для вызовов с сервера.

[!code-javascript[Main](tutorial-server-broadcast-with-signalr/samples/sample18.js)]

Функция `updateStockPrice` форматирует объект, полученный с сервера, в строку таблицы таким же образом, как и в функции `init`. Вместо того чтобы добавлять строку в таблицу, она находит текущую строку складского запаса в таблице и заменяет эту строку новой.

## <a name="test-the-application"></a>Тестирование приложения

Вы можете протестировать приложение, чтобы убедиться, что оно работает. Вы увидите, что все окна браузера отображаются в реальной таблице акций с неизменными ценами акций.

1. На панели инструментов включите **отладку скриптов** , а затем нажмите кнопку Воспроизведение, чтобы запустить приложение в режиме отладки.

    ![Снимок экрана: Включение режима отладки пользователем и выбор воспроизведения.](tutorial-server-broadcast-with-signalr/_static/image4.png)

    Откроется окно браузера, в котором отображается **Таблица текущих запасов**. В таблице «акции» первоначально отображается «загрузка...» После короткого времени приложение отобразит начальные данные о акции, а затем цены на акции начнут изменяться.

1. Скопируйте URL-адрес из браузера, откройте два других браузера и вставьте URL-адреса в адреса строки.

    Начальное отображение запасов аналогично первому браузеру, и изменения происходят одновременно.

1. Закройте все браузеры, откройте новый браузер и перейдите к тому же URL-адресу.

    Одноэлементный объект Стокктиккер продолжает выполняться на сервере. В **таблице «Live Stock** » показано, что акции продолжают изменяться. Вы не видите начальную таблицу с нулевыми рисунками изменений.

1. Закройте браузер.

## <a name="enable-logging"></a>Включение ведения журналов

SignalR имеет встроенную функцию ведения журнала, которую можно включить на клиенте, чтобы помочь в устранении неполадок. В этом разделе описано, как включить ведение журнала, и просмотреть примеры, демонстрирующие, как журналы указывают, какие из следующих методов транспорта использует SignalR:

* [WebSockets](http://en.wikipedia.org/wiki/WebSocket), поддерживаемые службами IIS 8 и текущими браузерами.

* [События, отправленные сервером](http://en.wikipedia.org/wiki/Server-sent_events), поддерживаются обозревателями, отличными от Internet Explorer.

* [Непрерывная рамка](http://en.wikipedia.org/wiki/Comet_(programming)#Hidden_iframe), поддерживаемая Internet Explorer.

* [Длинный опрос Ajax](http://en.wikipedia.org/wiki/Comet_(programming)#Ajax_with_long_polling), поддерживаемый всеми браузерами.

Для любого заданного соединения SignalR выбирает лучший метод транспортировки, который поддерживает сервер и клиент.

1. Откройте *стокктиккер. js*.

1. Добавьте эту выделенную строку кода, чтобы включить ведение журнала непосредственно перед кодом, который инициализирует подключение в конце файла:

    [!code-javascript[Main](tutorial-server-broadcast-with-signalr/samples/sample19.js?highlight=2)]

1. Нажмите клавишу **F5**, чтобы запустить проект.

1. Откройте окно средств разработчика в браузере и выберите консоль, чтобы просмотреть журналы. Может потребоваться обновить страницу, чтобы просмотреть журналы SignalR, согласования транспортного метода для нового подключения.

    * Если вы используете Internet Explorer 10 в Windows 8 (IIS 8), метод транспорта — это **WebSockets**.

    * Если вы используете Internet Explorer 10 в Windows 7 (IIS 7,5), то транспортным методом является **IFRAME**.

    * Если вы используете Firefox 19 в Windows 8 (IIS 8), метод транспорта — это **WebSockets**.

        > [!TIP]
        > В браузере Firefox установите надстройку Firebug, чтобы получить окно консоли.

    * Если вы используете Firefox 19 в Windows 7 (IIS 7,5), метод перевозки является **серверными** событиями.

## <a name="install-the-stockticker-sample"></a>Установка образца Стокктиккер

[Пакет Microsoft. AspNet. SignalR. Sample](http://nuget.org/packages/microsoft.aspnet.signalr.sample) устанавливает приложение стокктиккер. Пакет NuGet содержит больше возможностей, чем упрощенная версия, созданная с нуля. В этом разделе руководства вы установите пакет NuGet и ознакомьтесь с новыми функциями и кодом, который их реализует.

> [!IMPORTANT]
> Если пакет устанавливается без выполнения предыдущих шагов этого руководства, необходимо добавить в проект класс запуска OWIN. Этот шаг объясняется в этом файле readme. txt для пакета NuGet.

### <a name="install-the-signalrsample-nuget-package"></a>Установите пакет NuGet с SignalR. Sample.

1. В **обозревателе решений** щелкните проект правой кнопкой мыши и выберите **Управление пакетами NuGet**.

1. В **диспетчере пакетов NuGet: SignalR. стокктиккер**нажмите кнопку **Обзор**.

1. В **источнике пакета**выберите **NuGet.org**.

1. Введите *SignalR. Sample* в поле поиска и выберите **Microsoft. AspNet. signalr. Sample** > **установить**.

1. В **Обозреватель решений**разверните папку *SignalR. Sample* .

    Установка пакета SignalR. SAMPLED создала папку и ее содержимое.

1. В папке *SignalR. Sample* щелкните правой кнопкой мыши *стокктиккер. HTML*и выберите **задать в качестве начальной страницы**.

    > [!NOTE]
    > Установка SignalR. пример пакета NuGet может изменить версию jQuery в папке *Scripts* . Новый файл *стокктиккер. HTML* , устанавливаемый пакетом в папке *SignalR. Sample* , будет синхронизирован с версией jQuery, устанавливаемой пакетом, но если вы хотите снова запустить исходный файл *стокктиккер. HTML* , то, возможно, потребуется сначала обновить ссылку JQuery в теге script.

### <a name="run-the-application"></a>Выполнение приложения

 В таблице, которую вы видели в первом приложении, приходилось использовать полезные функции. В полном приложении для биржевых котировок отображаются новые функции: окно с горизонтальной прокруткой, которое показывает биржевые данные и акции, изменяющие цвет по мере увеличения и падения.

1. Нажмите клавишу **F5** , чтобы запустить приложение.

     При первом запуске приложения «Market» является «закрытым», и отображается статическая таблица и окно, которое не прокручивается.

1. Выберите **Открыть рыночный**.

    ![Снимок экрана: Live Tick.](tutorial-server-broadcast-with-signalr/_static/image5.png)

    * В реальном времени поле " **Биржевая сводка** " начинает прокручиваться по горизонтали, и сервер начинает периодически рассылать изменения цены акций на случайном уровне.

    * При каждом изменении цены на акцию приложение обновляет как **таблицу запасов в реальном** времени, так и **действующее биржевое деление**.

    * Если изменение цены на фондовой бирже положительно, приложение отображает акции с зеленым фоном.

    * Если изменение отрицательное, приложение отображает на бумаге красный фон.

1. Выберите **закрыть рыночный**.

    * Обновление таблицы останавливается.

    * Деление останавливает прокрутку.

1. Выберите **сбросить**.

    * Все данные о запасах сбрасываются.

    * Приложение восстанавливает начальное состояние до начала изменения цены.

1. Скопируйте URL-адрес из браузера, откройте два других браузера и вставьте URL-адреса в адреса строки.

1. Вы увидите, что одни и те же данные динамически обновляются в каждом браузере.

1. При выборе любого из элементов управления все браузеры реагируют одинаково в одно и то же время.

### <a name="live-stock-ticker-display"></a>Отображение биржевых котировок в реальном времени

В **реальном времени** отображается неупорядоченный список в элементе `<div>`, форматированном в одну строку в стиле CSS. Приложение инициализирует и обновляет Tick так же, как и таблица: заменяя заполнители в строке шаблона `<li>` и динамически добавляя элементы `<li>` в элемент `<ul>`. Приложение включает прокрутку с помощью функции jQuery `animate` для изменения левого поля неупорядоченного списка в `<div>`.

#### <a name="signalrsample-stocktickerhtml"></a>SignalR. пример Стокктиккер. HTML

HTML-код биржевых котировок:

[!code-html[Main](tutorial-server-broadcast-with-signalr/samples/sample20.html)]

#### <a name="signalrsample-stocktickercss"></a>SignalR. Sample Стокктиккер. CSS

Код CSS для биржевых котировок:

[!code-html[Main](tutorial-server-broadcast-with-signalr/samples/sample21.html)]

#### <a name="signalrsample-signalrstocktickerjs"></a>SignalR. Sample SignalR. Стокктиккер. js

Код jQuery, который выполняет прокрутку:

[!code-javascript[Main](tutorial-server-broadcast-with-signalr/samples/sample22.js)]

### <a name="additional-methods-on-the-server-that-the-client-can-call"></a>Дополнительные методы на сервере, который может вызывать клиент

Для обеспечения гибкости приложения существуют дополнительные методы, которые может вызывать приложение.

#### <a name="signalrsample-stocktickerhubcs"></a>SignalR. пример StockTickerHub.cs

Класс `StockTickerHub` определяет четыре дополнительных метода, которые может вызывать клиент:

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample23.cs)]

Приложение вызывает `OpenMarket`, `CloseMarket`и `Reset` в ответ на кнопки в верхней части страницы. Они демонстрируют шаблон одного клиента, запускающего изменение состояния, немедленно распространяемого на все клиенты. Каждый из этих методов вызывает метод в классе `StockTicker`, который вызывает изменение состояния рынка, а затем передает новое состояние.

#### <a name="signalrsample-stocktickercs"></a>SignalR. пример StockTicker.cs

В классе `StockTicker` приложение поддерживает состояние рынка со свойством `MarketState`, возвращающим значение перечисления `MarketState`.

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample24.cs)]

Каждый из методов, изменяющих состояние рынка, выполняет это в блоке блокировки, так как класс `StockTicker` должен быть потокобезопасным:

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample25.cs)]

Чтобы убедиться в том, что этот код является потокобезопасным, `_marketState` поле, которое обеспечивает свойство `MarketState`, назначенное `volatile`:

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample26.cs)]

Методы `BroadcastMarketStateChange` и `BroadcastMarketReset` похожи на метод Броадкастстоккприце, который вы уже видели, за исключением того, что они вызывают различные методы, определенные на клиенте:

[!code-csharp[Main](tutorial-server-broadcast-with-signalr/samples/sample27.cs)]

### <a name="additional-functions-on-the-client-that-the-server-can-call"></a>Дополнительные функции на клиенте, который может вызывать сервер

Функция `updateStockPrice` теперь обрабатывает как таблицу, так и отображение импульсов и использует `jQuery.Color` для красных и зеленых цветов Flash.

Новые функции в *SignalR. стокктиккер. js* включают и отключают кнопки на основе состояния рынка. Они также останавливают или начинают прямую прокрутку **биржевых котировок** . Так как многие функции добавляются в `ticker.client`, приложение использует [функцию расширения jQuery](http://api.jquery.com/jQuery.extend/) для их добавления.

[!code-javascript[Main](tutorial-server-broadcast-with-signalr/samples/sample28.js)]

### <a name="additional-client-setup-after-establishing-the-connection"></a>Дополнительные настройки клиента после установления соединения

После установления подключения клиент имеет некоторую дополнительную работу:

* Выясните, открыт или закрыт ли данный рынк, чтобы вызвать соответствующую функцию `marketOpened` или `marketClosed`.

* Присоедините вызовы серверных методов к кнопкам.

[!code-javascript[Main](tutorial-server-broadcast-with-signalr/samples/sample29.js)]

Методы сервера не привязаны к кнопкам до тех пор, пока приложение не установит подключение. Так что код не может вызывать методы сервера, прежде чем они будут доступны.

## <a name="additional-resources"></a>Дополнительные ресурсы

В этом учебнике вы узнали, как программировать приложение SignalR, которое передает сообщения с сервера на все подключенные клиенты. Теперь можно периодически выполнять широковещательную трансляцию сообщений и в ответ на уведомления от любого клиента. Концепцию многопотокового одноэлементного экземпляра можно использовать для сохранения состояния сервера в сценариях Интернет-игр с несколькими игроками. Пример см. в разделе [игра по воссозданию на основе SignalR](https://github.com/NTaylorMullen/ShootR).

Учебники, в которых показаны одноранговые сценарии связи, см. в разделе [Начало работы с SignalR](introduction-to-signalr.md) и [обновлением в режиме реального времени с помощью SignalR](tutorial-high-frequency-realtime-with-signalr.md).

Дополнительные сведения о SignalR см. в следующих ресурсах:

* [ASP.NET SignalR](../../index.md)
* [Проект SignalR](http://signalr.net/)
* [GitHub и примеры SignalR](https://github.com/SignalR/SignalR)
* [Вики-сайт SignalR](https://github.com/SignalR/SignalR/wiki)

## <a name="next-steps"></a>Дальнейшие действия

Изучив это руководство, вы:

> [!div class="checklist"]
> * Создал проект
> * Настройка кода сервера
> * Анализ кода сервера
> * Настройка клиентского кода
> * Анализ кода клиента
> * тестирование приложения.
> * Ведение журнала включено

Перейдите к следующей статье, чтобы узнать, как создать веб-приложение в режиме реального времени, использующее ASP.NET SignalR 2.
> [!div class="nextstepaction"]
> [Создание веб-приложения в режиме реального времени с помощью SignalR](real-time-web-applications-with-signalr.md)
