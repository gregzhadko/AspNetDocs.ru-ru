---
uid: signalr/overview/getting-started/real-time-web-applications-with-signalr
title: Практическое лабораторное занятие. В режиме реального времени веб-приложений с помощью SignalR | Документация Майкрософт
author: bradygaster
description: В режиме реального времени веб-приложений имеют возможность отправлять содержимое подключенным клиентам оказывается, в режиме реального времени на стороне сервера. Для разработчиков ASP.NET, ASP...
ms.author: bradyg
ms.date: 07/16/2014
ms.assetid: ba07958c-42e1-4da0-81db-ba6925ed6db0
msc.legacyurl: /signalr/overview/getting-started/real-time-web-applications-with-signalr
msc.type: authoredcontent
ms.openlocfilehash: 9904582450d4386ef8b8656078f6d40dbd1e10be
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59412012"
---
# <a name="hands-on-lab-real-time-web-applications-with-signalr"></a>Практическое лабораторное занятие. Веб-приложения в режиме реального времени с SignalR


по [Web Слышатся Team](https://twitter.com/webcamps)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

[Скачайте лагеря Web Тренировочный набор, выпуск октября 2015 г.](https://github.com/Microsoft-Web/WebCampTrainingKit/releases/tag/v2015.10.13b)

> В режиме реального времени веб-приложений имеют возможность отправлять содержимое подключенным клиентам оказывается, в режиме реального времени на стороне сервера. Для разработчиков ASP.NET **ASP.NET SignalR** — это библиотека, чтобы добавить функциональность в режиме реального времени веб-приложений. Он использует преимущества нескольких транспортов, автоматического выбора клиента и сервера лучше всего транспортировки лучше всего доступных транспорта. Он использует преимущества **WebSocket**, интерфейс API HTML5, двустороннего обмена данными между браузером и сервером.
> 
> **SignalR** также предоставляет простые, высокоуровневые API для этого сервера к клиенту RPC (вызывают функции JavaScript в браузерах клиентов из кода .NET на стороне сервера) в приложении ASP.NET, а также добавление полезные обработчики для управления подключениями как отключить или подключить события, группирования подключений и авторизации.
> 
> **SignalR** — это абстракция над некоторые транспорты, которые необходимы для выполнения работы в режиме реального времени между клиентом и сервером. Объект **SignalR** подключения запускается как HTTP и затем повышается до **WebSocket** подключения, если он доступен. **WebSocket** является идеальным транспортом для **SignalR**, поскольку оно обеспечивает наиболее эффективное использование памяти сервера, имеет наименьшую задержку, а наиболее базовых функций (таких как полнодуплексную связь между клиентом и сервер), но у него также есть самым строгим требованиям: **WebSocket** требует, чтобы использовать сервер **Windows Server 2012** или **Windows 8**, вместе с **.NET Framework 4.5**. Если эти требования не выполнены, **SignalR** будет пытаться использовать другие транспорты, чтобы сделать его подключений (таких как *Ajax, длинный опрос*).
> 
> **SignalR** API содержит две модели для обмена данными между клиентами и серверами: **Постоянные подключения** и **концентраторов**. Объект **подключения** представляет простой конечную точку для отправки одного получателя, группировать или широковещательной передачи сообщений. Объект **концентратора** представляют собой более высокоуровневые конвейер, построенных на основе подключения API, который позволяет клиентом и сервером, для прямого вызова методов на друг с другом.
> 
> ![Архитектура SignalR](real-time-web-applications-with-signalr/_static/image1.png)
> 
> Все примеры кода и фрагменты кода включены учебного набора лагеря Web, октябрь 2015 г. выпуска, найти по адресу [ https://github.com/Microsoft-Web/WebCampTrainingKit/releases/tag/v2015.10.13b ](https://github.com/Microsoft-Web/WebCampTrainingKit/releases/tag/v2015.10.13b).  Обратите внимание, что установщик на этой странице больше не работает; Используйте одну из ссылок в разделе "ресурсы".

<a id="Overview"></a>
## <a name="overview"></a>Обзор

<a id="Objectives"></a>
### <a name="objectives"></a>Цели

В этой практической работу вы узнаете, как:

- Отправляйте уведомления с сервера на клиент с помощью SignalR.
- Горизонтальное масштабирование приложения SignalR с помощью **SQL Server**.

<a id="Prerequisites"></a>
### <a name="prerequisites"></a>Предварительные требования

Для завершения этой практической работу требуется следующее:

- [Visual Studio Express 2013 для Web](https://www.microsoft.com/visualstudio/) или более поздней версии

<a id="Setup"></a>
### <a name="setup"></a>Установка

Для выполнения упражнений в этой практической работу, необходимо сначала настроить среду.

1. Откройте окно проводника Windows и перейдите к лаборатории **источника** папки.
2. Щелкните правой кнопкой мыши **Setup.cmd** и выберите **Запуск от имени администратора** для запуска процесса установки, будет настроить среду и установить фрагменты кода Visual Studio для этой лабораторной работы.
3. Если отображается диалоговое окно контроля учетных записей, подтвердите действие для продолжения.

> [!NOTE]
> Убедитесь, что все зависимости для этой лабораторной работы вы вернули перед запуском программы установки.


<a id="CodeSnippets"></a>
### <a name="using-the-code-snippets"></a>Фрагменты кода

В этом документе лаборатории вам будет рекомендовано вставлять блоки кода. Для удобства основная часть кода предоставляется как фрагменты кода Visual Studio, к которому можно получить из в Visual Studio 2013, чтобы избежать необходимости добавлять ее вручную.

> [!NOTE]
> Каждого упражнения сопровождается начальный решения, расположенный в **начать** папку упражнения, чему вы сможете каждого упражнения, независимо от других. Имейте в виду, что фрагменты кода, которые добавляются во время атаки, отсутствуют эти стартовые решения и могут не работать, пока не будут выполнены упражнения. В исходном коде для упражнения, вы также найдете **окончания** папку, содержащую решение Visual Studio с кодом, полученный в результате выполнения действий, описанных в соответствующий упражнении. Эти решения можно использовать в качестве руководства, если вам нужна дополнительная помощь, отвечая на это Практическое занятие.


---

<a id="Exercises"></a>
## <a name="exercises"></a>Упражнения

Это Практическое занятие включает в себя следующие упражнения:

1. [Работа с данными в режиме реального времени, с помощью SignalR](#Exercise1)
2. [Горизонтальное масштабирование с помощью SQL Server](#Exercise2)

Предполагаемое время для выполнения этого лабораторного: **60 минут**

> [!NOTE]
> При первом запуске Visual Studio, необходимо выбрать один из предварительно определенных коллекций параметров. Каждой коллекции предопределенных соответствует конкретному стилю разработки и определяет макетов окон, поведение редактора, фрагменты кода IntelliSense и параметры диалогового окна. В этом лабораторном занятии описаны действия, необходимые для выполнения данной задачи в Visual Studio при использовании **обычные параметры разработки** коллекции. При выборе другого набора параметров для среды разработки, возможно, различия в действиях, которые следует учитывать.


<a id="Exercise1"></a>
### <a name="exercise-1-working-with-real-time-data-using-signalr"></a>Упражнение 1. Работа с данными в режиме реального времени, с помощью SignalR

Хотя чата часто используется в качестве примера, можно сделать всего гораздо больше с веб-функций, в режиме реального времени. Любое время, пользователь обновляет веб-страницы, чтобы просмотреть новые данные или реализует страницы Ajax, длинный опрос для получения новых данных, можно использовать SignalR.

SignalR поддерживает **отправки данных с сервера** или **широковещательной рассылки** функциональные возможности; он автоматически выполняет управление подключениями. В классических подключений HTTP для обмена данными между клиентом и сервером подключение будет восстановлено, для каждого запроса, но SignalR обеспечивает постоянное подключение между клиентом и сервером. В SignalR, вызывает серверный код в клиентский код в браузере с помощью вызовов удаленных процедур (RPC) а не модели запрос ответ мы знаем, уже сегодня.

В этом упражнении вы настроите **Quiz Компьютерщик** приложения для использования SignalR для отображения панели мониторинга статистики с помощью обновленных метрик без необходимости обновления всей страницы.

<a id="Ex1Task1"></a>
#### <a name="task-1--exploring-the-geek-quiz-statistics-page"></a>Задача 1 – изучение странице Компьютерщик головоломки статистики

В этой задаче будет проходить через приложения и убедитесь, как отображается на странице статистики и как можно улучшить способ сведения обновляется.

1. Откройте **Visual Studio Express 2013 для Web** и откройте **GeekQuiz.sln** решение находится в **Source\Ex1 WorkingWithRealTimeData\Begin** папки.
2. Нажмите клавишу **F5** для запуска решения. **Вход** страница должна выглядеть в браузере.

    ![При запуске решения](real-time-web-applications-with-signalr/_static/image2.png "при запуске решения")

    *При запуске решения*
3. Нажмите кнопку **зарегистрировать** в правом верхнем углу страницы, чтобы создать нового пользователя в приложении.

    ![Зарегистрировать ссылку](real-time-web-applications-with-signalr/_static/image3.png "регистрационной ссылки")

    *Регистр связи*
4. В **зарегистрировать** введите **имя пользователя** и **пароль**, а затем нажмите кнопку **зарегистрировать**.

    ![Регистрация пользователя](real-time-web-applications-with-signalr/_static/image4.png "Регистрация пользователя")

    *Регистрация пользователя*
5. Приложение регистрирует новую учетную запись, и пользователь прошел проверку подлинности и перенаправляется на домашнюю страницу, отображение на первый вопрос головоломки.
6. Откройте **статистики** странице в новом окне и поместить **Главная** страницы и **статистики** странице side-by-side.

    ![Windows Side-by-side](real-time-web-applications-with-signalr/_static/image5.png "рядом на стороне windows")

    *Windows Side-by-side*
7. В **Главная** странице, ответьте на вопрос, щелкнув один из вариантов.

    ![Ответить на вопрос о](real-time-web-applications-with-signalr/_static/image6.png "ответить на вопрос")

    *Ответы на вопросы*
8. Щелкните одну из кнопок и появится ответ.

    ![Ответ на вопрос правильный](real-time-web-applications-with-signalr/_static/image7.png "правильный вопрос")

    *Контрольные вопросы правильно*
9. Обратите внимание на то, что информация, содержащаяся в странице Статистика устарела. Обновите страницу, чтобы просмотреть обновленные результаты.

    ![Страница статистики](real-time-web-applications-with-signalr/_static/image8.png "страница статистики")

    *Страница статистики*
10. Вернитесь в Visual Studio и остановить отладку.

<a id="Ex1Task2"></a>
#### <a name="task-2--adding-signalr-to-geek-quiz-to-show-online-charts"></a>Задача 2 – Добавление SignalR для Компьютерщик викторины, чтобы показать Online диаграммы

В этой задаче будет добавить в решение SignalR и автоматически отправлять обновления клиентов, когда новый ответ отправляется на сервер.

1. Из **средства** меню в Visual Studio, выберите пункт **диспетчер пакетов NuGet**, а затем нажмите кнопку **консоль диспетчера пакетов**.
2. В **консоль диспетчера пакетов** окно, выполните следующую команду:

    [!code-powershell[Main](real-time-web-applications-with-signalr/samples/sample1.ps1)]

    ![Установка пакета SignalR](real-time-web-applications-with-signalr/_static/image9.png "установки пакета SignalR")

    *Установка пакета SignalR*

   > [!NOTE]
   > При установке **SignalR** NuGet пакеты версии 2.0.2 из нового приложения MVC 5, необходимо будет вручную обновить **OWIN** пакетов версию 2.0.1 (или более поздней версии) перед установкой SignalR. Чтобы сделать это, можно выполнить следующий сценарий в **консоль диспетчера пакетов**:
   > 
   > [!code-powershell[Main](real-time-web-applications-with-signalr/samples/sample2.ps1)]
   > 
   > В одном из будущих выпусков SignalR OWIN зависимости будут обновляться автоматически.
3. В **обозревателе решений**, разверните **сценарии** папку и обратите внимание, что, SignalR *js* файлы были добавлены в решение.

    ![Ссылается на SignalR JavaScript](real-time-web-applications-with-signalr/_static/image10.png "ссылается на SignalR JavaScript")

    *Ссылки на SignalR JavaScript*
4. В **обозревателе решений**, щелкните правой кнопкой мыши **GeekQuiz** проекта, выберите **добавить** | **новую папку**и назовите его  **Концентраторы**.
5. Щелкните правой кнопкой мыши **концентраторов** папку и выберите **Add | Новый элемент**.

    ![Добавить новый элемент](real-time-web-applications-with-signalr/_static/image11.png "добавить новый элемент")

    *Добавление нового элемента*
6. В **Добавление нового элемента** выберите **Visual C# | Web | SignalR** узел в левой области выберите **класс концентратора SignalR (v2)** в центральной области, назовите файл **StatisticsHub.cs** и нажмите кнопку **добавить**.

    ![Добавить новый элемент диалоговое окно](real-time-web-applications-with-signalr/_static/image12.png "добавить новый элемент диалоговое окно")

    *Добавить новый элемент-диалоговое окно*
7. Замените код в **StatisticsHub** класса следующим кодом.

    (Code Snippet - *StatisticsHubClass RealTimeSignalR - сервера Ex1 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample3.cs)]
8. Откройте **Startup.cs** и добавьте следующую строку в конце **конфигурации** метод.

    (Code Snippet - *MapSignalR RealTimeSignalR - сервера Ex1 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample4.cs)]
9. Откройте **StatisticsService.cs** странице внутри **служб** папку и добавьте следующие директивы using.

    (Code Snippet - *UsingDirectives RealTimeSignalR - сервера Ex1 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample5.cs)]
10. Чтобы уведомить подключенные клиенты из обновления, сначала нужно получить **контекст** объект для текущего соединения. **Концентратора** объект содержит методы для отправки сообщений для одного клиента или широкое вещание на всех подключенных клиентов. Добавьте следующий метод в **StatisticsService** класс рассылать статистических данных.

    (Code Snippet - *NotifyUpdatesMethod RealTimeSignalR - сервера Ex1 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample6.cs)]

    > [!NOTE]
    > В приведенном выше коде используется имя произвольного метод для вызова функции на стороне клиента (т. е.: *updateStatistics*). Имя метода, указать интерпретируется как динамический объект, это означает, что нет IntelliSense или проверку во время компиляции. Выражение вычисляется во время выполнения. При выполнении вызова метода, имя метода и значения параметров SignalR отправляет клиенту. Если клиент имеет метод, который совпадает с именем, что вызывается метод и значения параметров, передаваемые ему. Если отсутствует соответствующий метод находится на стороне клиента, ошибка не возникает. Дополнительные сведения см. [руководство по API концентраторов SignalR ASP.NET](../guide-to-the-api/hubs-api-guide-server.md).
11. Откройте **TriviaController.cs** странице внутри **контроллеров** папку и добавьте следующие директивы using.

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample7.cs)]
12. Добавьте следующий выделенный код, который **Post** метода действия.

    (Code Snippet - *NotifyUpdatesCall RealTimeSignalR - сервера Ex1 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample8.cs)]
13. Откройте **Statistics.cshtml** странице внутри **представления | Главная** папки. Найдите **сценариев** разделе и добавьте следующие ссылки на скрипты в начале раздела.

    (Code Snippet - *SignalRScriptReferences RealTimeSignalR - сервера Ex1 -*)

    [!code-cshtml[Main](real-time-web-applications-with-signalr/samples/sample9.cshtml)]

    > [!NOTE]
    > При добавлении SignalR и других библиотек сценариев в проект Visual Studio, диспетчер пакетов может установить версию файла скрипта SignalR, более свежие, чем версия, приведенные в этом разделе. Убедитесь, что ссылку на сценарий в коде совпадает с версией библиотеки сценариев, которые установлены в вашем проекте.
14. Добавьте выделенный ниже код для подключения клиента к концентратору SignalR и обновления статистических данных, при получении нового сообщения от концентратора.

    (Code Snippet - *SignalRClientCode RealTimeSignalR - сервера Ex1 -*)

    [!code-cshtml[Main](real-time-web-applications-with-signalr/samples/sample10.cshtml)]

    В этом коде создается прокси-сервера-концентратора и регистрации обработчика событий для прослушивания сообщений, отправленных сервером. В этом случае можно прослушивать сообщения, проходящие через *updateStatistics* метод.

<a id="Ex1Task3"></a>
#### <a name="task-3--running-the-solution"></a>Задача 3 – при запуске решения

В этой задаче будет выполняться решение, чтобы убедиться, что представление Статистика обновляется автоматически с помощью SignalR после ответа на свой вопрос.

1. Нажмите клавишу **F5** для запуска решения.

    > [!NOTE]
    > Если еще не вошли в приложение, войдите с помощью пользователя, созданный в задаче 1.
2. Откройте **статистики** странице в новом окне и поместить **Главная** страницы и **статистики** странице side-by-side, как это делалось в задаче 1.
3. В **Главная** странице, ответьте на вопрос, щелкнув один из вариантов.

    ![Ответы на другой вопрос](real-time-web-applications-with-signalr/_static/image13.png "ответы на другой вопрос")

    *Ответы на другой вопрос*
4. Щелкните одну из кнопок и появится ответ. Обратите внимание на то, что статистические данные на странице обновляется автоматически после ответа на вопрос с обновленными данными без необходимости обновления всей страницы.

    ![Обновление статистики страницы после ответов](real-time-web-applications-with-signalr/_static/image14.png "обновление статистики страницы после ответов")

    *Страница статистики обновлен после ответов*

<a id="Exercise2"></a>
### <a name="exercise-2-scaling-out-using-sql-server"></a>Упражнение 2. Горизонтальное масштабирование с помощью SQL Server

При масштабировании веб-приложения, обычно можно между *масштабировании* и *масштабирование* параметры. *Увеличение масштаба* на больший сервер с помощью дополнительных ресурсов (ЦП, ОЗУ и др.) при *горизонтальное масштабирование* означает добавление новых серверов для обработки нагрузки. Проблема во втором типе аутентификации в том, что клиенты могут перенаправляться на разных серверах. Клиент, который подключен к одному серверу не будет получать сообщения, отправленные с другого сервера.

Эти проблемы можно решить с помощью компонент, называемый *объединительной платы*, для передачи сообщений между серверами. С задней панели, который включен каждый экземпляр приложения отправляет сообщения объединительной плате и задней панели перенаправляет их в другие экземпляры приложения.

В настоящее время существует три типа соединительных панелях для SignalR.

- **Windows Azure Service Bus**. Служебная шина — это инфраструктура обмена сообщениями, которая позволяет компонентам для отправки сообщений в слабо связанных.
- **SQL Server**. На задней стороне SQL Server записывает сообщения в таблицы SQL. Задняя панель с компонентом Service Broker для эффективного обмена сообщениями. Тем не менее она также работает, если не включен компонент Service Broker.
- **Redis**. Redis — это хранилище ключ значение в памяти. Redis поддерживает шаблона публикации/подписки («pub/sub») для отправки сообщений.

Каждое сообщение отправляется через канал сообщений. Реализует канал сообщений [IMessageBus](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.messaging.imessagebus(v=vs.100).aspx) интерфейс, который предоставляет абстракцию публикации/подписки. Соединительных панелях работы, заменив значение по умолчанию **IMessageBus** с шиной предназначен для этой задней панели.

Каждый экземпляр сервера подключается к задней панели через шину. При отправке сообщения, она переходит к задней панели и задней панели отправляет его на каждом сервере. Когда сервер получает сообщение от объединительной платы, она хранит сообщения в локальный кэш. Затем сервер доставляет сообщения клиентам из своего локального кэша.

Дополнительные сведения о том, как работает объединительной панели SignalR, см. в этой [статье](../performance/scaleout-in-signalr.md).

> [!NOTE]
> Существуют некоторые сценарии, в которых объединительной панели может стать узким местом. Ниже приведены некоторые типичные сценарии SignalR.
> 
> - [Рассылка сервера](tutorial-server-broadcast-with-signalr.md) (например, биржевые сводки): Соединительных панелях хорошо подходят для этого сценария, так как сервер определяет скорость, с которой отправляются сообщения.
> - [Клиент клиент](tutorial-getting-started-with-signalr.md) (например, чат): В этом случае задней панели может быть узким местом, если количество сообщений, масштабируется с количеством клиентов; то есть если увеличивается число сообщений, присоединить пропорционально как можно большего числа клиентов.
> - [В реальном времени высокой частотой](tutorial-high-frequency-realtime-with-signalr.md) (например, в режиме реального времени игры): Задняя панель не рекомендуется для этого сценария.


В этом упражнении вы воспользуетесь **SQL Server** распределяют сообщения между **Quiz Компьютерщик** приложения. Эти задачи будет выполняться на компьютере отдельный тест, чтобы узнать, как настроить конфигурацию, но чтобы получить полные результаты, вам понадобится для развертывания приложений SignalR на два или несколько серверов. Также необходимо установить SQL Server на одном из серверов или на отдельном выделенном сервере.

![Горизонтальное масштабирование с помощью схемы SQL Server](real-time-web-applications-with-signalr/_static/image15.png)

<a id="Ex2Task1"></a>
#### <a name="task-1---understanding-the-scenario"></a>Задача 1 - основные сведения о сценарии

В этой задаче будет выполняться два экземпляра **Quiz Компьютерщик** имитация IIS нескольких экземпляров на локальном компьютере. В этом случае при ответе на занимательные вопросы на одно приложение обновления не будут высылаться уведомления на странице статистики второго экземпляра. Эмуляция похож на среду, где приложение развертывается на нескольких экземплярах и с помощью подсистемы балансировки нагрузки для взаимодействия с ними.

1. Откройте **Begin.sln** решение находится в **источника/Ex2-ScalingOutWithSQLServer/начало** папки. После загрузки, обратите внимание на **обозревателя серверов** что решение содержит два проекта с идентичными структуры, но разные имена. Это будет имитировать выполнение двух экземпляров одного приложения на локальном компьютере.

    ![Начать решение, имитируя 2 экземпляров головоломки Компьютерщик](real-time-web-applications-with-signalr/_static/image16.png "начать решение, имитируя 2 экземпляров Компьютерщик головоломки")

    *Начать решение, имитируя 2 экземпляров Компьютерщик головоломки*
2. Откройте страницы свойств решения, щелкнув правой кнопкой мыши узел решения **свойства**. В разделе **запускаемым проектом**выберите **несколько запускаемых проектов** и измените **действие** значение для обоих проектов *запустить*.

    ![Запуск нескольких проектов](real-time-web-applications-with-signalr/_static/image17.png "запуск нескольких проектов")

    *Запуск нескольких проектов*
3. Нажмите клавишу **F5** для запуска решения. Приложение будет запущено два экземпляра **Quiz Компьютерщик** в разные порты, имитируя несколько экземпляров одного приложения. Закрепляет один из обозревателей на слева, а другой — в правой части экрана. Войдите с помощью учетных данных или регистрация нового пользователя. После входа в систему, сохранить страницу Trivia в левой части и перейдите к **статистики** страницу в браузере в правой части.

    ![Головоломка Компьютерщик рядом](real-time-web-applications-with-signalr/_static/image18.png)

    *Головоломка Компьютерщик рядом*

    ![Компьютерщик тест в разные порты](real-time-web-applications-with-signalr/_static/image19.png)

    *Компьютерщик тест в разные порты*
4. Запустите ответы на вопросы в браузере слева, и можно будет заметить, что **статистики** страницу в браузере правой не обновляется. Это обусловлено **SignalR** использует локальный кэш для распределения сообщений между клиентами и этот сценарий имитирует несколько экземпляров, поэтому кэш не может использоваться между ними. Можно убедиться, что **SignalR** работы за счет тестирования те же действия, но с помощью одного приложения. В следующих задачах вы настроите объединительной панели для репликации сообщений между экземплярами.
5. Вернитесь в Visual Studio и остановить отладку.

<a id="Ex2Task2"></a>
#### <a name="task-2--creating-the-sql-server-backplane"></a>Задача 2 – Создание на задней стороне SQL Server

В этой задаче вы создадите базы данных, которая будет использоваться в качестве объединительной платы для **Quiz Компьютерщик** приложения. Вы воспользуетесь **обозреватель объектов SQL Server** для просмотра вашего сервера и инициализировать базу данных. Кроме того, вы включите **компонента Service Broker**.

1. В **Visual Studio**, откройте меню **представление** и выберите **обозреватель объектов SQL Server**.
2. Подключитесь к экземпляру LocalDB, щелкнув правой кнопкой мыши **SQL Server** узла и выбрав **добавить SQL Server...**  параметр.

    ![Добавление экземпляра SQL Server](real-time-web-applications-with-signalr/_static/image20.png "Добавление экземпляра SQL Server")

    *Добавление экземпляра SQL Server в обозревателе объектов SQL Server*
3. Задайте **имя_сервера** для *(localdb) \v11.0* и оставить **проверки подлинности Windows** как свой режим проверки подлинности. Нажмите кнопку **Connect** для продолжения.

    ![Подключение к LocalDB](real-time-web-applications-with-signalr/_static/image21.png "подключение к LocalDB")

    *Подключение к LocalDB*
4. Теперь, когда вы подключены к своему экземпляру LocalDB, необходимо будет создать базу данных, который будет представлять на задней стороне SQL Server для SignalR. Чтобы сделать это, щелкните правой кнопкой мыши **баз данных** узел и выберите **добавить новую базу данных**.

    ![Добавление новой базы данных](real-time-web-applications-with-signalr/_static/image22.png "Добавление новой базы данных")

    *Добавление новой базы данных*
5. Задайте имя базы данных *SignalR* и нажмите кнопку **ОК** для его создания.

    ![Создание базы данных SignalR](real-time-web-applications-with-signalr/_static/image23.png "Создание базы данных SignalR")

    *Создание базы данных SignalR*

    > [!NOTE]
    > Можно выбрать любое имя для базы данных.
6. Чтобы более эффективно получать обновления от объединительной платы, рекомендуется включить компонент Service Broker для базы данных. Компонент Service Broker обеспечивает встроенную поддержку для обмена сообщениями и очереди в SQL Server. Задняя панель также работает без компонента Service Broker. Откройте новый запрос, щелкнув правой кнопкой мыши базу данных и выберите **новый запрос**.

    ![Открытие нового запроса](real-time-web-applications-with-signalr/_static/image24.png "Открытие нового запроса")

    *Открытие нового запроса*
7. Чтобы проверить, включен ли компонент Service Broker, запросите **—\_broker\_включена** столбца в **sys.databases** представления каталога. Выполните следующий скрипт в окне последних открытых запросов.

    [!code-sql[Main](real-time-web-applications-with-signalr/samples/sample11.sql)]

    ![Запрос состояния брокера службы](real-time-web-applications-with-signalr/_static/image25.png "запросе состояния службы Broker")

    *Запрос состояния брокера служб*
8. Если значение **—\_broker\_включена** столбец базы данных является &quot;0&quot;, используйте следующую команду, чтобы включить его. Замените **&lt;YOUR DATABASE&gt;** с именем, заданную при создании базы данных (например: SignalR).

    [!code-sql[Main](real-time-web-applications-with-signalr/samples/sample12.sql)]

    ![Активация компонента Service Broker](real-time-web-applications-with-signalr/_static/image26.png "Активация компонента Service Broker")

    *Активация компонента Service Broker*

    > [!NOTE]
    > Если этот запрос принимать участие во взаимоблокировке, убедитесь, что нет подключения к базе данных приложений.

<a id="Ex2Task3"></a>
#### <a name="task-3--configuring-the-signalr-application"></a>Задача 3 – Настройка приложения SignalR

В этой задаче вы настроите **Quiz Компьютерщик** для подключения к задней панели SQL Server. Сначала добавим **SignalR.SqlServer** пакет NuGet и укажите соединение, созданное строка к базе данных объединительной платы.

1. Откройте **консоль диспетчера пакетов** из **средства** > **диспетчер пакетов NuGet**. Убедитесь, что **GeekQuiz** проект выбран в **проект по умолчанию** стрелку раскрывающегося списка. Введите следующую команду, чтобы установить **Microsoft.AspNet.SignalR.SqlServer** пакет NuGet.

    [!code-powershell[Main](real-time-web-applications-with-signalr/samples/sample13.ps1)]
2. Повторите предыдущий шаг но на этот раз для проекта **GeekQuiz2**.
3. Чтобы настроить на задней стороне SQL Server, откройте **Startup.cs** файл **GeekQuiz** проекта и добавьте следующий код, чтобы **Настройка** метод. Замените **&lt;YOUR DATABASE&gt;** именем вашей базы данных, которые использовались при создании на задней стороне SQL Server. Повторите этот шаг для **GeekQuiz2** проекта.

    (Code Snippet - *StartupConfiguration RealTimeSignalR - Ex2 -*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample14.cs)]
4. Теперь, когда оба проекта настроены для использования на задней стороне SQL Server, нажмите клавишу **F5** запускать их одновременно.
5. Опять же **Visual Studio** приведет к запуску два экземпляра **Quiz Компьютерщик** в разные порты. Закрепляет один из браузеров слева, а другой — в правой части экрана и войдите с помощью учетных данных. Сохранить страницу Trivia в левой части и перейдите к **статистики** pagein правой браузера.
6. Запуск, ответы на вопросы в браузере слева. На этот раз **статистики** страница обновляется благодаря задней панели. Переключайтесь между приложениями (**статистики** теперь включен в левой части и **Trivia** правой стороны) и повторите тест, позволяющий проверить, что он работает для обоих экземпляров. Служит в качестве объединительной платы *общего кэша* сообщений для каждого подключенного сервера, а каждый сервер сохраняет сообщения в собственный локальный кэш для распространения на подключенных клиентов.
7. Вернитесь в Visual Studio и остановить отладку.
8. Задняя панель компонент SQL Server автоматически создает необходимые таблицы в указанной базе данных. В **обозреватель объектов SQL Server** панели, откройте базу данных, созданную для задней панели (например: SignalR) и разверните его таблиц. Вы должны увидеть следующие таблицы:

    ![Задняя панель созданных таблиц](real-time-web-applications-with-signalr/_static/image27.png)

    *Задняя панель созданных таблиц*
9. Щелкните правой кнопкой мыши **SignalR.Messages\_0** таблицы и выберите **данные представления**.

    ![Просмотр таблицы сообщения объединительной панели SignalR](real-time-web-applications-with-signalr/_static/image28.png)

    *Просмотр таблицы сообщения объединительной панели SignalR*
10. Вы увидите различные сообщения, отправленные **концентратора** отвечая на занимательные вопросы. Задняя панель распределяет эти сообщения в любой подключенный экземпляр.

    ![Таблица объединительной платы сообщений](real-time-web-applications-with-signalr/_static/image29.png)

    *Таблица объединительной платы сообщений*

---

<a id="Summary"></a>
## <a name="summary"></a>Сводка

В этой практической работу вы узнали, как добавить **SignalR** свои приложения и отправки уведомления с сервера в подключенные клиенты, с помощью **концентраторов**. Кроме того, вы узнали, как развернуть приложение с помощью *объединительной платы* компонента, когда приложение развертывается в нескольких экземплярах служб IIS.
