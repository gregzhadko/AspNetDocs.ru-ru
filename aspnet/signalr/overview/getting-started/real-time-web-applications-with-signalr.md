---
uid: signalr/overview/getting-started/real-time-web-applications-with-signalr
title: Практическое занятие. веб-приложения в режиме реального времени с SignalR | Документация Майкрософт
author: bradygaster
description: Веб-приложения в режиме реального времени позволяют отправлять содержимое на стороне сервера в подключенные клиенты, как это происходит в режиме реального времени. Для разработчиков ASP.NET, ASP...
ms.author: bradyg
ms.date: 07/16/2014
ms.assetid: ba07958c-42e1-4da0-81db-ba6925ed6db0
msc.legacyurl: /signalr/overview/getting-started/real-time-web-applications-with-signalr
msc.type: authoredcontent
ms.openlocfilehash: 9e39fd3f2fc9d4e791002450085215096c222fcd
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78431670"
---
# <a name="hands-on-lab-real-time-web-applications-with-signalr"></a>Практическое занятие. веб-приложения в режиме реального времени с помощью SignalR

по [веб-Camp командам](https://twitter.com/webcamps)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

[Скачайте комплект обучающих материалов по Web Camp, выпуск за Октябрь 2015](https://github.com/Microsoft-Web/WebCampTrainingKit/releases/tag/v2015.10.13b)

> Веб-приложения в режиме реального времени позволяют отправлять содержимое на стороне сервера в подключенные клиенты, как это происходит в режиме реального времени. Для разработчиков ASP.NET **ASP.NET SignalR** — это библиотека для добавления в приложения веб-функций в режиме реального времени. Она использует преимущества нескольких транспортов, автоматически выбирая оптимальную доступную транспортную передачу, используя оптимальный доступный транспорт клиента и сервера. Он использует преимущества **WebSocket**, API HTML5, который обеспечивает двунаправленный обмен данными между браузером и сервером.
> 
> **SignalR** также предоставляет простой, высокоуровневый API для выполнения СЕРВЕРной RPC-службы (вызов функций JavaScript в браузерах клиентов из серверного кода .NET) в приложении ASP.NET, а также добавление полезных обработчиков для управления подключениями, таких как события подключения и отключения, группирование соединений и авторизация.
> 
> **SignalR** является абстракцией для некоторых транспортов, необходимых для работы в режиме реального времени между клиентом и сервером. Подключение **SignalR** запускается как HTTP, а затем передается в подключение **WebSocket** , если оно доступно. **WebSocket** — это идеальный транспорт для **SignalR**, так как он обеспечивает наиболее эффективное использование памяти сервера, имеет наименьшую задержку и обладает самыми основными функциями (например, полным дуплексным обменом данными между клиентом и сервером), но обладает самыми строгими требованиями: для **WebSocket** требуется, чтобы сервер использовал **Windows Server 2012** или **Windows 8**, а также **.NET Framework 4,5**. Если эти требования не выполняются, то **SignalR** попытается использовать другие транспорты для подключения (например, *длительный опрос Ajax*).
> 
> API **SignalR** содержит две модели взаимодействия между клиентами и серверами: **постоянные подключения** и **концентраторы**. **Соединение** представляет собой простую конечную точку для отправки сообщений одного получателя, сгруппированных или широковещательных. **Концентратор** — это высокоуровневый конвейер, построенный на основе API подключения, который позволяет клиенту и серверу вызывать методы напрямую.
> 
> ![Архитектура SignalR](real-time-web-applications-with-signalr/_static/image1.png)
> 
> Все примеры кода и фрагментов включены в набор средств для обучения Web Camp, [https://github.com/Microsoft-Web/WebCampTrainingKit/releases/tag/v2015.10.13b](https://github.com/Microsoft-Web/WebCampTrainingKit/releases/tag/v2015.10.13b)выпущенный в октябре 2015.  Обратите внимание, что ссылка на этот установщик на этой странице больше не работает; Вместо этого используйте одну из ссылок в разделе активы.

<a id="Overview"></a>
## <a name="overview"></a>Обзор

<a id="Objectives"></a>
### <a name="objectives"></a>Цели

В этой практической лабораторной работе вы узнаете, как выполнять следующие задачи:

- Отправка уведомлений с сервера на клиент с помощью SignalR.
- Scale Out приложение SignalR с помощью **SQL Server**.

<a id="Prerequisites"></a>
### <a name="prerequisites"></a>предварительные требования

Для выполнения этой практической лабораторной работы требуется следующее:

- [Visual Studio Express 2013 для Web](https://www.microsoft.com/visualstudio/) или более поздней версии

<a id="Setup"></a>
### <a name="setup"></a>Настройка

Чтобы выполнить упражнения в этой практической лабораторной работе, сначала необходимо настроить среду.

1. Откройте окно проводника Windows и перейдите к **исходной** папке лаборатории.
2. Щелкните правой кнопкой мыши **Setup. cmd** и выберите **Запуск от имени администратора** , чтобы запустить процесс установки, который будет настраивать среду и установить фрагменты кода Visual Studio для этой лабораторной работы.
3. Если отображается диалоговое окно Контроль учетных записей пользователей, подтвердите действие для продолжения.

> [!NOTE]
> Убедитесь, что проверены все зависимости для этой лабораторной работы перед запуском программы установки.

<a id="CodeSnippets"></a>
### <a name="using-the-code-snippets"></a>Использование фрагментов кода

На протяжении всего лабораторного документа вы получите инструкции по вставке блоков кода. Для удобства большая часть этого кода предоставляется как Visual Studio Code фрагменты, к которым можно получить доступ из Visual Studio 2013, чтобы не добавлять их вручную.

> [!NOTE]
> Каждое упражнение сопровождается начальным решением, расположенным в **начальной** папке упражнения, которое позволяет выполнять каждое упражнение независимо от других. Имейте в виду, что фрагменты кода, добавленные во время упражнения, отсутствуют в этих начальных решениях и могут не работать, пока вы не завершите упражнение. В исходном коде для упражнения также будет найдена **Конечная** папка, содержащая решение Visual Studio с кодом, полученным в результате выполнения шагов в соответствующем упражнении. Эти решения можно использовать в качестве руководства, если вам нужна дополнительная помощь во время работы с этой практической лабораторной работой.

---

<a id="Exercises"></a>
## <a name="exercises"></a>Полнят

Эта практическая лабораторная работа включает в себя следующие упражнения:

1. [Работа с данными в режиме реального времени с помощью SignalR](#Exercise1)
2. [Горизонтальное масштабирование с помощью SQL Server](#Exercise2)

Предполагаемое время выполнения этой лабораторной работы: **60 минут**

> [!NOTE]
> При первом запуске Visual Studio необходимо выбрать одну из предварительно определенных коллекций параметров. Каждая предопределенная коллекция разработана для соответствия определенному стилю разработки и определяет макеты окон, поведение редактора, фрагменты кода IntelliSense и параметры диалоговых окон. Процедуры в этом лабораторном занятии описывают действия, необходимые для выполнения данной задачи в Visual Studio при использовании коллекции **общих параметров разработки** . При выборе другой коллекции параметров для среды разработки могут возникнуть различия в действиях, которые необходимо учитывать.

<a id="Exercise1"></a>
### <a name="exercise-1-working-with-real-time-data-using-signalr"></a>Упражнение 1. Работа с данными в режиме реального времени с помощью SignalR

Хотя беседа часто используется в качестве примера, вы можете сделать многое больше с помощью веб-функций в режиме реального времени. Каждый раз, когда пользователь обновляет веб-страницу для просмотра новых данных, или страница реализует длительный опрос Ajax для получения новых данных, вы можете использовать SignalR.

SignalR поддерживает функцию **принудительной** или **широковещательной** передачи сервера; он автоматически обрабатывает управление подключениями. В классических HTTP-подключениях для обмена данными между клиентом и сервером устанавливается соединение повторно для каждого запроса, но SignalR обеспечивает постоянное подключение между клиентом и сервером. В SignalR серверный код вызывает клиентский код в браузере с помощью удаленных вызовов процедур (RPC), а не модели «запрос-ответ», которая уже известна.

В этом упражнении вы настроите приложение " **Викторина** ", которое будет использовать SignalR для вывода панели мониторинга статистики с обновленными метриками без необходимости обновлять всю страницу.

<a id="Ex1Task1"></a>
#### <a name="task-1--exploring-the-geek-quiz-statistics-page"></a>Задача 1. Обзор страницы "Статистика головоломки"

В этой задаче вы просматриваете приложение и проверите, как отображается страница статистики, и как можно улучшить способ обновления информации.

1. Откройте **Visual Studio Express 2013 для Web** и откройте решение **жееккуиз. sln** , расположенное в папке **Source\Ex1-WorkingWithRealTimeData\Begin** .
2. Чтобы запустить решение, нажмите клавишу **F5**. Страница **входа** должна появиться в браузере.

    ![Запуск решения](real-time-web-applications-with-signalr/_static/image2.png "Запуск решения")

    *Запуск решения*
3. Нажмите кнопку **зарегистрировать** в правом верхнем углу страницы, чтобы создать нового пользователя в приложении.

    ![Ссылка для регистрации](real-time-web-applications-with-signalr/_static/image3.png "Ссылка для регистрации")

    *Ссылка для регистрации*
4. На странице **Регистрация** введите **имя пользователя** и **пароль**, а затем нажмите кнопку **зарегистрировать**.

    ![Регистрация пользователя](real-time-web-applications-with-signalr/_static/image4.png "Регистрация пользователя")

    *Регистрация пользователя*
5. Приложение регистрирует новую учетную запись, и пользователь проходит проверку подлинности и перенаправляется обратно на домашнюю страницу, где отображается первый контрольный вопрос.
6. Откройте страницу **Статистика** в новом окне и разместите страницу **Домашняя** страница и **Статистика** параллельно.

    ![Параллельные окна](real-time-web-applications-with-signalr/_static/image5.png "Параллельные окна")

    *Параллельные окна*
7. На **домашней** странице ответьте на вопрос, щелкнув один из вариантов.

    ![Ответ на вопрос](real-time-web-applications-with-signalr/_static/image6.png "Ответ на вопрос")

    *Ответ на вопрос*
8. После нажатия одной из кнопок появится ответ.

    ![Правильный ответ на вопрос](real-time-web-applications-with-signalr/_static/image7.png "Правильный ответ на вопрос")

    *Ответ на вопрос правильно*
9. Обратите внимание, что сведения, приведенные на странице Статистика, устарели. Обновите страницу, чтобы просмотреть обновленные результаты.

    ![Страница «Статистика»](real-time-web-applications-with-signalr/_static/image8.png "Страница «Статистика»")

    *Страница «Статистика»*
10. Вернитесь в Visual Studio и завершите отладку.

<a id="Ex1Task2"></a>
#### <a name="task-2--adding-signalr-to-geek-quiz-to-show-online-charts"></a>Задача 2. Добавление SignalR в головоломку для отображения в сети диаграмм

В этой задаче вы добавите в решение SignalR и автоматически отправите обновления клиентам при отправке на сервер нового ответа.

1. В меню **Сервис** в Visual Studio выберите **Диспетчер пакетов NuGet**, а затем щелкните **консоль диспетчера пакетов**.
2. В окне **консоли диспетчера пакетов** выполните следующую команду:

    [!code-powershell[Main](real-time-web-applications-with-signalr/samples/sample1.ps1)]

    ![Установка пакета SignalR](real-time-web-applications-with-signalr/_static/image9.png "Установка пакета SignalR")

    *Установка пакета SignalR*

   > [!NOTE]
   > При установке пакетов NuGet **SignalR** версии 2.0.2 из нового приложения MVC 5 необходимо вручную обновить пакеты **OWIN** до версии 2.0.1 (или выше) перед установкой SignalR. Для этого можно выполнить следующий скрипт в **консоли диспетчера пакетов**:
   > 
   > [!code-powershell[Main](real-time-web-applications-with-signalr/samples/sample2.ps1)]
   > 
   > В будущих выпусках SignalR зависимости OWIN будут автоматически обновлены.
3. В **Обозреватель решений**разверните папку « **скрипты** » и обратите внимание, что файлы SignalR. *JS* добавлены в решение.

    ![Ссылки на JavaScript SignalR](real-time-web-applications-with-signalr/_static/image10.png "Ссылки на JavaScript SignalR")

    *Ссылки на JavaScript SignalR*
4. В **Обозреватель решений**щелкните правой кнопкой мыши проект **Жееккуиз** , выберите **добавить** | **создать папку**и назовите ее **центры**.
5. Щелкните правой кнопкой мыши папку **концентраторы** и выберите **Добавить | Новый элемент**.

    ![Добавить новый элемент](real-time-web-applications-with-signalr/_static/image11.png "Добавление нового элемента")

    *Добавить новый элемент*
6. В диалоговом окне " **Добавление нового элемента** " выберите  **C# визуальный элемент | Интернет | Узел SignalR** в левой области выберите **класс концентратора SignalR (v2)** в центральной области, назовите файл **StatisticsHub.CS** и нажмите кнопку **Добавить**.

    ![Диалоговое окно "Добавление нового элемента"](real-time-web-applications-with-signalr/_static/image12.png "Диалоговое окно "Добавление нового элемента"")

    *Диалоговое окно "Добавление нового элемента"*
7. Замените код в классе **статистикшуб** следующим кодом.

    (Фрагмент кода — *реалтимесигналр-EX1-статистикшубкласс*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample3.cs)]
8. Откройте **Startup.CS** и добавьте следующую строку в конец метода **конфигурации** .

    (Фрагмент кода — *реалтимесигналр-EX1-мапсигналр*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample4.cs)]
9. Откройте страницу **StatisticsService.CS** в папке **Services** и добавьте следующие директивы using.

    (Фрагмент кода — *реалтимесигналр-EX1-усингдирективес*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample5.cs)]
10. Чтобы уведомить подключенных клиентов об обновлениях, сначала необходимо получить объект **контекста** для текущего соединения. Объект **Hub** содержит методы для отправки сообщений одному клиенту или вещания всем подключенным клиентам. Добавьте следующий метод в класс **статистикссервице** для передачи статистических данных.

    (Фрагмент кода — *реалтимесигналр-EX1-нотифюпдатесмесод*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample6.cs)]

    > [!NOTE]
    > В приведенном выше коде вы используете произвольное имя метода для вызова функции на клиенте (т. е. *updateStatistics*). Указанное имя метода интерпретируется как динамический объект, что означает отсутствие в нем IntelliSense или проверку во время компиляции. Выражение вычисляется во время выполнения. При выполнении вызова метода SignalR отправляет клиенту имя метода и значения параметров. Если клиент имеет метод, совпадающий с именем, вызывается этот метод и ему передаются значения параметров. Если на клиенте не найден соответствующий метод, ошибка не возникает. Дополнительные сведения см. в [руководстве по API концентраторов signalr ASP.NET](../guide-to-the-api/hubs-api-guide-server.md).
11. Откройте страницу **TriviaController.CS** в папке **Controllers** и добавьте следующие директивы using.

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample7.cs)]
12. Добавьте следующий выделенный код в метод действия **POST** .

    (Фрагмент кода — *реалтимесигналр-EX1-нотифюпдатескалл*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample8.cs)]
13. Откройте страницу **Statistics. cshtml** внутри **представлений | Домашняя** папка. Откройте раздел **Scripts** и добавьте следующие ссылки на скрипты в начале раздела.

    (Фрагмент кода — *реалтимесигналр-EX1-сигналрскриптреференцес*)

    [!code-cshtml[Main](real-time-web-applications-with-signalr/samples/sample9.cshtml)]

    > [!NOTE]
    > При добавлении в проект Visual Studio SignalR и других библиотек сценариев диспетчер пакетов может установить версию файла сценария SignalR, более позднюю по сравнению с версией, приведенной в этом разделе. Убедитесь, что ссылка на скрипт в коде совпадает с версией библиотеки скриптов, установленной в проекте.
14. Добавьте выделенный ниже код, чтобы подключить клиент к концентратору SignalR и обновить данные статистики при получении нового сообщения от концентратора.

    (Фрагмент кода — *реалтимесигналр-EX1-сигналрклиенткоде*)

    [!code-cshtml[Main](real-time-web-applications-with-signalr/samples/sample10.cshtml)]

    В этом коде вы создаете прокси-сервер концентратора и регистрируете обработчик событий для прослушивания сообщений, отправленных сервером. В этом случае Вы прослушиваете сообщения, отправленные с помощью метода *updateStatistics* .

<a id="Ex1Task3"></a>
#### <a name="task-3--running-the-solution"></a>Задача 3. Запуск решения

В этой задаче будет запущено решение, чтобы убедиться, что представление статистики автоматически обновляется с помощью SignalR после ответа на новый вопрос.

1. Чтобы запустить решение, нажмите клавишу **F5**.

    > [!NOTE]
    > Если вы еще не вошли в приложение, войдите в систему с учетной записью пользователя, созданного в задаче 1.
2. Откройте страницу **Статистика** в новом окне и разместите страницу **Домашняя** страница и **Статистика** параллельно, как показано в задаче 1.
3. На **домашней** странице ответьте на вопрос, щелкнув один из вариантов.

    ![Ответ на другой вопрос](real-time-web-applications-with-signalr/_static/image13.png "Ответ на другой вопрос")

    *Ответ на другой вопрос*
4. После нажатия одной из кнопок появится ответ. Обратите внимание, что статистические данные на странице обновляются автоматически после ответа на вопрос с обновленной информацией без необходимости обновления всей страницы.

    ![Страница статистики обновлена после ответа](real-time-web-applications-with-signalr/_static/image14.png "Страница статистики обновлена после ответа")

    *Страница статистики обновлена после ответа*

<a id="Exercise2"></a>
### <a name="exercise-2-scaling-out-using-sql-server"></a>Упражнение 2. масштабирование с помощью SQL Server

При масштабировании веб-приложения обычно можно выбирать между возможностями *масштабирования* *и масштабирования.* Увеличение *масштаба* означает использование более крупного сервера с большим количеством ресурсов (ЦП, ОЗУ и т. д.), а *масштабирование* означает добавление дополнительных серверов для работы с нагрузкой. Проблема в последнем заключается в том, что клиенты могут перенаправляться на разные серверы. Клиент, подключенный к одному серверу, не будет принимать сообщения, отправленные с другого сервера.

Эти проблемы можно решить с помощью компонента, называемого *объединительной платой*, для пересылки сообщений между серверами. После включения объединительной платы каждый экземпляр приложения отправляет сообщения в объединительную плату, а Объединительная плата перенаправляет их в другие экземпляры приложения.

В настоящее время существует три типа объединительных плат для SignalR:

- **Служебная шина Windows Azure**. Служебная шина — это инфраструктура обмена сообщениями, позволяющая компонентам обмениваться слабо связанными сообщениями.
- **SQL Server.** SQL Serverная Объединительная плата записывает сообщения в таблицы SQL. Объединительная плата использует Service Broker для эффективного обмена сообщениями. Однако он также работает, если Service Broker не включена.
- **Redis**. Redis — это хранилище "ключ — значение" в памяти. Redis поддерживает шаблон публикации/подписки ("Pub/resubscribe") для отправки сообщений.

Каждое сообщение отправляется через шину сообщений. Шина сообщений реализует интерфейс [имессажебус](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.messaging.imessagebus(v=vs.100).aspx) , который предоставляет абстракцию публикации и подписки. Объединительные платы работают, заменяя **имессажебус** по умолчанию на шину, предназначенную для этой объединительной платы.

Каждый экземпляр сервера подключается к объединительной плате через шину. При отправке сообщения он переходит на объединительную плату, а Объединительная плата отправляет его на каждый сервер. Когда сервер получает сообщение от объединительной платы, он сохраняет сообщение в его локальном кэше. Затем сервер доставляет сообщения клиентам из своего локального кэша.

Дополнительные сведения о работе объединительной платы SignalR см. в этой [статье](../performance/scaleout-in-signalr.md).

> [!NOTE]
> Существует несколько сценариев, в которых Объединительная плата может стать узким местом. Ниже приведены некоторые типичные сценарии SignalR.
> 
> - [Широковещательная рассылка сервера](tutorial-server-broadcast-with-signalr.md) (например, биржевая тикер). в этом сценарии хорошо работает Объединительная плата, поскольку сервер управляет скоростью отправки сообщений.
> - [Клиент-клиент](tutorial-getting-started-with-signalr.md) (например, чат). в этом сценарии Объединительная плата может стать узким местом, если количество сообщений масштабируется с учетом количества клиентов; то есть, если скорость передачи сообщений пропорционально увеличению числа клиентов, присоединяемых к нему.
> - [Высокая частота](tutorial-high-frequency-realtime-with-signalr.md) (например, игры в реальном времени). в этом сценарии не рекомендуется использовать объединительную плату.

В этом упражнении вы будете использовать **SQL Server** для распространения сообщений в приложении для **головоломки** . Эти задачи будут выполняться на одном тестовом компьютере, чтобы узнать, как настроить конфигурацию, но для получения полного результата потребуется развернуть приложение SignalR на двух или более серверах. Необходимо также установить SQL Server на одном из серверов или на отдельном выделенном сервере.

![Scale Out с помощью схемы SQL Server](real-time-web-applications-with-signalr/_static/image15.png)

<a id="Ex2Task1"></a>
#### <a name="task-1---understanding-the-scenario"></a>Задача 1. Основные сведения о сценарии

В этой задаче будут запущены 2 экземпляра класса " **головоломка** ", моделирующие несколько экземпляров IIS на локальном компьютере. В этом сценарии при ответе на вопросы Trivia в одном приложении обновление не будет уведомлено на странице статистики второго экземпляра. Такое моделирование напоминает среду, в которой приложение развертывается на нескольких экземплярах и использует подсистему балансировки нагрузки для взаимодействия с ними.

1. Откройте решение **Begin. sln** , расположенное в папке **Source/EX2-скалингаутвиссклсервер/Begin** . После загрузки вы обратите внимание на **Обозреватель сервера** , что решение имеет два проекта с идентичными структурами, но разными именами. Это позволит имитировать выполнение двух экземпляров одного приложения на локальном компьютере.

    ![Начало решения для имитации 2 экземпляров "высоко" головоломка](real-time-web-applications-with-signalr/_static/image16.png "Начало решения для имитации 2 экземпляров "высоко" головоломка")

    *Начало решения для имитации 2 экземпляров "высоко" головоломка*
2. Откройте страницу свойств решения, щелкнув правой кнопкой мыши узел решения и выбрав пункт **Свойства**. В разделе **запускаемый проект**выберите **Несколько запускаемых проектов** и измените значение параметра **действие** для обоих проектов на *Запуск*.

    ![Запуск нескольких проектов](real-time-web-applications-with-signalr/_static/image17.png "Запуск нескольких проектов")

    *Запуск нескольких проектов*
3. Чтобы запустить решение, нажмите клавишу **F5**. Приложение запустит два экземпляра класса "высокообъектный **тест** " на разных портах, имитируя несколько экземпляров одного приложения. Закрепите один из браузеров слева, а другой — справа от экрана. Выполните вход с использованием учетных данных или Зарегистрируйте нового пользователя. После входа в систему откройте страницу Trivia слева и перейдите на страницу **Статистика** в браузере справа.

    ![Параллельный контрольный опрос](real-time-web-applications-with-signalr/_static/image18.png)

    *Параллельный контрольный опрос*

    ![Головоломка в разных портах](real-time-web-applications-with-signalr/_static/image19.png)

    *Головоломка в разных портах*
4. Начните отвечать на вопросы в браузере слева, и вы увидите, что страница **статистики** в правильном браузере не обновляется. Это обусловлено тем, что **SignalR** использует локальный кэш для распределения сообщений между клиентами, и этот сценарий имитирует несколько экземпляров, поэтому кэш не используется совместно. Можно проверить работоспособность **SignalR** , проверив те же действия, но используя одно приложение. В следующих задачах будет настроена Объединительная плата для репликации сообщений между экземплярами.
5. Вернитесь в Visual Studio и завершите отладку.

<a id="Ex2Task2"></a>
#### <a name="task-2--creating-the-sql-server-backplane"></a>Задача 2. Создание объединительной платы SQL Server

В этой задаче вы создадите базу данных, которая будет использоваться в качестве объединительной платы для приложения для **головоломки** . Для просмотра сервера и инициализации базы данных будет использоваться **Обозреватель объектов SQL Server** . Кроме того, будет включен **Service Broker**.

1. В **Visual Studio**откройте **представление** меню и выберите **Обозреватель объектов SQL Server**.
2. Подключитесь к экземпляру LocalDB, щелкнув правой кнопкой мыши узел **SQL Server** и выбрав пункт **Добавить SQL Server...** .

    ![Добавление SQL Server экземпляра](real-time-web-applications-with-signalr/_static/image20.png "Добавление SQL Server экземпляра")

    *Добавление SQL Server экземпляра в обозреватель объектов SQL Server*
3. Задайте **имя сервера** *(LocalDB) \V11.0* и оставьте **проверку подлинности Windows** в качестве режима проверки подлинности. Чтобы продолжить, щелкните **Подключить** .

    ![Подключение к LocalDB](real-time-web-applications-with-signalr/_static/image21.png "Подключение к LocalDB")

    *Подключение к LocalDB*
4. Теперь, когда вы подключены к экземпляру LocalDB, необходимо создать базу данных, которая будет представлять SQL Serverную объединительную плату для SignalR. Для этого щелкните правой кнопкой мыши узел **базы данных** и выберите команду **Добавить новую базу данных**.

    ![Добавление новой базы данных](real-time-web-applications-with-signalr/_static/image22.png "Добавление новой базы данных")

    *Добавление новой базы данных*
5. Задайте для базы данных имя *SignalR* и нажмите кнопку **ОК** , чтобы создать его.

    ![Создание базы данных SignalR](real-time-web-applications-with-signalr/_static/image23.png "Создание базы данных SignalR")

    *Создание базы данных SignalR*

    > [!NOTE]
    > Можно выбрать любое имя для базы данных.
6. Для более эффективного получения обновлений от объединительной платы рекомендуется включить Service Broker для базы данных. Service Broker обеспечивает собственную поддержку обмена сообщениями и очередей в SQL Server. Задняя панель также работает без Service Broker. Откройте новый запрос, щелкнув правой кнопкой мыши базу данных и выбрав пункт **создать запрос**.

    ![Открытие нового запроса](real-time-web-applications-with-signalr/_static/image24.png "Открытие нового запроса")

    *Открытие нового запроса*
7. Чтобы проверить, включена ли Service Broker, запросите столбец **\_Broker\_включен** в представлении каталога **sys. databases** . Выполните следующий скрипт в недавно открытом окне запроса.

    [!code-sql[Main](real-time-web-applications-with-signalr/samples/sample11.sql)]

    ![Запрос состояния Service Broker](real-time-web-applications-with-signalr/_static/image25.png "Запрос состояния Service Broker")

    *Запрос состояния Service Broker*
8. Если значение столбца **\_broker\_Enabled** в базе данных равно &quot;0&quot;, используйте следующую команду, чтобы включить ее. Замените **&lt;&gt;базы данных** именем, заданным при создании базы данных (например, SignalR).

    [!code-sql[Main](real-time-web-applications-with-signalr/samples/sample12.sql)]

    ![Включение Service Broker](real-time-web-applications-with-signalr/_static/image26.png "Включение компонента Service Broker")

    *Включение Service Broker*

    > [!NOTE]
    > Если этот запрос выглядит как взаимоблокировка, убедитесь, что к базе данных не подключено ни одного приложения.

<a id="Ex2Task3"></a>
#### <a name="task-3--configuring-the-signalr-application"></a>Задача 3. Настройка приложения SignalR

В этой задаче вы настроите свой высокодоступный **тест** для подключения к объединительной плате SQL Server. Сначала необходимо добавить пакет NuGet **SignalR. SqlServer** и задать строку подключения для базы данных объединительной платы.

1. Откройте **консоль диспетчера пакетов** из **меню Инструменты** > **Диспетчер пакетов NuGet**. Убедитесь, что в раскрывающемся списке **проект по умолчанию** выбран проект **жееккуиз** . Введите следующую команду, чтобы установить пакет NuGet **Microsoft. AspNet. SignalR. SqlServer** .

    [!code-powershell[Main](real-time-web-applications-with-signalr/samples/sample13.ps1)]
2. Повторите предыдущий шаг, но на этот раз для проекта **GeekQuiz2**.
3. Чтобы настроить SQL Serverную объединительную плату, откройте файл **Startup.CS** проекта **жееккуиз** и добавьте следующий код в метод **Configure** . Замените **&lt;&gt;базы** данных именем базы данных, которое использовалось при создании SQL Server объединительной платы. Повторите этот шаг для проекта **GeekQuiz2** .

    (Фрагмент кода — *реалтимесигналр-EX2-стартупконфигуратион*)

    [!code-csharp[Main](real-time-web-applications-with-signalr/samples/sample14.cs)]
4. Теперь, когда оба проекта настроены для использования объединительной платы SQL Server, нажмите клавишу **F5** , чтобы запустить их одновременно.
5. Опять же, Visual Studio запустит два экземпляра класса « **визуальный** **опрос** » на разных портах. Закрепите один из браузеров слева, а другой — справа от экрана и войдите с помощью своих учетных данных. Не задерживайте страницу Trivia слева и перейдите к странице **статистики** в правильном браузере.
6. Начните отвечать на вопросы в браузере слева. На этот раз страница **статистики** обновляется благодаря объединительной плате. Переключайтесь между приложениями (**Статистика** отображается слева, а **Trivia** — справа) и повторите проверку, чтобы убедиться, что она работает для обоих экземпляров. Задняя панель выступает в качестве *общего кэша* сообщений для каждого подключенного сервера, и каждый сервер хранит сообщения в собственном локальном кэше для распространения подключенным клиентам.
7. Вернитесь в Visual Studio и завершите отладку.
8. Компонент объединительной платы SQL Server автоматически создает необходимые таблицы в указанной базе данных. На панели **Обозреватель объектов SQL Server** откройте базу данных, созданную для объединительной платы (например, SignalR), и разверните ее таблицы. Должны отобразиться следующие таблицы:

    ![Таблицы, созданные в объединительной плате](real-time-web-applications-with-signalr/_static/image27.png)

    *Таблицы, созданные в объединительной плате*
9. Щелкните правой кнопкой мыши элемент **SignalR. messages\_0** Table и выберите **Просмотреть данные**.

    ![Просмотр таблицы сообщений о объединительной плате SignalR](real-time-web-applications-with-signalr/_static/image28.png)

    *Просмотр таблицы сообщений о объединительной плате SignalR*
10. При ответе на вопросы Trivia можно увидеть различные сообщения, отправляемые в **центр** . Объединительная плата распространяет эти сообщения на любой подключенный экземпляр.

    ![Таблица сообщений о объединительной плате](real-time-web-applications-with-signalr/_static/image29.png)

    *Таблица сообщений о объединительной плате*

---

<a id="Summary"></a>
## <a name="summary"></a>Сводка

В этой практической лабораторной работе вы узнали, как добавить **SignalR** в приложение и отправлять уведомления с сервера на подключенные клиенты с помощью **концентраторов**. Кроме того, вы узнали, как масштабировать приложение с помощью компонента *объединительной платы* при развертывании приложения в нескольких ЭКЗЕМПЛЯРАХ служб IIS.
