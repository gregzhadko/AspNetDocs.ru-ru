---
uid: signalr/overview/getting-started/introduction-to-signalr
title: Общие сведения о SignalR | Документация Майкрософт
author: bradygaster
description: В этой статье описывается, что такое SignalR и какие решения он создавал.
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: 0fab5e35-8c1f-43d4-8635-b8aba8766a71
msc.legacyurl: /signalr/overview/getting-started/introduction-to-signalr
msc.type: authoredcontent
ms.openlocfilehash: 11b494b4839c646b018098c76a8a9ae0a2169757
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2019
ms.locfileid: "74600492"
---
# <a name="introduction-to-signalr"></a>Введение в SignalR

по [Патрик Флетчера](https://github.com/pfletcher)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этой статье описывается, что такое SignalR и какие решения он создавал. 
> 
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
> 
> Оставьте отзыв о том, как вы понравится вам в этом учебнике, и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, не связанные непосредственно с этим руководством, их можно опубликовать на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](https://stackoverflow.com/questions/tagged/signalr).

## <a name="what-is-signalr"></a>Что такое SignalR?

ASP.NET SignalR — это библиотека для разработчиков ASP.NET, которая упрощает процесс добавления веб-функций в режиме реального времени к приложениям. Веб-функции, работающие в режиме реального времени, — это возможность мгновенно отправить содержимое на подключенных клиентах по мере доступности сервера, а не ждать, пока клиент запросит новые данные.

SignalR можно использовать для добавления любых видов веб-функций в режиме реального времени в приложение ASP.NET. Хотя чат часто используется в качестве примера, вы можете сделать многое еще. Каждый раз, когда пользователь обновляет веб-страницу для просмотра новых данных, или на странице реализован [длинный опрос](http://en.wikipedia.org/wiki/Push_technology#Long_polling) для получения новых данных, это является кандидатом на использование SignalR. Примеры включают панели мониторинга и приложения мониторинга, совместные приложения (например, одновременное редактирование документов), обновления хода выполнения заданий и формы в реальном времени.

SignalR также обеспечивает совершенно новые типы веб-приложений, требующих высокой частоты обновления с сервера, например для игр в режиме реального времени.

SignalR предоставляет простой API для создания удаленных вызовов процедур (RPC) "сервер-клиент", которые вызывают функции JavaScript в клиентских браузерах (и других клиентских платформах) из кода .NET на стороне сервера. SignalR также включает API для управления подключениями (например, события подключения и отключения) и группирования соединений.

![Вызов методов с помощью SignalR](introduction-to-signalr/_static/image1.png)

SignalR обрабатывает управление подключениями автоматически и позволяет рассылать сообщения на все подключенные клиенты одновременно, например в комнату чата. Можно также отправить сообщения конкретным клиентам. Соединение между клиентом и сервером сохраняется, в отличие от классической HTTP-подключения, которое устанавливается заново для каждого обмена данными.

SignalR поддерживает функцию принудительной отправки с сервера, в которой серверный код может вызывать клиентский код в браузере с помощью удаленных вызовов процедур (RPC), а не модели «запрос-ответ», которая обычно используется в Интернете.

Приложения SignalR могут масштабироваться на тысячи клиентов с помощью служебной шины, SQL Server или [Redis](http://redis.io).

SignalR — открытый исходный код, доступный через [GitHub](https://github.com/signalr).

## <a name="signalr-and-websocket"></a>SignalR и WebSocket

SignalR использует новый транспорт WebSocket, когда он доступен, и возвращается к более старым транспортам там, где это необходимо. Хотя вы, безусловно, можете написать свое приложение напрямую с помощью WebSocket, использование SignalR означает, что многие дополнительные функции, которые необходимо реализовать, уже выполнены. Что важнее всего, это означает, что вы можете создать код приложения, чтобы воспользоваться преимуществами WebSocket, не заботясь о создании отдельного пути кода для старых клиентов. SignalR также потребует от вас беспокоиться об обновлениях WebSocket, так как SignalR обновляется для поддержки изменений в базовом транспорте, предоставляя приложению согласованный интерфейс в разных версиях WebSocket.

<a id="transports"></a>

## <a name="transports-and-fallbacks"></a>Транспорты и резервные варианты

SignalR является абстракцией для некоторых транспортов, необходимых для работы в режиме реального времени между клиентом и сервером. Подключение SignalR запускается как HTTP, а затем повышается до подключения WebSocket, если оно доступно. WebSocket — это идеальный транспорт для SignalR, так как он обеспечивает наиболее эффективное использование памяти сервера, имеет наименьшую задержку и обладает самыми основными функциями (например, полным дуплексным обменом данными между клиентом и сервером), но обладает самым строгим требования. для WebSocket требуется, чтобы сервер использовал Windows Server 2012 или Windows 8, а также .NET Framework 4,5. Если эти требования не выполняются, то SignalR попытается использовать другие транспорты для создания подключений.

### <a name="html-5-transports"></a>Транспорты HTML 5

Эти транспорты зависят от поддержки [HTML 5](http://en.wikipedia.org/wiki/HTML5). Если клиентский браузер не поддерживает стандарт HTML 5, будут использоваться старые транспорты.

- **WebSocket** (если как сервер, так и браузер указывают, что они могут поддерживать WebSocket). WebSocket — это единственный транспорт, который устанавливает истинное, двустороннее подключение между клиентом и сервером. Однако WebSocket также имеет самые строгие требования. Она полностью поддерживается только в последних версиях Microsoft Internet Explorer, Google Chrome и Mozilla Firefox и только частично реализована в других браузерах, таких как Opera и Safari.
- **Сервер отправляет события**, также известные как EventSource (если браузер поддерживает события, отправленные сервером, которые по сути являются всеми обозревателями, кроме Internet Explorer).

### <a name="comet-transports"></a>Транспорты Comet

Следующие транспорты основаны на модели веб-приложения [Comet](http://en.wikipedia.org/wiki/Comet_(programming)) , в которой браузер или другой клиент поддерживает ДЛИТЕЛЬный HTTP-запрос, который сервер может использовать для отправки данных клиенту без специального запроса клиента.

- **Непрерывная рамка** (только для Internet Explorer). Бесконечное кадры создает скрытый IFrame, который выполняет запрос к конечной точке на сервере, который не завершен. Затем сервер постоянно отправляет скрипт клиенту, который сразу же выполняется, предоставляя однонаправленное подключение к серверу в режиме реального времени от сервера к клиенту. Соединение между клиентом и сервером использует отдельное соединение между сервером и клиентским соединением, как и стандартный HTTP-запрос, для каждого фрагмента данных, который необходимо отправить, создается новое соединение.
- **Длинный опрос Ajax**. Длительный опрос не создает постоянное подключение, а вместо этого опрашивает сервер с помощью запроса, который остается открытым, пока сервер не ответит, после чего соединение закрывается и сразу же запрашивается новое соединение. Это может привести к задержке при сбросе соединения.

Дополнительные сведения о поддержке транспортов при настройке см. в разделе [Поддерживаемые платформы](supported-platforms.md).

### <a name="transport-selection-process"></a>Процесс выбора транспорта

В следующем списке показаны действия, которые использует SignalR для выбора используемого транспорта.

1. Если браузер Internet Explorer 8 или более ранней версии, используется длинный опрос.
2. Если настроено JSONP (то есть параметр `jsonp` имеет значение `true` при запуске соединения), используется длинный опрос.
3. Если выполняется междоменное подключение (то есть если конечная точка SignalR не находится в том же домене, что и страница размещения), то при соблюдении следующих условий будет использоваться WebSocket.

   - Клиент поддерживает CORS (совместное использование ресурсов между источниками). Дополнительные сведения о том, какие клиенты поддерживают CORS, см. [в разделе CORS по адресу caniuse.com](http://www.caniuse.com/CORS).
   - Клиент поддерживает WebSocket
   - Сервер поддерживает WebSocket

     Если какое бы то ни было условие не выполнено, будет использоваться длинный опрос. Дополнительные сведения о междоменных соединениях см. в разделе [как установить междоменное подключение](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain).
4. Если JSONP не настроен и соединение не является междоменным, будет использоваться WebSocket, если клиент и сервер его поддерживают.
5. Если клиент или сервер не поддерживают WebSocket, то используются события отправки сервера, если они доступны.
6. Если события отправки сервера недоступны, предпринимается неограниченная рамка.
7. Если непостоянное выполнение кадра завершается сбоем, используется длинный опрос.

<a id="MonitoringTransports"></a>
### <a name="monitoring-transports"></a>Мониторинг транспорта

Вы можете определить, какой транспорт использует приложение, включив ведение журнала в центре и открыв окно консоли в браузере.

Чтобы включить ведение журнала для событий концентратора в браузере, добавьте следующую команду в клиентское приложение:

`$.connection.hub.logging = true;`

- В Internet Explorer откройте Инструменты разработчика, нажав клавишу F12, и перейдите на вкладку консоль.

    ![Консоль в Microsoft Internet Explorer](introduction-to-signalr/_static/image2.png)
- В Chrome откройте консоль, нажав клавиши Ctrl + Shift + J.

    ![Консоль в Google Chrome](introduction-to-signalr/_static/image3.png)

После открытия консоли и включения ведения журнала вы сможете увидеть, какой транспорт используется SignalR.

![Консоль в Internet Explorer с отображением протокола WebSocket](introduction-to-signalr/_static/image4.png)

### <a name="specifying-a-transport"></a>Указание транспорта

Согласование транспорта занимает определенное время и ресурсы клиента и сервера. Если известны возможности клиента, можно указать транспорт при запуске клиентского соединения. В следующем фрагменте кода показано, как запустить соединение с помощью транспортного транспорта AJAX с длинным опросом, как было бы использовано, если известно, что клиент не поддерживал какой-либо другой протокол:

`connection.start({ transport: 'longPolling' });`

Можно указать резервный порядок, если требуется, чтобы клиент попробно протестировать определенные транспорты по порядку. В следующем фрагменте кода демонстрируется попытка выполнить WebSocket и отработка отказа, которая сразу же проходит к длительному опросу.

`connection.start({ transport: ['webSockets','longPolling'] });`

Строковые константы для указания транспортов определяются следующим образом:

- `webSockets`
- `foreverFrame`
- `serverSentEvents`
- `longPolling`

## <a name="connections-and-hubs"></a>Подключения и концентраторы

API SignalR содержит две модели взаимодействия между клиентами и серверами: постоянные подключения и концентраторы.

Соединение представляет собой простую конечную точку для отправки сообщений одного получателя, сгруппированных или широковещательных. API постоянного подключения (представленный в коде .NET классом Персистентконнектион) предоставляет разработчику прямой доступ к протоколу обмена данными низкого уровня, предоставляемому SignalR. Использование модели взаимодействия подключений будет знакомо разработчикам, использующим API-интерфейсы на основе подключений, например Windows Communication Foundation.

Концентратор — это высокоуровневый конвейер, построенный на основе API подключения, который позволяет клиенту и серверу вызывать методы напрямую. SignalR обрабатывает расходящиеся между компьютерами границы, как если бы они были различными волшебями, позволяя клиентам вызывать методы на сервере так же легко, как локальные методы, и наоборот. Использование модели взаимодействия центров будет знакомо разработчикам, которые использовали API удаленного вызова, такие как удаленное взаимодействие .NET. Использование концентратора также позволяет передавать методам строго типизированные параметры, включая привязку модели.

### <a name="architecture-diagram"></a>Схема архитектуры

На следующей схеме показана связь между концентраторами, постоянными подключениями и базовыми технологиями, используемыми для транспортов.

![Схема архитектуры SignalR, показывающая интерфейсы API, транспорт и клиенты](introduction-to-signalr/_static/image5.png)

### <a name="how-hubs-work"></a>Как работают концентраторы

Когда код на стороне сервера вызывает метод на клиенте, пакет отправляется через активный транспорт, содержащий имя и параметры вызываемого метода (когда объект отправляется в качестве параметра метода, он сериализуется с помощью JSON). Затем клиент сопоставляет имя метода с методами, определенными в коде на стороне клиента. При наличии совпадения клиентский метод будет выполнен с использованием десериализованных данных параметра.

Для отслеживания вызова метода можно использовать такие средства [, как Fiddler.](http://fiddler2.com/) На следующем рисунке показан вызов метода, отправленный с сервера SignalR в клиент веб-браузера на панели журналы в Fiddler. Вызов метода отправляется из центра с именем `MoveShapeHub`, а вызываемый метод называется `updateShape`.

![Представление журнала Fiddler, показывающего трафик SignalR](introduction-to-signalr/_static/image6.png)

В этом примере имя концентратора определяется с помощью параметра `H`. имя метода определяется с помощью параметра `M`, а отправляемые в метод данные идентифицируются с помощью параметра `A`. Приложение, создавшее это сообщение, создается в руководстве с [высокой частотой в реальном времени](tutorial-high-frequency-realtime-with-signalr.md) .

### <a name="choosing-a-communication-model"></a>Выбор модели связи

Большинство приложений должны использовать API концентраторов. API подключений можно использовать в следующих случаях.

- Необходимо указать формат фактического отправленного сообщения.
- Разработчик предпочитает работать с системой обмена сообщениями и моделью диспетчеризации, а не с помощью удаленной модели вызова.
- Существующее приложение, использующее модель обмена сообщениями, переносится на использование SignalR.
