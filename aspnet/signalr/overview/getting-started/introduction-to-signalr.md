---
uid: signalr/overview/getting-started/introduction-to-signalr
title: Общие сведения о SignalR | Документация Майкрософт
author: bradygaster
description: В этой статье описывается, что такое SignalR и какие решения он создавал.
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: 0fab5e35-8c1f-43d4-8635-b8aba8766a71
msc.legacyurl: /signalr/overview/getting-started/introduction-to-signalr
msc.type: authoredcontent
ms.openlocfilehash: 11b494b4839c646b018098c76a8a9ae0a2169757
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2019
ms.locfileid: "74600492"
---
# <a name="introduction-to-signalr"></a><span data-ttu-id="ef9ae-103">Введение в SignalR</span><span class="sxs-lookup"><span data-stu-id="ef9ae-103">Introduction to SignalR</span></span>

<span data-ttu-id="ef9ae-104">по [Патрик Флетчера](https://github.com/pfletcher)</span><span class="sxs-lookup"><span data-stu-id="ef9ae-104">by [Patrick Fletcher](https://github.com/pfletcher)</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="ef9ae-105">В этой статье описывается, что такое SignalR и какие решения он создавал.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-105">This article describes what SignalR is, and some of the solutions it was designed to create.</span></span> 
> 
> ## <a name="questions-and-comments"></a><span data-ttu-id="ef9ae-106">Вопросы и комментарии</span><span class="sxs-lookup"><span data-stu-id="ef9ae-106">Questions and comments</span></span>
> 
> <span data-ttu-id="ef9ae-107">Оставьте отзыв о том, как вы понравится вам в этом учебнике, и что можно улучшить в комментариях в нижней части страницы.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-107">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="ef9ae-108">Если у вас есть вопросы, не связанные непосредственно с этим руководством, их можно опубликовать на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](https://stackoverflow.com/questions/tagged/signalr).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-108">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](https://stackoverflow.com/questions/tagged/signalr).</span></span>

## <a name="what-is-signalr"></a><span data-ttu-id="ef9ae-109">Что такое SignalR?</span><span class="sxs-lookup"><span data-stu-id="ef9ae-109">What is SignalR?</span></span>

<span data-ttu-id="ef9ae-110">ASP.NET SignalR — это библиотека для разработчиков ASP.NET, которая упрощает процесс добавления веб-функций в режиме реального времени к приложениям.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-110">ASP.NET SignalR is a library for ASP.NET developers that simplifies the process of adding real-time web functionality to applications.</span></span> <span data-ttu-id="ef9ae-111">Веб-функции, работающие в режиме реального времени, — это возможность мгновенно отправить содержимое на подключенных клиентах по мере доступности сервера, а не ждать, пока клиент запросит новые данные.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-111">Real-time web functionality is the ability to have server code push content to connected clients instantly as it becomes available, rather than having the server wait for a client to request new data.</span></span>

<span data-ttu-id="ef9ae-112">SignalR можно использовать для добавления любых видов веб-функций в режиме реального времени в приложение ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-112">SignalR can be used to add any sort of "real-time" web functionality to your ASP.NET application.</span></span> <span data-ttu-id="ef9ae-113">Хотя чат часто используется в качестве примера, вы можете сделать многое еще.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-113">While chat is often used as an example, you can do a whole lot more.</span></span> <span data-ttu-id="ef9ae-114">Каждый раз, когда пользователь обновляет веб-страницу для просмотра новых данных, или на странице реализован [длинный опрос](http://en.wikipedia.org/wiki/Push_technology#Long_polling) для получения новых данных, это является кандидатом на использование SignalR.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-114">Any time a user refreshes a web page to see new data, or the page implements [long polling](http://en.wikipedia.org/wiki/Push_technology#Long_polling) to retrieve new data, it is a candidate for using SignalR.</span></span> <span data-ttu-id="ef9ae-115">Примеры включают панели мониторинга и приложения мониторинга, совместные приложения (например, одновременное редактирование документов), обновления хода выполнения заданий и формы в реальном времени.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-115">Examples include dashboards and monitoring applications, collaborative applications (such as simultaneous editing of documents), job progress updates, and real-time forms.</span></span>

<span data-ttu-id="ef9ae-116">SignalR также обеспечивает совершенно новые типы веб-приложений, требующих высокой частоты обновления с сервера, например для игр в режиме реального времени.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-116">SignalR also enables completely new types of web applications that require high frequency updates from the server, for example, real-time gaming.</span></span>

<span data-ttu-id="ef9ae-117">SignalR предоставляет простой API для создания удаленных вызовов процедур (RPC) "сервер-клиент", которые вызывают функции JavaScript в клиентских браузерах (и других клиентских платформах) из кода .NET на стороне сервера.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-117">SignalR provides a simple API for creating server-to-client remote procedure calls (RPC) that call JavaScript functions in client browsers (and other client platforms) from server-side .NET code.</span></span> <span data-ttu-id="ef9ae-118">SignalR также включает API для управления подключениями (например, события подключения и отключения) и группирования соединений.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-118">SignalR also includes API for connection management (for instance, connect and disconnect events), and grouping connections.</span></span>

![Вызов методов с помощью SignalR](introduction-to-signalr/_static/image1.png)

<span data-ttu-id="ef9ae-120">SignalR обрабатывает управление подключениями автоматически и позволяет рассылать сообщения на все подключенные клиенты одновременно, например в комнату чата.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-120">SignalR handles connection management automatically, and lets you broadcast messages to all connected clients simultaneously, like a chat room.</span></span> <span data-ttu-id="ef9ae-121">Можно также отправить сообщения конкретным клиентам.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-121">You can also send messages to specific clients.</span></span> <span data-ttu-id="ef9ae-122">Соединение между клиентом и сервером сохраняется, в отличие от классической HTTP-подключения, которое устанавливается заново для каждого обмена данными.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-122">The connection between the client and server is persistent, unlike a classic HTTP connection, which is re-established for each communication.</span></span>

<span data-ttu-id="ef9ae-123">SignalR поддерживает функцию принудительной отправки с сервера, в которой серверный код может вызывать клиентский код в браузере с помощью удаленных вызовов процедур (RPC), а не модели «запрос-ответ», которая обычно используется в Интернете.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-123">SignalR supports "server push" functionality, in which server code can call out to client code in the browser using Remote Procedure Calls (RPC), rather than the request-response model common on the web today.</span></span>

<span data-ttu-id="ef9ae-124">Приложения SignalR могут масштабироваться на тысячи клиентов с помощью служебной шины, SQL Server или [Redis](http://redis.io).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-124">SignalR applications can scale out to thousands of clients using Service Bus, SQL Server or [Redis](http://redis.io).</span></span>

<span data-ttu-id="ef9ae-125">SignalR — открытый исходный код, доступный через [GitHub](https://github.com/signalr).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-125">SignalR is open-source, accessible through [GitHub](https://github.com/signalr).</span></span>

## <a name="signalr-and-websocket"></a><span data-ttu-id="ef9ae-126">SignalR и WebSocket</span><span class="sxs-lookup"><span data-stu-id="ef9ae-126">SignalR and WebSocket</span></span>

<span data-ttu-id="ef9ae-127">SignalR использует новый транспорт WebSocket, когда он доступен, и возвращается к более старым транспортам там, где это необходимо.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-127">SignalR uses the new WebSocket transport where available and falls back to older transports where necessary.</span></span> <span data-ttu-id="ef9ae-128">Хотя вы, безусловно, можете написать свое приложение напрямую с помощью WebSocket, использование SignalR означает, что многие дополнительные функции, которые необходимо реализовать, уже выполнены.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-128">While you could certainly write your app using WebSocket directly, using SignalR means that a lot of the extra functionality you would need to implement is already done for you.</span></span> <span data-ttu-id="ef9ae-129">Что важнее всего, это означает, что вы можете создать код приложения, чтобы воспользоваться преимуществами WebSocket, не заботясь о создании отдельного пути кода для старых клиентов.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-129">Most importantly, this means that you can code your app to take advantage of WebSocket without having to worry about creating a separate code path for older clients.</span></span> <span data-ttu-id="ef9ae-130">SignalR также потребует от вас беспокоиться об обновлениях WebSocket, так как SignalR обновляется для поддержки изменений в базовом транспорте, предоставляя приложению согласованный интерфейс в разных версиях WebSocket.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-130">SignalR also shields you from having to worry about updates to WebSocket, since SignalR is updated to support changes in the underlying transport, providing your application a consistent interface across versions of WebSocket.</span></span>

<a id="transports"></a>

## <a name="transports-and-fallbacks"></a><span data-ttu-id="ef9ae-131">Транспорты и резервные варианты</span><span class="sxs-lookup"><span data-stu-id="ef9ae-131">Transports and fallbacks</span></span>

<span data-ttu-id="ef9ae-132">SignalR является абстракцией для некоторых транспортов, необходимых для работы в режиме реального времени между клиентом и сервером.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-132">SignalR is an abstraction over some of the transports that are required to do real-time work between client and server.</span></span> <span data-ttu-id="ef9ae-133">Подключение SignalR запускается как HTTP, а затем повышается до подключения WebSocket, если оно доступно.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-133">A SignalR connection starts as HTTP, and is then promoted to a WebSocket connection if it is available.</span></span> <span data-ttu-id="ef9ae-134">WebSocket — это идеальный транспорт для SignalR, так как он обеспечивает наиболее эффективное использование памяти сервера, имеет наименьшую задержку и обладает самыми основными функциями (например, полным дуплексным обменом данными между клиентом и сервером), но обладает самым строгим требования. для WebSocket требуется, чтобы сервер использовал Windows Server 2012 или Windows 8, а также .NET Framework 4,5.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-134">WebSocket is the ideal transport for SignalR, since it makes the most efficient use of server memory, has the lowest latency, and has the most underlying features (such as full duplex communication between client and server), but it also has the most stringent requirements: WebSocket requires the server to be using Windows Server 2012 or Windows 8, and .NET Framework 4.5.</span></span> <span data-ttu-id="ef9ae-135">Если эти требования не выполняются, то SignalR попытается использовать другие транспорты для создания подключений.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-135">If these requirements are not met, SignalR will attempt to use other transports to make its connections.</span></span>

### <a name="html-5-transports"></a><span data-ttu-id="ef9ae-136">Транспорты HTML 5</span><span class="sxs-lookup"><span data-stu-id="ef9ae-136">HTML 5 transports</span></span>

<span data-ttu-id="ef9ae-137">Эти транспорты зависят от поддержки [HTML 5](http://en.wikipedia.org/wiki/HTML5).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-137">These transports depend on support for [HTML 5](http://en.wikipedia.org/wiki/HTML5).</span></span> <span data-ttu-id="ef9ae-138">Если клиентский браузер не поддерживает стандарт HTML 5, будут использоваться старые транспорты.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-138">If the client browser does not support the HTML 5 standard, older transports will be used.</span></span>

- <span data-ttu-id="ef9ae-139">**WebSocket** (если как сервер, так и браузер указывают, что они могут поддерживать WebSocket).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-139">**WebSocket** (if both the server and browser indicate they can support Websocket).</span></span> <span data-ttu-id="ef9ae-140">WebSocket — это единственный транспорт, который устанавливает истинное, двустороннее подключение между клиентом и сервером.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-140">WebSocket is the only transport that establishes a true persistent, two-way connection between client and server.</span></span> <span data-ttu-id="ef9ae-141">Однако WebSocket также имеет самые строгие требования. Она полностью поддерживается только в последних версиях Microsoft Internet Explorer, Google Chrome и Mozilla Firefox и только частично реализована в других браузерах, таких как Opera и Safari.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-141">However, WebSocket also has the most stringent requirements; it is fully supported only in the latest versions of Microsoft Internet Explorer, Google Chrome, and Mozilla Firefox, and only has a partial implementation in other browsers such as Opera and Safari.</span></span>
- <span data-ttu-id="ef9ae-142">**Сервер отправляет события**, также известные как EventSource (если браузер поддерживает события, отправленные сервером, которые по сути являются всеми обозревателями, кроме Internet Explorer).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-142">**Server Sent Events**, also known as EventSource (if the browser supports Server Sent Events, which is basically all browsers except Internet Explorer.)</span></span>

### <a name="comet-transports"></a><span data-ttu-id="ef9ae-143">Транспорты Comet</span><span class="sxs-lookup"><span data-stu-id="ef9ae-143">Comet transports</span></span>

<span data-ttu-id="ef9ae-144">Следующие транспорты основаны на модели веб-приложения [Comet](http://en.wikipedia.org/wiki/Comet_(programming)) , в которой браузер или другой клиент поддерживает ДЛИТЕЛЬный HTTP-запрос, который сервер может использовать для отправки данных клиенту без специального запроса клиента.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-144">The following transports are based on the [Comet](http://en.wikipedia.org/wiki/Comet_(programming)) web application model, in which a browser or other client maintains a long-held HTTP request, which the server can use to push data to the client without the client specifically requesting it.</span></span>

- <span data-ttu-id="ef9ae-145">**Непрерывная рамка** (только для Internet Explorer).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-145">**Forever Frame** (for Internet Explorer only).</span></span> <span data-ttu-id="ef9ae-146">Бесконечное кадры создает скрытый IFrame, который выполняет запрос к конечной точке на сервере, который не завершен.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-146">Forever Frame creates a hidden IFrame which makes a request to an endpoint on the server that does not complete.</span></span> <span data-ttu-id="ef9ae-147">Затем сервер постоянно отправляет скрипт клиенту, который сразу же выполняется, предоставляя однонаправленное подключение к серверу в режиме реального времени от сервера к клиенту.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-147">The server then continually sends script to the client which is immediately executed, providing a one-way realtime connection from server to client.</span></span> <span data-ttu-id="ef9ae-148">Соединение между клиентом и сервером использует отдельное соединение между сервером и клиентским соединением, как и стандартный HTTP-запрос, для каждого фрагмента данных, который необходимо отправить, создается новое соединение.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-148">The connection from client to server uses a separate connection from the server to client connection, and like a standard HTTP request, a new connection is created for each piece of data that needs to be sent.</span></span>
- <span data-ttu-id="ef9ae-149">**Длинный опрос Ajax**.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-149">**Ajax long polling**.</span></span> <span data-ttu-id="ef9ae-150">Длительный опрос не создает постоянное подключение, а вместо этого опрашивает сервер с помощью запроса, который остается открытым, пока сервер не ответит, после чего соединение закрывается и сразу же запрашивается новое соединение.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-150">Long polling does not create a persistent connection, but instead polls the server with a request that stays open until the server responds, at which point the connection closes, and a new connection is requested immediately.</span></span> <span data-ttu-id="ef9ae-151">Это может привести к задержке при сбросе соединения.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-151">This may introduce some latency while the connection resets.</span></span>

<span data-ttu-id="ef9ae-152">Дополнительные сведения о поддержке транспортов при настройке см. в разделе [Поддерживаемые платформы](supported-platforms.md).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-152">For more information on what transports are supported under which configurations, see [Supported Platforms](supported-platforms.md).</span></span>

### <a name="transport-selection-process"></a><span data-ttu-id="ef9ae-153">Процесс выбора транспорта</span><span class="sxs-lookup"><span data-stu-id="ef9ae-153">Transport selection process</span></span>

<span data-ttu-id="ef9ae-154">В следующем списке показаны действия, которые использует SignalR для выбора используемого транспорта.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-154">The following list shows the steps that SignalR uses to decide which transport to use.</span></span>

1. <span data-ttu-id="ef9ae-155">Если браузер Internet Explorer 8 или более ранней версии, используется длинный опрос.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-155">If the browser is Internet Explorer 8 or earlier, Long Polling is used.</span></span>
2. <span data-ttu-id="ef9ae-156">Если настроено JSONP (то есть параметр `jsonp` имеет значение `true` при запуске соединения), используется длинный опрос.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-156">If JSONP is configured (that is, the `jsonp` parameter is set to `true` when the connection is started), Long Polling is used.</span></span>
3. <span data-ttu-id="ef9ae-157">Если выполняется междоменное подключение (то есть если конечная точка SignalR не находится в том же домене, что и страница размещения), то при соблюдении следующих условий будет использоваться WebSocket.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-157">If a cross-domain connection is being made (that is, if the SignalR endpoint is not in the same domain as the hosting page), then WebSocket will be used if the following criteria are met:</span></span>

   - <span data-ttu-id="ef9ae-158">Клиент поддерживает CORS (совместное использование ресурсов между источниками).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-158">The client supports CORS (Cross-Origin Resource Sharing).</span></span> <span data-ttu-id="ef9ae-159">Дополнительные сведения о том, какие клиенты поддерживают CORS, см. [в разделе CORS по адресу caniuse.com](http://www.caniuse.com/CORS).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-159">For details on which clients support CORS, see [CORS at caniuse.com](http://www.caniuse.com/CORS).</span></span>
   - <span data-ttu-id="ef9ae-160">Клиент поддерживает WebSocket</span><span class="sxs-lookup"><span data-stu-id="ef9ae-160">The client supports WebSocket</span></span>
   - <span data-ttu-id="ef9ae-161">Сервер поддерживает WebSocket</span><span class="sxs-lookup"><span data-stu-id="ef9ae-161">The server supports WebSocket</span></span>

     <span data-ttu-id="ef9ae-162">Если какое бы то ни было условие не выполнено, будет использоваться длинный опрос.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-162">If any of these criteria are not met, Long Polling will be used.</span></span> <span data-ttu-id="ef9ae-163">Дополнительные сведения о междоменных соединениях см. в разделе [как установить междоменное подключение](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-163">For more information on cross-domain connections, see [How to establish a cross-domain connection](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain).</span></span>
4. <span data-ttu-id="ef9ae-164">Если JSONP не настроен и соединение не является междоменным, будет использоваться WebSocket, если клиент и сервер его поддерживают.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-164">If JSONP is not configured and the connection is not cross-domain, WebSocket will be used if both the client and server support it.</span></span>
5. <span data-ttu-id="ef9ae-165">Если клиент или сервер не поддерживают WebSocket, то используются события отправки сервера, если они доступны.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-165">If either the client or server do not support WebSocket, Server Sent Events is used if it is available.</span></span>
6. <span data-ttu-id="ef9ae-166">Если события отправки сервера недоступны, предпринимается неограниченная рамка.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-166">If Server Sent Events is not available, Forever Frame is attempted.</span></span>
7. <span data-ttu-id="ef9ae-167">Если непостоянное выполнение кадра завершается сбоем, используется длинный опрос.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-167">If Forever Frame fails, Long Polling is used.</span></span>

<a id="MonitoringTransports"></a>
### <a name="monitoring-transports"></a><span data-ttu-id="ef9ae-168">Мониторинг транспорта</span><span class="sxs-lookup"><span data-stu-id="ef9ae-168">Monitoring transports</span></span>

<span data-ttu-id="ef9ae-169">Вы можете определить, какой транспорт использует приложение, включив ведение журнала в центре и открыв окно консоли в браузере.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-169">You can determine what transport your application is using by enabling logging on your hub, and opening the console window in your browser.</span></span>

<span data-ttu-id="ef9ae-170">Чтобы включить ведение журнала для событий концентратора в браузере, добавьте следующую команду в клиентское приложение:</span><span class="sxs-lookup"><span data-stu-id="ef9ae-170">To enable logging for your hub's events in a browser, add the following command to your client application:</span></span>

`$.connection.hub.logging = true;`

- <span data-ttu-id="ef9ae-171">В Internet Explorer откройте Инструменты разработчика, нажав клавишу F12, и перейдите на вкладку консоль.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-171">In Internet Explorer, open the developer tools by pressing F12, and click the Console tab.</span></span>

    ![Консоль в Microsoft Internet Explorer](introduction-to-signalr/_static/image2.png)
- <span data-ttu-id="ef9ae-173">В Chrome откройте консоль, нажав клавиши Ctrl + Shift + J.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-173">In Chrome, open the console by pressing Ctrl+Shift+J.</span></span>

    ![Консоль в Google Chrome](introduction-to-signalr/_static/image3.png)

<span data-ttu-id="ef9ae-175">После открытия консоли и включения ведения журнала вы сможете увидеть, какой транспорт используется SignalR.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-175">With the console open and logging enabled, you'll be able to see which transport is being used by SignalR.</span></span>

![Консоль в Internet Explorer с отображением протокола WebSocket](introduction-to-signalr/_static/image4.png)

### <a name="specifying-a-transport"></a><span data-ttu-id="ef9ae-177">Указание транспорта</span><span class="sxs-lookup"><span data-stu-id="ef9ae-177">Specifying a transport</span></span>

<span data-ttu-id="ef9ae-178">Согласование транспорта занимает определенное время и ресурсы клиента и сервера.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-178">Negotiating a transport takes a certain amount of time and client/server resources.</span></span> <span data-ttu-id="ef9ae-179">Если известны возможности клиента, можно указать транспорт при запуске клиентского соединения.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-179">If the client capabilities are known, then a transport can be specified when the client connection is started.</span></span> <span data-ttu-id="ef9ae-180">В следующем фрагменте кода показано, как запустить соединение с помощью транспортного транспорта AJAX с длинным опросом, как было бы использовано, если известно, что клиент не поддерживал какой-либо другой протокол:</span><span class="sxs-lookup"><span data-stu-id="ef9ae-180">The following code snippet demonstrates starting a connection using the Ajax Long Polling transport, as would be used if it was known that the client did not support any other protocol:</span></span>

`connection.start({ transport: 'longPolling' });`

<span data-ttu-id="ef9ae-181">Можно указать резервный порядок, если требуется, чтобы клиент попробно протестировать определенные транспорты по порядку.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-181">You can specify a fallback order if you want a client to try specific transports in order.</span></span> <span data-ttu-id="ef9ae-182">В следующем фрагменте кода демонстрируется попытка выполнить WebSocket и отработка отказа, которая сразу же проходит к длительному опросу.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-182">The following code snippet demonstrates trying WebSocket, and failing that, going directly to Long Polling.</span></span>

`connection.start({ transport: ['webSockets','longPolling'] });`

<span data-ttu-id="ef9ae-183">Строковые константы для указания транспортов определяются следующим образом:</span><span class="sxs-lookup"><span data-stu-id="ef9ae-183">The string constants for specifying transports are defined as follows:</span></span>

- `webSockets`
- `foreverFrame`
- `serverSentEvents`
- `longPolling`

## <a name="connections-and-hubs"></a><span data-ttu-id="ef9ae-184">Подключения и концентраторы</span><span class="sxs-lookup"><span data-stu-id="ef9ae-184">Connections and Hubs</span></span>

<span data-ttu-id="ef9ae-185">API SignalR содержит две модели взаимодействия между клиентами и серверами: постоянные подключения и концентраторы.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-185">The SignalR API contains two models for communicating between clients and servers: Persistent Connections and Hubs.</span></span>

<span data-ttu-id="ef9ae-186">Соединение представляет собой простую конечную точку для отправки сообщений одного получателя, сгруппированных или широковещательных.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-186">A Connection represents a simple endpoint for sending single-recipient, grouped, or broadcast messages.</span></span> <span data-ttu-id="ef9ae-187">API постоянного подключения (представленный в коде .NET классом Персистентконнектион) предоставляет разработчику прямой доступ к протоколу обмена данными низкого уровня, предоставляемому SignalR.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-187">The Persistent Connection API (represented in .NET code by the PersistentConnection class) gives the developer direct access to the low-level communication protocol that SignalR exposes.</span></span> <span data-ttu-id="ef9ae-188">Использование модели взаимодействия подключений будет знакомо разработчикам, использующим API-интерфейсы на основе подключений, например Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-188">Using the Connections communication model will be familiar to developers who have used connection-based APIs such as Windows Communication Foundation.</span></span>

<span data-ttu-id="ef9ae-189">Концентратор — это высокоуровневый конвейер, построенный на основе API подключения, который позволяет клиенту и серверу вызывать методы напрямую.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-189">A Hub is a more high-level pipeline built upon the Connection API that allows your client and server to call methods on each other directly.</span></span> <span data-ttu-id="ef9ae-190">SignalR обрабатывает расходящиеся между компьютерами границы, как если бы они были различными волшебями, позволяя клиентам вызывать методы на сервере так же легко, как локальные методы, и наоборот.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-190">SignalR handles the dispatching across machine boundaries as if by magic, allowing clients to call methods on the server as easily as local methods, and vice versa.</span></span> <span data-ttu-id="ef9ae-191">Использование модели взаимодействия центров будет знакомо разработчикам, которые использовали API удаленного вызова, такие как удаленное взаимодействие .NET.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-191">Using the Hubs communication model will be familiar to developers who have used remote invocation APIs such as .NET Remoting.</span></span> <span data-ttu-id="ef9ae-192">Использование концентратора также позволяет передавать методам строго типизированные параметры, включая привязку модели.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-192">Using a Hub also allows you to pass strongly typed parameters to methods, enabling model binding.</span></span>

### <a name="architecture-diagram"></a><span data-ttu-id="ef9ae-193">Схема архитектуры</span><span class="sxs-lookup"><span data-stu-id="ef9ae-193">Architecture diagram</span></span>

<span data-ttu-id="ef9ae-194">На следующей схеме показана связь между концентраторами, постоянными подключениями и базовыми технологиями, используемыми для транспортов.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-194">The following diagram shows the relationship between Hubs, Persistent Connections, and the underlying technologies used for transports.</span></span>

![Схема архитектуры SignalR, показывающая интерфейсы API, транспорт и клиенты](introduction-to-signalr/_static/image5.png)

### <a name="how-hubs-work"></a><span data-ttu-id="ef9ae-196">Как работают концентраторы</span><span class="sxs-lookup"><span data-stu-id="ef9ae-196">How Hubs work</span></span>

<span data-ttu-id="ef9ae-197">Когда код на стороне сервера вызывает метод на клиенте, пакет отправляется через активный транспорт, содержащий имя и параметры вызываемого метода (когда объект отправляется в качестве параметра метода, он сериализуется с помощью JSON).</span><span class="sxs-lookup"><span data-stu-id="ef9ae-197">When server-side code calls a method on the client, a packet is sent across the active transport that contains the name and parameters of the method to be called (when an object is sent as a method parameter, it is serialized using JSON).</span></span> <span data-ttu-id="ef9ae-198">Затем клиент сопоставляет имя метода с методами, определенными в коде на стороне клиента.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-198">The client then matches the method name to methods defined in client-side code.</span></span> <span data-ttu-id="ef9ae-199">При наличии совпадения клиентский метод будет выполнен с использованием десериализованных данных параметра.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-199">If there is a match, the client method will be executed using the deserialized parameter data.</span></span>

<span data-ttu-id="ef9ae-200">Для отслеживания вызова метода можно использовать такие средства [, как Fiddler.](http://fiddler2.com/)</span><span class="sxs-lookup"><span data-stu-id="ef9ae-200">The method call can be monitored using tools like [Fiddler.](http://fiddler2.com/)</span></span> <span data-ttu-id="ef9ae-201">На следующем рисунке показан вызов метода, отправленный с сервера SignalR в клиент веб-браузера на панели журналы в Fiddler.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-201">The following image shows a method call sent from a SignalR server to a web browser client in the Logs pane of Fiddler.</span></span> <span data-ttu-id="ef9ae-202">Вызов метода отправляется из центра с именем `MoveShapeHub`, а вызываемый метод называется `updateShape`.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-202">The method call is being sent from a hub called `MoveShapeHub`, and the method being invoked is called `updateShape`.</span></span>

![Представление журнала Fiddler, показывающего трафик SignalR](introduction-to-signalr/_static/image6.png)

<span data-ttu-id="ef9ae-204">В этом примере имя концентратора определяется с помощью параметра `H`. имя метода определяется с помощью параметра `M`, а отправляемые в метод данные идентифицируются с помощью параметра `A`.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-204">In this example, the hub name is identified with the `H` parameter; the method name is identified with the `M` parameter, and the data being sent to the method is identified with the `A` parameter.</span></span> <span data-ttu-id="ef9ae-205">Приложение, создавшее это сообщение, создается в руководстве с [высокой частотой в реальном времени](tutorial-high-frequency-realtime-with-signalr.md) .</span><span class="sxs-lookup"><span data-stu-id="ef9ae-205">The application that generated this message is created in the [High-Frequency Realtime](tutorial-high-frequency-realtime-with-signalr.md) tutorial.</span></span>

### <a name="choosing-a-communication-model"></a><span data-ttu-id="ef9ae-206">Выбор модели связи</span><span class="sxs-lookup"><span data-stu-id="ef9ae-206">Choosing a communication model</span></span>

<span data-ttu-id="ef9ae-207">Большинство приложений должны использовать API концентраторов.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-207">Most applications should use the Hubs API.</span></span> <span data-ttu-id="ef9ae-208">API подключений можно использовать в следующих случаях.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-208">The Connections API could be used in the following circumstances:</span></span>

- <span data-ttu-id="ef9ae-209">Необходимо указать формат фактического отправленного сообщения.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-209">The format of the actual message sent needs to be specified.</span></span>
- <span data-ttu-id="ef9ae-210">Разработчик предпочитает работать с системой обмена сообщениями и моделью диспетчеризации, а не с помощью удаленной модели вызова.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-210">The developer prefers to work with a messaging and dispatching model rather than a remote invocation model.</span></span>
- <span data-ttu-id="ef9ae-211">Существующее приложение, использующее модель обмена сообщениями, переносится на использование SignalR.</span><span class="sxs-lookup"><span data-stu-id="ef9ae-211">An existing application that uses a messaging model is being ported to use SignalR.</span></span>
