---
uid: signalr/overview/getting-started/introduction-to-signalr
title: Введение в SignalR Документы Майкрософт
author: bradygaster
description: В этой статье описывается, что такое SignalR, и некоторые из решений, которые он был разработан для создания.
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: 0fab5e35-8c1f-43d4-8635-b8aba8766a71
msc.legacyurl: /signalr/overview/getting-started/introduction-to-signalr
msc.type: authoredcontent
ms.openlocfilehash: 8dbc31a5c8d59fa55dc5b513c1a51d24d18a685f
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675943"
---
# <a name="introduction-to-signalr"></a><span data-ttu-id="3f59b-103">Введение в SignalR</span><span class="sxs-lookup"><span data-stu-id="3f59b-103">Introduction to SignalR</span></span>

<span data-ttu-id="3f59b-104">[Патрик Флетчер](https://github.com/pfletcher)</span><span class="sxs-lookup"><span data-stu-id="3f59b-104">by [Patrick Fletcher](https://github.com/pfletcher)</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="3f59b-105">В этой статье описывается, что такое SignalR, и некоторые из решений, которые он был разработан для создания.</span><span class="sxs-lookup"><span data-stu-id="3f59b-105">This article describes what SignalR is, and some of the solutions it was designed to create.</span></span> 
> 
> ## <a name="questions-and-comments"></a><span data-ttu-id="3f59b-106">Вопросы и комментарии</span><span class="sxs-lookup"><span data-stu-id="3f59b-106">Questions and comments</span></span>
> 
> <span data-ttu-id="3f59b-107">Пожалуйста, оставьте обратную связь о том, как вам понравился этот учебник и что мы могли бы улучшить в комментариях в нижней части страницы.</span><span class="sxs-lookup"><span data-stu-id="3f59b-107">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="3f59b-108">Если у вас есть вопросы, которые не имеют прямого отношения к учебнику, вы можете разместить их на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com.](https://stackoverflow.com/questions/tagged/signalr)</span><span class="sxs-lookup"><span data-stu-id="3f59b-108">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](https://stackoverflow.com/questions/tagged/signalr).</span></span>

## <a name="what-is-signalr"></a><span data-ttu-id="3f59b-109">Что такое SignalR?</span><span class="sxs-lookup"><span data-stu-id="3f59b-109">What is SignalR?</span></span>

<span data-ttu-id="3f59b-110">ASP.NET SignalR — это библиотека для разработчиков ASP.NET, которая упрощает процесс добавления веб-функций в реальном времени в приложения.</span><span class="sxs-lookup"><span data-stu-id="3f59b-110">ASP.NET SignalR is a library for ASP.NET developers that simplifies the process of adding real-time web functionality to applications.</span></span> <span data-ttu-id="3f59b-111">Веб-функция в реальном времени — это возможность мгновенного нажатия содержимого серверного кода на подключенных клиентов, а не ожидание клиента новых данных.</span><span class="sxs-lookup"><span data-stu-id="3f59b-111">Real-time web functionality is the ability to have server code push content to connected clients instantly as it becomes available, rather than having the server wait for a client to request new data.</span></span>

<span data-ttu-id="3f59b-112">SignalR может быть использован для добавления любых веб-функций в режиме реального времени в ASP.NET приложение.</span><span class="sxs-lookup"><span data-stu-id="3f59b-112">SignalR can be used to add any sort of "real-time" web functionality to your ASP.NET application.</span></span> <span data-ttu-id="3f59b-113">Хотя чат часто используется в качестве примера, вы можете сделать гораздо больше.</span><span class="sxs-lookup"><span data-stu-id="3f59b-113">While chat is often used as an example, you can do a whole lot more.</span></span> <span data-ttu-id="3f59b-114">Каждый раз, когда пользователь обновляет веб-страницу, чтобы увидеть новые данные, или страница реализует [длительный опрос](http://en.wikipedia.org/wiki/Push_technology#Long_polling) для получения новых данных, он является кандидатом для использования SignalR.</span><span class="sxs-lookup"><span data-stu-id="3f59b-114">Any time a user refreshes a web page to see new data, or the page implements [long polling](http://en.wikipedia.org/wiki/Push_technology#Long_polling) to retrieve new data, it is a candidate for using SignalR.</span></span> <span data-ttu-id="3f59b-115">Примеры включают панели мониторинга и приложения для мониторинга, совместные приложения (например, одновременное редактирование документов), обновления хода выполнения работ и формы в режиме реального времени.</span><span class="sxs-lookup"><span data-stu-id="3f59b-115">Examples include dashboards and monitoring applications, collaborative applications (such as simultaneous editing of documents), job progress updates, and real-time forms.</span></span>

<span data-ttu-id="3f59b-116">SignalR также позволяет создавать совершенно новые типы веб-приложений, которые требуют высокочастотных обновлений с сервера, например, игр в режиме реального времени.</span><span class="sxs-lookup"><span data-stu-id="3f59b-116">SignalR also enables completely new types of web applications that require high frequency updates from the server, for example, real-time gaming.</span></span>

<span data-ttu-id="3f59b-117">SignalR предоставляет простой API для создания удаленных вызовов процедуры от сервера к клиенту (RPC), которые вызывают функции JavaScript в клиентских браузерах (и других клиентских платформах) из кода .NET.</span><span class="sxs-lookup"><span data-stu-id="3f59b-117">SignalR provides a simple API for creating server-to-client remote procedure calls (RPC) that call JavaScript functions in client browsers (and other client platforms) from server-side .NET code.</span></span> <span data-ttu-id="3f59b-118">SignalR также включает API для управления подключением (например, для подключения и отключения событий) и группирования соединений.</span><span class="sxs-lookup"><span data-stu-id="3f59b-118">SignalR also includes API for connection management (for instance, connect and disconnect events), and grouping connections.</span></span>

![Ссылаясь на методы с помощью SignalR](introduction-to-signalr/_static/image1.png)

<span data-ttu-id="3f59b-120">SignalR автоматически управляет подключениями и позволяет транслировать сообщения всем подключенным клиентам одновременно, как в комнате чата.</span><span class="sxs-lookup"><span data-stu-id="3f59b-120">SignalR handles connection management automatically, and lets you broadcast messages to all connected clients simultaneously, like a chat room.</span></span> <span data-ttu-id="3f59b-121">Сообщения можно также отправлять отдельным клиентам.</span><span class="sxs-lookup"><span data-stu-id="3f59b-121">You can also send messages to specific clients.</span></span> <span data-ttu-id="3f59b-122">Подключение между клиентом и сервером является постоянным в отличие от классического подключения HTTP, которое устанавливается повторно для каждого сеанса связи.</span><span class="sxs-lookup"><span data-stu-id="3f59b-122">The connection between the client and server is persistent, unlike a classic HTTP connection, which is re-established for each communication.</span></span>

<span data-ttu-id="3f59b-123">SignalR поддерживает функциональность "серверный толчок", в которой серверный код может вызывать клиентский код в браузере с помощью удаленных процедурных вызовов (RPC), а не модели запроса-ответа, распространенной сегодня в Интернете.</span><span class="sxs-lookup"><span data-stu-id="3f59b-123">SignalR supports "server push" functionality, in which server code can call out to client code in the browser using Remote Procedure Calls (RPC), rather than the request-response model common on the web today.</span></span>

<span data-ttu-id="3f59b-124">Приложения SignalR могут масштабироваться для тысяч клиентов с помощью встроенных и сторонних поставщиков масштабов.</span><span class="sxs-lookup"><span data-stu-id="3f59b-124">SignalR applications can scale out to thousands of clients using built-in, and third-party scale-out providers.</span></span>

<span data-ttu-id="3f59b-125">Встроенные поставщики включают в себя:</span><span class="sxs-lookup"><span data-stu-id="3f59b-125">Built-in providers include:</span></span>
* [<span data-ttu-id="3f59b-126">Служебная шина</span><span class="sxs-lookup"><span data-stu-id="3f59b-126">Service Bus</span></span>](https://www.nuget.org/packages/Microsoft.AspNet.SignalR.ServiceBus3)
* [<span data-ttu-id="3f59b-127">SQL Server</span><span class="sxs-lookup"><span data-stu-id="3f59b-127">SQL Server</span></span>](https://www.nuget.org/packages/Microsoft.AspNet.SignalR.SqlServer)
* [<span data-ttu-id="3f59b-128">Redis</span><span class="sxs-lookup"><span data-stu-id="3f59b-128">Redis</span></span>](https://www.nuget.org/packages/Microsoft.AspNet.SignalR.Redis)

<span data-ttu-id="3f59b-129">Сторонние поставщики включают в себя:</span><span class="sxs-lookup"><span data-stu-id="3f59b-129">Third-party providers include:</span></span>
* <span data-ttu-id="3f59b-130">[NCache](https://www.alachisoft.com/ncache/asp-net-core-signalr.html).</span><span class="sxs-lookup"><span data-stu-id="3f59b-130">[NCache](https://www.alachisoft.com/ncache/asp-net-core-signalr.html).</span></span>

<span data-ttu-id="3f59b-131">SignalR с открытым исходным кодом, доступный через [GitHub](https://github.com/signalr).</span><span class="sxs-lookup"><span data-stu-id="3f59b-131">SignalR is open-source, accessible through [GitHub](https://github.com/signalr).</span></span>

## <a name="signalr-and-websocket"></a><span data-ttu-id="3f59b-132">SignalR и WebSocket</span><span class="sxs-lookup"><span data-stu-id="3f59b-132">SignalR and WebSocket</span></span>

<span data-ttu-id="3f59b-133">SignalR использует новый транспорт WebSocket там, где это возможно, и при необходимости возвращается к старым транспортным средствам.</span><span class="sxs-lookup"><span data-stu-id="3f59b-133">SignalR uses the new WebSocket transport where available and falls back to older transports where necessary.</span></span> <span data-ttu-id="3f59b-134">Хотя вы, безусловно, можете написать свое приложение с помощью WebSocket напрямую, использование SignalR означает, что много дополнительных функций, которые вам нужно будет реализовать уже сделано для вас.</span><span class="sxs-lookup"><span data-stu-id="3f59b-134">While you could certainly write your app using WebSocket directly, using SignalR means that a lot of the extra functionality you would need to implement is already done for you.</span></span> <span data-ttu-id="3f59b-135">Самое главное, это означает, что вы можете кодировать приложение, чтобы воспользоваться WebSocket, не беспокоясь о создании отдельного пути кода для пожилых клиентов.</span><span class="sxs-lookup"><span data-stu-id="3f59b-135">Most importantly, this means that you can code your app to take advantage of WebSocket without having to worry about creating a separate code path for older clients.</span></span> <span data-ttu-id="3f59b-136">SignalR также защищает вас от необходимости беспокоиться об обновлениях WebSocket, так как SignalR обновляется для поддержки изменений в базовом транспорте, предоставляя приложению согласованный интерфейс в разных версиях WebSocket.</span><span class="sxs-lookup"><span data-stu-id="3f59b-136">SignalR also shields you from having to worry about updates to WebSocket, since SignalR is updated to support changes in the underlying transport, providing your application a consistent interface across versions of WebSocket.</span></span>

<a id="transports"></a>

## <a name="transports-and-fallbacks"></a><span data-ttu-id="3f59b-137">Транспорт и запасы</span><span class="sxs-lookup"><span data-stu-id="3f59b-137">Transports and fallbacks</span></span>

<span data-ttu-id="3f59b-138">SignalR — это абстракция по сравнению с некоторыми переносами, которые необходимы для работы в режиме реального времени между клиентом и сервером.</span><span class="sxs-lookup"><span data-stu-id="3f59b-138">SignalR is an abstraction over some of the transports that are required to do real-time work between client and server.</span></span> <span data-ttu-id="3f59b-139">Соединение SignalR начинается как HTTP, а затем повышается до подключения WebSocket, если оно доступно.</span><span class="sxs-lookup"><span data-stu-id="3f59b-139">A SignalR connection starts as HTTP, and is then promoted to a WebSocket connection if it is available.</span></span> <span data-ttu-id="3f59b-140">WebSocket является идеальным транспортом для SignalR, так как он делает наиболее эффективное использование памяти сервера, имеет самую низкую задержку, и имеет наиболее основные функции (например, полный дуплекс связи между клиентом и сервером), но он также имеет самые строгие требования: WebSocket требует сервера для использования Windows Server 2012 или Windows 8, и .NET Framework 4.5.</span><span class="sxs-lookup"><span data-stu-id="3f59b-140">WebSocket is the ideal transport for SignalR, since it makes the most efficient use of server memory, has the lowest latency, and has the most underlying features (such as full duplex communication between client and server), but it also has the most stringent requirements: WebSocket requires the server to be using Windows Server 2012 or Windows 8, and .NET Framework 4.5.</span></span> <span data-ttu-id="3f59b-141">Если эти требования не будут выполнены, SignalR попытается использовать другие транспортные перевозки для подключения.</span><span class="sxs-lookup"><span data-stu-id="3f59b-141">If these requirements are not met, SignalR will attempt to use other transports to make its connections.</span></span>

### <a name="html-5-transports"></a><span data-ttu-id="3f59b-142">HTML 5 транспорты</span><span class="sxs-lookup"><span data-stu-id="3f59b-142">HTML 5 transports</span></span>

<span data-ttu-id="3f59b-143">Эти перевозки зависят от поддержки [HTML 5](http://en.wikipedia.org/wiki/HTML5).</span><span class="sxs-lookup"><span data-stu-id="3f59b-143">These transports depend on support for [HTML 5](http://en.wikipedia.org/wiki/HTML5).</span></span> <span data-ttu-id="3f59b-144">Если клиентский браузер не поддерживает стандарт HTML 5, будут использоваться старые транспортные средства.</span><span class="sxs-lookup"><span data-stu-id="3f59b-144">If the client browser does not support the HTML 5 standard, older transports will be used.</span></span>

- <span data-ttu-id="3f59b-145">**WebSocket** (если и сервер, и браузер указывают, что они могут поддерживать Websocket).</span><span class="sxs-lookup"><span data-stu-id="3f59b-145">**WebSocket** (if both the server and browser indicate they can support Websocket).</span></span> <span data-ttu-id="3f59b-146">WebSocket является единственным транспортом, который устанавливает истинную постоянную двусторонню связь между клиентом и сервером.</span><span class="sxs-lookup"><span data-stu-id="3f59b-146">WebSocket is the only transport that establishes a true persistent, two-way connection between client and server.</span></span> <span data-ttu-id="3f59b-147">Тем не менее, WebSocket также имеет самые строгие требования; он полностью поддерживается только в последних версиях Microsoft Internet Explorer, Google Chrome и Mozilla Firefox, и имеет только частичную реализацию в других браузерах, таких как Opera и Safari.</span><span class="sxs-lookup"><span data-stu-id="3f59b-147">However, WebSocket also has the most stringent requirements; it is fully supported only in the latest versions of Microsoft Internet Explorer, Google Chrome, and Mozilla Firefox, and only has a partial implementation in other browsers such as Opera and Safari.</span></span>
- <span data-ttu-id="3f59b-148">**Server Sent Events**, также известный как EventSource (если браузер поддерживает события отправленного сервера, который в основном все браузеры, кроме Internet Explorer.)</span><span class="sxs-lookup"><span data-stu-id="3f59b-148">**Server Sent Events**, also known as EventSource (if the browser supports Server Sent Events, which is basically all browsers except Internet Explorer.)</span></span>

### <a name="comet-transports"></a><span data-ttu-id="3f59b-149">Перевозки кометы</span><span class="sxs-lookup"><span data-stu-id="3f59b-149">Comet transports</span></span>

<span data-ttu-id="3f59b-150">Следующие переносы основаны на модели веб-приложений [Comet,](http://en.wikipedia.org/wiki/Comet_(programming)) в которой браузер или другой клиент поддерживает давний запрос HTTP, который сервер может использовать для передачи данных клиенту без специального запроса клиента.</span><span class="sxs-lookup"><span data-stu-id="3f59b-150">The following transports are based on the [Comet](http://en.wikipedia.org/wiki/Comet_(programming)) web application model, in which a browser or other client maintains a long-held HTTP request, which the server can use to push data to the client without the client specifically requesting it.</span></span>

- <span data-ttu-id="3f59b-151">**Forever Frame** (только для Internet Explorer).</span><span class="sxs-lookup"><span data-stu-id="3f59b-151">**Forever Frame** (for Internet Explorer only).</span></span> <span data-ttu-id="3f59b-152">Forever Frame создает скрытый IFrame, который делает запрос на конечную точку на сервере, который не выполняется.</span><span class="sxs-lookup"><span data-stu-id="3f59b-152">Forever Frame creates a hidden IFrame which makes a request to an endpoint on the server that does not complete.</span></span> <span data-ttu-id="3f59b-153">Затем сервер постоянно отправляет скрипт клиенту, который немедленно выполняется, обеспечивая одностороннее подключение в режиме реального времени от сервера к клиенту.</span><span class="sxs-lookup"><span data-stu-id="3f59b-153">The server then continually sends script to the client which is immediately executed, providing a one-way realtime connection from server to client.</span></span> <span data-ttu-id="3f59b-154">Соединение с клиента на сервер использует отдельное соединение с сервером на клиентское соединение, и, как стандартный запрос HTTP, новое соединение создается для каждой части данных, которые должны быть отправлены.</span><span class="sxs-lookup"><span data-stu-id="3f59b-154">The connection from client to server uses a separate connection from the server to client connection, and like a standard HTTP request, a new connection is created for each piece of data that needs to be sent.</span></span>
- <span data-ttu-id="3f59b-155">**Ajax долго голосования**.</span><span class="sxs-lookup"><span data-stu-id="3f59b-155">**Ajax long polling**.</span></span> <span data-ttu-id="3f59b-156">Длинный опрос не создает постоянное соединение, но вместо этого опрашивает сервер с запросом, который остается открытым до тех пор, пока сервер не ответит, после чего соединение закрывается, и немедленно запрашивается новое соединение.</span><span class="sxs-lookup"><span data-stu-id="3f59b-156">Long polling does not create a persistent connection, but instead polls the server with a request that stays open until the server responds, at which point the connection closes, and a new connection is requested immediately.</span></span> <span data-ttu-id="3f59b-157">Это может привести к некоторой задержке во время сброса соединения.</span><span class="sxs-lookup"><span data-stu-id="3f59b-157">This may introduce some latency while the connection resets.</span></span>

<span data-ttu-id="3f59b-158">Для получения дополнительной информации о том, какие транспортные перевозки поддерживаются под какими конфигурациями, [см.](supported-platforms.md)</span><span class="sxs-lookup"><span data-stu-id="3f59b-158">For more information on what transports are supported under which configurations, see [Supported Platforms](supported-platforms.md).</span></span>

### <a name="transport-selection-process"></a><span data-ttu-id="3f59b-159">Процесс выбора транспорта</span><span class="sxs-lookup"><span data-stu-id="3f59b-159">Transport selection process</span></span>

<span data-ttu-id="3f59b-160">В следующем списке показаны шаги, которые Использует SignalR для принятия решения о том, какой транспорт использовать.</span><span class="sxs-lookup"><span data-stu-id="3f59b-160">The following list shows the steps that SignalR uses to decide which transport to use.</span></span>

1. <span data-ttu-id="3f59b-161">Если браузер Internet Explorer 8 или раньше, используется Long Polling.</span><span class="sxs-lookup"><span data-stu-id="3f59b-161">If the browser is Internet Explorer 8 or earlier, Long Polling is used.</span></span>
2. <span data-ttu-id="3f59b-162">Если Настроен JSONP (т.е. `jsonp` параметр `true` устанавливается при начале соединения), используется Длинный опрос.</span><span class="sxs-lookup"><span data-stu-id="3f59b-162">If JSONP is configured (that is, the `jsonp` parameter is set to `true` when the connection is started), Long Polling is used.</span></span>
3. <span data-ttu-id="3f59b-163">Если делается кросс-доменсоединение (т.е. если конечная точка SignalR не находится в том же домене, что и страница хостинга), то WebSocket будет использоваться, если будут выполнены следующие критерии:</span><span class="sxs-lookup"><span data-stu-id="3f59b-163">If a cross-domain connection is being made (that is, if the SignalR endpoint is not in the same domain as the hosting page), then WebSocket will be used if the following criteria are met:</span></span>

   - <span data-ttu-id="3f59b-164">Клиент поддерживает CORS (совместное использование ресурсов Cross-Origin).</span><span class="sxs-lookup"><span data-stu-id="3f59b-164">The client supports CORS (Cross-Origin Resource Sharing).</span></span> <span data-ttu-id="3f59b-165">Подробную информацию о том, какие клиенты поддерживают CORS, можно узнать [в caniuse.com CORS.](http://www.caniuse.com/CORS)</span><span class="sxs-lookup"><span data-stu-id="3f59b-165">For details on which clients support CORS, see [CORS at caniuse.com](http://www.caniuse.com/CORS).</span></span>
   - <span data-ttu-id="3f59b-166">Клиент поддерживает WebSocket</span><span class="sxs-lookup"><span data-stu-id="3f59b-166">The client supports WebSocket</span></span>
   - <span data-ttu-id="3f59b-167">Сервер поддерживает WebSocket</span><span class="sxs-lookup"><span data-stu-id="3f59b-167">The server supports WebSocket</span></span>

     <span data-ttu-id="3f59b-168">Если какой-либо из этих критериев не будет выполнен, будет использоваться Long Polling.</span><span class="sxs-lookup"><span data-stu-id="3f59b-168">If any of these criteria are not met, Long Polling will be used.</span></span> <span data-ttu-id="3f59b-169">Для получения дополнительной информации о соединениях кросс-домена [см.](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain)</span><span class="sxs-lookup"><span data-stu-id="3f59b-169">For more information on cross-domain connections, see [How to establish a cross-domain connection](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain).</span></span>
4. <span data-ttu-id="3f59b-170">Если JSONP не настроен и соединение не является кросс-доменом, WebSocket будет использоваться, если клиент и сервер поддерживают его.</span><span class="sxs-lookup"><span data-stu-id="3f59b-170">If JSONP is not configured and the connection is not cross-domain, WebSocket will be used if both the client and server support it.</span></span>
5. <span data-ttu-id="3f59b-171">Если клиент или сервер не поддерживают WebSocket, сервер Sent Events используется, если он доступен.</span><span class="sxs-lookup"><span data-stu-id="3f59b-171">If either the client or server do not support WebSocket, Server Sent Events is used if it is available.</span></span>
6. <span data-ttu-id="3f59b-172">Если события отправлены сервера недоступны, попытка Forever Frame будет предпринята.</span><span class="sxs-lookup"><span data-stu-id="3f59b-172">If Server Sent Events is not available, Forever Frame is attempted.</span></span>
7. <span data-ttu-id="3f59b-173">Если Forever Frame выходит из строя, используется длинный опрос.</span><span class="sxs-lookup"><span data-stu-id="3f59b-173">If Forever Frame fails, Long Polling is used.</span></span>

<a id="MonitoringTransports"></a>
### <a name="monitoring-transports"></a><span data-ttu-id="3f59b-174">Мониторинг перевозок</span><span class="sxs-lookup"><span data-stu-id="3f59b-174">Monitoring transports</span></span>

<span data-ttu-id="3f59b-175">Вы можете определить, какой транспорт использует приложение, включив вход в концентратор и открыв окно консоли в браузере.</span><span class="sxs-lookup"><span data-stu-id="3f59b-175">You can determine what transport your application is using by enabling logging on your hub, and opening the console window in your browser.</span></span>

<span data-ttu-id="3f59b-176">Чтобы включить журнал для событий вашего концентратора в браузере, добавьте следующую команду в клиентское приложение:</span><span class="sxs-lookup"><span data-stu-id="3f59b-176">To enable logging for your hub's events in a browser, add the following command to your client application:</span></span>

`$.connection.hub.logging = true;`

- <span data-ttu-id="3f59b-177">В Internet Explorer откройте инструменты разработчика, нажав на F12, и нажмите на вкладку Консоль.</span><span class="sxs-lookup"><span data-stu-id="3f59b-177">In Internet Explorer, open the developer tools by pressing F12, and click the Console tab.</span></span>

    ![Консоль в Microsoft Internet Explorer](introduction-to-signalr/_static/image2.png)
- <span data-ttu-id="3f59b-179">В Chrome откройте консоль, нажав на Ctrl-Shift-J.</span><span class="sxs-lookup"><span data-stu-id="3f59b-179">In Chrome, open the console by pressing Ctrl+Shift+J.</span></span>

    ![Консоль в Google Chrome](introduction-to-signalr/_static/image3.png)

<span data-ttu-id="3f59b-181">С открытым консолью и включенной регистрацией, вы сможете увидеть, какой транспорт используется SignalR.</span><span class="sxs-lookup"><span data-stu-id="3f59b-181">With the console open and logging enabled, you'll be able to see which transport is being used by SignalR.</span></span>

![Консоль в Internet Explorer, показывающая транспорт WebSocket](introduction-to-signalr/_static/image4.png)

### <a name="specifying-a-transport"></a><span data-ttu-id="3f59b-183">Определение транспорта</span><span class="sxs-lookup"><span data-stu-id="3f59b-183">Specifying a transport</span></span>

<span data-ttu-id="3f59b-184">Переговоры о транспортировке занимают определенное количество времени и ресурсов клиента/сервера.</span><span class="sxs-lookup"><span data-stu-id="3f59b-184">Negotiating a transport takes a certain amount of time and client/server resources.</span></span> <span data-ttu-id="3f59b-185">Если возможности клиента известны, то при подключении клиента может быть указан транспорт.</span><span class="sxs-lookup"><span data-stu-id="3f59b-185">If the client capabilities are known, then a transport can be specified when the client connection is started.</span></span> <span data-ttu-id="3f59b-186">Следующий фрагмент кода демонстрирует начало соединения с помощью транспорта Ajax Long Polling, как это было бы использовано, если бы было известно, что клиент не поддерживает какой-либо другой протокол:</span><span class="sxs-lookup"><span data-stu-id="3f59b-186">The following code snippet demonstrates starting a connection using the Ajax Long Polling transport, as would be used if it was known that the client did not support any other protocol:</span></span>

`connection.start({ transport: 'longPolling' });`

<span data-ttu-id="3f59b-187">Вы можете указать запасной заказ, если вы хотите, чтобы клиент попробовал конкретные перевозки в порядке.</span><span class="sxs-lookup"><span data-stu-id="3f59b-187">You can specify a fallback order if you want a client to try specific transports in order.</span></span> <span data-ttu-id="3f59b-188">Следующий фрагмент кода демонстрирует попытку WebSocket, и не в том, что, перейдя непосредственно к Long Polling.</span><span class="sxs-lookup"><span data-stu-id="3f59b-188">The following code snippet demonstrates trying WebSocket, and failing that, going directly to Long Polling.</span></span>

`connection.start({ transport: ['webSockets','longPolling'] });`

<span data-ttu-id="3f59b-189">Константы строки для определения переносов определяются следующим образом:</span><span class="sxs-lookup"><span data-stu-id="3f59b-189">The string constants for specifying transports are defined as follows:</span></span>

- `webSockets`
- `foreverFrame`
- `serverSentEvents`
- `longPolling`

## <a name="connections-and-hubs"></a><span data-ttu-id="3f59b-190">Соединения и концентраторы</span><span class="sxs-lookup"><span data-stu-id="3f59b-190">Connections and Hubs</span></span>

<span data-ttu-id="3f59b-191">API SignalR содержит две модели общения между клиентами и серверами: Постоянные соединения и концентраторы.</span><span class="sxs-lookup"><span data-stu-id="3f59b-191">The SignalR API contains two models for communicating between clients and servers: Persistent Connections and Hubs.</span></span>

<span data-ttu-id="3f59b-192">Соединение представляет собой простую конечную точку для отправки сообщений с одним получателем, сгруппированными или транслируемыми сообщениями.</span><span class="sxs-lookup"><span data-stu-id="3f59b-192">A Connection represents a simple endpoint for sending single-recipient, grouped, or broadcast messages.</span></span> <span data-ttu-id="3f59b-193">API Persistent Connection (представленный в коде .NET классом PersistentConnection) предоставляет разработчику прямой доступ к низкоуровневому протоколу связи, который предоставляет SignalR.</span><span class="sxs-lookup"><span data-stu-id="3f59b-193">The Persistent Connection API (represented in .NET code by the PersistentConnection class) gives the developer direct access to the low-level communication protocol that SignalR exposes.</span></span> <span data-ttu-id="3f59b-194">С помощью коммуникационной модели Connections будет знакома разработчикам, которые использовали AI на основе подключений, такие как Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="3f59b-194">Using the Connections communication model will be familiar to developers who have used connection-based APIs such as Windows Communication Foundation.</span></span>

<span data-ttu-id="3f59b-195">Концентратор — это более высокоуровневый конвейер, построенный на API connection API, который позволяет клиенту и серверу вызывать методы друг на друга напрямую.</span><span class="sxs-lookup"><span data-stu-id="3f59b-195">A Hub is a more high-level pipeline built upon the Connection API that allows your client and server to call methods on each other directly.</span></span> <span data-ttu-id="3f59b-196">SignalR обрабатывает диспетчеризм через границы машины, как по волшебству, позволяя клиентам вызывать методы на сервере так же легко, как локальные методы, и наоборот.</span><span class="sxs-lookup"><span data-stu-id="3f59b-196">SignalR handles the dispatching across machine boundaries as if by magic, allowing clients to call methods on the server as easily as local methods, and vice versa.</span></span> <span data-ttu-id="3f59b-197">С помощью коммуникационной модели Hubs будет знакома разработчикам, которые использовали aI-абоцирования удаленного призыва, такие как .NET Remoting.</span><span class="sxs-lookup"><span data-stu-id="3f59b-197">Using the Hubs communication model will be familiar to developers who have used remote invocation APIs such as .NET Remoting.</span></span> <span data-ttu-id="3f59b-198">Использование концентратора также позволяет передавать сильно набранные параметры методам, что позволяет связывать модель.</span><span class="sxs-lookup"><span data-stu-id="3f59b-198">Using a Hub also allows you to pass strongly typed parameters to methods, enabling model binding.</span></span>

### <a name="architecture-diagram"></a><span data-ttu-id="3f59b-199">Диаграмма архитектуры</span><span class="sxs-lookup"><span data-stu-id="3f59b-199">Architecture diagram</span></span>

<span data-ttu-id="3f59b-200">На следующей диаграмме показана взаимосвязь между концентраторами, постоянными соединениями и базовыми технологиями, используемыми для транспортировки.</span><span class="sxs-lookup"><span data-stu-id="3f59b-200">The following diagram shows the relationship between Hubs, Persistent Connections, and the underlying technologies used for transports.</span></span>

![Диаграмма архитектуры SignalR, показывающая AIS, транспорт ы и клиентов](introduction-to-signalr/_static/image5.png)

### <a name="how-hubs-work"></a><span data-ttu-id="3f59b-202">Как работают концентраторы</span><span class="sxs-lookup"><span data-stu-id="3f59b-202">How Hubs work</span></span>

<span data-ttu-id="3f59b-203">Когда код сервера вызывает метод на клиенте, пакет отправляется через активный транспорт, содержащий имя и параметры вызова метода (когда объект отправляется в качестве параметра метода, он сериализируется с помощью JSON).</span><span class="sxs-lookup"><span data-stu-id="3f59b-203">When server-side code calls a method on the client, a packet is sent across the active transport that contains the name and parameters of the method to be called (when an object is sent as a method parameter, it is serialized using JSON).</span></span> <span data-ttu-id="3f59b-204">Затем клиент сопоставляет имя метода с методами, определенными в коде клиентской стороны.</span><span class="sxs-lookup"><span data-stu-id="3f59b-204">The client then matches the method name to methods defined in client-side code.</span></span> <span data-ttu-id="3f59b-205">При совпадении метод клиента будет выполнен с использованием десериализованных параметров.</span><span class="sxs-lookup"><span data-stu-id="3f59b-205">If there is a match, the client method will be executed using the deserialized parameter data.</span></span>

<span data-ttu-id="3f59b-206">Метод вызова можно контролировать с помощью таких инструментов, как [Fiddler.](http://fiddler2.com/)</span><span class="sxs-lookup"><span data-stu-id="3f59b-206">The method call can be monitored using tools like [Fiddler.](http://fiddler2.com/)</span></span> <span data-ttu-id="3f59b-207">Следующее изображение показывает вызов метода, отправленного с сервера SignalR клиенту веб-браузера в панели журналов Fiddler.</span><span class="sxs-lookup"><span data-stu-id="3f59b-207">The following image shows a method call sent from a SignalR server to a web browser client in the Logs pane of Fiddler.</span></span> <span data-ttu-id="3f59b-208">Вызов метода отправляется из `MoveShapeHub`концентратора, вызываемого, и вызовный метод вызывается. `updateShape`</span><span class="sxs-lookup"><span data-stu-id="3f59b-208">The method call is being sent from a hub called `MoveShapeHub`, and the method being invoked is called `updateShape`.</span></span>

![Вид журнала Fiddler, показывающий трафик SignalR](introduction-to-signalr/_static/image6.png)

<span data-ttu-id="3f59b-210">В этом примере имя концентратора отождествляется с параметром; `H` имя метода идентифицируется с параметром, `M` а данные, `A` отправляемые на метод, идентифицируются с параметром.</span><span class="sxs-lookup"><span data-stu-id="3f59b-210">In this example, the hub name is identified with the `H` parameter; the method name is identified with the `M` parameter, and the data being sent to the method is identified with the `A` parameter.</span></span> <span data-ttu-id="3f59b-211">Приложение, генерирукоторое это сообщение, создается в учебнике [по высокому времени в реальном времени.](tutorial-high-frequency-realtime-with-signalr.md)</span><span class="sxs-lookup"><span data-stu-id="3f59b-211">The application that generated this message is created in the [High-Frequency Realtime](tutorial-high-frequency-realtime-with-signalr.md) tutorial.</span></span>

### <a name="choosing-a-communication-model"></a><span data-ttu-id="3f59b-212">Выбор модели связи</span><span class="sxs-lookup"><span data-stu-id="3f59b-212">Choosing a communication model</span></span>

<span data-ttu-id="3f59b-213">Большинство приложений должны использовать API концентратов.</span><span class="sxs-lookup"><span data-stu-id="3f59b-213">Most applications should use the Hubs API.</span></span> <span data-ttu-id="3f59b-214">API соединений может быть использован при следующих обстоятельствах:</span><span class="sxs-lookup"><span data-stu-id="3f59b-214">The Connections API could be used in the following circumstances:</span></span>

- <span data-ttu-id="3f59b-215">Формат отправки сообщения должен быть уточнен.</span><span class="sxs-lookup"><span data-stu-id="3f59b-215">The format of the actual message sent needs to be specified.</span></span>
- <span data-ttu-id="3f59b-216">Разработчик предпочитает работать с моделью обмена сообщениями и отправки, а не с моделью удаленного вызова.</span><span class="sxs-lookup"><span data-stu-id="3f59b-216">The developer prefers to work with a messaging and dispatching model rather than a remote invocation model.</span></span>
- <span data-ttu-id="3f59b-217">Существующее приложение, используюваееео модель обмена сообщениями, портируется для использования SignalR.</span><span class="sxs-lookup"><span data-stu-id="3f59b-217">An existing application that uses a messaging model is being ported to use SignalR.</span></span>
