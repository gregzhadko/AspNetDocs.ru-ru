---
uid: signalr/overview/getting-started/introduction-to-signalr
title: Введение в SignalR Документы Майкрософт
author: bradygaster
description: В этой статье описывается, что такое SignalR, и некоторые из решений, которые он был разработан для создания.
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: 0fab5e35-8c1f-43d4-8635-b8aba8766a71
msc.legacyurl: /signalr/overview/getting-started/introduction-to-signalr
msc.type: authoredcontent
ms.openlocfilehash: 8dbc31a5c8d59fa55dc5b513c1a51d24d18a685f
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675943"
---
# <a name="introduction-to-signalr"></a>Введение в SignalR

[Патрик Флетчер](https://github.com/pfletcher)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этой статье описывается, что такое SignalR, и некоторые из решений, которые он был разработан для создания. 
> 
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
> 
> Пожалуйста, оставьте обратную связь о том, как вам понравился этот учебник и что мы могли бы улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, которые не имеют прямого отношения к учебнику, вы можете разместить их на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com.](https://stackoverflow.com/questions/tagged/signalr)

## <a name="what-is-signalr"></a>Что такое SignalR?

ASP.NET SignalR — это библиотека для разработчиков ASP.NET, которая упрощает процесс добавления веб-функций в реальном времени в приложения. Веб-функция в реальном времени — это возможность мгновенного нажатия содержимого серверного кода на подключенных клиентов, а не ожидание клиента новых данных.

SignalR может быть использован для добавления любых веб-функций в режиме реального времени в ASP.NET приложение. Хотя чат часто используется в качестве примера, вы можете сделать гораздо больше. Каждый раз, когда пользователь обновляет веб-страницу, чтобы увидеть новые данные, или страница реализует [длительный опрос](http://en.wikipedia.org/wiki/Push_technology#Long_polling) для получения новых данных, он является кандидатом для использования SignalR. Примеры включают панели мониторинга и приложения для мониторинга, совместные приложения (например, одновременное редактирование документов), обновления хода выполнения работ и формы в режиме реального времени.

SignalR также позволяет создавать совершенно новые типы веб-приложений, которые требуют высокочастотных обновлений с сервера, например, игр в режиме реального времени.

SignalR предоставляет простой API для создания удаленных вызовов процедуры от сервера к клиенту (RPC), которые вызывают функции JavaScript в клиентских браузерах (и других клиентских платформах) из кода .NET. SignalR также включает API для управления подключением (например, для подключения и отключения событий) и группирования соединений.

![Ссылаясь на методы с помощью SignalR](introduction-to-signalr/_static/image1.png)

SignalR автоматически управляет подключениями и позволяет транслировать сообщения всем подключенным клиентам одновременно, как в комнате чата. Сообщения можно также отправлять отдельным клиентам. Подключение между клиентом и сервером является постоянным в отличие от классического подключения HTTP, которое устанавливается повторно для каждого сеанса связи.

SignalR поддерживает функциональность "серверный толчок", в которой серверный код может вызывать клиентский код в браузере с помощью удаленных процедурных вызовов (RPC), а не модели запроса-ответа, распространенной сегодня в Интернете.

Приложения SignalR могут масштабироваться для тысяч клиентов с помощью встроенных и сторонних поставщиков масштабов.

Встроенные поставщики включают в себя:
* [Служебная шина](https://www.nuget.org/packages/Microsoft.AspNet.SignalR.ServiceBus3)
* [SQL Server](https://www.nuget.org/packages/Microsoft.AspNet.SignalR.SqlServer)
* [Redis](https://www.nuget.org/packages/Microsoft.AspNet.SignalR.Redis)

Сторонние поставщики включают в себя:
* [NCache](https://www.alachisoft.com/ncache/asp-net-core-signalr.html).

SignalR с открытым исходным кодом, доступный через [GitHub](https://github.com/signalr).

## <a name="signalr-and-websocket"></a>SignalR и WebSocket

SignalR использует новый транспорт WebSocket там, где это возможно, и при необходимости возвращается к старым транспортным средствам. Хотя вы, безусловно, можете написать свое приложение с помощью WebSocket напрямую, использование SignalR означает, что много дополнительных функций, которые вам нужно будет реализовать уже сделано для вас. Самое главное, это означает, что вы можете кодировать приложение, чтобы воспользоваться WebSocket, не беспокоясь о создании отдельного пути кода для пожилых клиентов. SignalR также защищает вас от необходимости беспокоиться об обновлениях WebSocket, так как SignalR обновляется для поддержки изменений в базовом транспорте, предоставляя приложению согласованный интерфейс в разных версиях WebSocket.

<a id="transports"></a>

## <a name="transports-and-fallbacks"></a>Транспорт и запасы

SignalR — это абстракция по сравнению с некоторыми переносами, которые необходимы для работы в режиме реального времени между клиентом и сервером. Соединение SignalR начинается как HTTP, а затем повышается до подключения WebSocket, если оно доступно. WebSocket является идеальным транспортом для SignalR, так как он делает наиболее эффективное использование памяти сервера, имеет самую низкую задержку, и имеет наиболее основные функции (например, полный дуплекс связи между клиентом и сервером), но он также имеет самые строгие требования: WebSocket требует сервера для использования Windows Server 2012 или Windows 8, и .NET Framework 4.5. Если эти требования не будут выполнены, SignalR попытается использовать другие транспортные перевозки для подключения.

### <a name="html-5-transports"></a>HTML 5 транспорты

Эти перевозки зависят от поддержки [HTML 5](http://en.wikipedia.org/wiki/HTML5). Если клиентский браузер не поддерживает стандарт HTML 5, будут использоваться старые транспортные средства.

- **WebSocket** (если и сервер, и браузер указывают, что они могут поддерживать Websocket). WebSocket является единственным транспортом, который устанавливает истинную постоянную двусторонню связь между клиентом и сервером. Тем не менее, WebSocket также имеет самые строгие требования; он полностью поддерживается только в последних версиях Microsoft Internet Explorer, Google Chrome и Mozilla Firefox, и имеет только частичную реализацию в других браузерах, таких как Opera и Safari.
- **Server Sent Events**, также известный как EventSource (если браузер поддерживает события отправленного сервера, который в основном все браузеры, кроме Internet Explorer.)

### <a name="comet-transports"></a>Перевозки кометы

Следующие переносы основаны на модели веб-приложений [Comet,](http://en.wikipedia.org/wiki/Comet_(programming)) в которой браузер или другой клиент поддерживает давний запрос HTTP, который сервер может использовать для передачи данных клиенту без специального запроса клиента.

- **Forever Frame** (только для Internet Explorer). Forever Frame создает скрытый IFrame, который делает запрос на конечную точку на сервере, который не выполняется. Затем сервер постоянно отправляет скрипт клиенту, который немедленно выполняется, обеспечивая одностороннее подключение в режиме реального времени от сервера к клиенту. Соединение с клиента на сервер использует отдельное соединение с сервером на клиентское соединение, и, как стандартный запрос HTTP, новое соединение создается для каждой части данных, которые должны быть отправлены.
- **Ajax долго голосования**. Длинный опрос не создает постоянное соединение, но вместо этого опрашивает сервер с запросом, который остается открытым до тех пор, пока сервер не ответит, после чего соединение закрывается, и немедленно запрашивается новое соединение. Это может привести к некоторой задержке во время сброса соединения.

Для получения дополнительной информации о том, какие транспортные перевозки поддерживаются под какими конфигурациями, [см.](supported-platforms.md)

### <a name="transport-selection-process"></a>Процесс выбора транспорта

В следующем списке показаны шаги, которые Использует SignalR для принятия решения о том, какой транспорт использовать.

1. Если браузер Internet Explorer 8 или раньше, используется Long Polling.
2. Если Настроен JSONP (т.е. `jsonp` параметр `true` устанавливается при начале соединения), используется Длинный опрос.
3. Если делается кросс-доменсоединение (т.е. если конечная точка SignalR не находится в том же домене, что и страница хостинга), то WebSocket будет использоваться, если будут выполнены следующие критерии:

   - Клиент поддерживает CORS (совместное использование ресурсов Cross-Origin). Подробную информацию о том, какие клиенты поддерживают CORS, можно узнать [в caniuse.com CORS.](http://www.caniuse.com/CORS)
   - Клиент поддерживает WebSocket
   - Сервер поддерживает WebSocket

     Если какой-либо из этих критериев не будет выполнен, будет использоваться Long Polling. Для получения дополнительной информации о соединениях кросс-домена [см.](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain)
4. Если JSONP не настроен и соединение не является кросс-доменом, WebSocket будет использоваться, если клиент и сервер поддерживают его.
5. Если клиент или сервер не поддерживают WebSocket, сервер Sent Events используется, если он доступен.
6. Если события отправлены сервера недоступны, попытка Forever Frame будет предпринята.
7. Если Forever Frame выходит из строя, используется длинный опрос.

<a id="MonitoringTransports"></a>
### <a name="monitoring-transports"></a>Мониторинг перевозок

Вы можете определить, какой транспорт использует приложение, включив вход в концентратор и открыв окно консоли в браузере.

Чтобы включить журнал для событий вашего концентратора в браузере, добавьте следующую команду в клиентское приложение:

`$.connection.hub.logging = true;`

- В Internet Explorer откройте инструменты разработчика, нажав на F12, и нажмите на вкладку Консоль.

    ![Консоль в Microsoft Internet Explorer](introduction-to-signalr/_static/image2.png)
- В Chrome откройте консоль, нажав на Ctrl-Shift-J.

    ![Консоль в Google Chrome](introduction-to-signalr/_static/image3.png)

С открытым консолью и включенной регистрацией, вы сможете увидеть, какой транспорт используется SignalR.

![Консоль в Internet Explorer, показывающая транспорт WebSocket](introduction-to-signalr/_static/image4.png)

### <a name="specifying-a-transport"></a>Определение транспорта

Переговоры о транспортировке занимают определенное количество времени и ресурсов клиента/сервера. Если возможности клиента известны, то при подключении клиента может быть указан транспорт. Следующий фрагмент кода демонстрирует начало соединения с помощью транспорта Ajax Long Polling, как это было бы использовано, если бы было известно, что клиент не поддерживает какой-либо другой протокол:

`connection.start({ transport: 'longPolling' });`

Вы можете указать запасной заказ, если вы хотите, чтобы клиент попробовал конкретные перевозки в порядке. Следующий фрагмент кода демонстрирует попытку WebSocket, и не в том, что, перейдя непосредственно к Long Polling.

`connection.start({ transport: ['webSockets','longPolling'] });`

Константы строки для определения переносов определяются следующим образом:

- `webSockets`
- `foreverFrame`
- `serverSentEvents`
- `longPolling`

## <a name="connections-and-hubs"></a>Соединения и концентраторы

API SignalR содержит две модели общения между клиентами и серверами: Постоянные соединения и концентраторы.

Соединение представляет собой простую конечную точку для отправки сообщений с одним получателем, сгруппированными или транслируемыми сообщениями. API Persistent Connection (представленный в коде .NET классом PersistentConnection) предоставляет разработчику прямой доступ к низкоуровневому протоколу связи, который предоставляет SignalR. С помощью коммуникационной модели Connections будет знакома разработчикам, которые использовали AI на основе подключений, такие как Windows Communication Foundation.

Концентратор — это более высокоуровневый конвейер, построенный на API connection API, который позволяет клиенту и серверу вызывать методы друг на друга напрямую. SignalR обрабатывает диспетчеризм через границы машины, как по волшебству, позволяя клиентам вызывать методы на сервере так же легко, как локальные методы, и наоборот. С помощью коммуникационной модели Hubs будет знакома разработчикам, которые использовали aI-абоцирования удаленного призыва, такие как .NET Remoting. Использование концентратора также позволяет передавать сильно набранные параметры методам, что позволяет связывать модель.

### <a name="architecture-diagram"></a>Диаграмма архитектуры

На следующей диаграмме показана взаимосвязь между концентраторами, постоянными соединениями и базовыми технологиями, используемыми для транспортировки.

![Диаграмма архитектуры SignalR, показывающая AIS, транспорт ы и клиентов](introduction-to-signalr/_static/image5.png)

### <a name="how-hubs-work"></a>Как работают концентраторы

Когда код сервера вызывает метод на клиенте, пакет отправляется через активный транспорт, содержащий имя и параметры вызова метода (когда объект отправляется в качестве параметра метода, он сериализируется с помощью JSON). Затем клиент сопоставляет имя метода с методами, определенными в коде клиентской стороны. При совпадении метод клиента будет выполнен с использованием десериализованных параметров.

Метод вызова можно контролировать с помощью таких инструментов, как [Fiddler.](http://fiddler2.com/) Следующее изображение показывает вызов метода, отправленного с сервера SignalR клиенту веб-браузера в панели журналов Fiddler. Вызов метода отправляется из `MoveShapeHub`концентратора, вызываемого, и вызовный метод вызывается. `updateShape`

![Вид журнала Fiddler, показывающий трафик SignalR](introduction-to-signalr/_static/image6.png)

В этом примере имя концентратора отождествляется с параметром; `H` имя метода идентифицируется с параметром, `M` а данные, `A` отправляемые на метод, идентифицируются с параметром. Приложение, генерирукоторое это сообщение, создается в учебнике [по высокому времени в реальном времени.](tutorial-high-frequency-realtime-with-signalr.md)

### <a name="choosing-a-communication-model"></a>Выбор модели связи

Большинство приложений должны использовать API концентратов. API соединений может быть использован при следующих обстоятельствах:

- Формат отправки сообщения должен быть уточнен.
- Разработчик предпочитает работать с моделью обмена сообщениями и отправки, а не с моделью удаленного вызова.
- Существующее приложение, используюваееео модель обмена сообщениями, портируется для использования SignalR.
