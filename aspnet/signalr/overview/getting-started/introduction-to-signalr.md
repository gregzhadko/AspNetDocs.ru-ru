---
uid: signalr/overview/getting-started/introduction-to-signalr
title: Введение в SignalR | Документация Майкрософт
author: bradygaster
description: В этой статье описывается функция SignalR и некоторые решения, для которого она была разработана для создания.
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: 0fab5e35-8c1f-43d4-8635-b8aba8766a71
msc.legacyurl: /signalr/overview/getting-started/introduction-to-signalr
msc.type: authoredcontent
ms.openlocfilehash: 3598ac3d16a2065d1fb76d1637f0ae84797f630c
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/21/2019
ms.locfileid: "65120094"
---
# <a name="introduction-to-signalr"></a>Введение в SignalR

по [Патрик Флетчера](https://github.com/pfletcher)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этой статье описывается функция SignalR и некоторые решения, для которого она была разработана для создания. 
> 
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
> 
> Оставьте свои отзывы на том, как вам понравилось, и этот учебник и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, которые не имеют отношения к руководству, их можно разместить [форум по ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](https://stackoverflow.com/questions/tagged/signalr).

## <a name="what-is-signalr"></a>Что такое SignalR

ASP.NET SignalR — это библиотека для разработчиков ASP.NET, которая упрощает добавление функциональности в режиме реального времени веб-приложений. В режиме реального времени веб-функций является возможность отправки данных код с сервера содержимого для мгновенно предоставлять подключенным клиентам, как она станет доступной, а не ждать, пока клиент запросит новые данные.

SignalR может использоваться для добавления каких-либо «в режиме реального времени» веб-функций в приложение ASP.NET. Хотя чата часто используется в качестве примера, можно сделать гораздо более. Всякий раз, когда пользователь обновляет веб-страницы для просмотра новых данных или страница реализует [долго опрашивающего](http://en.wikipedia.org/wiki/Push_technology#Long_polling) для получения новых данных, он является кандидатом для использования SignalR. Примеры включают информационные панели и мониторинг приложений, приложений для совместной работы (например, одновременное редактирование документов), задания обновления хода выполнения и формы в режиме реального времени.

SignalR также позволяет использовать полностью новые типы веб-приложений, требующих высокой частотой обновления с сервера, например, игры, в режиме реального времени.

SignalR обеспечивает простой API-Интерфейс для создания-клиентом и сервером удаленные вызовы процедур (RPC), которые вызывают функции JavaScript в клиентских браузерах (и других клиентских платформах) из кода .NET на стороне сервера. SignalR также включает API для управления подключениями (например, подключения и события отключения) и группировки подключений.

![Вызов методов с помощью SignalR](introduction-to-signalr/_static/image1.png)

SignalR автоматически выполняет управление соединениями и позволяет широковещательных сообщений для всех подключенных клиентов одновременно, как и в чат. Также можно отправлять сообщения для конкретных клиентов. Соединение между клиентом и сервером является постоянным, в отличие от классического подключения HTTP будет восстановлено, для каждой связи.

SignalR поддерживает функции «принудительной отправки с сервера», в котором серверный код может выполнить вызов клиентского кода в браузере с помощью вызовов удаленных процедур (RPC), а не общие модели запрос ответ в Интернете сегодня.

SignalR приложения можно масштабировать до нескольких тысяч клиентов с помощью служебной шины, SQL Server или [Redis](http://redis.io).

SignalR открытым исходным кодом, доступная с помощью [GitHub](https://github.com/signalr).

## <a name="signalr-and-websocket"></a>SignalR и WebSocket

SignalR использует новый транспорт WebSocket, если они доступны и возвращается к более старой транспортов там, где необходимо. Хотя безусловно можно написать приложение напрямую с помощью WebSocket, SignalR означает, что много дополнительных функциональных возможностей, которые необходимо реализовать уже выполняется автоматически. Самое главное это означает, что позволяет создавать код приложения, чтобы воспользоваться преимуществами WebSocket не нужно беспокоиться о создании пути отдельный код для старых клиентов. SignalR также скрывает от вас не беспокоиться об обновлениях для веб-сокет, поскольку SignalR обновляется для поддержки изменений в транспорта, предоставляя согласованный интерфейс приложения в версиях WebSocket.

<a id="transports"></a>

## <a name="transports-and-fallbacks"></a>Транспорты и в случае ошибки

SignalR — это абстракция над некоторые транспорты, которые необходимы для выполнения работы в режиме реального времени между клиентом и сервером. Подключения SignalR запускается как HTTP и затем повышен до соединения WebSocket, если он доступен. WebSocket является идеальным транспорт для SignalR, так как он обеспечивает наиболее эффективное использование памяти сервера, имеет наименьшую задержку и имеет наиболее базовых компонентов (например, полнодуплексную связь между клиентом и сервером), но она также содержит самые строгие требования требования: WebSocket требуется, чтобы использовать Windows Server 2012 или Windows 8 и .NET Framework 4.5 сервер. Если эти требования не выполнены, SignalR будет пытаться использовать другие транспорты, чтобы сделать его подключения.

### <a name="html-5-transports"></a>Передает HTML 5

Эти транспорты зависит от поддержки для [HTML 5](http://en.wikipedia.org/wiki/HTML5). Если браузер клиента не поддерживает стандарт HTML 5, будет использоваться старые транспортов.

- **WebSocket** (если на сервере и браузер указывают, они могут поддерживать Websocket). WebSocket находится только транспорт, который устанавливает значение true, постоянное и двустороннее подключение между клиентом и сервером. Тем не менее WebSocket также имеет самым строгим требованиям; он полностью поддерживается только в последних версиях Microsoft Internet Explorer, Google Chrome и Mozilla Firefox и имеет только частичную реализацию в других браузерах, таких как Opera и Safari.
- **События отправляются сервера**, которая также называется EventSource (если браузер поддерживает отправленных событий сервера, который представляет собой все браузеры, за исключением Internet Explorer.)

### <a name="comet-transports"></a>Транспорты Comet

На основе следующих транспортов [Comet](http://en.wikipedia.org/wiki/Comet_(programming)) модели веб-приложения, в котором браузер или другой клиент поддерживает запрос HTTP долго удерживается, что сервер может использовать для отправки данных клиенту без использования клиента, в частности запрашивая его.

- **Forever Frame** (для Internet Explorer). Навсегда кадра создает скрытом запросе IFrame, который выполняет запрос к конечной точке на сервере, которая не завершена. Затем сервер постоянно отправляет скрипт для клиента, который выполняется немедленно, предоставляя соединение одностороннего в реальном времени от сервера клиенту. Подключение от клиента к серверу использует отдельное соединение с сервера для клиентского соединения и как стандартного HTTP-запроса, создается новое соединение для каждого фрагмента данных, который требуется отправить.
- **AJAX, длинный опрос**. Продолжительного опроса не создает постоянное подключение, но вместо этого опрашивает сервер вместе с запросом, который остается открытым, пока сервер отвечает, после чего закрывает соединение, и сразу же запрашивается новое соединение. Это может привести к некоторая задержка, хотя сбрасывает соединение.

Дополнительные сведения о какие конфигурации поддерживаются какие транспортов, см. в разделе [поддерживаемые платформы](supported-platforms.md).

### <a name="transport-selection-process"></a>Процесс выбора транспорта

Ниже перечислены действия, которые использует SignalR, чтобы определить, используемый транспорт.

1. Если обозреватель Internet Explorer 8 или более ранней версии, используется длинный опрос.
2. Если настроен JSONP (то есть `jsonp` параметр имеет значение `true` при запуске соединения), используется длинный опрос.
3. Если между доменами устанавливается соединение (то есть если SignalR конечная точка не в том же домене, что и страница размещения), то WebSocket будет использоваться при соблюдении следующих условий:

   - Клиент поддерживает CORS (Cross-Origin общий доступ к ресурсам). Дополнительные сведения, в которых клиенты поддерживают CORS, см. в разделе [CORS на caniuse.com](http://www.caniuse.com/CORS).
   - Клиент поддерживает WebSocket
   - Сервер поддерживает WebSocket

     Если любой из этих условий не выполняются, длинный опрос будет использоваться. Дополнительные сведения о подключениях между доменами, см. в разделе [как для установления соединения между доменами](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain).
4. Если JSONP не настроен, а подключение выполняется не между доменами, WebSocket будет использоваться, если он поддерживается клиентом и сервером.
5. Если клиент или сервер не поддерживают WebSocket, отправленных событий сервера используется в том случае, если он доступен.
6. Если отправленных событий сервера не доступен, выполняется попытка навсегда кадра.
7. В случае сбоя навсегда кадра используется длинный опрос.

<a id="MonitoringTransports"></a>
### <a name="monitoring-transports"></a>Мониторинг транспортов

Можно определить, какой транспорт, приложение использует за счет ведения журнала в концентраторе и открыв окно консоли в браузере.

Чтобы включить ведение журнала для вашего концентратора событий в браузере, добавьте следующую команду в клиентском приложении:

`$.connection.hub.logging = true;`

- Открытие средств разработчика, нажав клавишу F12 в Internet Explorer и перейдите на вкладку консоли.

    ![Консоль в Microsoft Internet Explorer](introduction-to-signalr/_static/image2.png)
- В браузере Chrome откройте консоль, нажав клавиши Ctrl + Shift + J.

    ![Консоль в Google Chrome](introduction-to-signalr/_static/image3.png)

Откройте консоль и ведение журнала включено вы сможете см. в разделе, какой транспорт используется SignalR.

![Консоли в Internet Explorer, показывающий транспорт WebSocket](introduction-to-signalr/_static/image4.png)

### <a name="specifying-a-transport"></a>Указание транспорта

Согласования транспорта занимает определенное время и клиентом и сервером ресурсов. Известны возможности клиента, транспорт можно указать, при запуске клиентского соединения. В следующем фрагменте кода показано, как запускается подключение с помощью транспорта Ajax длинный опрос, как будет использоваться, если она была известна, что клиент не поддерживает любой другой протокол:

`connection.start({ transport: 'longPolling' });`

Можно указать порядок возврата, если вы хотите, чтобы попробовать конкретных транспортов в порядке клиент. В следующем фрагменте кода демонстрируется ознакомлении WebSocket и сбоя, непосредственно на, длинный опрос.

`connection.start({ transport: ['webSockets','longPolling'] });`

Строковые константы для указания транспортов, определяются следующим образом:

- `webSockets`
- `foreverFrame`
- `serverSentEvents`
- `longPolling`

## <a name="connections-and-hubs"></a>Подключениями и концентраторами

SignalR API содержит две модели для обмена данными между клиентами и серверами: Постоянные подключения и концентраторов.

Соединение представляет простой конечную точку для отправки одного получателя, сгруппированных и широковещательных сообщений. Постоянные подключения API, (представленной в коде .NET с помощью класса PersistentConnection) предоставляет, разработчику прямой доступ к протокол связи низкого уровня, предоставляющей SignalR. С помощью модели обмена данными подключения будут знакомы разработчикам, которые использовали API на основе подключения, такие как Windows Communication Foundation.

Концентратор — более высокоуровневые конвейера, построенных на основе подключения API, который позволяет клиентом и сервером, для прямого вызова методов на друг с другом. SignalR обрабатывает доставку разных компьютерах как в результате команды magic, позволяя клиентам вызывать методы на сервере, как легко, как локальные методы и наоборот. С помощью модели связи концентраторы будут вам знакомы разработчикам, которые использовали удаленного вызова API-интерфейсы, такие как удаленное взаимодействие .NET. Используя Центр также дает возможность передачи строго типизированных параметров методов, включение привязки модели.

### <a name="architecture-diagram"></a>Схема архитектуры

Следующей схеме показана связь между концентраторами, постоянные подключения и базовой технологии, используемые для транспортов.

![Схема архитектуры SignalR, показывающая API-интерфейсы, транспорты и клиентов](introduction-to-signalr/_static/image5.png)

### <a name="how-hubs-work"></a>Как работают концентраторов

Когда серверный код вызывает метод на стороне клиента, пакет отправляется в активный транспорт, который содержит имя и параметры метода для вызова (если объект передается как параметр метода, он сериализуется с использованием JSON). Клиент затем совпадает с именем метода к методам, определенным в коде на стороне клиента. Если есть совпадение имени, метод клиента выполняется с помощью параметра десериализованные данные.

Вызов метода можно отслеживать с помощью таких средств, как [Fiddler.](http://fiddler2.com/) На следующем рисунке вызова метода, отправленного с сервера SignalR клиенту веб-браузера в области журналов Fiddler. Вызов метода было отправлено с центр `MoveShapeHub`, и вызове метода, вызываемого `updateShape`.

![Просмотр данных журнала Fiddler трафика SignalR](introduction-to-signalr/_static/image6.png)

В этом примере имя центра идентифицируется с помощью `H` параметра; метод определяется имя `M` отмечаются параметров и данных, отправляемых в метод `A` параметр. Приложения, создавшего это сообщение создается в [реального времени с высокой частотой](tutorial-high-frequency-realtime-with-signalr.md) руководства.

### <a name="choosing-a-communication-model"></a>Выбор модели обмена данными

Большинство приложений должны использовать API концентраторов. Подключения API можно использовать в следующих случаях:

- Формат фактическое сообщение, отправленное необходимо указывать.
- Разработчик предпочитает работать с модели обмена сообщениями и диспетчеризации, а не модель удаленного вызова.
- Для использования SignalR при переносе существующего приложения, использующего модель обмена сообщениями.
