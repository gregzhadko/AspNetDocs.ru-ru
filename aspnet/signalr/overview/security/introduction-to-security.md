---
uid: signalr/overview/security/introduction-to-security
title: Общие сведения о безопасности SignalR | Документация Майкрософт
author: bradygaster
description: Описывает вопросы безопасности, которые необходимо учитывать при разработке приложений с SignalR.
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: ed562717-8591-4936-8e10-c7e63dcb570a
msc.legacyurl: /signalr/overview/security/introduction-to-security
msc.type: authoredcontent
ms.openlocfilehash: 6e96c9a086241b6f3fff40d4a5fb0a3636bfa4b7
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59387332"
---
# <a name="introduction-to-signalr-security"></a>Общие сведения о безопасности SignalR

по [Флетчера Патрик](https://github.com/pfletcher), [Tom FitzMacken](https://github.com/tfitzmac)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этой статье описываются проблемы безопасности, которые необходимо учитывать при разработке приложений с SignalR.
>
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемого в этом разделе
>
>
> - [Visual Studio 2013](https://my.visualstudio.com/Downloads?q=visual%20studio%202013)
> - .NET 4.5
> - SignalR версии 2
>
>
>
> ## <a name="previous-versions-of-this-topic"></a>Предыдущие версии этого раздела
>
> Сведения о более ранних версий SignalR, см. в разделе [более старых версий SignalR](../older-versions/index.md).
>
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
>
> Оставьте свои отзывы на том, как вам понравилось, и этот учебник и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, которые не имеют отношения к руководству, их можно разместить [форум по ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).


## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Основные понятия безопасности SignalR](#concepts)

    - [Проверка подлинности и авторизация](#authentication)
    - [Маркер подключения](#connectiontoken)
    - [Повторное присоединение групп при повторном подключении](#rejoingroup)
- [Как SignalR предотвращает подделки запросов между сайтами](#csrf)
- [Рекомендации по обеспечению безопасности SignalR](#recommendations)

    - [Защищенный протокол слои сокетов (SSL)](#ssl)
    - [Не используйте группы в качестве механизма обеспечения безопасности](#groupsecurity)
    - [Безопасно обработки входных данных от клиентов](#input)
    - [Согласование изменение состояния пользователя с активным соединением](#reconcile)
    - [Автоматически созданные файлы JavaScript прокси-сервера](#autogen)
    - [Исключения](#exceptions)

<a id="concepts"></a>

## <a name="signalr-security-concepts"></a>Основные понятия безопасности SignalR

<a id="authentication"></a>

### <a name="authentication-and-authorization"></a>Аутентификация и авторизация

SignalR не предоставляет какие-либо функции для проверки подлинности пользователей. Вместо этого можно интегрировать в существующую структуру проверки подлинности для приложения функции SignalR. Проверяйте подлинность пользователей как обычно в приложении, а также работы с результатами проверки подлинности в вашей SignalR кода. Например может проверять подлинность пользователей с помощью проверки подлинности форм ASP.NET и в концентраторе, принудительное применение какие пользователи или роли авторизованы для вызова метода. В концентраторе также можно передать данные проверки подлинности, такие как имя пользователя или от того, принадлежит ли пользователь к роли, клиенту.

SignalR обеспечивает [Authorize](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.authorizeattribute(v=vs.111).aspx) атрибут, чтобы указать, какие пользователи имеют доступ к концентратору или метод. Примените атрибут Authorize к концентратору или отдельные методы в концентраторе. Без атрибута Authorize все открытые методы концентратора доступны для клиентов, которые подключены к центру. Дополнительные сведения о концентраторах см. в разделе [проверки подлинности и авторизация для концентраторов SignalR](hub-authorization.md).

Можно применить `Authorize` атрибут концентраторов, но не постоянные подключения. Для принудительного выполнения правил авторизации, при использовании `PersistentConnection` необходимо переопределить `AuthorizeRequest` метод. Дополнительные сведения о постоянных подключений, см. в разделе [проверки подлинности и авторизация для постоянных подключений SignalR](persistent-connection-authorization.md).

<a id="connectiontoken"></a>

### <a name="connection-token"></a>Маркер подключения

SignalR уменьшает риск выполнения вредоносных команд, проверив удостоверение отправителя. Для каждого запроса клиента и сервера передать маркер соединения, который содержит идентификатор подключения и имя пользователя для прошедших проверку пользователей. Идентификатор подключения однозначно определяет каждым подключенным клиентом. Идентификатор подключения случайным образом формирует сервер, если новое соединение создается и сохраняется на время подключения этот идентификатор. Механизм проверки подлинности для веб-приложение предоставляет имя пользователя. SignalR использует шифрования и цифровой подписи для защиты маркер подключения.

![](introduction-to-security/_static/image2.png)

Для каждого запроса сервер проверяет содержимое маркер, чтобы убедиться, что запрос исходит от указанного пользователя. Имя пользователя должно соответствовать идентификатор подключения. Проверив идентификатор подключения и имя пользователя, SignalR не позволяет пользователь-злоумышленник легко олицетворение других пользователей. Если сервер не удается проверить маркер подключения, запрос отклоняется.

![](introduction-to-security/_static/image4.png)

Так как идентификатор подключения является частью процесса проверки, не следует раскрывать один пользователь идентификатор подключения для других пользователей или хранения значения на стороне клиента, например, в файле cookie.

#### <a name="connection-tokens-vs-other-token-types"></a>Маркеры подключения и другие типы маркеров

Маркеры подключения иногда помечаются средствами безопасности, так как они могут быть сеанса маркеры или маркеры проверки подлинности, которые представляет собой риск, если предоставлены.

Маркер подключения SignalR не маркер проверки подлинности. Он используется, чтобы убедиться, что пользователь, выполняющий этот запрос идентичен, установившего соединение. Маркер подключения необходим, так как ASP.NET SignalR разрешает соединения для перемещения между серверами. Маркер связывает соединение с конкретным пользователем, но не подтверждают идентификацию пользователя, выполняющего запрос. Для запроса SignalR пройти надлежащую проверку подлинности он должен иметь некоторые токен, который подтверждает удостоверение пользователя, например, файл cookie или токен носителя. Тем не менее, соединение сам маркер делает нет утверждения, который был сделан запрос этого пользователя, а только то, что идентификатор подключения содержащихся в маркере, связанный с данным пользователем.

Поскольку маркер подключения предоставляет свои собственные нет утверждения для проверки подлинности, он не считается «сеанс» или «проверка подлинности» маркера. Создание подключения пользователя токена и воспроизведение его в запрос, проверку подлинности от имени другого пользователя (или непроверенного запроса) будут неудачны, поскольку не будет соответствовать удостоверение пользователя запроса и удостоверением, хранящимся в маркере.

<a id="rejoingroup"></a>

### <a name="rejoining-groups-when-reconnecting"></a>Повторное присоединение групп при повторном подключении

По умолчанию SignalR приложение будет автоматически повторно назначить пользователю в соответствующие группы при повторном подключении из к временному нарушению работы, например при удалении и заново установить соединение, время ожидания соединения. При повторном подключении, клиент передает маркер группы, который включает в себя идентификатор подключения и назначенные группы. Маркер группы цифровой подписывается и шифруется. Клиентское приложение сохраняет один и тот же идентификатор подключения после повторного подключения; Таким образом идентификатор подключения, переданные от повторного подключения клиента должен соответствовать предыдущий идентификатор соединения, используемый клиентом. Такая проверка предотвращает пользователь-злоумышленник передачи запросы на присоединение к группам несанкционированного, при повторном подключении.

Тем не менее важно отметить, что маркер группы имеет неограниченный срок действия. Если пользователь принадлежал к группе в прошлом, но было заблокировано из этой группы, этот пользователь может быть возможность имитировать маркер группы, который включает запрещенных группы. Если вам нужно безопасно управлять какие пользователи входят в какие группы, необходимо хранить их на сервере, например в базе данных. Затем добавьте логику для приложения, которое проверяет на сервере, принадлежит ли пользователь в группу. Например, проверка членства в группе, см. в разделе [работа с группами](../guide-to-the-api/working-with-groups.md).

Автоматическое повторное присоединение групп применим только для повторного соединения после временному нарушению работы. Если пользователь отключается покидая приложение или повторного запуска приложения, приложения необходимо обрабатывать как добавить этого пользователя в требуемые группы. Дополнительные сведения см. в разделе [работа с группами](../guide-to-the-api/working-with-groups.md).

<a id="csrf"></a>

## <a name="how-signalr-prevents-cross-site-request-forgery"></a>Как SignalR предотвращает подделки запросов между сайтами

Подделки межсайтовых запросов (CSRF) — это атака, при которой вредоносный сайт отправляет запрос на уязвимом сайте, где пользователь вошел в. SignalR предотвращает CSRF, делая крайне маловероятно для вредоносный сайт создать допустимый запрос для вашего приложения SignalR.

### <a name="description-of-csrf-attack"></a>Описание атаки CSRF

Вот пример атаки CSRF:

1. Пользователь входит в www.example.com, с помощью форм проверки подлинности.
2. Сервер проверяет подлинность пользователя. Ответ от сервера включает файл cookie проверки подлинности.
3. Не выходя из пользователь посещает вредоносных веб-сайта. Этот вредоносный сайт содержит следующий HTML-формы:

    [!code-html[Main](introduction-to-security/samples/sample1.html)]

   Обратите внимание, что отправляет уязвимом сайте, не на сайте вредоносных действий формы. Это часть CSRF «cross-site».
4. Пользователь нажимает кнопку «Отправить». Браузер включает в себя файл cookie проверки подлинности с запросом.
5. Этот запрос выполняется на сервере example.com, контекст проверки подлинности пользователя и могут выполнять любые операции, прошедший проверку пользователь может сделать.

Несмотря на то, что в этом примере требует от пользователя, нажмите кнопку «формы», страницу вредоносных может так же, как легко запускать сценарий, который отправляет запрос AJAX в приложение SignalR. Кроме того с помощью протокола SSL не может помешать атаки CSRF, так как вредоносный сайт может отправить запрос « https://».

Как правило атак CSRF — для веб-сайтов, использующих файлы cookie для проверки подлинности, потому что браузеры отправляют все необходимые файлы cookie веб-узлу. Тем не менее атаки CSRF не ограничены использованием файлы cookie. Например Basic и дайджест-проверки подлинности также уязвимы. После входа пользователя в систему с помощью обычной или дайджест-проверки подлинности, браузер автоматически отправляет учетные данные до завершения сеанса.

### <a name="csrf-mitigations-taken-by-signalr"></a>Способы устранения рисков CSRF выполняемое SignalR

SignalR принимает следующие действия, чтобы предотвратить создание допустимых запросов к вашему приложению вредоносный сайт. SignalR состоит из следующих этапов по умолчанию, не нужно предпринимать никаких действий в коде.

- **Отключить междоменные запросы** SignalR отключает междоменные запросы, чтобы запретить пользователям вызов конечной точки SignalR из внешнего домена. SignalR считает, что любой запрос от внешнего домена к недействительности и блокирует запрос. Мы рекомендуем оставить поведение по умолчанию; в противном случае вредоносный сайт может обманом вынудить пользователей отправляет команды на веб-узла. Если вам нужно использовать междоменные запросы, см. в разделе [как для установления соединения между доменами](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain) .
- **Передать маркер подключения в строке запроса, а не файл cookie** SignalR передает маркер подключения как значения строки запроса, а не как файл cookie. Хранение маркер подключения в файле cookie небезопасна, поскольку можно случайно перехода вперед в браузере маркер подключения при обнаружении вредоносного кода. Кроме того передавая маркер подключения в строке запроса позволяет защитить маркер подключения от сохранения за пределами текущего соединения. Таким образом пользователь-злоумышленник не может сделать запрос под учетными данными проверки подлинности другого пользователя.
- **Проверить маркер подключения** как описано в разделе [маркер подключения](#connectiontoken) разделе сервер знает, какой идентификатор соединения связан с каждого проверенного пользователя. Сервер не обрабатывает все запросы из идентификатор соединения, который не совпадает с именем пользователя. Это маловероятно, что пользователь-злоумышленник может узнать допустимый запрос, поскольку ему необходимо знать имя пользователя и идентификатор текущего подключения, созданный случайным образом. Этот идентификатор подключения становится недействительным, сразу же после завершения соединения. Анонимные пользователи не должны доступа к конфиденциальным сведениям.

<a id="recommendations"></a>

## <a name="signalr-security-recommendations"></a>Рекомендации по обеспечению безопасности SignalR

<a id="ssl"></a>

### <a name="secure-socket-layers-ssl-protocol"></a>Защищенный протокол слои сокетов (SSL)

Протокол SSL использует шифрование для защиты передачи данных между клиентом и сервером. Если приложение SignalR передает конфиденциальные данные между клиентом и сервером, используйте SSL для транспорта. Дополнительные сведения о настройке SSL см. в разделе [настройке SSL в службах IIS 7](https://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis).

<a id="groupsecurity"></a>

### <a name="do-not-use-groups-as-a-security-mechanism"></a>Не используйте группы в качестве механизма обеспечения безопасности

Группы — это удобный способ сбора связанных пользователей, но они не являются безопасный механизм для ограничения доступа к конфиденциальной информации. Это особенно важно в тех случаях, когда пользователи могут автоматически повторно присоединиться к группам во время повторного подключения. Вместо этого рассмотрите возможность добавления привилегированных пользователей роли и ограничение доступа к методу концентратора, чтобы только члены этой роли. Пример того, ограничение доступа на основе роли, см. в разделе [проверки подлинности и авторизация для концентраторов SignalR](hub-authorization.md). Пример проверки доступа пользователей к группам, при повторном подключении, см. в разделе [работа с группами](../guide-to-the-api/working-with-groups.md).

<a id="input"></a>

### <a name="safely-handling-input-from-clients"></a>Безопасно обработки входных данных от клиентов

Чтобы убедиться, что пользователь-злоумышленник не отправляет скрипт для других пользователей, необходимо закодировать все входные данные от клиентов, предназначенный для широковещательной передачи другим клиентам. Так как приложение SignalR может иметь множество различных типов клиентов следует кодировать сообщения в принимающее клиентов, а не на сервере. Таким образом HTML-кодирование работает для веб-клиента, но не для других типов клиентов. Например, веб-клиента метод для отображения сообщения чата будет безопасно обрабатывать имя пользователя и сообщение путем вызова `html()` функции.

[!code-html[Main](introduction-to-security/samples/sample2.html?highlight=3-4)]

<a id="reconcile"></a>

### <a name="reconciling-a-change-in-user-status-with-an-active-connection"></a>Согласование изменение состояния пользователя с активным соединением

Если состояние проверки подлинности пользователя изменится, пока существует активное соединение, пользователь получит сообщение об ошибке, «удостоверение пользователя нельзя изменить во время подключения SignalR.» В этом случае приложение должно повторного подключения к серверу, чтобы убедиться, что координируются идентификатор подключения и имя пользователя. Например если приложение позволяет пользователю войти в систему пока существует активное соединение, имя пользователя для соединения больше не будет соответствовать имени, передается в следующем запросе. Будет остановить соединения, прежде чем пользователь выходит из системы и перезапустите его.

Тем не менее важно отметить, что большинство приложений будет не нужно вручную остановить и запустить подключение. Если приложение перенаправляет пользователей на отдельную страницу после входа, таких как поведение по умолчанию в приложении веб-форм или MVC-приложения или обновляет текущую страницу после выхода, активное соединение прервется автоматически и не делает требуются дополнительные действия.

В следующем примере показано, как для остановки и запуска подключения при изменении состояния пользователя.

[!code-html[Main](introduction-to-security/samples/sample3.html)]

Или, состояние проверки подлинности пользователя может измениться, если веб-сайт использует скользящий срок действия с помощью форм и активности, не следует допустимый файл cookie проверки подлинности. В этом случае пользователь будет иметь вышел из системы и имя пользователя больше не будут соответствовать имени пользователя в маркер подключения. Эту проблему можно устранить, добавив некоторые скрипт, который периодически запрашивает ресурс на веб-сервере, чтобы сохранить допустимый файл cookie проверки подлинности. В следующем примере показано, как для запроса ресурса каждые 30 минут.

[!code-javascript[Main](introduction-to-security/samples/sample4.js)]

<a id="autogen"></a>

### <a name="automatically-generated-javascript-proxy-files"></a>Автоматически созданные файлы JavaScript прокси-сервера

Если вы не хотите включать все концентраторам и методам в файле JavaScript прокси-сервера для каждого пользователя, можно отключить автоматическое создание файла. Можно выбрать этот параметр, если у вас несколько концентраторам и методам, но не каждого пользователя, которые следует учитывать все методы. Отключить автоматическое создание, задав **EnableJavaScriptProxies** для **false**.

[!code-csharp[Main](introduction-to-security/samples/sample5.cs)]

Дополнительные сведения о прокси-сервер файлы JavaScript, см. в разделе [созданный прокси и что он делает для вас](../guide-to-the-api/hubs-api-guide-javascript-client.md#genproxy). <a id="exceptions"></a>

### <a name="exceptions"></a>Исключения

Следует избегать передачи объектов исключений для клиентов, так как объекты могут содержать конфиденциальные сведения клиентов. Вместо этого можно вызовите метод на клиенте, который отображается соответствующее сообщение об ошибке.

[!code-csharp[Main](introduction-to-security/samples/sample6.cs)]
