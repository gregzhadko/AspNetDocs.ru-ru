---
uid: signalr/overview/security/introduction-to-security
title: Введение в SignalR безопасности (ru) Документы Майкрософт
author: bradygaster
description: Описывает проблемы безопасности, которые необходимо учитывать при разработке приложения SignalR.
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: ed562717-8591-4936-8e10-c7e63dcb570a
msc.legacyurl: /signalr/overview/security/introduction-to-security
msc.type: authoredcontent
ms.openlocfilehash: 24ce20b45543468de28ad017ba62d2f6e5a00f3b
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675811"
---
# <a name="introduction-to-signalr-security"></a>Общие сведения о безопасности SignalR

[Патрик Флетчер](https://github.com/pfletcher), [Том Фицкакен](https://github.com/tfitzmac)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этой статье описаны проблемы безопасности, которые необходимо учитывать при разработке приложения SignalR.
>
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемые в этой теме
>
>
> - [Visual Studio 2013](https://my.visualstudio.com/Downloads?q=visual%20studio%202013)
> - .NET 4.5
> - Версия SignalR 2
>
>
>
> ## <a name="previous-versions-of-this-topic"></a>Предыдущие версии этой темы
>
> Для получения информации о более ранних версиях SignalR, см [SignalR Старые версии](../older-versions/index.md).
>
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
>
> Пожалуйста, оставьте обратную связь о том, как вам понравился этот учебник и что мы могли бы улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, которые не имеют прямого отношения к учебнику, вы можете разместить их на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com.](http://stackoverflow.com/)

## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Концепции безопасности SignalR](#concepts)

    - [Аутентификация и авторизация](#authentication)
    - [Токен подключения](#connectiontoken)
    - [Воссоединение групп при повторном подключении](#rejoingroup)
- [Как SignalR предотвращает подделку запросов на перекрестные сайты](#csrf)
- [Рекомендации по безопасности SignalR](#recommendations)

    - [Протокол «Безопасные слои розетки» (SSL)](#ssl)
    - [Не используйте группы в качестве механизма безопасности](#groupsecurity)
    - [Безопасная обработка входных данных от клиентов](#input)
    - [Согласование изменения статуса пользователя с активным подключением](#reconcile)
    - [Автоматически генерируемые прокси-файлы JavaScript](#autogen)
    - [Исключения](#exceptions)

<a id="concepts"></a>

## <a name="signalr-security-concepts"></a>Концепции безопасности SignalR

<a id="authentication"></a>

### <a name="authentication-and-authorization"></a>Аутентификация и авторизация

SignalR не предоставляет никаких функций для проверки подлинности пользователей. Вместо этого вы интегрируете функции SignalR в существующую структуру аутентификации для приложения. Вы проверяете подлинность пользователей, как обычно в вашем приложении, и работаете с результатами проверки подлинности в коде SignalR. Например, можно проверить подлинность пользователей с помощью ASP.NET аутентификации форм, а затем в концентраторе, заставить пользователей или роли вызывать метод. В вашем концентраторе вы также можете передавать клиенту информацию о проверке подлинности, например, имя пользователя или принадлежность пользователя к роли.

SignalR предоставляет атрибут [Authorize,](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.authorizeattribute(v=vs.111).aspx) чтобы указать, какие пользователи имеют доступ к концентратору или методу. Атрибут Authorize применяется либо к концентратору, либо к определенным методам в концентраторе. Без атрибута Authorize все общедоступные методы концентратора доступны клиенту, подключенному к концентратору. Для получения дополнительной информации о концентрах, [см. Аутентификация и авторизация для концентраторов SignalR](hub-authorization.md).

Атрибут применяется `Authorize` к концентратам, но не к постоянным соединениям. Для обеспечения соблюдения `PersistentConnection` правил авторизации `AuthorizeRequest` при использовании метода необходимо переопределить метод. Для получения дополнительной информации [Authentication and Authorization for SignalR Persistent Connections](persistent-connection-authorization.md)о постоянных соединениях см.

<a id="connectiontoken"></a>

### <a name="connection-token"></a>Токен подключения

SignalR снижает риск выполнения вредоносных команд, подтверждая личность отправителя. Для каждого запроса клиент и сервер передают маркер соединения, содержащий идентификатор соединения и имя пользователя для аутентифицированных пользователей. Идентификатор соединения однозначно идентифицирует каждого подключенного клиента. Сервер случайным образом генерирует идентификатор соединения при создании нового соединения и сохраняет этот идентификатор в течение всего периода соединения. Механизм проверки подлинности для веб-приложения предоставляет имя пользователя. SignalR использует шифрование и цифровую подпись для защиты токена соединения.

![](introduction-to-security/_static/image2.png)

Для каждого запроса сервер проверяет содержимое маркера, чтобы убедиться, что запрос исходит от указанного пользователя. Имя пользователя должно соответствовать идентификатору соединения. Проверка идентификатора соединения и имени пользователя, SignalR предотвращает злоумышленника от легковыдающейся идентификации другого пользователя. Если сервер не может проверить маркер соединения, запрос завершается сбой.

![](introduction-to-security/_static/image4.png)

Поскольку идентификатор соединения является частью процесса проверки, не следует раскрывать идентификатор соединения одного пользователя другим пользователям или хранить значение на клиенте, например в файле cookie.

#### <a name="connection-tokens-vs-other-token-types"></a>Токены соединения по сравнению с другими типами токенов

Токены соединения иногда помечаются средствами безопасности, поскольку они кажутся маркерами сеанса или маркерами проверки подлинности, что создает риск при их воздействии.

Токен соединения SignalR не является маркером проверки подлинности. Он используется для подтверждения того, что пользователь, делающих этот запрос, является тем же самым, что создал соединение. Токен соединения необходим, поскольку ASP.NET SignalR позволяет соединениям перемещаться между серверами. Токен связывает соединение с определенным пользователем, но не утверждает личность пользователя, делающего запрос. Для того чтобы запрос SignalR был надлежащим образом проверен, он должен иметь другой маркер, утверждающий личность пользователя, например маркер или маркер носителя. Однако сам маркер соединения не утверждает, что запрос был сделан этим пользователем, только то, что идентификатор соединения, содержащийся в маркере, связан с этим пользователем.

Поскольку маркер соединения не предоставляет собственной претензии по проверке подлинности, он не считается маркером "сессия" или "аутентификация". Принимая токен соединения данного пользователя и восхваивая его в запросе, проверенном как другой пользователь (или непроверенный запрос), не удастся, потому что идентификация пользователя запроса и идентификатор, хранящийся в маркере, не совпадают.

<a id="rejoingroup"></a>

### <a name="rejoining-groups-when-reconnecting"></a>Воссоединение групп при повторном подключении

По умолчанию приложение SignalR автоматически переназначит пользователя соответствующим группам при повторном подключении от временного сбоя, например, когда соединение отброшено и восстановлено до отключения соединения. При повторном подключении клиент передает маркер группы, включающий идентификатор соединения и назначенные группы. Токен группы подписывается в цифровом виде и шифруется. Клиент сохраняет тот же идентификатор соединения после повторного подключения; таким образом, идентификатор соединения, передаваемый от повторно подключенного клиента, должен соответствовать предыдущему идентификатору соединения, используемому клиентом. Эта проверка не позволяет злоумышленнику передавать запросы на присоединение несанкционированных групп при повторном подключении.

Однако важно отметить, что у группы токен не истекает. Если пользователь принадлежал к группе в прошлом, но был запрещен в этой группе, этот пользователь может имитировать маркер группы, включающий запрещенную группу. Если вам необходимо надежно управлять тем, какие пользователи принадлежат к каким группам, необходимо хранить эти данные на сервере, например, в базе данных. Затем добавьте в приложение логику, которая проверяет на сервере, принадлежит ли пользователь к группе. Пример подтверждения членства в группе [см.](../guide-to-the-api/working-with-groups.md)

Автоматические воссоединение групп применяется только при повторном подключении соединения после временного сбоя. Если пользователь отключается, отобравшись от приложения или перезагружаясь, приложение должно разобраться, как добавить этого пользователя в правильные группы. Для получения дополнительной информации [см.](../guide-to-the-api/working-with-groups.md)

<a id="csrf"></a>

## <a name="how-signalr-prevents-cross-site-request-forgery"></a>Как SignalR предотвращает подделку запросов на перекрестные сайты

Кросс-сайт Запрос подделка (CSRF) является атака, когда вредоносный сайт отправляет запрос на уязвимый сайт, где пользователь в настоящее время войти в систему. SignalR предотвращает CSRF, делая крайне маловероятным для вредоносного сайта, чтобы создать действительный запрос для вашего приложения SignalR.

### <a name="description-of-csrf-attack"></a>Описание атаки CSRF

Вот пример атаки CSRF:

1. Пользователь входит в www.example.com, используя аутентификацию форм.
2. Сервер проверяет подлинность пользователя. Ответ от сервера включает в себя файлы cookie для проверки подлинности.
3. Не выходя из системы, пользователь посещает вредоносный веб-сайт. Этот вредоносный сайт содержит следующую форму HTML:

    [!code-html[Main](introduction-to-security/samples/sample1.html)]

   Обратите внимание, что форма действия должности на уязвимый сайт, а не на вредоносный сайт. Это "кросс-сайт" часть CSRF.
4. Пользователь нажимает кнопку отправки. Браузер включает в себя файлы проверки подлинности с запросом.
5. Запрос выполняется на example.com сервере с контекстом проверки подлинности пользователя и может делать все, что разрешено для проверки подлинности пользователя.

Хотя этот пример требует, чтобы пользователь нажал кнопку формы, вредоносная страница может так же легко запустить скрипт, который отправляет запрос AJAX в приложение SignalR. Кроме того, использование SSL не предотвращает атаку CSRF, так как вредоносный сайт может отправить запрос "https://".

Как правило, атаки CSRF возможны против веб-сайтов, которые используют файлы cookie для проверки подлинности, потому что браузеры отправляют все соответствующие файлы cookie на веб-сайт назначения. Однако атаки CSRF не ограничиваются использованием файлов cookie. Например, уязвимость также является достоверной проверкой элементарной и дайджестной проверки. После того, как пользователь входит в систему с помощью проверки подлинности Basic или Digest, браузер автоматически отправляет учетные данные до окончания сеанса.

### <a name="csrf-mitigations-taken-by-signalr"></a>Смягчения csRF, принятые SignalR

SignalR предпринимает следующие шаги, чтобы предотвратить создание вредоносного сайта действительных запросов в ваше приложение. SignalR принимает эти меры по умолчанию, вам не нужно предпринимать никаких действий в коде.

- **Отключить запросы на перекрестный домен** SignalR отстраняет от перекрестных запросов домена, чтобы пользователи не вызывали конечную точку SignalR из внешнего домена. SignalR считает любой запрос из внешнего домена недействительным и блокирует запрос. Мы рекомендуем вам сохранить это поведение по умолчанию; в противном случае вредоносный сайт может обмануть пользователей в отправке команд на ваш сайт. Если вам нужно использовать перекрестные запросы домена, [см. Как установить соединение кросс-домена](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain) .
- **Передайте токен соединения в строке запроса, а не cookie** SignalR передает маркер соединения как значение строки запроса, а не как файл cookie. Хранение маркера соединения в файле cookie небезопасно, поскольку браузер может непреднамеренно перенаправить маркер соединения при обнаружении вредоносного кода. Кроме того, передача маркера соединения в строке запроса предотвращает сохранение маркера соединения за пределами текущего соединения. Таким образом, вредоносный пользователь не может сделать запрос под учетными данными проверки подлинности другого пользователя.
- **Проверка токена соединения** Как описано в разделе [маркеров соединения,](#connectiontoken) сервер знает, какой идентификатор соединения связан с каждым проверенным пользователем. Сервер не обрабатывает запрос от идентификатора соединения, который не соответствует имени пользователя. Маловероятно, что вредоносный пользователь может угадать действительный запрос, потому что злоумышленник должен знать имя пользователя и текущий случайный идентификатор соединения. Этот идентификатор соединения становится недействительным, как только соединение будет прекращено. Анонимные пользователи не должны иметь доступ к какой-либо конфиденциальной информации.

<a id="recommendations"></a>

## <a name="signalr-security-recommendations"></a>Рекомендации по безопасности SignalR

<a id="ssl"></a>

### <a name="secure-socket-layers-ssl-protocol"></a>Протокол «Безопасные слои розетки» (SSL)

Протокол SSL использует шифрование для защиты передачи данных между клиентом и сервером. Если приложение SignalR передает конфиденциальную информацию между клиентом и сервером, используйте SSL для транспортировки. Для получения дополнительной информации о настройке SSL, [см. Как настроить SSL на IIS 7](https://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis).

<a id="groupsecurity"></a>

### <a name="do-not-use-groups-as-a-security-mechanism"></a>Не используйте группы в качестве механизма безопасности

Группы являются удобным способом сбора связанных пользователей, но они не являются безопасным механизмом для ограничения доступа к конфиденциальной информации. Это особенно верно, когда пользователи могут автоматически воссоединяться с группами во время повторного подключения. Вместо этого рассмотрите возможность добавления привилегированных пользователей к роли и ограничения доступа к методу концентратора только для членов этой роли. Пример ограничения доступа на основе роли [см.](hub-authorization.md) Например, проверка доступа пользователей к группам при повторном подключении [см.](../guide-to-the-api/working-with-groups.md)

<a id="input"></a>

### <a name="safely-handling-input-from-clients"></a>Безопасная обработка входных данных от клиентов

Чтобы гарантировать, что вредоносный пользователь не отправляет скрипт другим пользователям, необходимо кодировать все входные данные от клиентов, предназначенные для трансляции другим клиентам. Вы должны кодировать сообщения на принимающих клиентах, а не на сервере, потому что ваше приложение SignalR может иметь много различных типов клиентов. Таким образом, HTML-кодирование работает для веб-клиента, но не для других типов клиентов. Например, метод веб-клиента для отображения сообщения чата безопасно `html()` обрабатывает имя пользователя и сообщение, вызывая функцию.

[!code-html[Main](introduction-to-security/samples/sample2.html?highlight=3-4)]

<a id="reconcile"></a>

### <a name="reconciling-a-change-in-user-status-with-an-active-connection"></a>Согласование изменения статуса пользователя с активным подключением

Если статус аутентификации пользователя изменяется при наличии активного соединения, пользователь получает ошибку, в ходе которого говорится: "Идентификация пользователя не может изменяться во время активного подключения SignalR". В этом случае приложение должно повторно подключиться к серверу, чтобы убедиться, что идентификатор соединения и имя пользователя скоординированы. Например, если приложение позволяет пользователю выйти из системы, пока существует активное соединение, имя пользователя для соединения больше не будет совпадать с именем, которое передается для следующего запроса. Вы хотите, чтобы остановить соединение, прежде чем пользователь выходит из системы, а затем перезапустить его.

Однако важно отметить, что большинству приложений не нужно будет вручную останавливать и запускать соединение. Если приложение перенаправляет пользователей на отдельную страницу после выхода из системы, например поведение по умолчанию в приложении Web Forms или MVC, или обновляет текущую страницу после выхода из системы, активное соединение автоматически отключается и не требует каких-либо дополнительных действий.

В следующем примере показано, как остановить и запустить соединение при изменении статуса пользователя.

[!code-html[Main](introduction-to-security/samples/sample3.html)]

Или статус аутентификации пользователя может измениться, если ваш сайт использует скользящий срок действия с формами аутентификации, и нет никакой активности, чтобы сохранить файлы проверки подлинности действительными. В этом случае пользователь будет выходить из системы, и имя пользователя больше не будет совпадать с именем пользователя в маркере соединения. Эту проблему можно устранить, добавив некоторый скрипт, который периодически запрашивает ресурс на веб-сервере, чтобы сохранить проверку подлинности. В следующем примере показано, как запрашивать ресурс каждые 30 минут.

[!code-javascript[Main](introduction-to-security/samples/sample4.js)]

<a id="autogen"></a>

### <a name="automatically-generated-javascript-proxy-files"></a>Автоматически генерируемые прокси-файлы JavaScript

Если вы не хотите включать все концентраторы и методы в прокси-файл JavaScript для каждого пользователя, вы можете отключить автоматическое генерирование файла. Вы можете выбрать этот вариант, если у вас есть несколько концентраторов и методов, но не хотите, чтобы каждый пользователь был в курсе всех методов. Вы отключаете автоматическое поколение, установив **EnableJavaScriptProxies** на **ложное.**

[!code-csharp[Main](introduction-to-security/samples/sample5.cs)]

Для получения дополнительной информации о прокси-файлах JavaScript [см.](../guide-to-the-api/hubs-api-guide-javascript-client.md#genproxy) <a id="exceptions"></a>

### <a name="exceptions"></a>Исключения

Следует избегать передачи объектов исключений клиентам, поскольку объекты могут передавать конфиденциальную информацию клиентам. Вместо этого позвоните в клиент, который отображает соответствующее сообщение об ошибке.

[!code-csharp[Main](introduction-to-security/samples/sample6.cs)]
