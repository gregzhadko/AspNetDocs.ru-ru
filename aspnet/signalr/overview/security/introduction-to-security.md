---
uid: signalr/overview/security/introduction-to-security
title: Общие сведения о безопасности SignalR | Документация Майкрософт
author: bradygaster
description: Описание проблем безопасности, которые необходимо учитывать при разработке приложения SignalR.
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: ed562717-8591-4936-8e10-c7e63dcb570a
msc.legacyurl: /signalr/overview/security/introduction-to-security
msc.type: authoredcontent
ms.openlocfilehash: 24ce20b45543468de28ad017ba62d2f6e5a00f3b
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78450078"
---
# <a name="introduction-to-signalr-security"></a>Общие сведения о безопасности SignalR

[Патрик Флетчера](https://github.com/pfletcher), [Tom фитзмаккен](https://github.com/tfitzmac)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этой статье описываются вопросы безопасности, которые необходимо учитывать при разработке приложения SignalR.
>
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемые в этом разделе
>
>
> - [Visual Studio 2013](https://my.visualstudio.com/Downloads?q=visual%20studio%202013)
> - .NET 4.5
> - SignalR версии 2
>
>
>
> ## <a name="previous-versions-of-this-topic"></a>Предыдущие версии этого раздела
>
> Сведения о более ранних версиях SignalR см. в статье о [старых версиях](../older-versions/index.md)SignalR.
>
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
>
> Оставьте отзыв о том, как вы понравится вам в этом учебнике, и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, не связанные непосредственно с этим руководством, их можно опубликовать на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).

## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Основные понятия безопасности SignalR](#concepts)

    - [Аутентификация и авторизация](#authentication)
    - [Токен подключения](#connectiontoken)
    - [Повторное присоединение групп при восстановлении соединения](#rejoingroup)
- [Как SignalR предотвращает подделку межсайтовых запросов](#csrf)
- [Рекомендации по безопасности SignalR](#recommendations)

    - [Протокол SSL](#ssl)
    - [Не используйте группы в качестве механизма безопасности](#groupsecurity)
    - [Безопасная обработка входных данных от клиентов](#input)
    - [Согласование изменения состояния пользователя с активным подключением](#reconcile)
    - [Автоматически создаваемые прокси-файлы JavaScript](#autogen)
    - [Исключения](#exceptions)

<a id="concepts"></a>

## <a name="signalr-security-concepts"></a>Основные понятия безопасности SignalR

<a id="authentication"></a>

### <a name="authentication-and-authorization"></a>Аутентификация и авторизация

SignalR не предоставляет никаких функций для проверки подлинности пользователей. Вместо этого функции SignalR интегрируются в существующую структуру проверки подлинности для приложения. Проверка подлинности пользователей выполняется как обычно в приложении и работает с результатами проверки подлинности в коде SignalR. Например, вы можете проверить подлинность пользователей с помощью ASP.NET Forms Authentication, а затем в своем центре задать, каким пользователям или ролям разрешено вызывать метод. В центре можно также передать сведения о проверке подлинности, например имя пользователя или принадлежность пользователя к роли клиенту.

SignalR предоставляет атрибут [авторизации](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.authorizeattribute(v=vs.111).aspx) , чтобы указать, какие пользователи имеют доступ к концентратору или методу. Атрибут авторизации применяется к концентратору или определенным методам в концентраторе. Без атрибута авторизовать все открытые методы в концентраторе доступны для клиента, подключенного к концентратору. Дополнительные сведения о концентраторах см. в разделе [Проверка подлинности и авторизация для концентраторов SignalR](hub-authorization.md).

Атрибут `Authorize` применяется к концентраторам, но не к постоянным подключениям. Чтобы применить правила авторизации при использовании `PersistentConnection` необходимо переопределить метод `AuthorizeRequest`. Дополнительные сведения о постоянных подключениях см. в разделе [Проверка подлинности и авторизация для постоянных подключений SignalR](persistent-connection-authorization.md).

<a id="connectiontoken"></a>

### <a name="connection-token"></a>Токен подключения

SignalR снижает риск выполнения вредоносных команд путем проверки удостоверения отправителя. Для каждого запроса клиент и сервер передают маркер подключения, который содержит идентификатор подключения и имя пользователя для пользователей, прошедших проверку подлинности. Идентификатор подключения однозначно определяет каждого подключенного клиента. Сервер случайным образом создает идентификатор подключения при создании нового соединения и сохраняет этот идентификатор на время соединения. Механизм проверки подлинности для веб-приложения предоставляет имя пользователя. SignalR использует шифрование и цифровую подпись для защиты маркера подключения.

![](introduction-to-security/_static/image2.png)

Для каждого запроса сервер проверяет содержимое токена, чтобы убедиться, что запрос поступает от указанного пользователя. Имя пользователя должно соответствовать идентификатору соединения. Если проверить идентификатор подключения и имя пользователя, SignalR не позволит злоумышленнику легко олицетворять другого пользователя. Если сервер не может проверить маркер подключения, запрос завершается ошибкой.

![](introduction-to-security/_static/image4.png)

Поскольку идентификатор подключения является частью процесса проверки, не следует раскрывать идентификаторы подключения одного пользователя другим пользователям или хранить значение на клиенте, например в файле cookie.

#### <a name="connection-tokens-vs-other-token-types"></a>Маркеры соединения и другие типы токенов

Маркеры подключения иногда помечаются средствами безопасности, так как они выглядят как токены сеанса или токены проверки подлинности, что создает риск, если он предоставлен.

Маркер подключения SignalR не является маркером проверки подлинности. Он используется для подтверждения того, что пользователь, выполняющий этот запрос, совпадает с тем, который создал соединение. Маркер соединения необходим, так как ASP.NET SignalR разрешает подключение для перемещения между серверами. Маркер связывает соединение с конкретным пользователем, но не утверждает удостоверение пользователя, выполняющего запрос. Чтобы запрос SignalR прошел надлежащую проверку подлинности, он должен иметь другой маркер, который утверждает удостоверение пользователя, например файл cookie или токен носителя. Тем не менее, сам маркер соединения не запрашивает, что запрос был сделан этим пользователем, с этим пользователем связывается только идентификатор соединения, содержащийся в маркере.

Поскольку маркер подключения не предоставляет собственного утверждения проверки подлинности, он не считается маркером "сеанс" или "Проверка подлинности". Получение маркера подключения данного пользователя и его воспроизведение в запросе, прошедшем проверку подлинности от имени другого пользователя (или запроса без проверки подлинности), завершится ошибкой, так как идентификатор пользователя запроса и удостоверение, хранящиеся в маркере, не будут совпадать.

<a id="rejoingroup"></a>

### <a name="rejoining-groups-when-reconnecting"></a>Повторное присоединение групп при восстановлении соединения

По умолчанию приложение SignalR автоматически переназначит пользователя соответствующим группам при повторном подключении из временного перерыва, например при удалении и повторном установлении соединения до истечения времени ожидания соединения. При повторном подключении клиент передает маркер группы, включающий идентификатор подключения и назначенные группы. Маркер группы имеет цифровую подпись и шифруется. Клиент оставляет тот же идентификатор подключения после повторного подключения; Таким образом, идентификатор соединения, переданный из повторно подключенного клиента, должен соответствовать предыдущему идентификатору соединения, используемому клиентом. Эта проверка не позволяет злоумышленнику передавать запросы на присоединение к неавторизованным группам при повторном подключении.

Однако важно отметить, что срок действия токена группы не истекает. Если пользователь принадлежал к группе в прошлом, но заблокирован из этой группы, этот пользователь может имитировать маркер группы, включающий группу запрещенных. Если необходимо безопасно управлять тем, какие пользователи принадлежат какой группе, необходимо сохранить эти данные на сервере, например в базе данных. Затем добавьте в приложение логику, которая проверяет на сервере принадлежность пользователя к группе. Пример проверки членства в группе см. в разделе [Работа с группами](../guide-to-the-api/working-with-groups.md).

Автоматическое повторное присоединение групп применяется только после временного перерыва подключения. Если пользователь отключится от приложения или перезапускает приложение, приложение должно будет решить, как добавить этого пользователя в правильные группы. Дополнительные сведения см. в разделе [Работа с группами](../guide-to-the-api/working-with-groups.md).

<a id="csrf"></a>

## <a name="how-signalr-prevents-cross-site-request-forgery"></a>Как SignalR предотвращает подделку межсайтовых запросов

Подделка межсайтовых запросов (CSRF) — это атака, при которой вредоносный сайт отправляет запрос на уязвимый сайт, на котором пользователь в данный момент вошел в систему. SignalR предотвращает CSRF, делая его чрезвычайно маловероятной для вредоносного сайта, чтобы создать допустимый запрос для вашего приложения SignalR.

### <a name="description-of-csrf-attack"></a>Описание атаки CSRF

Ниже приведен пример атаки CSRF.

1. Пользователь входит в www.example.com с использованием проверки подлинности с помощью форм.
2. Сервер проверяет подлинность пользователя. Ответ сервера включает файл cookie проверки подлинности.
3. Не выполняя выход, пользователь посещает вредоносный веб-узел. Этот вредоносный сайт содержит следующую HTML-форму:

    [!code-html[Main](introduction-to-security/samples/sample1.html)]

   Обратите внимание, что действие формы публикует сообщение на уязвимом сайте, а не на вредоносном сайте. Это часть CSRF, связанная с "межсайт".
4. Пользователь нажимает кнопку Submit (отправить). Браузер включает файл cookie проверки подлинности с запросом.
5. Запрос выполняется на сервере example.com с помощью контекста проверки подлинности пользователя и может выполнять любые действия, которые разрешено выполнять прошедшему проверку подлинности пользователю.

Хотя в этом примере пользователь должен нажать кнопку формы, вредоносная страница может просто запустить сценарий, отправляющий запрос AJAX в приложение SignalR. Более того, использование протокола SSL не мешает CSRF атаке, так как вредоносный сайт может отправить запрос "https://".

Как правило, атаки CSRF возможны для веб-сайтов, использующих файлы cookie для проверки подлинности, так как браузеры отправляют все соответствующие файлы cookie на целевой веб-сайт. Однако атаки CSRF не ограничиваются использованием файлов cookie. Например, также уязвимы обычная и краткая проверка подлинности. После входа пользователя в систему с базовой или дайджест-проверкой подлинности браузер автоматически отправляет учетные данные, пока сеанс не завершится.

### <a name="csrf-mitigations-taken-by-signalr"></a>CSRFные решения, созданные SignalR

SignalR выполняет следующие действия, чтобы предотвратить создание вредоносными сайтами допустимых запросов к приложению. По умолчанию SignalR выполняет эти действия. в коде не нужно предпринимать никаких действий.

- **Отключение междоменных запросов** SignalR отключает запросы между доменами, чтобы запретить пользователям вызывать конечную точку SignalR из внешнего домена. SignalR считает, что любой запрос из внешнего домена является недопустимым, и блокирует запрос. Рекомендуется использовать это поведение по умолчанию. в противном случае злонамеренный сайт может заставить пользователей отправлять команды на ваш сайт. Если необходимо использовать запросы между доменами, см. раздел [как установить междоменное подключение](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain) .
- **Передача токена подключения в строке запроса, а не файла cookie** SignalR передает маркер подключения как значение строки запроса, а не как файл cookie. Хранение токена подключения в файле cookie является ненадежным, так как браузер может случайно переслать маркер подключения при обнаружении вредоносного кода. Кроме того, передача маркера соединения в строке запроса предотвращает сохранение токена соединения за пределами текущего соединения. Таким образом, злоумышленник не может выполнить запрос под учетными данными для проверки подлинности другого пользователя.
- **Проверка токена подключения** Как описано в разделе [маркера подключения](#connectiontoken) , сервер знает, какой идентификатор подключения связан с каждым аутентифицированным пользователем. Сервер не обрабатывает запросы от идентификатора соединения, который не соответствует имени пользователя. Маловероятно, что злоумышленник может угадать допустимый запрос, поскольку злоумышленнику необходимо знать имя пользователя и текущий идентификатор подключения, который был случайно сгенерирован. Идентификатор подключения становится недействительным, как только соединение будет завершено. Анонимные пользователи не должны иметь доступа к конфиденциальной информации.

<a id="recommendations"></a>

## <a name="signalr-security-recommendations"></a>Рекомендации по безопасности SignalR

<a id="ssl"></a>

### <a name="secure-socket-layers-ssl-protocol"></a>Протокол SSL

Протокол SSL использует шифрование для защиты передачи данных между клиентом и сервером. Если приложение SignalR передает конфиденциальную информацию между клиентом и сервером, используйте SSL для транспорта. Дополнительные сведения о настройке SSL см. в разделе [Настройка SSL в IIS 7](https://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis).

<a id="groupsecurity"></a>

### <a name="do-not-use-groups-as-a-security-mechanism"></a>Не используйте группы в качестве механизма безопасности

Группы — это удобный способ сбора связанных пользователей, но они не являются безопасным механизмом для ограничения доступа к конфиденциальной информации. Это особенно справедливо, когда пользователи могут автоматически повторно присоединять группы во время переподключения. Вместо этого рассмотрите возможность добавления привилегированных пользователей к роли и ограничение доступа к методу концентратора только членами этой роли. Пример запрещения доступа на основе роли см. в разделе [Проверка подлинности и авторизация для концентраторов SignalR](hub-authorization.md). Пример проверки доступа пользователей к группам при повторном подключении см. в разделе [Работа с группами](../guide-to-the-api/working-with-groups.md).

<a id="input"></a>

### <a name="safely-handling-input-from-clients"></a>Безопасная обработка входных данных от клиентов

Чтобы убедиться, что злоумышленник не отправляет скрипт другим пользователям, необходимо закодировать все входные данные с клиентов, предназначенных для передачи другим клиентам. Следует кодировать сообщения на принимающих клиентах, а не на сервере, так как приложение SignalR может иметь много различных типов клиентов. Поэтому кодировка HTML работает для веб-клиента, но не для других типов клиентов. Например, метод веб-клиента для вывода сообщения разговора безопасно обрабатывает имя пользователя и сообщение, вызывая функцию `html()`.

[!code-html[Main](introduction-to-security/samples/sample2.html?highlight=3-4)]

<a id="reconcile"></a>

### <a name="reconciling-a-change-in-user-status-with-an-active-connection"></a>Согласование изменения состояния пользователя с активным подключением

Если состояние проверки подлинности пользователя изменяется во время существования активного подключения, пользователь получит сообщение об ошибке "не удается изменить удостоверение пользователя во время активного подключения SignalR". В этом случае приложение должно повторно подключиться к серверу, чтобы убедиться, что идентификатор подключения и имя пользователя координируются. Например, если приложение разрешает пользователю выход во время существования активного подключения, имя пользователя для соединения больше не будет совпадать с именем, переданным в качестве следующего запроса. Необходимо будет прерывать подключение до выхода пользователя из системы, а затем перезапускать его.

Однако важно отметить, что большинству приложений не придется вручную останавливаться и запускать подключение. Если приложение перенаправляет пользователей на отдельную страницу после выхода, например поведение по умолчанию в приложении веб-форм или приложения MVC или обновляет текущую страницу после выхода, активное подключение автоматически отключается и не требуется любое дополнительное действие.

В следующем примере показано, как отключить и запустить соединение при изменении состояния пользователя.

[!code-html[Main](introduction-to-security/samples/sample3.html)]

Или же состояние проверки подлинности пользователя может измениться, если сайт использует скользящий срок действия с проверкой подлинности с помощью форм, и нет активности для сохранения допустимого файла cookie проверки подлинности. В этом случае пользователь будет выходить из систему, а имя пользователя больше не будет совпадать с именем пользователя в маркере подключения. Эту проблему можно устранить, добавив скрипт, который периодически запрашивает ресурс на веб-сервере, чтобы обеспечить допустимость файла cookie проверки подлинности. В следующем примере показано, как запросить ресурс каждые 30 минут.

[!code-javascript[Main](introduction-to-security/samples/sample4.js)]

<a id="autogen"></a>

### <a name="automatically-generated-javascript-proxy-files"></a>Автоматически создаваемые прокси-файлы JavaScript

Если вы не хотите включать все концентраторы и методы в прокси-файл JavaScript для каждого пользователя, можно отключить автоматическое создание файла. Этот вариант можно выбрать, если у вас есть несколько концентраторов и методов, но не нужно, чтобы каждый пользователь знал о всех методах. Автоматическое создание отключается путем установки для **енаблежаваскриптпроксиес** значения **false**.

[!code-csharp[Main](introduction-to-security/samples/sample5.cs)]

Дополнительные сведения о прокси-файлах JavaScript см. [в разделе созданный прокси-сервер и его назначение](../guide-to-the-api/hubs-api-guide-javascript-client.md#genproxy). <a id="exceptions"></a>

### <a name="exceptions"></a>Исключения

Следует избегать передачи объектов исключений клиентам, так как объекты могут предоставлять клиентам конфиденциальную информацию. Вместо этого вызовите метод на клиенте, который отображает соответствующее сообщение об ошибке.

[!code-csharp[Main](introduction-to-security/samples/sample6.cs)]
