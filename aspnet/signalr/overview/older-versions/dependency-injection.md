---
uid: signalr/overview/older-versions/dependency-injection
title: Внедрение зависимостей в SignalR 1. x | Документация Майкрософт
author: bradygaster
description: ''
ms.author: bradyg
ms.date: 05/15/2013
ms.assetid: eaa206c4-edb3-487e-8fcb-54a3261fed36
msc.legacyurl: /signalr/overview/older-versions/dependency-injection
msc.type: authoredcontent
ms.openlocfilehash: de838ab6b3a299eb1e5ebeb9fa3c583478ce3e56
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78431544"
---
# <a name="dependency-injection-in-signalr-1x"></a>Внедрение зависимостей в SignalR 1.x

по [Майк Уоссон](https://github.com/MikeWasson), [Патрик Флетчера](https://github.com/pfletcher)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

Внедрение зависимостей — это способ удаления жестко запрограммированных зависимостей между объектами, что упрощает замену зависимостей объекта либо для тестирования (с помощью макетных объектов), либо для изменения поведения во время выполнения. В этом руководстве показано, как выполнять внедрение зависимостей в концентраторах SignalR. В нем также показано, как использовать контейнеры IoC с SignalR. Контейнер IoC — это общая платформа для внедрения зависимостей.

## <a name="what-is-dependency-injection"></a>Что такое внедрение зависимостей?

Пропустите этот раздел, если вы уже знакомы с внедрением зависимостей.

*Внедрение зависимостей* (DI) — это шаблон, в котором объекты не отвечают за создание собственных зависимостей. Ниже приведен простой пример мотивации. Предположим, что у вас есть объект, который должен записывать сообщения в журнал. Вы можете определить интерфейс ведения журнала:

[!code-csharp[Main](dependency-injection/samples/sample1.cs)]

В объекте можно создать `ILogger` для записи сообщений в журнал:

[!code-csharp[Main](dependency-injection/samples/sample2.cs)]

Это работает, но это не лучшая структура. Если вы хотите заменить `FileLogger` другой реализацией `ILogger`, необходимо будет изменить `SomeComponent`. Допустим, что многие другие объекты используют `FileLogger`, необходимо изменить их все. Или, если вы решили сделать `FileLogger` Singleton, вам также потребуется внести изменения во всем приложении.

Лучшим подходом является «внедрение» `ILogger` в объект, например с помощью аргумента конструктора:

[!code-csharp[Main](dependency-injection/samples/sample3.cs)]

Теперь объект не отвечает за выбор `ILogger` для использования. Можно переключать реализации `ILogger`, не изменяя зависимые от нее объекты.

[!code-csharp[Main](dependency-injection/samples/sample4.cs)]

Этот шаблон называется [внедрением конструктора](http://www.martinfowler.com/articles/injection.html#FormsOfDependencyInjection). Другой шаблон — это внедрение метода присваивания, где зависимость задается через метод задания или свойство.

## <a name="simple-dependency-injection-in-signalr"></a>Простое внедрение зависимостей в SignalR

Рассмотрим приложение разговора из учебника [Начало работы с SignalR](../getting-started/tutorial-getting-started-with-signalr.md). Ниже приведен класс Hub из этого приложения.

[!code-csharp[Main](dependency-injection/samples/sample5.cs)]

Предположим, что необходимо сохранить сообщения разговора на сервере перед их отправкой. Вы можете определить интерфейс, который абстрагирует эту функциональность, и использовать DI для внедрения интерфейса в класс `ChatHub`.

[!code-csharp[Main](dependency-injection/samples/sample6.cs)]

Единственная проблема заключается в том, что приложение SignalR не создает концентраторы напрямую. SignalR создает их для вас. По умолчанию SignalR ждет, что класс концентратора имеет конструктор без параметров. Однако можно легко зарегистрировать функцию для создания экземпляров концентратора и использовать эту функцию для выполнения внедрения. Зарегистрируйте функцию, вызвав **GlobalHost. депенденциресолвер. Register**.

[!code-csharp[Main](dependency-injection/samples/sample7.cs)]

Теперь SignalR будет вызывать эту анонимную функцию при необходимости создания экземпляра `ChatHub`.

## <a name="ioc-containers"></a>Контейнеры IoC

Предыдущий код подходит для простых случаев. Но все еще пришлось написать следующее:

[!code-css[Main](dependency-injection/samples/sample8.css)]

В сложном приложении с множеством зависимостей может потребоваться написать большой код "проводной связи". Этот код может быть трудно поддерживать, особенно если зависимости являются вложенными. Это также затрудняет тестирование модулей.

Одним из решений является использование контейнера IoC. Контейнер IoC — это программный компонент, отвечающий за управление зависимостями. Вы регистрируете типы в контейнере, а затем используете контейнер для создания объектов. Контейнер автоматически определяет отношения зависимости. Многие контейнеры IoC также позволяют контролировать время существования и области действия объекта.

> [!NOTE]
> "IoC" означает "инверсия управления", которая представляет собой общий шаблон, в котором инфраструктура вызывает код приложения. Контейнер IoC конструирует ваши объекты, что «инвертирует» обычный поток управления.

## <a name="using-ioc-containers-in-signalr"></a>Использование контейнеров IoC в SignalR

Возможно, приложение для разговора слишком просто, чтобы получить преимущество от IoC-контейнера. Вместо этого давайте взглянем на пример [стокктиккер](http://nuget.org/packages/microsoft.aspnet.signalr.sample) .

Образец Стокктиккер определяет два основных класса:

- `StockTickerHub`: класс Hub, который управляет подключениями клиентов.
- `StockTicker`: одноэлементный экземпляр, содержащий цены акций, и периодически обновляет их.

`StockTickerHub` содержит ссылку на `StockTicker` Singleton, а `StockTicker` содержит ссылку на **ихубконнектионконтекст** для `StockTickerHub`. Он использует этот интерфейс для взаимодействия с экземплярами `StockTickerHub`. (Дополнительные сведения см. [в статье серверное вещание с помощью ASP.NET SignalR](index.md).)

Мы можем использовать контейнер IoC для унтангле этих зависимостей чуть ниже. Во первых, давайте Упростите классы `StockTickerHub` и `StockTicker`. В следующем коде я добавил в комментарий те части, которые нам не нужны.

Удалите конструктор без параметров из `StockTicker`. Вместо этого мы всегда будем использовать DI для создания концентратора.

[!code-csharp[Main](dependency-injection/samples/sample9.cs)]

Для Стокктиккер удалите одноэлементный экземпляр. Позже мы будем использовать контейнер IoC для управления временем жизни Стокктиккер. Кроме того, сделайте конструктор открытым.

[!code-csharp[Main](dependency-injection/samples/sample10.cs?highlight=7)]

Теперь можно выполнить рефакторинг кода, создав интерфейс для `StockTicker`. Мы будем использовать этот интерфейс для отделения `StockTickerHub` от класса `StockTicker`.

Visual Studio упрощает этот тип рефакторинга. Откройте файл StockTicker.cs, щелкните правой кнопкой мыши объявление класса `StockTicker` и выберите **Рефакторинг** ... **Извлечение интерфейса**.

![](dependency-injection/_static/image1.png)

В диалоговом окне **Извлечение интерфейса** нажмите кнопку **выбрать все**. Оставьте другие значения по умолчанию. Нажмите кнопку **ОК**.

![](dependency-injection/_static/image2.png)

Visual Studio создает новый интерфейс с именем `IStockTicker`, а также изменяет `StockTicker` на производный от `IStockTicker`.

Откройте файл IStockTicker.cs и измените интерфейс на **Public**.

[!code-csharp[Main](dependency-injection/samples/sample11.cs?highlight=1)]

В классе `StockTickerHub` измените два экземпляра `StockTicker` на `IStockTicker`:

[!code-csharp[Main](dependency-injection/samples/sample12.cs?highlight=4,6)]

Создание `IStockTicker` интерфейса не является обязательным, но я хотел продемонстрировать, как DI может помочь уменьшить взаимозависимость между компонентами в приложении.

## <a name="add-the-ninject-library"></a>Добавление библиотеки Нинжект

Существует множество контейнеров IoC с открытым кодом для .NET. В этом руководстве я буду использовать [нинжект](http://www.ninject.org/). (Другие популярные библиотеки включают [Castle Windsor](http://www.castleproject.org/), [Spring.NET](http://www.springframework.net/), [Autofac](https://code.google.com/p/autofac/), [Unity](https://github.com/unitycontainer/unity)и [StructureMap](http://docs.structuremap.net).)

Используйте диспетчер пакетов NuGet для установки [библиотеки нинжект](https://nuget.org/packages/Ninject/3.0.1.10). В Visual Studio в меню **Сервис** выберите **диспетчер пакетов NuGet** > **консоль диспетчера пакетов**. В окне "Консоль диспетчера пакетов" введите следующую команду:

[!code-powershell[Main](dependency-injection/samples/sample13.ps1)]

## <a name="replace-the-signalr-dependency-resolver"></a>Замена сопоставителя зависимостей SignalR

Чтобы использовать Нинжект в SignalR, создайте класс, производный от **дефаултдепенденциресолвер**.

[!code-csharp[Main](dependency-injection/samples/sample14.cs)]

Этот класс переопределяет **методы** **дефаултдепенденциресолвер** **и методом WebService.** SignalR вызывает эти методы для создания различных объектов во время выполнения, включая экземпляры концентратора, а также различные службы, которые внутренне используют SignalR.

- Метод **WebService** создает один экземпляр типа. Переопределите этот метод, чтобы вызвать метод **TryGet** ядра нинжект. Если этот метод возвращает значение null, возвращается сопоставитель по умолчанию.
- Метод **WebService** создает коллекцию объектов указанного типа. Переопределите этот метод, чтобы объединить результаты из Нинжект с результатами распознавателя по умолчанию.

## <a name="configure-ninject-bindings"></a>Настройка привязок Нинжект

Теперь мы будем использовать Нинжект для объявления привязок типов.

Откройте файл RegisterHubs.cs. В методе `RegisterHubs.Start` создайте контейнер Нинжект, который Нинжект вызывает *ядро*.

[!code-csharp[Main](dependency-injection/samples/sample15.cs)]

Создайте экземпляр пользовательского сопоставителя зависимостей:

[!code-csharp[Main](dependency-injection/samples/sample16.cs)]

Создайте привязку для `IStockTicker` следующим образом:

[!code-html[Main](dependency-injection/samples/sample17.html)]

Этот код говорит две вещи. Во всяком случае, когда приложению требуется `IStockTicker`, ядро должно создать экземпляр `StockTicker`. Во-вторых, класс `StockTicker` должен быть создан как одноэлементный объект. Нинжект создаст один экземпляр объекта и возвратит тот же экземпляр для каждого запроса.

Создайте привязку для **ихубконнектионконтекст** следующим образом:

[!code-csharp[Main](dependency-injection/samples/sample18.cs)]

Этот код создает анонимную функцию, которая возвращает **ихубконнектион**. Метод **вхенинжектединто** указывает нинжект использовать эту функцию только при создании экземпляров `IStockTicker`. Причина заключается в том, что SignalR создает экземпляры **ихубконнектионконтекст** внутренне, и мы не хотим переопределять способ их создания. Эта функция применяется только к нашему `StockTicker` классу.

Передайте сопоставитель зависимостей в метод **мафубс** :

[!code-csharp[Main](dependency-injection/samples/sample19.cs)]

Теперь SignalR будет использовать сопоставитель, указанный в **мафубс**, вместо распознавателя по умолчанию.

Ниже приведен полный листинг кода для `RegisterHubs.Start`.

[!code-csharp[Main](dependency-injection/samples/sample20.cs)]

Чтобы запустить приложение Стокктиккер в Visual Studio, нажмите клавишу F5. В окне браузера перейдите к `http://localhost:*port*/SignalR.Sample/StockTicker.html`.

![](dependency-injection/_static/image3.png)

Приложение имеет точно те же функциональные возможности, что и ранее. (Описание см. в разделе [серверное вещание с помощью ASP.NET SignalR](index.md).) Поведение не изменилось. просто сделать код проще в тестировании, обслуживании и развитии.
