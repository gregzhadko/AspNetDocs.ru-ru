---
uid: signalr/overview/older-versions/introduction-to-security
title: Общие сведения о безопасности SignalR (SignalR 1.x) | Документация Майкрософт
author: bradygaster
description: Описывает вопросы безопасности, которые необходимо учитывать при разработке приложений с SignalR.
ms.author: bradyg
ms.date: 10/17/2013
ms.assetid: 715a4059-d307-4631-abbb-c789c95d6eb4
msc.legacyurl: /signalr/overview/older-versions/introduction-to-security
msc.type: authoredcontent
ms.openlocfilehash: 08106dd6df491da817e0d449e85a09a8bc0fc77c
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59422061"
---
# <a name="introduction-to-signalr-security-signalr-1x"></a>Общие сведения о безопасности SignalR (SignalR 1.x)

по [Флетчера Патрик](https://github.com/pfletcher), [Tom FitzMacken](https://github.com/tfitzmac)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этой статье описываются проблемы безопасности, которые необходимо учитывать при разработке приложений с SignalR.


## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Основные понятия безопасности SignalR](#concepts)

    - [Аутентификация и авторизация](#authentication)
    - [Маркер подключения](#connectiontoken)
    - [Повторное присоединение групп при повторном подключении](#rejoingroup)
- [Как SignalR предотвращает подделки запросов между сайтами](#csrf)
- [Рекомендации по обеспечению безопасности SignalR](#recommendations)

    - [Защищенный протокол слои сокетов (SSL)](#ssl)
    - [Не используйте группы в качестве механизма обеспечения безопасности](#groupsecurity)
    - [Безопасно обработки входных данных от клиентов](#input)
    - [Согласование изменение состояния пользователя с активным соединением](#reconcile)
    - [Автоматически созданные файлы JavaScript прокси-сервера](#autogen)
    - [Исключения](#exceptions)

<a id="concepts"></a>

## <a name="signalr-security-concepts"></a>Основные понятия безопасности SignalR

<a id="authentication"></a>

### <a name="authentication-and-authorization"></a>Аутентификация и авторизация

SignalR позволяет интегрировать в существующую структуру проверки подлинности для приложения. Он не предоставляет какие-либо функции для проверки подлинности пользователей. Вместо этого можно проверять подлинность пользователей, обычно в приложении, а затем работать с результатами проверки подлинности в коде SignalR. Например может проверять подлинность пользователей с помощью проверки подлинности форм ASP.NET и в концентраторе, принудительное применение какие пользователи или роли авторизованы для вызова метода. В концентраторе также можно передать данные проверки подлинности, такие как имя пользователя или от того, принадлежит ли пользователь к роли, клиенту.

SignalR обеспечивает [Authorize](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.authorizeattribute(v=vs.111).aspx) атрибут, чтобы указать, какие пользователи имеют доступ к концентратору или метод. Примените атрибут Authorize к концентратору или отдельные методы в концентраторе. Без атрибута Authorize все открытые методы концентратора доступны для клиентов, которые подключены к центру. Дополнительные сведения о концентраторах см. в разделе [проверки подлинности и авторизация для концентраторов SignalR](../security/hub-authorization.md).

`Authorize` Атрибут используется только с концентраторами. Для принудительного выполнения правил авторизации, при использовании `PersistentConnection` необходимо переопределить `AuthorizeRequest` метод. Дополнительные сведения о постоянных подключений, см. в разделе [проверки подлинности и авторизация для постоянных подключений SignalR](../security/persistent-connection-authorization.md).

<a id="connectiontoken"></a>

### <a name="connection-token"></a>Маркер подключения

SignalR уменьшает риск выполнения вредоносных команд, проверив удостоверение отправителя. Маркер соединения, содержащая идентификатор подключения и имя пользователя для прошедших проверку пользователей передаются между клиентом и сервером для каждого запроса. Идентификатор подключения — это уникальный идентификатор, который создается сервером случайным образом, когда создается новое соединение и сохраняется в течение всего соединения. Имя пользователя предоставляется механизм проверки подлинности для веб-приложения. Маркер подключения защищен с помощью шифрования и цифровой подписи.

![](introduction-to-security/_static/image2.png)

Для каждого запроса сервер проверяет содержимое маркер, чтобы убедиться, что запрос исходит от указанного пользователя. Имя пользователя должно соответствовать идентификатор подключения. Проверив идентификатор подключения и имя пользователя, SignalR не позволяет пользователь-злоумышленник легко олицетворение других пользователей. Если сервер не удается проверить маркер подключения, запрос отклоняется.

![](introduction-to-security/_static/image4.png)

Так как идентификатор подключения является частью процесса проверки, не следует раскрывать один пользователь идентификатор подключения для других пользователей или хранения значения на стороне клиента, например, в файле cookie.

<a id="rejoingroup"></a>

### <a name="rejoining-groups-when-reconnecting"></a>Повторное присоединение групп при повторном подключении

По умолчанию SignalR приложение будет автоматически повторно назначить пользователю в соответствующие группы при повторном подключении из к временному нарушению работы, например при удалении и заново установить соединение, время ожидания соединения. При повторном подключении, клиент передает маркер группы, который включает в себя идентификатор подключения и назначенные группы. Маркер группы цифровой подписывается и шифруется. Клиентское приложение сохраняет один и тот же идентификатор подключения после повторного подключения; Таким образом идентификатор подключения, переданные от повторного подключения клиента должен соответствовать предыдущий идентификатор соединения, используемый клиентом. Такая проверка предотвращает пользователь-злоумышленник передачи запросы на присоединение к группам несанкционированного, при повторном подключении.

Тем не менее важно отметить, что маркер группы имеет неограниченный срок действия. Если пользователь принадлежал к группе в прошлом, но было заблокировано из этой группы, этот пользователь может быть возможность имитировать маркер группы, который включает запрещенных группы. Если вам нужно безопасно управлять какие пользователи входят в какие группы, необходимо хранить их на сервере, например в базе данных. Затем добавьте логику для приложения, которое проверяет на сервере, принадлежит ли пользователь в группу. Например, проверка членства в группе, см. в разделе [работа с группами](../guide-to-the-api/working-with-groups.md).

Автоматическое повторное присоединение групп применим только для повторного соединения после временному нарушению работы. Если пользователь отключается покидая приложение или повторного запуска приложения, приложения необходимо обрабатывать как добавить этого пользователя в требуемые группы. Дополнительные сведения см. в разделе [работа с группами](../guide-to-the-api/working-with-groups.md).

<a id="csrf"></a>

## <a name="how-signalr-prevents-cross-site-request-forgery"></a>Как SignalR предотвращает подделки запросов между сайтами

Подделки межсайтовых запросов (CSRF) — это атака, при которой вредоносный сайт отправляет запрос на уязвимом сайте, где пользователь вошел в. SignalR предотвращает CSRF, делая крайне маловероятно для вредоносный сайт создать допустимый запрос для вашего приложения SignalR.

### <a name="description-of-csrf-attack"></a>Описание атаки CSRF

Вот пример атаки CSRF:

1. Когда пользователь входит в `www.example.com`, с помощью проверки подлинности форм.
2. Сервер проверяет подлинность пользователя. Ответ от сервера включает файл cookie проверки подлинности.
3. Не выходя из пользователь посещает вредоносных веб-сайта. Этот вредоносный сайт содержит следующий HTML-формы: 

    [!code-html[Main](introduction-to-security/samples/sample1.html)]

   Обратите внимание, что отправляет уязвимом сайте, не на сайте вредоносных действий формы. Это часть CSRF «cross-site».
4. Пользователь нажимает кнопку «Отправить». Браузер включает в себя файл cookie проверки подлинности с запросом.
5. Этот запрос выполняется на сервере example.com, контекст проверки подлинности пользователя и могут выполнять любые операции, прошедший проверку пользователь может сделать.

Несмотря на то, что в этом примере требует от пользователя, нажмите кнопку «формы», страницу вредоносных может так же, как легко запускать сценарий, который отправляет запрос AJAX в приложение SignalR. Кроме того с помощью протокола SSL не может помешать атаки CSRF, так как вредоносный сайт может отправить запрос « https://».

Как правило атак CSRF — для веб-сайтов, использующих файлы cookie для проверки подлинности, потому что браузеры отправляют все необходимые файлы cookie веб-узлу. Тем не менее атаки CSRF не ограничены использованием файлы cookie. Например Basic и дайджест-проверки подлинности также уязвимы. После входа пользователя в систему с помощью обычной или дайджест-проверки подлинности, браузер автоматически отправляет учетные данные до завершения сеанса.

### <a name="csrf-mitigations-taken-by-signalr"></a>Способы устранения рисков CSRF выполняемое SignalR

SignalR принимает следующие действия, чтобы предотвратить создание допустимых запросов к вашему приложению SignalR вредоносный сайт. Эти действия создаются по умолчанию и не требуют никаких действий в коде.

- **Отключить междоменные запросы**  
 По умолчанию междоменные запросы отключены в приложении SignalR, чтобы запретить пользователям вызов конечной точки SignalR из внешнего домена. Любой запрос, который поступает из внешнего домена автоматически считается недействительным и будет заблокирован. Рекомендуется оставить поведение по умолчанию; в противном случае вредоносный сайт может обманом вынудить пользователей отправляет команды на веб-узла. Если вам нужно использовать междоменные запросы, см. в разделе [как для установления соединения между доменами](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain) .
- **Передать маркер подключения в строке запроса, а не файл cookie**  
 SignalR передает маркер подключения как значения строки запроса, а не как файл cookie. Не сохраняя маркер подключения как файл cookie, маркер подключения не перенаправляется случайно браузером при обнаружении вредоносного кода. Кроме того маркер подключения не сохраняется вне текущего соединения. Таким образом пользователь-злоумышленник не может сделать запрос под учетными данными проверки подлинности другого пользователя.
- **Проверить маркер подключения**  
 Как описано в разделе [маркер подключения](#connectiontoken) разделе сервер знает, какой идентификатор соединения связан с каждого проверенного пользователя. Сервер не обрабатывает все запросы из идентификатор соединения, который не совпадает с именем пользователя. Это маловероятно, что пользователь-злоумышленник может узнать допустимый запрос, поскольку ему необходимо знать имя пользователя и идентификатор текущего подключения, созданный случайным образом. Этот идентификатор подключения становится недействительным, сразу же после завершения соединения. Анонимные пользователи не должны доступа к конфиденциальным сведениям.

<a id="recommendations"></a>

## <a name="signalr-security-recommendations"></a>Рекомендации по обеспечению безопасности SignalR

<a id="ssl"></a>

### <a name="secure-socket-layers-ssl-protocol"></a>Защищенный протокол слои сокетов (SSL)

Протокол SSL использует шифрование для защиты передачи данных между клиентом и сервером. Если приложение SignalR передает конфиденциальные данные между клиентом и сервером, используйте SSL для транспорта. Дополнительные сведения о настройке SSL см. в разделе [настройке SSL в службах IIS 7](https://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis).

<a id="groupsecurity"></a>

### <a name="do-not-use-groups-as-a-security-mechanism"></a>Не используйте группы в качестве механизма обеспечения безопасности

Группы — это удобный способ сбора связанных пользователей, но они не являются безопасный механизм для ограничения доступа к конфиденциальной информации. Это особенно важно в тех случаях, когда пользователи могут автоматически повторно присоединиться к группам во время повторного подключения. Вместо этого рассмотрите возможность добавления привилегированных пользователей роли и ограничение доступа к методу концентратора, чтобы только члены этой роли. Пример того, ограничение доступа на основе роли, см. в разделе [проверки подлинности и авторизация для концентраторов SignalR](../security/hub-authorization.md). Пример проверки доступа пользователей к группам, при повторном подключении, см. в разделе [работа с группами](../guide-to-the-api/working-with-groups.md).

<a id="input"></a>

### <a name="safely-handling-input-from-clients"></a>Безопасно обработки входных данных от клиентов

Все входные данные от клиентов, предназначенный для широковещательной передачи другим клиентам должны быть закодированы, чтобы убедиться, что пользователь-злоумышленник не отправляет скрипт другим пользователям. Рекомендуется для кодирования сообщений в принимающее клиентов, а не на сервере, так как приложение SignalR может иметь множество различных типов клиентов. Таким образом HTML-кодирование работает для веб-клиента, но не для других типов клиентов. Например, веб-клиента метод для отображения сообщения чата будет безопасно обрабатывать имя пользователя и сообщение путем вызова `html()` функции.

[!code-html[Main](introduction-to-security/samples/sample2.html?highlight=3-4)]

<a id="reconcile"></a>

### <a name="reconciling-a-change-in-user-status-with-an-active-connection"></a>Согласование изменение состояния пользователя с активным соединением

Если состояние проверки подлинности пользователя изменится, пока существует активное соединение, пользователь получит сообщение об ошибке, «удостоверение пользователя нельзя изменить во время подключения SignalR.» В этом случае приложение должно повторного подключения к серверу, чтобы убедиться, что координируются идентификатор подключения и имя пользователя. Например если приложение позволяет пользователю войти в систему пока существует активное соединение, имя пользователя для соединения больше не будет соответствовать имени, передается в следующем запросе. Будет остановить соединения, прежде чем пользователь выходит из системы и перезапустите его.

Тем не менее важно отметить, что большинство приложений будет не нужно вручную остановить и запустить подключение. Если приложение перенаправляет пользователей на отдельную страницу после входа, таких как поведение по умолчанию в приложении веб-форм или MVC-приложения или обновляет текущую страницу после выхода, активное соединение прервется автоматически и не делает требуются дополнительные действия.

В следующем примере показано, как для остановки и запуска подключения при изменении состояния пользователя.

[!code-html[Main](introduction-to-security/samples/sample3.html)]

Или, состояние проверки подлинности пользователя может измениться, если веб-сайт использует скользящий срок действия с помощью форм и активности, не следует допустимый файл cookie проверки подлинности. В этом случае пользователь будет иметь вышел из системы и имя пользователя больше не будут соответствовать имени пользователя в маркер подключения. Эту проблему можно устранить, добавив некоторые скрипт, который периодически запрашивает ресурс на веб-сервере, чтобы сохранить допустимый файл cookie проверки подлинности. В следующем примере показано, как для запроса ресурса каждые 30 минут.

[!code-javascript[Main](introduction-to-security/samples/sample4.js)]

<a id="autogen"></a>

### <a name="automatically-generated-javascript-proxy-files"></a>Автоматически созданные файлы JavaScript прокси-сервера

Если вы не хотите включать все концентраторам и методам в файле JavaScript прокси-сервера для каждого пользователя, можно отключить автоматическое создание файла. Можно выбрать этот параметр, если у вас несколько концентраторам и методам, но не каждого пользователя, которые следует учитывать все методы. Отключить автоматическое создание, задав **EnableJavaScriptProxies** для **false**.

[!code-csharp[Main](introduction-to-security/samples/sample5.cs)]

Дополнительные сведения о прокси-сервер файлы JavaScript, см. в разделе [созданный прокси и что он делает для вас](../guide-to-the-api/hubs-api-guide-javascript-client.md#genproxy). <a id="exceptions"></a>

### <a name="exceptions"></a>Исключения

Следует избегать передачи объектов исключений для клиентов, так как объекты могут содержать конфиденциальные сведения клиентов. Вместо этого можно вызовите метод на клиенте, который отображается соответствующее сообщение об ошибке.

[!code-csharp[Main](introduction-to-security/samples/sample6.cs)]
