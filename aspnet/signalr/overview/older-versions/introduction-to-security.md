---
uid: signalr/overview/older-versions/introduction-to-security
title: Общие сведения о безопасности SignalR (SignalR 1. x) | Документация Майкрософт
author: bradygaster
description: Описание проблем безопасности, которые необходимо учитывать при разработке приложения SignalR.
ms.author: bradyg
ms.date: 10/17/2013
ms.assetid: 715a4059-d307-4631-abbb-c789c95d6eb4
msc.legacyurl: /signalr/overview/older-versions/introduction-to-security
msc.type: authoredcontent
ms.openlocfilehash: 34172c0a2a15a7ab0d782704d5831ce236f5c989
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78431352"
---
# <a name="introduction-to-signalr-security-signalr-1x"></a>Общие сведения о безопасности SignalR (SignalR 1.x)

[Патрик Флетчера](https://github.com/pfletcher), [Tom фитзмаккен](https://github.com/tfitzmac)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этой статье описываются вопросы безопасности, которые необходимо учитывать при разработке приложения SignalR.

## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Основные понятия безопасности SignalR](#concepts)

    - [Аутентификация и авторизация](#authentication)
    - [Токен подключения](#connectiontoken)
    - [Повторное присоединение групп при восстановлении соединения](#rejoingroup)
- [Как SignalR предотвращает подделку межсайтовых запросов](#csrf)
- [Рекомендации по безопасности SignalR](#recommendations)

    - [Протокол SSL](#ssl)
    - [Не используйте группы в качестве механизма безопасности](#groupsecurity)
    - [Безопасная обработка входных данных от клиентов](#input)
    - [Согласование изменения состояния пользователя с активным подключением](#reconcile)
    - [Автоматически создаваемые прокси-файлы JavaScript](#autogen)
    - [Исключения](#exceptions)

<a id="concepts"></a>

## <a name="signalr-security-concepts"></a>Основные понятия безопасности SignalR

<a id="authentication"></a>

### <a name="authentication-and-authorization"></a>Аутентификация и авторизация

SignalR предназначен для интеграции с существующей структурой проверки подлинности приложения. Он не предоставляет никаких функций для проверки подлинности пользователей. Вместо этого выполняется проверка подлинности пользователей как обычно в приложении, а затем работа с результатами проверки подлинности в коде SignalR. Например, вы можете проверить подлинность пользователей с помощью ASP.NET Forms Authentication, а затем в своем центре задать, каким пользователям или ролям разрешено вызывать метод. В центре можно также передать сведения о проверке подлинности, например имя пользователя или принадлежность пользователя к роли клиенту.

SignalR предоставляет атрибут [авторизации](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.authorizeattribute(v=vs.111).aspx) , чтобы указать, какие пользователи имеют доступ к концентратору или методу. Атрибут авторизации применяется к концентратору или определенным методам в концентраторе. Без атрибута авторизовать все открытые методы в концентраторе доступны для клиента, подключенного к концентратору. Дополнительные сведения о концентраторах см. в разделе [Проверка подлинности и авторизация для концентраторов SignalR](../security/hub-authorization.md).

Атрибут `Authorize` используется только с концентраторами. Чтобы применить правила авторизации при использовании `PersistentConnection` необходимо переопределить метод `AuthorizeRequest`. Дополнительные сведения о постоянных подключениях см. в разделе [Проверка подлинности и авторизация для постоянных подключений SignalR](../security/persistent-connection-authorization.md).

<a id="connectiontoken"></a>

### <a name="connection-token"></a>Токен подключения

SignalR снижает риск выполнения вредоносных команд путем проверки удостоверения отправителя. Токен подключения, содержащий идентификатор подключения и имя пользователя для пользователей, прошедших проверку подлинности, передается между клиентом и сервером для каждого запроса. Идентификатор соединения — это уникальный идентификатор, который создается сервером случайным образом при создании нового соединения и сохраняется в течение соединения. Имя пользователя предоставляется механизмом проверки подлинности для веб-приложения. Маркер подключения защищен с помощью шифрования и цифровой подписи.

![](introduction-to-security/_static/image2.png)

Для каждого запроса сервер проверяет содержимое токена, чтобы убедиться, что запрос поступает от указанного пользователя. Имя пользователя должно соответствовать идентификатору соединения. Если проверить идентификатор подключения и имя пользователя, SignalR не позволит злоумышленнику легко олицетворять другого пользователя. Если сервер не может проверить маркер подключения, запрос завершается ошибкой.

![](introduction-to-security/_static/image4.png)

Поскольку идентификатор подключения является частью процесса проверки, не следует раскрывать идентификаторы подключения одного пользователя другим пользователям или хранить значение на клиенте, например в файле cookie.

<a id="rejoingroup"></a>

### <a name="rejoining-groups-when-reconnecting"></a>Повторное присоединение групп при восстановлении соединения

По умолчанию приложение SignalR автоматически переназначит пользователя соответствующим группам при повторном подключении из временного перерыва, например при удалении и повторном установлении соединения до истечения времени ожидания соединения. При повторном подключении клиент передает маркер группы, включающий идентификатор подключения и назначенные группы. Маркер группы имеет цифровую подпись и шифруется. Клиент оставляет тот же идентификатор подключения после повторного подключения; Таким образом, идентификатор соединения, переданный из повторно подключенного клиента, должен соответствовать предыдущему идентификатору соединения, используемому клиентом. Эта проверка не позволяет злоумышленнику передавать запросы на присоединение к неавторизованным группам при повторном подключении.

Однако важно отметить, что срок действия токена группы не истекает. Если пользователь принадлежал к группе в прошлом, но заблокирован из этой группы, этот пользователь может имитировать маркер группы, включающий группу запрещенных. Если необходимо безопасно управлять тем, какие пользователи принадлежат какой группе, необходимо сохранить эти данные на сервере, например в базе данных. Затем добавьте в приложение логику, которая проверяет на сервере принадлежность пользователя к группе. Пример проверки членства в группе см. в разделе [Работа с группами](../guide-to-the-api/working-with-groups.md).

Автоматическое повторное присоединение групп применяется только после временного перерыва подключения. Если пользователь отключится от приложения или перезапускает приложение, приложение должно будет решить, как добавить этого пользователя в правильные группы. Дополнительные сведения см. в разделе [Работа с группами](../guide-to-the-api/working-with-groups.md).

<a id="csrf"></a>

## <a name="how-signalr-prevents-cross-site-request-forgery"></a>Как SignalR предотвращает подделку межсайтовых запросов

Подделка межсайтовых запросов (CSRF) — это атака, при которой вредоносный сайт отправляет запрос на уязвимый сайт, на котором пользователь в данный момент вошел в систему. SignalR предотвращает CSRF, делая его чрезвычайно маловероятной для вредоносного сайта, чтобы создать допустимый запрос для вашего приложения SignalR.

### <a name="description-of-csrf-attack"></a>Описание атаки CSRF

Ниже приведен пример атаки CSRF.

1. Пользователь входит в `www.example.com`с использованием проверки подлинности с помощью форм.
2. Сервер проверяет подлинность пользователя. Ответ сервера включает файл cookie проверки подлинности.
3. Не выполняя выход, пользователь посещает вредоносный веб-узел. Этот вредоносный сайт содержит следующую HTML-форму: 

    [!code-html[Main](introduction-to-security/samples/sample1.html)]

   Обратите внимание, что действие формы публикует сообщение на уязвимом сайте, а не на вредоносном сайте. Это часть CSRF, связанная с "межсайт".
4. Пользователь нажимает кнопку Submit (отправить). Браузер включает файл cookie проверки подлинности с запросом.
5. Запрос выполняется на сервере example.com с помощью контекста проверки подлинности пользователя и может выполнять любые действия, которые разрешено выполнять прошедшему проверку подлинности пользователю.

Хотя в этом примере пользователь должен нажать кнопку формы, вредоносная страница может просто запустить сценарий, отправляющий запрос AJAX в приложение SignalR. Более того, использование протокола SSL не мешает CSRF атаке, так как вредоносный сайт может отправить запрос "https://".

Как правило, атаки CSRF возможны для веб-сайтов, использующих файлы cookie для проверки подлинности, так как браузеры отправляют все соответствующие файлы cookie на целевой веб-сайт. Однако атаки CSRF не ограничиваются использованием файлов cookie. Например, также уязвимы обычная и краткая проверка подлинности. После входа пользователя в систему с базовой или дайджест-проверкой подлинности браузер автоматически отправляет учетные данные, пока сеанс не завершится.

### <a name="csrf-mitigations-taken-by-signalr"></a>CSRFные решения, созданные SignalR

SignalR выполняет следующие действия, чтобы предотвратить создание вредоносным сайтом правильных запросов к приложению SignalR. Эти действия выполняются по умолчанию и не нуждаются в каких – либо действиях в коде.

- **Отключение междоменных запросов**  
 По умолчанию запросы между доменами отключены в приложении SignalR, чтобы запретить пользователям вызывать конечную точку SignalR из внешнего домена. Любой запрос, поступающий из внешнего домена, автоматически считается недопустимым и заблокирован. Рекомендуется использовать это поведение по умолчанию. в противном случае злонамеренный сайт может заставить пользователей отправлять команды на ваш сайт. Если необходимо использовать запросы между доменами, см. раздел [как установить междоменное подключение](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain) .
- **Передача токена подключения в строке запроса, а не файла cookie**  
 SignalR передает маркер подключения как значение строки запроса, а не как файл cookie. Если токен подключения не хранится как файл cookie, маркер подключения не будет случайно перенаправлен браузером при обнаружении вредоносного кода. Кроме того, маркер подключения не сохраняется за пределами текущего соединения. Таким образом, злоумышленник не может выполнить запрос под учетными данными для проверки подлинности другого пользователя.
- **Проверка токена подключения**  
 Как описано в разделе [маркера подключения](#connectiontoken) , сервер знает, какой идентификатор подключения связан с каждым аутентифицированным пользователем. Сервер не обрабатывает запросы от идентификатора соединения, который не соответствует имени пользователя. Маловероятно, что злоумышленник может угадать допустимый запрос, поскольку злоумышленнику необходимо знать имя пользователя и текущий идентификатор подключения, который был случайно сгенерирован. Идентификатор подключения становится недействительным, как только соединение будет завершено. Анонимные пользователи не должны иметь доступа к конфиденциальной информации.

<a id="recommendations"></a>

## <a name="signalr-security-recommendations"></a>Рекомендации по безопасности SignalR

<a id="ssl"></a>

### <a name="secure-socket-layers-ssl-protocol"></a>Протокол SSL

Протокол SSL использует шифрование для защиты передачи данных между клиентом и сервером. Если приложение SignalR передает конфиденциальную информацию между клиентом и сервером, используйте SSL для транспорта. Дополнительные сведения о настройке SSL см. в разделе [Настройка SSL в IIS 7](https://www.iis.net/learn/manage/configuring-security/how-to-set-up-ssl-on-iis).

<a id="groupsecurity"></a>

### <a name="do-not-use-groups-as-a-security-mechanism"></a>Не используйте группы в качестве механизма безопасности

Группы — это удобный способ сбора связанных пользователей, но они не являются безопасным механизмом для ограничения доступа к конфиденциальной информации. Это особенно справедливо, когда пользователи могут автоматически повторно присоединять группы во время переподключения. Вместо этого рассмотрите возможность добавления привилегированных пользователей к роли и ограничение доступа к методу концентратора только членами этой роли. Пример запрещения доступа на основе роли см. в разделе [Проверка подлинности и авторизация для концентраторов SignalR](../security/hub-authorization.md). Пример проверки доступа пользователей к группам при повторном подключении см. в разделе [Работа с группами](../guide-to-the-api/working-with-groups.md).

<a id="input"></a>

### <a name="safely-handling-input-from-clients"></a>Безопасная обработка входных данных от клиентов

Все входные данные от клиентов, предназначенные для передачи другим клиентам, должны быть закодированы, чтобы пользователь-злоумышленник не отправлял скрипт другим пользователям. Лучше кодировать сообщения на принимающих клиентах, а не на сервере, так как приложение SignalR может иметь много различных типов клиентов. Поэтому кодировка HTML работает для веб-клиента, но не для других типов клиентов. Например, метод веб-клиента для вывода сообщения разговора безопасно обрабатывает имя пользователя и сообщение, вызывая функцию `html()`.

[!code-html[Main](introduction-to-security/samples/sample2.html?highlight=3-4)]

<a id="reconcile"></a>

### <a name="reconciling-a-change-in-user-status-with-an-active-connection"></a>Согласование изменения состояния пользователя с активным подключением

Если состояние проверки подлинности пользователя изменяется во время существования активного подключения, пользователь получит сообщение об ошибке "не удается изменить удостоверение пользователя во время активного подключения SignalR". В этом случае приложение должно повторно подключиться к серверу, чтобы убедиться, что идентификатор подключения и имя пользователя координируются. Например, если приложение разрешает пользователю выход во время существования активного подключения, имя пользователя для соединения больше не будет совпадать с именем, переданным в качестве следующего запроса. Необходимо будет прерывать подключение до выхода пользователя из системы, а затем перезапускать его.

Однако важно отметить, что большинству приложений не придется вручную останавливаться и запускать подключение. Если приложение перенаправляет пользователей на отдельную страницу после выхода, например поведение по умолчанию в приложении веб-форм или приложения MVC или обновляет текущую страницу после выхода, активное подключение автоматически отключается и не требуется любое дополнительное действие.

В следующем примере показано, как отключить и запустить соединение при изменении состояния пользователя.

[!code-html[Main](introduction-to-security/samples/sample3.html)]

Или же состояние проверки подлинности пользователя может измениться, если сайт использует скользящий срок действия с проверкой подлинности с помощью форм, и нет активности для сохранения допустимого файла cookie проверки подлинности. В этом случае пользователь будет выходить из систему, а имя пользователя больше не будет совпадать с именем пользователя в маркере подключения. Эту проблему можно устранить, добавив скрипт, который периодически запрашивает ресурс на веб-сервере, чтобы обеспечить допустимость файла cookie проверки подлинности. В следующем примере показано, как запросить ресурс каждые 30 минут.

[!code-javascript[Main](introduction-to-security/samples/sample4.js)]

<a id="autogen"></a>

### <a name="automatically-generated-javascript-proxy-files"></a>Автоматически создаваемые прокси-файлы JavaScript

Если вы не хотите включать все концентраторы и методы в прокси-файл JavaScript для каждого пользователя, можно отключить автоматическое создание файла. Этот вариант можно выбрать, если у вас есть несколько концентраторов и методов, но не нужно, чтобы каждый пользователь знал о всех методах. Автоматическое создание отключается путем установки для **енаблежаваскриптпроксиес** значения **false**.

[!code-csharp[Main](introduction-to-security/samples/sample5.cs)]

Дополнительные сведения о прокси-файлах JavaScript см. [в разделе созданный прокси-сервер и его назначение](../guide-to-the-api/hubs-api-guide-javascript-client.md#genproxy). <a id="exceptions"></a>

### <a name="exceptions"></a>Исключения

Следует избегать передачи объектов исключений клиентам, так как объекты могут предоставлять клиентам конфиденциальную информацию. Вместо этого вызовите метод на клиенте, который отображает соответствующее сообщение об ошибке.

[!code-csharp[Main](introduction-to-security/samples/sample6.cs)]
