---
uid: signalr/overview/older-versions/tutorial-high-frequency-realtime-with-signalr
title: Высокочастотный в реальном времени с SignalR 1.x | Документация Майкрософт
author: bradygaster
description: Этом руководстве показано, как создать веб-приложения, использующего ASP.NET SignalR для предоставления функции обмена сообщениями с высокой частотой. Высокочастотный обмена сообщениями в...
ms.author: bradyg
ms.date: 04/16/2013
ms.assetid: ad2a5da5-2e79-40ea-bc84-028d327f5982
msc.legacyurl: /signalr/overview/older-versions/tutorial-high-frequency-realtime-with-signalr
msc.type: authoredcontent
ms.openlocfilehash: 179f6dd3a60f8c49770ee34af93d54defad0adc4
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59379421"
---
# <a name="high-frequency-realtime-with-signalr-1x"></a>Обмен сообщениями с высоким уровнем периодичности в режиме реального времени с помощью SignalR 1.x

по [Патрик Флетчера](https://github.com/pfletcher)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> Этом руководстве показано, как создать веб-приложения, использующего ASP.NET SignalR для предоставления функции обмена сообщениями с высокой частотой. В этом случае обмена сообщениями высокой частотой означает обновления, которые отправляются по фиксированной ставке; в случае этого приложения, не более 10 сообщений в секунду.
> 
> В этом руководстве вы создадите приложение отображает фигуры, пользователи смогут перетаскивать. Позиция фигуры в другие подключенные браузеры будут обновлены в соответствии с положение перетаскиваемого фигуры, с помощью синхронизированного обновления.
> 
> Основные понятия, представленных в этом руководстве имеют приложений в режиме реального времени играх и других приложений моделирования.
> 
> Комментарии в этом руководстве приветствуются. Если у вас есть вопросы, которые не имеют отношения к руководству, их можно разместить [форум по ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com).


## <a name="overview"></a>Обзор

Этот учебник демонстрирует создание приложения, состояние объекта с границами других браузеров в режиме реального времени. Приложения, которую мы создадим называется MoveShape. На странице MoveShape будет отображаться элемент HTML Div, который пользователь может перетащить; Когда пользователь перетаскивает элемент Div, его новая позиция будет отправляться на сервер, который затем сообщает о других подключенных клиентов обновить положение фигуры в соответствии с.

![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image1.png)

Приложение, созданное в этом руководстве основан на демонстрацию — дэмьен Эвардс. Можно увидеть видео, содержащий этой демонстрации [здесь](https://channel9.msdn.com/Series/Building-Web-Apps-with-ASP-NET-Jump-Start/Building-Web-Apps-with-ASPNET-Jump-Start-08-Real-time-Communication-with-SignalR).

Руководства запустится, где демонстрируется способ отправки сообщений SignalR из каждого события, которое возникает при перетаскивании фигуры. Каждым подключенным клиентом обновляют положение локальная версия фигуры каждый раз при получении сообщения.

Пока приложение будет работать с помощью этого метода, это не рекомендуемый модель программирования, так как бы не ограничена количеству начало отправленных сообщений, поэтому клиенты и сервер может получить перегружены сообщений и может привести к снижению производительности . Отображаемые анимации на стороне клиента также будет несвязанном, фигура будет перемещать мгновенно каждым методом, а не перемещение плавно для каждого нового расположения. Последующих разделах этого руководства мы рассмотрим, как создать функцию таймера, который ограничивает максимальную скорость, с которой сообщения отправляются с клиента или сервера, а также как плавно перемещать фигуру между расположениями. Окончательная версия приложения, созданные в этом руководстве можно загрузить из [коллекции исходных кодов](https://code.msdn.microsoft.com/SignalR-MoveShape-demo-3366dac6).

Этот учебник содержит следующие разделы:

- [Необходимые компоненты](#prerequisites)
- [Создание проекта](#createtheproject)
- [Добавьте пакеты ASP.NET SignalR и JQuery.UI NuGet](#nugetpackages)
- [Создание базового приложения](#baseapp)
- [Добавить цикл клиента](#clientloop)
- [Добавление сервера выполните циклический](#serverloop)
- [Добавление анимации на стороне клиента](#animation)
- [Дальнейшие действия](#furthersteps)

<a id="prerequisites"></a>

## <a name="prerequisites"></a>Предварительные требования

Этого учебника требуется Visual Studio 2012 или Visual Studio 2010. Если используется Visual Studio 2010, проект будет использовать .NET Framework 4, а не .NET Framework 4.5.

Если вы используете Visual Studio 2012, рекомендуется установить [обновления ASP.NET и веб-инструментами 2012.2](https://go.microsoft.com/fwlink/?LinkId=282650). Это обновление содержит новые функции, например для публикации, новые функциональные возможности и новые шаблоны.

Если у вас есть Visual Studio 2010, убедитесь, что [NuGet](https://visualstudiogallery.msdn.microsoft.com/27077b70-9dad-4c64-adcf-c7cf6bc9970c) установлен.

<a id="createtheproject"></a>

## <a name="create-the-project"></a>Создание проекта

В этом разделе мы создадим проект в Visual Studio.

1. Из **файл** меню **новый проект**.
2. В **новый проект** диалогового окна разверните узел **C#** под **шаблоны** и выберите **Web**.
3. Выберите **пустое веб-приложение ASP.NET** шаблон, имя проекта *MoveShapeDemo*и нажмите кнопку **ОК**.

    ![Создание нового проекта](tutorial-high-frequency-realtime-with-signalr/_static/image2.png)

<a id="nugetpackages"></a>

## <a name="add-the-signalr-and-jqueryui-nuget-packages"></a>Добавьте пакеты JQuery.UI NuGet и SignalR

Путем установки пакета NuGet в проект можно добавить функциональные возможности SignalR. Этом руководстве также будет использоваться пакет JQuery.UI разрешения в фигуру, чтобы перетаскивать, а анимировано.

1. Нажмите кнопку **инструменты | Диспетчер пакетов NuGet | Консоль диспетчера пакетов**.
2. Введите следующую команду в диспетчере пакетов.

    [!code-powershell[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample1.ps1)]

    Пакет SignalR устанавливает ряд других пакетах NuGet в качестве зависимостей. После завершения установки у вас есть все серверные и клиентские компоненты, необходимые для использования в приложении ASP.NET SignalR.
3. Введите следующую команду в консоли диспетчера пакетов для установки пакетов JQuery и JQuery.UI.

    [!code-powershell[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample2.ps1)]

<a id="baseapp"></a>

## <a name="create-the-base-application"></a>Создание базового приложения

В этом разделе мы создадим приложение браузера, которое отправляет расположение фигуры на сервер во время каждого события перемещения мыши. Сервер затем передает эти сведения для всех других подключенных клиентов мере их получения. Мы расширим в это приложение в следующих разделах.

1. В **обозревателе решений**, правой кнопкой мыши проект и выберите **добавить**, **класс...** . Назовите класс **MoveShapeHub** и нажмите кнопку **добавить**.
2. Замените код в новом **MoveShapeHub** класса следующим кодом.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample3.cs)]

    `MoveShapeHub` Выше класс является реализацией концентратор SignalR. Как и в [начало работы с SignalR](index.md) руководстве концентратора есть метод, который клиенты будут вызывать напрямую. В этом случае клиент передает объект, содержащий новый координаты X и Y в фигуру, чтобы на сервере, который затем возвращает широковещательная рассылка для всех других подключенных клиентов. SignalR автоматически будет сериализовать этот объект, с помощью JSON.

    Объект, который будет отправлен клиенту (`ShapeModel`) содержит члены для хранения позиции фигуры. Версия объекта на сервере также содержит член для отслеживания хранения данных какой-либо клиент, таким образом, чтобы данного клиента не будет отправлено, свои собственные данные. Использует этот член `JsonIgnore` атрибут для предотвращения сериализации и отправки клиенту.
3. Затем мы настроим концентратор при запуске приложения. В **обозревателе решений**, щелкните правой кнопкой мыши проект, а затем нажмите кнопку **Add | Глобальный класс приложения**. Примите имя по умолчанию *Global* и нажмите кнопку **ОК**.

    ![Добавление глобального класса приложения](tutorial-high-frequency-realtime-with-signalr/_static/image3.png)
4. Добавьте следующий `using` инструкции после указанных **с помощью** операторов в классе Global.asax.cs.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample4.cs)]
5. Добавьте следующую строку кода в `Application_Start` метод глобального класса, чтобы зарегистрировать маршрут по умолчанию для SignalR.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample5.cs)]

    Файл global.asax должен выглядеть следующим образом:

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample6.cs)]
6. Далее мы добавим клиента. В **обозревателе решений**, щелкните правой кнопкой мыши проект, а затем нажмите кнопку **Add | Новый элемент**. В **Добавление нового элемента** диалоговом окне выберите **HTML-страницу**. Присвойте странице соответствующее имя (например **Default.html**) и нажмите кнопку **добавить**.
7. В **обозревателе решений**, щелкните правой кнопкой мыши страницу, вы только что создали и нажмите кнопку **задать в качестве начальной страницы**.
8. Замените код по умолчанию в HTML-страницы в следующем фрагменте кода.

    > [!NOTE]
    > Убедитесь, что сценарий ссылается на ниже совпадение пакеты, добавляемые в проект в папку «скрипты». В Visual Studio 2010 версия JQuery и SignalR, добавлен в проект может не совпадать номера версий ниже.

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample7.html)]

    Приведенный выше код HTML и JavaScript создает красный Div, вызывается фигуры, включает поведение перетаскивания фигуры, с помощью библиотеки jQuery и использует фигуры `drag` событий для отправки положение фигуры на сервер.
9. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; следует переместить фигуру в окне браузера.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image4.png)

<a id="clientloop"></a>

## <a name="add-the-client-loop"></a>Добавить цикл клиента

С момента отправки расположение фигуры на каждое событие перемещения мыши создаст ненужные объема сетевого трафика, сообщения от клиента должны регулироваться. Мы будем использовать javascript `setInterval` функции, чтобы настроить цикл, который отправляет на сервер по фиксированной ставке новые сведения о положении. Этот цикл — это очень простой представление цикла «игры», многократно вызванной функции, которые можно применить все функциональные возможности игр или других моделирования.

1. Обновите код клиента в HTML-страницы для сопоставления в следующем фрагменте кода.

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample8.html)]

    Выше обновление добавляет `updateServerModel` функцию, которая вызывается с фиксированной частотой. Эта функция отправляет на сервер данные положения всякий раз, когда `moved` флаг указывает, что новые данные позиции для отправки.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; следует переместить фигуру в окне браузера. Так как будет регулировать количество сообщений, отправляемых на сервер, анимация не будет отображаться как smooth, как описано в предыдущем разделе.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image5.png)

<a id="serverloop"></a>

## <a name="add-the-server-loop"></a>Добавление сервера выполните циклический

В текущем приложении сообщения, отправленные с сервера клиенту иду так часто, как их получения. Это представляет подобную проблему, так как была обнаружена на клиенте; сообщения могут отправляться чаще, чем они нужны, и соединение может быть перегружено нежелательным в результате. В этом разделе описывается, как обновить сервер для реализации таймер, который регулирует скорость исходящих сообщений.

1. Замените содержимое файла `MoveShapeHub.cs` следующим фрагментом кода.

    [!code-csharp[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample9.cs)]

    Приведенный выше код разворачивается клиента, чтобы добавить `Broadcaster` класс, который регулирует поток исходящих сообщений с помощью `Timer` класс из .NET framework.

    Так как сам концентратор является временным (он создается каждый раз при необходимости), `Broadcaster` будут создаваться как единственный экземпляр. Чтобы отложить его создания, пока они не понадобятся, убедившись, что первый экземпляр концентратора полностью создан, прежде чем таймер запускается используется ленивая инициализация, (появился в .NET 4).

    Вызов клиентов `UpdateShape` функция затем перемещается за пределы центра `UpdateModel` метод, чтобы он больше не вызывается немедленно в том случае, когда входящие сообщения извлекаются. Вместо этого со скоростью 25 вызовов в секунду, будут отправляться сообщения для клиентов под управлением `_broadcastLoop` таймера изнутри `Broadcaster` класса.

    Наконец, вместо вызова метода клиента от концентратора напрямую, `Broadcaster` классу необходимо получить ссылку в настоящее время работы центр (`_hubContext`) с помощью `GlobalHost`.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; следует переместить фигуру в окне браузера. Не будет видимая разница в браузере из предыдущего раздела, но число сообщений, отправляемых клиенту будет возвращена.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image6.png)

<a id="animation"></a>

## <a name="add-smooth-animation-on-the-client"></a>Добавление анимации на стороне клиента

Приложения почти завершена, но можно сделать один Дополнительные улучшения, в движении фигуры на стороне клиента при переносе в ответ на сообщения сервера. Вместо того чтобы задавать положение фигуры в новое расположение, заданным на сервере, мы будем использовать библиотеку JQuery UI `animate` function для перемещения фигуры плавно между его текущим и новым позиции.

1. Обновление клиента `updateShape` метод для поиска, такие как выделенный ниже код:

    [!code-html[Main](tutorial-high-frequency-realtime-with-signalr/samples/sample10.html?highlight=35-42)]

    Приведенный выше код перемещает фигуру из старой позиции в новую, учитывая сервером в ходе анимации интервал (в данном случае 100 миллисекунд). Все предыдущие анимацию на фигуре очищается перед началом новой анимации.
2. Запустите приложение, нажав клавишу F5. Скопируйте URL-адрес страницы и вставьте его в второе окно браузера. Перетащите фигуру в одном из окна браузера; следует переместить фигуру в окне браузера. Перемещение фигуры в другом окне должны появиться менее рывками, так как его перемещение является Интерполировать во времени, а не значение один раз на входящее сообщение.

    ![Окно приложения](tutorial-high-frequency-realtime-with-signalr/_static/image7.png)

<a id="furthersteps"></a>

## <a name="further-steps"></a>Дальнейшие действия

В этом руководстве вы узнали, как запрограммировать приложение SignalR, которое отправляет сообщения с высокой частотой между клиентами и серверами. Эта парадигма связи полезен для разработки игр и других режимов моделирования, такие как [ShootR игры, созданные с помощью SignalR](http://shootr.signalr.net).

Готовое приложение, созданное в этом руководстве можно загрузить из [коллекции исходных кодов](https://code.msdn.microsoft.com/SignalR-MoveShape-demo-3366dac6).

Дополнительные сведения о концепции разработки SignalR, посетите следующие сайты SignalR исходный код и ресурсы:

- [Проект SignalR](http://signalr.net)
- [SignalR Github и примерами](https://github.com/SignalR/SignalR)
- [Вики-сайте SignalR](https://github.com/SignalR/SignalR/wiki)
