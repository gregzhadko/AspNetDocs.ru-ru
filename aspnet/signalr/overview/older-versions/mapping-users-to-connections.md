---
uid: signalr/overview/older-versions/mapping-users-to-connections
title: Сопоставление пользователей SignalR с подключениями в SignalR 1. x | Документация Майкрософт
author: bradygaster
description: В этом разделе показано, как хранить сведения о пользователях и их подключениях.
ms.author: bradyg
ms.date: 10/17/2013
ms.assetid: ebbc93a8-e6c4-4122-8e0d-3aa42293c747
msc.legacyurl: /signalr/overview/older-versions/mapping-users-to-connections
msc.type: authoredcontent
ms.openlocfilehash: 9d948495e9b8821fcb465611b6926603c3756a19
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78450000"
---
# <a name="mapping-signalr-users-to-connections-in-signalr-1x"></a>Сопоставление пользователей SignalR с подключениями в SignalR 1.x

[Патрик Флетчера](https://github.com/pfletcher), [Tom фитзмаккен](https://github.com/tfitzmac)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этом разделе показано, как хранить сведения о пользователях и их подключениях.

## <a name="introduction"></a>Введение

Каждый клиент, подключающийся к концентратору, передает уникальный идентификатор соединения. Это значение можно получить в свойстве `Context.ConnectionId` контекста концентратора. Если приложению необходимо сопоставить пользователя с идентификатором подключения и сохранить это сопоставление, можно использовать один из следующих способов.

- [Хранилище в памяти](#inmemory), например словарь
- [Группа SignalR для каждого пользователя](#groups)
- [Постоянное внешнее хранилище](#database), например таблица базы данных или хранилище таблиц Azure

Каждая из этих реализаций показана в этом разделе. Для наблюдения за состоянием подключения пользователя используются методы `OnConnected`, `OnDisconnected`и `OnReconnected` класса `Hub`.

Оптимальный подход для вашего приложения зависит от следующих факторов.

- Число веб-серверов, на которых размещено приложение.
- Требуется ли получить список подключенных в данный момент пользователей.
- Необходимость сохранения сведений о группах и пользователях при перезапуске приложения или сервера.
- Является ли причиной проблемы задержка вызова внешнего сервера.

В следующей таблице показано, какой подход подходит для этих вопросов.

|  | Более одного сервера | Получение списка подключенных в данный момент пользователей | Сохранять сведения после перезагрузки | Оптимальная производительность |
| --- | --- | --- | --- | --- |
| В памяти |  | ![](mapping-users-to-connections/_static/image1.png) |  | ![](mapping-users-to-connections/_static/image2.png) |
| Группы с одним пользователем | ![](mapping-users-to-connections/_static/image3.png) |  |  | ![](mapping-users-to-connections/_static/image4.png) |
| Постоянный, внешний | ![](mapping-users-to-connections/_static/image5.png) | ![](mapping-users-to-connections/_static/image6.png) | ![](mapping-users-to-connections/_static/image7.png) |  |

<a id="inmemory"></a>

## <a name="in-memory-storage"></a>Хранилище в памяти

В следующих примерах показано, как сохранить данные соединения и пользователя в словаре, который хранится в памяти. Словарь использует `HashSet` для хранения идентификатора соединения. В любой момент времени у пользователя может быть несколько подключений к приложению SignalR. Например, пользователь, который подключен через несколько устройств или несколько вкладок браузера, может иметь несколько идентификаторов подключения.

Если приложение завершает работу, вся информация теряется, но будет повторно заполнена при повторной установке подключений пользователями. Хранилище в памяти не работает, если в вашей среде имеется несколько веб-серверов, поскольку каждый сервер будет иметь отдельную коллекцию подключений.

В первом примере показан класс, который управляет сопоставлением пользователей с соединениями. Ключом для хэширования будет имя пользователя.

[!code-csharp[Main](mapping-users-to-connections/samples/sample1.cs)]

В следующем примере показано, как использовать класс сопоставления соединения из концентратора. Экземпляр класса хранится в имени переменной `_connections`.

[!code-csharp[Main](mapping-users-to-connections/samples/sample2.cs)]

<a id="groups"></a>

## <a name="single-user-groups"></a>Группы с одним пользователем

Вы можете создать группу для каждого пользователя, а затем отправить сообщение в эту группу, когда хотите обратиться только к этому пользователю. Имя каждой группы является именем пользователя. Если пользователь имеет более одного подключения, каждый идентификатор подключения добавляется в группу пользователя.

Не следует удалять вручную пользователя из группы при отключении пользователя. Это действие автоматически выполняется платформой SignalR.

В следующем примере показано, как реализовать однопользовательскую группу.

[!code-csharp[Main](mapping-users-to-connections/samples/sample3.cs)]

<a id="database"></a>

## <a name="permanent-external-storage"></a>Постоянное внешнее хранилище

В этом разделе показано, как использовать базу данных или хранилище таблиц Azure для хранения сведений о соединении. Этот подход работает при наличии нескольких веб-серверов, поскольку каждый веб-сервер может взаимодействовать с одним и тем же репозиторием данных. Если веб-серверы не работают или приложение перезапускается, метод `OnDisconnected` не вызывается. Таким образом, в репозитории данных могут быть записи для идентификаторов соединений, которые больше не действительны. Чтобы очистить эти потерянные записи, может потребоваться сделать недействительным любое подключение, созданное за пределами времени, относящегося к вашему приложению. Примеры в этом разделе включают значение для отслеживания при создании соединения, но не показывают, как очищать старые записи, так как это может потребоваться в качестве фонового процесса.

### <a name="database"></a>База данных

В следующих примерах показано, как хранить соединения и сведения о пользователях в базе данных. Можно использовать любую технологию доступа к данным. Однако в приведенном ниже примере показано, как определить модели с помощью Entity Framework. Эти модели сущностей соответствуют таблицам и полям базы данных. Структура данных может значительно варьироваться в зависимости от требований приложения.

В первом примере показано, как определить сущность пользователя, которая может быть связана с множеством сущностей соединения.

[!code-csharp[Main](mapping-users-to-connections/samples/sample4.cs)]

Затем из центра можно отвести отслеживание состояния каждого подключения с помощью приведенного ниже кода.

[!code-csharp[Main](mapping-users-to-connections/samples/sample5.cs)]

### <a name="azure-table-storage"></a>Хранилище таблиц Azure

Следующий пример хранилища таблиц Azure похож на пример базы данных. Она не включает все сведения, необходимые для начала работы со службой хранилища таблиц Azure. Дополнительные сведения см. [в статье Использование табличного хранилища из .NET](https://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-tables/).

В следующем примере показана сущность таблицы для хранения сведений о соединении. Он разделяет данные по имени пользователя и определяет каждую сущность по идентификатору соединения, чтобы пользователь мог в любое время иметь несколько подключений.

[!code-csharp[Main](mapping-users-to-connections/samples/sample6.cs)]

В центре вы следите за состоянием подключения каждого пользователя.

[!code-csharp[Main](mapping-users-to-connections/samples/sample7.cs)]
