---
uid: signalr/overview/older-versions/mapping-users-to-connections
title: Сопоставление пользователей SignalR с подключениями в SignalR 1.x | Документация Майкрософт
author: bradygaster
description: В этом разделе показано, как сохранить сведения о пользователях и их подключений.
ms.author: bradyg
ms.date: 10/17/2013
ms.assetid: ebbc93a8-e6c4-4122-8e0d-3aa42293c747
msc.legacyurl: /signalr/overview/older-versions/mapping-users-to-connections
msc.type: authoredcontent
ms.openlocfilehash: 75c8d2f4a102bef541195280a01d75271331dec4
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59422516"
---
# <a name="mapping-signalr-users-to-connections-in-signalr-1x"></a>Сопоставление пользователей SignalR с подключениями в SignalR 1.x

по [Флетчера Патрик](https://github.com/pfletcher), [Tom FitzMacken](https://github.com/tfitzmac)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этом разделе показано, как сохранить сведения о пользователях и их подключений.


## <a name="introduction"></a>Вступление

Каждый клиент, подключающийся к концентратору передает уникальный идентификатор соединения. Можно получить это значение в `Context.ConnectionId` свойство контекста концентратора. Если приложению требуется сопоставить пользователя с идентификатором соединения и сохранить это сопоставление, можно использовать один из следующих:

- [Хранилища in-memory](#inmemory), такие как словарь
- [Группа SignalR для каждого пользователя](#groups)
- [Постоянная, внешние хранилища](#database), например таблицы базы данных или хранилище таблиц Azure

Каждая из этих реализаций будет показано в этом разделе. Использовании `OnConnected`, `OnDisconnected`, и `OnReconnected` методы `Hub` класса для отслеживания состояния подключения пользователя.

Зависит от оптимального подхода для приложения:

- Число веб-серверов, размещение приложения.
- Нужно ли получить список подключенных пользователей.
- Нужно ли сохранять данные пользователей и групп, после перезапуска приложения или сервера.
- Задержка при вызове внешнего сервера, является ли проблема.

В следующей таблице показано, какой метод подходит для этих факторов.

|  | Более одного сервера | Получить список подключенных пользователей | Сохранять данные после перезагрузки | Оптимальной производительности |
| --- | --- | --- | --- | --- |
| In-memory |  | ![](mapping-users-to-connections/_static/image1.png) |  | ![](mapping-users-to-connections/_static/image2.png) |
| Группы в однопользовательском режиме | ![](mapping-users-to-connections/_static/image3.png) |  |  | ![](mapping-users-to-connections/_static/image4.png) |
| Постоянные, внешние | ![](mapping-users-to-connections/_static/image5.png) | ![](mapping-users-to-connections/_static/image6.png) | ![](mapping-users-to-connections/_static/image7.png) |  |

<a id="inmemory"></a>

## <a name="in-memory-storage"></a>Хранилище в памяти

Следующие примеры показывают, как сохранить сведения о соединении и пользователя в словаре, который хранится в памяти. Словарь использует `HashSet` для хранения идентификатор подключения. В любой момент пользователь может иметь несколько подключений к приложению SignalR. Например пользователь, подключенный через несколько устройств или несколько вкладок браузера будет иметь более одного идентификатор подключения.

Если приложение завершает работу, все данные теряются, но он будет повторно заполнен как пользователям восстановить свои соединения. Хранилище в памяти не работает, если в среде имеются несколько веб-сервер, поскольку каждый сервер в отдельной коллекции подключений.

В первом примере класс, который управляет сопоставление пользователей для подключения. Ключ для класса HashSet будет имя пользователя.

[!code-csharp[Main](mapping-users-to-connections/samples/sample1.cs)]

Далее примере показано, как использовать класс сопоставление подключения с помощью центра. Экземпляр класса хранится в переменной с именем `_connections`.

[!code-csharp[Main](mapping-users-to-connections/samples/sample2.cs)]

<a id="groups"></a>

## <a name="single-user-groups"></a>Группы в однопользовательском режиме

Можно создать группу для каждого пользователя и отправить сообщение в эту группу, если вы хотите связаться только этот пользователь. Имя каждой группы — это имя пользователя. Если у пользователя есть больше одного соединения, каждый идентификатор соединения добавляется к группе пользователей.

Не следует удалять вручную пользователь из группы при отключении пользователя. Это действие автоматически выполняется платформой SignalR.

Приведенный ниже показано, как реализовывать группы одного пользователя.

[!code-csharp[Main](mapping-users-to-connections/samples/sample3.cs)]

<a id="database"></a>

## <a name="permanent-external-storage"></a>Постоянная, внешнего хранилища

В этом разделе показано, как использовать хранилище таблиц Azure или базы данных для хранения сведений о соединении. Этот подход работает при наличии нескольких веб-серверов, так как каждый веб-сервер может взаимодействовать с один и тот же репозиторий данных. Если остановить веб-серверов, работает или повторного запуска приложения, `OnDisconnected` метод не вызывается. Таким образом существует возможность, что репозиторий данных будет иметь записи идентификаторов подключений, которые больше не являются допустимыми. Чтобы очистить эти потерянные записи, вы можете сделать недействительным любые соединения, который был создан за пределами периодичностью, необходимые для вашего приложения. В примерах этого раздела включают в себя значение для отслеживания при создании подключения, но не показано, как удалить старые записи, поскольку вы можете сделать это в фоновом процессе.

### <a name="database"></a>База данных

Следующие примеры показывают, как сохранить сведения о соединении и пользователя в базе данных. Можно использовать любые технологии доступа к данным; Тем не менее в приведенном ниже примере показано, как для определения моделей с помощью Entity Framework. Эти модели сущности соответствуют таблиц базы данных и полей. Структуру данных может значительно изменяться в зависимости от требований приложения.

Первый пример показано, как определить Пользовательская сущность, которая может быть связан с нескольких сущностей соединения.

[!code-csharp[Main](mapping-users-to-connections/samples/sample4.cs)]

Затем из вещей, отслеживать состояние каждого подключения с кодом, показанным ниже.

[!code-csharp[Main](mapping-users-to-connections/samples/sample5.cs)]

### <a name="azure-table-storage"></a>Хранилище таблиц Azure

В следующем примере хранилища таблиц Azure как в примере базы данных. Он не включает все сведения, которые необходимо приступить к работе со службой хранилища таблиц Azure. Сведения см. в разделе [Практическое использование табличного хранилища из .NET](https://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-tables/).

В следующем примере показано сущности таблицы для хранения сведений о соединении. Он разбивает данные по имени пользователя и определяет каждую сущность по идентификатор подключения, поэтому пользователь может иметь несколько подключений в любое время.

[!code-csharp[Main](mapping-users-to-connections/samples/sample6.cs)]

В концентраторе отслеживать состояние соединения каждого пользователя.

[!code-csharp[Main](mapping-users-to-connections/samples/sample7.cs)]
