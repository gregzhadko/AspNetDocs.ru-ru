---
uid: signalr/overview/older-versions/scaleout-in-signalr
title: Общие сведения о масштабировании в SignalR 1.x | Документация Майкрософт
author: bradygaster
description: ''
ms.author: bradyg
ms.date: 04/29/2013
ms.assetid: 3fd9f11c-799b-4001-bd60-1e70cfc61c19
msc.legacyurl: /signalr/overview/older-versions/scaleout-in-signalr
msc.type: authoredcontent
ms.openlocfilehash: 9bad72d31a0ebc491910ebb128b3b3a7fb537958
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59402691"
---
# <a name="introduction-to-scaleout-in-signalr-1x"></a>Общие сведения о масштабировании в SignalR 1.x

по [Майк Уоссон](https://github.com/MikeWasson), [Патрик Флетчера](https://github.com/pfletcher)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

Вообще говоря, существует два способа масштабировать веб-приложения: *масштаба* и *горизонтальное масштабирование*.

- Увеличить масштаб означает использование на больший сервер (или большего размера виртуальной Машины) с более ОЗУ, ЦП и т. д.
- Горизонтальное масштабирование означает добавление дополнительных серверов для обработки нагрузки.

Проблема с масштабированием в том, поспешно нажал ли ограничение на размер машины. Кроме этого вам нужно масштабировать. Тем не менее при масштабировании, клиенты могут перенаправляться на разных серверах. Клиент, который подключен к одному серверу не будет получать сообщения, отправленные с другого сервера.

![](scaleout-in-signalr/_static/image1.png)

Одним из решений является пересылки сообщений между серверами, используя компонент, называемый *объединительной платы*. С задней панели, который включен каждый экземпляр приложения отправляет сообщения объединительной плате и задней панели перенаправляет их в другие экземпляры приложения. (В области электроники, объединительной платы является группой parallel соединителей. Используя аналогию объединительной панели SignalR подключает несколько серверов.)

![](scaleout-in-signalr/_static/image2.png)

SignalR в настоящее время предоставляет три расширения:

- **Служебная шина Azure**. Служебная шина — это инфраструктура обмена сообщениями, которая позволяет компонентам для отправки сообщений в слабо связанным образом.
- **Redis**. Redis — это хранилище ключ значение в памяти. Redis поддерживает шаблона публикации/подписки («pub/sub») для отправки сообщений.
- **SQL Server**. На задней стороне SQL Server записывает сообщения в таблицы SQL. Задняя панель с компонентом Service Broker для эффективного обмена сообщениями. Тем не менее она также работает, если не включен компонент Service Broker.

Если вы развернете приложение в Azure, рассмотрите возможность использования на задней стороне служебной шины Azure. Если развертываются на ферме серверов, рассмотрите возможность SQL Server или Redis соединительных панелях.

В следующих разделах содержатся пошаговые учебники по каждой объединительной платы:

- [Масштабирование SignalR с помощью служебной шины Azure](scaleout-with-windows-azure-service-bus.md)
- [Масштабирование SignalR с помощью Redis](scaleout-with-redis.md)
- [Масштабирование SignalR с помощью SQL Server](scaleout-with-sql-server.md)

## <a name="implementation"></a>Реализация

В SignalR каждое сообщение отправляется через канал сообщений. Реализует канал сообщений [IMessageBus](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.messaging.imessagebus(v=vs.100).aspx) интерфейс, который предоставляет абстракцию публикации/подписки. Соединительных панелях работы, заменив значение по умолчанию **IMessageBus** с шиной предназначен для этой задней панели. Например, канал сообщений для Redis является [RedisMessageBus](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.redis.redismessagebus(v=vs.100).aspx), и он использует Redis [pub/sub](http://redis.io/topics/pubsub) механизм для отправки и получения сообщений.

Каждый экземпляр сервера подключается к задней панели через шину. При отправке сообщения, она переходит к задней панели и задней панели отправляет его на каждом сервере. Если сервер получает сообщение от объединительной платы, он помещает сообщение в локальном кэше. Затем сервер доставляет сообщения клиентам из своего локального кэша.

Для каждого клиентского соединения клиента выполняется в режиме чтения потока сообщений отслеживается с помощью курсора. (Курсор представляет позицию в потоке сообщений). Если клиент отключается, а затем снова подключается, шина запрашивает все сообщения, полученные после значения курсора клиента. То же самое происходит, когда соединение использует [долго опрашивающего](../getting-started/introduction-to-signalr.md#transports). После выполнения запроса долгого опроса, клиент открывает новое подключение и запрашивает сообщения, полученные после курсора.

Работает механизм курсора, даже если клиент направляется на другой сервер, на переподключение. Задняя панель учитывает всех серверов, и неважно, какой сервер, клиент подключается к.

## <a name="limitations"></a>Ограничения

Использование объединительной платы, пропускная способность максимальное сообщений является ниже, чем это, когда клиенты напрямую обмениваться данными с одного сервера узла. Том, что задней панели перенаправляет каждое сообщение на каждый узел, поэтому задней панели может стать узким местом. Является ли это ограничение проблемы зависит от приложения. Например Вот несколько типичных сценариев, SignalR.

- [Рассылка сервера](tutorial-server-broadcast-with-aspnet-signalr.md) (например, биржевые сводки): Соединительных панелях хорошо подходят для этого сценария, так как сервер определяет скорость, с которой отправляются сообщения.
- [Клиент клиент](tutorial-getting-started-with-signalr.md) (например, чат): В этом случае задней панели может быть узким местом, если количество сообщений, масштабируется с количеством клиентов; то есть если увеличивается число сообщений, присоединить пропорционально как можно большего числа клиентов.
- [В реальном времени высокой частотой](tutorial-high-frequency-realtime-with-signalr.md) (например, в режиме реального времени игры): Задняя панель не рекомендуется для этого сценария.

## <a name="enabling-tracing-for-signalr-scaleout"></a>Включение трассировки для масштабирование SignalR

Чтобы включить трассировку для соединительных панелях, добавьте следующие разделы в файл web.config в корне **конфигурации** элемент:

[!code-html[Main](scaleout-in-signalr/samples/sample1.html)]
