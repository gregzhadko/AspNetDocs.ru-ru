---
uid: signalr/overview/performance/signalr-performance
title: Производительность SignalR | Документация Майкрософт
author: bradygaster
description: Производительность SignalR
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: 3751f5e7-59db-4be0-a290-50abc24e5c84
msc.legacyurl: /signalr/overview/performance/signalr-performance
msc.type: authoredcontent
ms.openlocfilehash: b8a44f4c924c94cdfff1ce7630539b45fe269bbf
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78449862"
---
# <a name="signalr-performance"></a>Производительность SignalR

по [Патрик Флетчера](https://github.com/pfletcher)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этом разделе описывается разработка, измерение и повышение производительности в приложении SignalR.
>
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемые в этом разделе
>
>
> - [Visual Studio 2013](https://my.visualstudio.com/Downloads?q=visual%20studio%202013)
> - .NET 4.5
> - SignalR версии 2
>
>
>
> ## <a name="previous-versions-of-this-topic"></a>Предыдущие версии этого раздела
>
> Сведения о более ранних версиях SignalR см. в статье о [старых версиях](../older-versions/index.md)SignalR.
>
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
>
> Оставьте отзыв о том, как вы понравится вам в этом учебнике, и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, не связанные непосредственно с этим руководством, их можно опубликовать на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).

Последние сведения о производительности и масштабировании SignalR см. в статье [масштабирование веб-сайта в режиме реального времени с помощью ASP.NET SignalR](https://channel9.msdn.com/Events/Build/2013/3-502).

Этот раздел состоит из следующих подразделов.

- [Рекомендации по проектированию](#design)
- [Настройка сервера SignalR для повышения производительности](#tuning)
- [Устранение проблем с производительностью](#troubleshooting)
- [Использование счетчиков производительности SignalR](#perfcounters)
- [Использование других счетчиков производительности](#othercounters)
- [Другие ресурсы](#otherresources)

<a id="design"></a>

## <a name="design-considerations"></a>Рекомендации по проектированию

В этом разделе описываются шаблоны, которые могут быть реализованы во время разработки приложения SignalR, чтобы избежать снижения производительности, создавая ненужный сетевой трафик.

### <a name="throttling-message-frequency"></a>Частота сообщений регулирования

Даже в приложении, которое отправляет сообщения с высокой частотой (например, с игровым приложением реального времени), большинству приложений не требуется отправлять в секунду несколько сообщений. Чтобы уменьшить объем трафика, создаваемого каждым клиентом, можно реализовать цикл обработки сообщений, который помещает очереди и отправляет сообщения не чаще, чем фиксированная скорость (то есть до определенного числа сообщений будет отправляться каждую секунду, если в это время есть сообщения в тервал для отправки). Пример приложения, который регулирует сообщения до определенной скорости (от клиента и сервера), см. в разделе [Высокая частота в реальном времени с SignalR](../getting-started/tutorial-high-frequency-realtime-with-signalr.md).

### <a name="reducing-message-size"></a>Уменьшение размера сообщения

Можно уменьшить размер сообщения SignalR, уменьшив размер сериализованных объектов. В серверном коде при отправке объекта, содержащего свойства, которые не требуется передавать, запретите сериализацию этих свойств с помощью атрибута `JsonIgnore`. Имена свойств также хранятся в сообщении. имена свойств можно сократить с помощью атрибута `JsonProperty`. В следующем примере кода показано, как исключить свойство из отправки клиенту и как сократить имена свойств:

**Серверный код .NET, демонстрирующий атрибут Жсонигноре для исключения данных из отправки клиенту, а атрибут JsonProperty — для уменьшения размера сообщения.**

[!code-csharp[Main](signalr-performance/samples/sample1.cs?highlight=5,7,10)]

Чтобы сохранить удобочитаемость и удобство сопровождения в клиентском коде, сокращенные имена свойств можно повторно сопоставить с понятными именами после получения сообщения. В следующем примере кода демонстрируется один из возможных способов повторного сопоставления сокращенных имен с более длинными, путем определения контракта сообщения (сопоставления) и использования функции `reMap` для применения контракта к оптимизированному классу сообщений:

**Код JavaScript на стороне клиента, который повторно сопоставляет сокращенные имена свойств с понятными для человека именами.**

[!code-javascript[Main](signalr-performance/samples/sample2.js)]

Имена можно также сократить в сообщениях от клиента на сервере, используя тот же метод.

Уменьшение объема памяти (т. е. объема памяти, используемого для сообщения) объекта Message также может повысить производительность. Например, если полный диапазон `int` не требуется, вместо него можно использовать `short` или `byte`.

Так как сообщения хранятся в памяти сервера в шине сообщений, уменьшение размера сообщений может также привести к проблемам с памятью сервера.

<a id="tuning"></a>

### <a name="tuning-your-signalr-server-for-performance"></a>Настройка сервера SignalR для повышения производительности

Следующие параметры конфигурации можно использовать для настройки сервера для повышения производительности в приложении SignalR. Общие сведения о том, как повысить производительность приложения ASP.NET, см. в разделе [улучшение производительности ASP.NET](https://msdn.microsoft.com/library/ff647787.aspx).

**Параметры конфигурации SignalR**

- **Дефаултмессажебуфферсизе**: по умолчанию signalr поддерживает 1000 сообщений в памяти на каждый концентратор на каждое соединение. Если используются большие сообщения, это может привести к возникновению проблем с памятью, которые можно сократить, уменьшив это значение. Этот параметр можно задать в обработчике `Application_Start` событий в приложении ASP.NET или в методе `Configuration` класса запуска OWIN в собственном приложении. В следующем примере показано, как уменьшить это значение, чтобы уменьшить объем памяти, занимаемый приложением, чтобы сократить используемую память сервера:

    **Серверный код .NET в Startup.cs для уменьшения размера буфера сообщений по умолчанию**

    [!code-csharp[Main](signalr-performance/samples/sample3.cs)]

**Параметры конфигурации IIS**

- **Максимальное число одновременных запросов на приложение**: увеличение числа одновременных запросов IIS увеличит количество ресурсов сервера, доступных для обслуживания запросов. Значение по умолчанию — 5000; чтобы увеличить этот параметр, выполните следующие команды в командной строке с повышенными привилегиями:

    [!code-console[Main](signalr-performance/samples/sample4.cmd)]
- **ApplicationPool QueueLength**. это максимальное число запросов, которые очереди HTTP. sys для пула приложений. Когда очередь заполнена, новые запросы получают ответ 503 "Служба недоступна". Значение по умолчанию ― 1000.

    Сокращение длины очереди рабочего процесса в пуле приложений, в котором размещается приложение, приведет к экономии ресурсов памяти. Дополнительные сведения см. в разделе [Управление, Настройка и настройка пулов приложений](https://technet.microsoft.com/library/cc745955.aspx).

**Параметры конфигурации ASP.NET**

В этом разделе содержатся параметры конфигурации, которые можно задать в файле `aspnet.config`. Этот файл находится в одном из двух расположений в зависимости от платформы:

- `%windir%\Microsoft.NET\Framework\v4.0.30319\aspnet.config`
- `%windir%\Microsoft.NET\Framework64\v4.0.30319\aspnet.config`

Параметры ASP.NET, которые могут улучшить производительность SignalR, включают следующее:

- **Максимальное число одновременных запросов на ЦП**: увеличение этого значения может привести к снижению узких мест производительности. Чтобы увеличить этот параметр, добавьте следующий параметр конфигурации в файл `aspnet.config`:

    [!code-xml[Main](signalr-performance/samples/sample5.xml?highlight=4)]
- **Ограничение очереди запросов**: Если общее число соединений превышает значение параметра `maxConcurrentRequestsPerCPU`, ASP.NET начнет регулирование запросов с помощью очереди. Чтобы увеличить размер очереди, можно увеличить значение параметра `requestQueueLimit`. Для этого добавьте следующий параметр конфигурации в узел `processModel` в `config/machine.config` (а не `aspnet.config`):

    [!code-xml[Main](signalr-performance/samples/sample6.xml)]

<a id="troubleshooting"></a>

## <a name="troubleshooting-performance-issues"></a>Устранение проблем с производительностью

В этом разделе описываются способы поиска узких мест производительности в приложении.

### <a name="verifying-that-websocket-is-being-used"></a>Проверка использования WebSocket

Хотя SignalR может использовать разнообразные транспорты для обмена данными между клиентом и сервером, WebSocket обеспечивает значительное преимущество в производительности и следует использовать, если клиент и сервер его поддерживают. Чтобы определить, соответствуют ли клиент и сервер требованиям WebSocket, см. раздел [транспорты и резервные](../getting-started/introduction-to-signalr.md#transports)серверы. Чтобы определить, какой транспорт используется в приложении, можно использовать средства разработчика браузера и просмотреть журналы, чтобы узнать, какой транспорт используется для подключения. Сведения об использовании средств разработки браузеров в Internet Explorer и Chrome см. в статье [транспорты и резервные стратегии](../getting-started/introduction-to-signalr.md#transports).

<a id="perfcounters"></a>

## <a name="using-signalr-performance-counters"></a>Использование счетчиков производительности SignalR

В этом разделе описывается включение и использование счетчиков производительности SignalR, найденных в пакете `Microsoft.AspNet.SignalR.Utils`.

### <a name="installing-signalrexe"></a>Установка SignalR. exe

Счетчики производительности можно добавить на сервер с помощью служебной программы SignalR. exe. Чтобы установить эту программу, выполните следующие действия.

1. В Visual Studio выберите **инструменты** > **диспетчер пакетов NuGet** > **Управление пакетами NuGet для решения**
2. Найдите **SignalR. utils**и нажмите кнопку установить.

    ![](signalr-performance/_static/image1.png)
3. Примите условия лицензионного соглашения, чтобы установить пакет.
4. SignalR. exe будет установлен для `<project folder>/packages/Microsoft.AspNet.SignalR.Utils.<version>/tools`.

### <a name="installing-performance-counters-with-signalrexe"></a>Установка счетчиков производительности с помощью SignalR. exe

Чтобы установить счетчики производительности SignalR, запустите SignalR. exe в командной строке с повышенными привилегиями со следующим параметром:

[!code-console[Main](signalr-performance/samples/sample7.cmd)]

Чтобы удалить счетчики производительности SignalR, запустите SignalR. exe в командной строке с повышенными привилегиями со следующим параметром:

[!code-console[Main](signalr-performance/samples/sample8.cmd)]

### <a name="signalr-performance-counters"></a>Счетчики производительности SignalR

Пакет служебных программ устанавливает следующие счетчики производительности. Счетчик "всего" измеряет количество событий, произошедших с момента последнего перезапуска сервера или пула приложений.

**Метрики подключения**

Следующие метрики измеряют происходящие события времени существования соединения. Дополнительные сведения см. в разделе [Основные сведения и обработка событий времени жизни соединения](../guide-to-the-api/handling-connection-lifetime-events.md).

- **Подключено подключений**
- **Подключения повторно подключены**
- **Подключения отключены**
- **Текущих подключений**

**Метрики сообщений**

Следующие метрики измеряют трафик сообщений, создаваемый SignalR.

- **Всего получено сообщений подключения**
- **Всего Отправлено сообщений подключения**
- **Получено сообщений о соединении/с**
- **Отправлено сообщений о соединении/с**

**Метрики шины сообщений**

Следующие метрики измеряют трафик через внутреннюю шину сообщений SignalR, очередь, в которой размещаются все входящие и исходящие сообщения SignalR. Сообщение **публикуется** во время отправки или вещания. **Подписчик** в этом контексте является подпиской на канале сообщений; Это число должно равняться числу клиентов плюс сам сервер. **Выделенный рабочий процесс** — это компонент, который отправляет данные в активные соединения; **занятая рабочая роль** — это одна из них, которая активно отправляет сообщение.

- **Всего получено сообщений в шине сообщений**
- **Получено сообщений в шине сообщений/с**
- **Всего опубликованных сообщений в шине сообщений**
- **Опубликовано сообщений в шине сообщений/с**
- **Текущие подписчики шины сообщений**
- **Всего подписчиков на шину сообщений**
- **Подписчиков шины сообщений/с**
- **Выделенные рабочие процессы шины сообщений**
- **Рабочие процессы, занятые шиной сообщений**
- **Актуальные разделы шины сообщений**

**Метрики ошибок**

Следующие метрики измеряют ошибки, создаваемые трафиком сообщений SignalR. Ошибки **разрешения концентратора** возникают, когда не удается разрешить концентратор или метод концентратора. Ошибки **вызова концентратора** — это исключения, возникающие при вызове метода концентратора. Ошибки **транспорта** — это ошибки соединения, возникающие во время HTTP-запроса или ответа.

- **Ошибки: все итоги**
- **Ошибок: "всего/с"**
- **Ошибки: общее разрешение концентратора**
- **Ошибки: разрешение концентратора/с**
- **Ошибки: всего вызовов концентратора**
- **Ошибки: вызов концентратора/с**
- **Ошибки: всего транспортных**
- **Ошибки: транспорт/с**

<a id="scaleout_metrics"></a>

**Метрики масштабирования**

Следующие метрики измеряют трафик и ошибки, созданные поставщиком масштабирования. **Поток** в этом контексте — это единица масштабирования, используемая поставщиком масштабирования; Это таблица, если используется SQL Server, раздел, если используется служебная шина, и подписка, если используется Redis. Каждый поток обеспечивает упорядоченные операции чтения и записи; один поток является потенциальным узким местом в масштабе, поэтому количество потоков можно увеличить, чтобы снизить эту узкие места. Если используется несколько потоков, SignalR автоматически распределяет сообщения (сегменты) по этим потокам таким образом, чтобы сообщения, отправленные из любого подключения, были в порядке.

Параметр [макскуеуеленгс](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.messaging.scaleoutconfiguration.maxqueuelength(v=vs.118).aspx) управляет длиной очереди отправки scaleing, обслуживаемой SignalR. Если задать для него значение больше 0, все сообщения в очереди отправки будут отправляться по одному в настроенную объединительную плату обмена сообщениями. Если размер очереди превышает заданную длину, последующие вызовы Send немедленно завершаются сбоем с исключением [InvalidOperationException](https://msdn.microsoft.com/library/system.invalidoperationexception(v=vs.118).aspx) , пока число сообщений в очереди не станет меньше значения параметра. Очередь по умолчанию отключена, так как реализованные объединительные платы обычно имеют собственные очереди или управление потоком. В случае SQL Server пул соединений эффективно ограничивает количество отправок, которые будут отправляться в любое время.

По умолчанию для SQL Server и Redis используется только один поток, пять потоков используются для служебной шины, а очередь отключается, но эти параметры можно изменить с помощью настройки в SQL Server и служебной шине:

**Серверный код .NET для настройки числа таблиц и длины очереди для SQL Serverной объединительной платы**

[!code-csharp[Main](signalr-performance/samples/sample9.cs)]

**Серверный код .NET для настройки числа разделов и длины очереди для объединительной платы служебной шины**

[!code-csharp[Main](signalr-performance/samples/sample10.cs)]

Поток **буферизации** — это тот, который перешел в состояние сбоя. Если поток находится в состоянии сбоя, все сообщения, отправленные на объединительную плату, будут завершаться сбоем сразу, пока поток не завершится ошибкой. **Длина очереди отправки** — это количество сообщений, которые были отправлены, но еще не отправлены.

- **Получено сообщений в канале масштабирования сообщений в секунду**
- **Всего потоков масштабирования**
- **Открытие потоков масштабирования**
- **Буферизация потоков с масштабированием**
- **Всего ошибок масштабирования**
- **Ошибок масштабирования/с**
- **Длина очереди отправки при увеличении**

Дополнительные сведения об измерении этих счетчиков см. в разделе [масштабирование SignalR с помощью служебной шины Azure](scaleout-with-windows-azure-service-bus.md).

<a id="othercounters"></a>

## <a name="using-other-performance-counters"></a>Использование других счетчиков производительности

Следующие счетчики производительности также могут быть полезны при наблюдении за производительностью приложения.

**Память**

- Память CLR .NET\\байт во всех кучах (для w3wp)

**ASP.NET**

- Текущий ASP. NET \ запросов
- ASP.NET\Queued
- ASP.NET\Rejected

**ЦП**

- Время Информатион\процессор процессора

**TCP/IP**

- TCPv6/подключения установлены
- TCPv4/подключения установлены

**Веб-служба**

- Подключения к веб-служба \ текущих
- Подключения к веб-Сервице\максимум

**Работа с потоками**

- Блокировки CLR .NET и потоки\\число текущих логических потоков
- Блокировки CLR .NET и потоки\\количество текущих физических потоков

<a id="otherresources"></a>

## <a name="other-resources"></a>Другие ресурсы

Дополнительные сведения о мониторинге производительности ASP.NET и настройке см. в следующих разделах:

- [Общие сведения о производительности ASP.NET](https://msdn.microsoft.com/library/cc668225(v=vs.100).aspx)
- [Использование потоков ASP.NET в IIS 7,5, IIS 7,0 и IIS 6,0](https://blogs.msdn.com/b/tmarq/archive/2007/07/21/asp-net-thread-usage-on-iis-7-0-and-6-0.aspx)
- [Элемент &lt;applicationPool&gt; (веб-параметры)](https://msdn.microsoft.com/library/dd560842.aspx)
