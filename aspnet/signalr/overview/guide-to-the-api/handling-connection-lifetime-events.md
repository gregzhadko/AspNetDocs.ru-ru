---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Основные сведения и обработка событий времени жизни подключения в SignalR | Документация Майкрософт
author: bradygaster
description: В этой статье описывается, как использовать события, предоставляемые API концентраторов.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78467424"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a>Общие сведения и обработка событий времени существования подключений в SignalR

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этой статье приводятся общие сведения о событиях подключения, повторного подключения и отсоединении SignalR, которые можно настроить, а также о параметрах времени ожидания и активности, которые можно настраивать.
>
> В этой статье предполагается, что у вас уже есть знания о событиях SignalR и времени жизни подключения. Общие сведения о SignalR см. в статье [Общие сведения](../getting-started/introduction-to-signalr.md)о SignalR. Список событий времени жизни подключения см. в следующих ресурсах:
>
> - [Как управлять событиями времени жизни соединения в классе HUB](hubs-api-guide-server.md#connectionlifetime)
> - [Как управлять событиями времени жизни соединения в клиентах JavaScript](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [Как управлять событиями времени жизни соединения в клиентах .NET](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемые в этом разделе
>
>
> - [Visual Studio 2017](https://visualstudio.microsoft.com/downloads/)
> - .NET 4.5
> - SignalR версии 2
>
>
>
> ## <a name="previous-versions-of-this-topic"></a>Предыдущие версии этого раздела
>
> Сведения о более ранних версиях SignalR см. в статье о [старых версиях](../older-versions/index.md)SignalR.
>
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
>
> Оставьте отзыв о том, как вы понравится вам в этом учебнике, и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, не связанные непосредственно с этим руководством, их можно опубликовать на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).

## <a name="overview"></a>Обзор

Эта статья состоит из следующих разделов:

- [Терминология и сценарии времени жизни подключения](#terminology)

    - [Подключения SignalR, транспортные подключения и физические подключения](#signalrvstransport)
    - [Сценарии отключения транспорта](#transportdisconnect)
    - [Сценарии отключения клиента](#clientdisconnect)
    - [Сценарии отключения сервера](#serverdisconnect)
- [Параметры времени ожидания и KeepAlive](#timeoutkeepalive)

    - [ConnectionTimeout](#connectiontimeout)
    - [дисконнекттимеаут](#disconnecttimeout)
    - [Проверки](#keepalive)
    - [Изменение параметров времени ожидания и активности](#changetimeout)
- [Уведомление пользователя о отключении](#notifydisconnect)
- [Непрерывное повторное подключение](#continuousreconnect)
- [Отключение клиента в серверном коде](#disconnectclientfromserver)
- [Определение причины отключения](#detectingreasonfordisconnection)

Ссылки на справочные статьи по API относятся к версии .NET 4,5 API. Если вы используете .NET 4, см. [статьи с описанием API для .NET 4](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a>Терминология и сценарии времени жизни подключения

Обработчик событий `OnReconnected` в концентраторе SignalR может выполняться непосредственно после `OnConnected`, но не после `OnDisconnected` для данного клиента. Причина, по которой можно установить соединение без отключения, заключается в наличии нескольких способов использования слова "Connection" в SignalR.

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a>Подключения SignalR, транспортные подключения и физические подключения

В этой статье будут различны *подключения SignalR*, *транспортные подключения*и *физические подключения*.

- **Подключение SignalR** — это логическая связь между клиентом и URL-адресом сервера, обслуживаемая API SignalR и уникально идентифицируемая по идентификатору соединения. Данные об этой связи обслуживаются SignalR и используются для установления транспортного соединения. Связь завершается и SignalR уничтожает данные, когда клиент вызывает метод `Stop` или достигается предельное время ожидания, когда SignalR пытается восстановить потерянное транспортное соединение.
- **Транспортное соединение** — это логическая связь между клиентом и сервером, обслуживаемая одним из четырех транспортных API-интерфейсов: WebSockets, серверные события, бесконечный кадр или длительный опрос. SignalR использует транспортный интерфейс API для создания транспортного соединения, а API транспорта зависит от наличия физического сетевого подключения для создания транспортного соединения. Транспортное соединение завершается, когда SignalR завершает его работу или если транспортный API обнаруживает, что физическое подключение разорвано.
- **Физическое подключение** относится к физическим сетевым связям — беспроводным, радиосигналам, маршрутизаторам и т. д., которые упрощают обмен данными между клиентским компьютером и компьютером сервера. Для установления транспортного соединения должно присутствовать физическое подключение, а для установления соединения SignalR должно быть установлено транспортное соединение. Однако разрыв физического подключения не всегда немедленно завершает подключение транспорта или подключение SignalR, как будет объяснено далее в этом разделе.

На следующей схеме подключение SignalR представлено API концентраторов и уровнем SignalR API Персистентконнектион, транспортное соединение представлено уровнем транспорта, а физическое соединение представляется линиями между сервером. и клиентов.

![Схема архитектуры SignalR](handling-connection-lifetime-events/_static/image1.png)

При вызове метода `Start` в клиенте SignalR вы предоставляете коду клиента SignalR все необходимые сведения для установления физического подключения к серверу. Клиентский код SignalR использует эти сведения для выполнения HTTP-запроса и установления физического соединения, использующего один из четырех транспортных методов. В случае сбоя транспортного соединения или сбоя сервера подключение SignalR не происходит немедленно, так как у клиента все еще есть сведения, необходимые для автоматического повторного создания нового транспортного соединения с одним и тем же URL-адресом SignalR. В этом случае вмешательство пользователя из пользовательского приложения не происходит, и когда код клиента SignalR устанавливает новое транспортное соединение, он не запускает новое подключение SignalR. Непрерывность соединения SignalR отражается на том факте, что идентификатор соединения, который создается при вызове метода `Start`, не изменяется.

Обработчик событий `OnReconnected` в концентраторе выполняется, когда транспортное соединение автоматически повторно устанавливается после потери. Обработчик событий `OnDisconnected` выполняется в конце соединения SignalR. Подключение SignalR может завершиться любым из следующих способов:

- Если клиент вызывает метод `Stop`, на сервер отправляется сообщение об ошибке, и клиент и сервер завершают подключение SignalR немедленно.
- После потери соединения между клиентом и сервером клиент пытается повторно подключиться, и сервер ожидает повторного подключения клиента. Если попытки повторного подключения завершаются неудачей и время ожидания отключения истекло, то клиент и сервер завершают подключение SignalR. Клиент прекращает попытки повторного подключения, а сервер уничтожает его представление о подключении SignalR.
- Если клиент прекращает выполнение без возможности вызова метода `Stop`, сервер ожидает повторного подключения клиента, а затем завершает подключение SignalR после истечения времени ожидания отключения.
- Если сервер перестает работать, клиент пытается повторно подключиться (заново создать транспортное соединение), а затем завершает подключение SignalR после истечения времени ожидания отключения.

При отсутствии проблем с подключением пользовательское приложение завершает подключение SignalR, вызывая метод `Stop`, подключение SignalR и начало и конец транспортного соединения. В следующих разделах более подробно описаны другие сценарии.

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a>Сценарии отключения транспорта

Физические подключения могут быть слишком высокой, иначе могут возникнуть перерывы в связи. В зависимости от таких факторов, как продолжительность прерывания, транспортное соединение может быть удалено. Затем SignalR пытается повторно установить транспортное соединение. Иногда интерфейс транспортного подключения обнаруживает прерывание и удаляет транспортное соединение, а SignalR сразу же обнаруживает, что подключение потеряно. В других сценариях ни API транспортного подключения, ни SignalR не сообщают о том, что подключение потеряно. Для всех транспортов, за исключением длительного опроса, клиент SignalR использует функцию *KeepAlive* для проверки потери подключения, которую транспортный API не удается обнаружить. Сведения о длительных подключениях см. в подразделе [Параметры времени ожидания и KeepAlive](#timeoutkeepalive) далее в этой статье.

Если соединение неактивно, периодически сервер отправляет клиенту пакет KeepAlive. Начиная с даты написания этой статьи периодичность по умолчанию составляет 10 секунд. Прослушивая эти пакеты, клиенты могут определить, существует ли проблема с подключением. Если пакет KeepAlive не получен, когда он ожидается, через некоторое время клиент считает, что возникают проблемы с подключением, например медленная работа или прерывания. Если KeepAlive по-прежнему не получается через более длительное время, клиент предполагает, что соединение было разорвано и начинается попытка повторного подключения.

На следующей схеме показаны события клиента и сервера, которые возникают в типичном сценарии при возникновении проблем с физическим подключением, которые не распознаются API транспорта немедленно. Схема применяется к следующим обстоятельствам.

- Транспорт — это WebSocket, бесконечный кадр или события, отправленные сервером.
- В физическом сетевом подключении есть различные периоды прерывания.
- Транспортный API не знает о прерываниях, поэтому для их обнаружения SignalR полагается на функцию KeepAlive.

![Отключения транспорта](handling-connection-lifetime-events/_static/image2.png)

Если клиент переходит в режим повторного подключения, но не может установить транспортное соединение в течение времени ожидания разъединения, сервер прерывает подключение SignalR. В этом случае сервер выполняет метод `OnDisconnected` концентратора и помещает в очередь сообщение об отключении для отправки клиенту в случае, если клиент управляет подключением позже. Если клиент затем выполняет повторное соединение, он получает команду Disconnect и вызывает метод `Stop`. В этом сценарии `OnReconnected` не выполняется при повторном подключении клиента, и `OnDisconnected` не выполняется, когда клиент вызывает `Stop`. Этот сценарий показан на следующей схеме.

![Перебои в транспортировке — время ожидания сервера](handling-connection-lifetime-events/_static/image3.png)

События времени жизни подключения SignalR, которые могут быть вызваны на клиенте, следующие:

- `ConnectionSlow`ное событие клиента.

    Вызывается, когда с момента получения последнего сообщения или проверки связи KeepAlive прошло предустановленная доля времени ожидания KeepAlive. Период предупреждения о времени ожидания проверки активности по умолчанию равен 2/3 времени ожидания KeepAlive. Время ожидания KeepAlive составляет 20 секунд, поэтому предупреждение возникает примерно через 13 секунд.

    По умолчанию сервер отправляет проверки связи на KeepAlive каждые 10 секунд, а клиент проверяет наличие проверок связи для проверки активности примерно каждые 2 секунды (третья из различий между значением времени ожидания KeepAlive и значением предупреждения о времени ожидания KeepAlive).

    Если транспортный API сообщает об отсутствии соединения, то SignalR может быть уведомлен о соединении до того, как будет пройден период предупреждения об истечении времени ожидания KeepAlive. В этом случае событие `ConnectionSlow` не будет вызвано, а SignalR перейдет непосредственно к событию `Reconnecting`.
- `Reconnecting`ное событие клиента.

    Вызывается, когда (a) транспортный API обнаруживает, что соединение потеряно, или (б) время ожидания KeepAlive прошло с момента получения последнего сообщения или проверки связи с KeepAlive. Код клиента SignalR начинает попытки повторно подключиться. Это событие можно решить, если требуется, чтобы приложение заработало какие-либо действия при потере транспортного соединения. Время ожидания проверки активности по умолчанию составляет 20 секунд.

    Если клиентский код пытается вызвать метод концентратора, когда SignalR находится в режиме повторного подключения, SignalR попытается отправить команду. В большинстве случаев такие попытки завершатся ошибкой, но в некоторых обстоятельствах они могут завершиться успешно. Для событий, отправленных сервером, непрерывных кадров и длительных опросов, SignalR использует два канала связи, один из которых используется для отправки сообщений, а другой — для получения сообщений. Канал, используемый для получения, является безвозвратным открытым, и это тот, который закрывается при прерывании физического подключения. Канал, используемый для отправки, остается доступным, поэтому при восстановлении физического подключения вызов метода от клиента к серверу может быть успешным до восстановления канала получения. Возвращаемое значение не будет получено, пока SignalR повторно не откроет канал, используемый для приема.
- `Reconnected`ное событие клиента.

    Возникает при восстановлении транспортного соединения. Обработчик событий `OnReconnected` в концентраторе выполняется.
- событие `Closed` клиента (событие`disconnected` в JavaScript).

    Возникает, когда истекает время ожидания отключения, пока клиентский код SignalR пытается повторно подключиться после потери транспортного соединения. Время ожидания отключения по умолчанию составляет 30 секунд. (Это событие также возникает, когда соединение завершается из-за вызова метода `Stop`.)

Соединения транспорта, которые не обнаруживаются транспортным ИНТЕРФЕЙСом транспорта, и не задерживают получение проверок связи для проверки активности с сервера дольше, чем период предупреждения об истечении времени ожидания, может не привести к возникновению каких-либо событий времени жизни соединения.

Некоторые сетевые среды намеренно закрывают неактивные подключения, а еще одна функция пакетов KeepAlive заключается в предотвращении этой ситуации, разрешая этим сетям знание того, что подключение SignalR используется. В экстремальных случаях частота по умолчанию для проверки связи по KeepAlive может быть недостаточной для предотвращения закрытых соединений. В этом случае можно настроить отправку проверок связи для проверки активности. Дополнительные сведения см. в подразделе [Параметры времени ожидания и KeepAlive](#timeoutkeepalive) далее в этой статье.

> [!NOTE]
>
> **Важно**. последовательность событий, описанных здесь, не гарантируется. SignalR делает каждую попытку создавать события времени жизни соединения предсказуемым образом в соответствии с этой схемой, но существует множество разновидностей сетевых событий и многих способов, с помощью которых базовые платформы связи, такие как транспортные интерфейсы API, обрабатывают их. Например, событие `Reconnected` может не вызываться при повторном подключении клиента, или если попытка установить соединение завершается неудачей, может запуститься обработчик `OnConnected` на сервере. В этом разделе описываются только те эффекты, которые обычно производятся в некоторых типичных обстоятельствах.

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a>Сценарии отключения клиента

В клиенте браузера код клиента SignalR, поддерживающий подключение SignalR, выполняется в контексте JavaScript веб-страницы. Именно поэтому подключение SignalR должно закончиться при переходе с одной страницы на другую, и вот почему у вас есть несколько соединений с несколькими идентификаторами подключений при подключении из нескольких окон или вкладок браузера. Когда пользователь закрывает окно или вкладку браузера либо переходит на новую страницу или обновляет страницу, подключение SignalR немедленно завершается, так как клиентский код SignalR обрабатывает это событие браузера и вызывает метод `Stop`. В этих сценариях или на любой клиентской платформе, когда приложение вызывает метод `Stop`, обработчик событий `OnDisconnected` немедленно выполняется на сервере, а клиент вызывает событие `Closed` (событие называется `disconnected` в JavaScript).

Если клиентское приложение или компьютер, на котором оно выполняется, зависает или переходит в спящий режим (например, когда пользователь закрывает переносной компьютер), сервер не получает сведений о том, что произошло. Как только сервер знает, потери клиента могут быть вызваны прерыванием подключения, и клиент может пытаться повторно подключиться. Таким образом, в этих сценариях сервер ожидает, чтобы клиент получил возможность повторного подключения, а `OnDisconnected` не выполняется до истечения времени ожидания отключения (по умолчанию около 30 секунд). Этот сценарий показан на следующей схеме.

![Сбой клиентского компьютера](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a>Сценарии отключения сервера

Когда сервер переходит в автономный режим, он перезапускается, завершается с ошибкой, перезапускается домен приложения и т. д. — результат может быть похож на потерянное подключение, или API транспорта и SignalR могут сразу же выяснить, что сервер отсутствует, и SignalR может начать попытки повторного подключения, не вызывая событие `ConnectionSlow`. Если клиент переключается в режим повторного подключения и сервер восстанавливается или перезапускается, а новый сервер переходит в режим «в сети» до истечения времени ожидания отключения, клиент повторно подключится к восстановленному или новому серверу. В этом случае подключение SignalR будет продолжаться на клиенте и будет вызвано событие `Reconnected`. На первом сервере `OnDisconnected` никогда не выполняется, и на новом сервере `OnReconnected` выполняется, несмотря на то, что `OnConnected` ранее не выполнялся для этого клиента на этом сервере. (Результат аналогичен, если клиент повторно подключится к тому же серверу после перезапуска или очистки домена приложений, так как при перезапуске сервера он не имеет памяти.) На следующей схеме предполагается, что транспортный API немедленно сообщает о потерянном соединении, поэтому событие `ConnectionSlow` не возникает.

![Сбой и повторное подключение сервера](handling-connection-lifetime-events/_static/image5.png)

Если сервер не будет доступен в течение времени ожидания отключения, подключение SignalR завершается. В этом сценарии событие `Closed` (`disconnected` на клиентах JavaScript) вызывается на клиенте, но `OnDisconnected` никогда не вызывается на сервере. На следующей схеме предполагается, что транспортный интерфейс API не знает о потерянном соединении, поэтому он обнаруживается функцией проверки активности SignalR и вызывается событие `ConnectionSlow`.

![Сбой и время ожидания сервера](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a>Параметры времени ожидания и KeepAlive

Значения `ConnectionTimeout`, `DisconnectTimeout`и `KeepAlive` по умолчанию подходят для большинства сценариев, но их можно изменить, если в вашей среде есть особые потребности. Например, если сетевая среда закрывает подключения, которые бездействуют в течение 5 секунд, может потребоваться уменьшить значение KeepAlive.

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a>ConnectionTimeout

Этот параметр представляет период времени, в течение которого необходимо открыть транспортное соединение и ожидать ответа перед его закрытием и открытием нового соединения. Значение по умолчанию — 110 секунд.

Этот параметр применяется только в том случае, если отключена функция KeepAlive, которая обычно применяется только к долгосрочному транспортному потоку. На следующей схеме показан результат этого параметра для соединения с длительным опросом.

![Долгосрочное подключение к транспортному протоколу](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a>дисконнекттимеаут

Этот параметр представляет период времени ожидания после потери транспортного соединения перед вызовом события `Disconnected`. Значение по умолчанию — 30 секунд. При установке `DisconnectTimeout``KeepAlive` автоматически задается значение 1/3 `DisconnectTimeout`.

<a id="keepalive"></a>

### <a name="keepalive"></a>Проверки

Этот параметр представляет время ожидания перед отправкой пакета KeepAlive через неактивное соединение. Значение по умолчанию — 10 секунд. Это значение не должно превышать 1/3 значения `DisconnectTimeout`.

Если необходимо задать оба `DisconnectTimeout` и `KeepAlive`, установите `KeepAlive` после `DisconnectTimeout`. В противном случае параметр `KeepAlive` будет перезаписан, когда `DisconnectTimeout` автоматически задаст `KeepAlive` значение времени ожидания 1/3.

Если вы хотите отключить функцию KeepAlive, присвойте параметру `KeepAlive` значение null. Функция KeepAlive автоматически отключается для длинного транспорта с длительным опросом.

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a>Изменение параметров времени ожидания и активности

Чтобы изменить значения по умолчанию для этих параметров, задайте их в `Application_Start` в файле *Global. asax* , как показано в следующем примере. Значения, показанные в образце кода, совпадают со значениями по умолчанию.

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a>Уведомление пользователя о отключении

В некоторых приложениях может потребоваться отображение сообщения пользователю при возникновении проблем с подключением. Существует несколько вариантов того, как и когда это сделать. Приведенные ниже примеры кода предназначены для клиента JavaScript, использующего созданный прокси-сервер.

- Обрабатывайте событие `connectionSlow`, чтобы отобразить сообщение, как только SignalR сообщает о проблемах с подключением, прежде чем он перейдет в режим повторного подключения.

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- Обрабатывает событие `reconnecting` для вывода сообщения, когда SignalR сообщает о разрыве соединения и переходит в режим повторного подключения.

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- Обрабатывает событие `disconnected` для вывода сообщения при превышении времени ожидания попытки повторного подключения. В этом сценарии единственный способ повторно установить соединение с сервером — перезапустить подключение SignalR, вызвав метод `Start`, который создаст новый идентификатор подключения. В следующем примере кода используется флаг, чтобы гарантировать, что уведомление будет выдаваться только после истечения времени ожидания повторного подключения, а не после обычного окончания соединения SignalR, вызванного вызовом метода `Stop`.

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a>Непрерывное повторное подключение

В некоторых приложениях может потребоваться автоматически восстановить подключение после того, как оно будет потеряно, и время ожидания попытки повторного подключения истекло. Для этого можно вызвать метод `Start` из обработчика событий `Closed` (`disconnected` обработчика событий на клиентах JavaScript). Вы можете подождать период времени, прежде чем вызывать `Start`, чтобы избежать этого слишком часто, если сервер или физическое подключение недоступны. Следующий пример кода предназначен для клиента JavaScript, использующего созданный прокси-сервер.

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

Потенциальная проблема, которую следует учитывать в мобильных клиентах, заключается в том, что непрерывные попытки повторного подключения при недоступности сервера или физического подключения могут привести к ненужному истощению аккумулятора.

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a>Отключение клиента в серверном коде

SignalR версии 2 не имеет встроенного API сервера для отключения клиентов. Существуют [планы по добавлению этой функции в будущем](https://github.com/SignalR/SignalR/issues/2101). В текущем выпуске SignalR самым простым способом отключения клиента от сервера является реализация метода отключения на клиенте и вызов этого метода с сервера. В следующем примере кода показан метод Disconnect для клиента JavaScript с использованием созданного прокси-сервера.

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> Безопасность. ни один из методов отключения клиентов, ни предлагаемого встроенного API не будет решать ситуацию с взломанными клиентами, на которых выполняется вредоносный код, так как клиенты могут повторно подключаться или злонамеренный код мог удалить `stopClient` метод или изменить то, что он делает. Подходящее место для реализации защиты типа "отказ в обслуживании" (DOS) не находится на уровне платформы или сервера, а не в инфраструктуре внешнего интерфейса.

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a>Определение причины отключения

SignalR 2,1 добавляет перегрузку в событие сервера `OnDisconnect`, которое указывает, что клиент намеренно отключен, а не истекает. Параметр `StopCalled` имеет значение true, если клиент явным образом закрыл соединение. В JavaScript, если ошибка сервера привела к отключению клиента, сведения об ошибке передаются клиенту в качестве `$.connection.hub.lastError`.

**C#код сервера: `stopCalled` параметр**

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

**Клиентский код JavaScript: доступ к `lastError` в событии `disconnect`.**

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
