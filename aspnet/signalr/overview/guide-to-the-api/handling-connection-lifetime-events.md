---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Основные сведения и обработка событий времени жизни подключения в SignalR | Документация Майкрософт
author: bradygaster
description: В этой статье описывается, как использовать события, предоставляемые API концентраторов.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78467424"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="0ff6c-103">Общие сведения и обработка событий времени существования подключений в SignalR</span><span class="sxs-lookup"><span data-stu-id="0ff6c-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="0ff6c-104">В этой статье приводятся общие сведения о событиях подключения, повторного подключения и отсоединении SignalR, которые можно настроить, а также о параметрах времени ожидания и активности, которые можно настраивать.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="0ff6c-105">В этой статье предполагается, что у вас уже есть знания о событиях SignalR и времени жизни подключения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="0ff6c-106">Общие сведения о SignalR см. в статье [Общие сведения](../getting-started/introduction-to-signalr.md)о SignalR.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="0ff6c-107">Список событий времени жизни подключения см. в следующих ресурсах:</span><span class="sxs-lookup"><span data-stu-id="0ff6c-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="0ff6c-108">Как управлять событиями времени жизни соединения в классе HUB</span><span class="sxs-lookup"><span data-stu-id="0ff6c-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="0ff6c-109">Как управлять событиями времени жизни соединения в клиентах JavaScript</span><span class="sxs-lookup"><span data-stu-id="0ff6c-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="0ff6c-110">Как управлять событиями времени жизни соединения в клиентах .NET</span><span class="sxs-lookup"><span data-stu-id="0ff6c-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="0ff6c-111">Версии программного обеспечения, используемые в этом разделе</span><span class="sxs-lookup"><span data-stu-id="0ff6c-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="0ff6c-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="0ff6c-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="0ff6c-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="0ff6c-113">.NET 4.5</span></span>
> - <span data-ttu-id="0ff6c-114">SignalR версии 2</span><span class="sxs-lookup"><span data-stu-id="0ff6c-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="0ff6c-115">Предыдущие версии этого раздела</span><span class="sxs-lookup"><span data-stu-id="0ff6c-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="0ff6c-116">Сведения о более ранних версиях SignalR см. в статье о [старых версиях](../older-versions/index.md)SignalR.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="0ff6c-117">Вопросы и комментарии</span><span class="sxs-lookup"><span data-stu-id="0ff6c-117">Questions and comments</span></span>
>
> <span data-ttu-id="0ff6c-118">Оставьте отзыв о том, как вы понравится вам в этом учебнике, и что можно улучшить в комментариях в нижней части страницы.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="0ff6c-119">Если у вас есть вопросы, не связанные непосредственно с этим руководством, их можно опубликовать на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="0ff6c-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="0ff6c-120">Обзор</span><span class="sxs-lookup"><span data-stu-id="0ff6c-120">Overview</span></span>

<span data-ttu-id="0ff6c-121">Эта статья состоит из следующих разделов:</span><span class="sxs-lookup"><span data-stu-id="0ff6c-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="0ff6c-122">Терминология и сценарии времени жизни подключения</span><span class="sxs-lookup"><span data-stu-id="0ff6c-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="0ff6c-123">Подключения SignalR, транспортные подключения и физические подключения</span><span class="sxs-lookup"><span data-stu-id="0ff6c-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="0ff6c-124">Сценарии отключения транспорта</span><span class="sxs-lookup"><span data-stu-id="0ff6c-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="0ff6c-125">Сценарии отключения клиента</span><span class="sxs-lookup"><span data-stu-id="0ff6c-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="0ff6c-126">Сценарии отключения сервера</span><span class="sxs-lookup"><span data-stu-id="0ff6c-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="0ff6c-127">Параметры времени ожидания и KeepAlive</span><span class="sxs-lookup"><span data-stu-id="0ff6c-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="0ff6c-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="0ff6c-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="0ff6c-129">дисконнекттимеаут</span><span class="sxs-lookup"><span data-stu-id="0ff6c-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="0ff6c-130">Проверки</span><span class="sxs-lookup"><span data-stu-id="0ff6c-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="0ff6c-131">Изменение параметров времени ожидания и активности</span><span class="sxs-lookup"><span data-stu-id="0ff6c-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="0ff6c-132">Уведомление пользователя о отключении</span><span class="sxs-lookup"><span data-stu-id="0ff6c-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="0ff6c-133">Непрерывное повторное подключение</span><span class="sxs-lookup"><span data-stu-id="0ff6c-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="0ff6c-134">Отключение клиента в серверном коде</span><span class="sxs-lookup"><span data-stu-id="0ff6c-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="0ff6c-135">Определение причины отключения</span><span class="sxs-lookup"><span data-stu-id="0ff6c-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="0ff6c-136">Ссылки на справочные статьи по API относятся к версии .NET 4,5 API.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="0ff6c-137">Если вы используете .NET 4, см. [статьи с описанием API для .NET 4](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="0ff6c-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="0ff6c-138">Терминология и сценарии времени жизни подключения</span><span class="sxs-lookup"><span data-stu-id="0ff6c-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="0ff6c-139">Обработчик событий `OnReconnected` в концентраторе SignalR может выполняться непосредственно после `OnConnected`, но не после `OnDisconnected` для данного клиента.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="0ff6c-140">Причина, по которой можно установить соединение без отключения, заключается в наличии нескольких способов использования слова "Connection" в SignalR.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="0ff6c-141">Подключения SignalR, транспортные подключения и физические подключения</span><span class="sxs-lookup"><span data-stu-id="0ff6c-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="0ff6c-142">В этой статье будут различны *подключения SignalR*, *транспортные подключения*и *физические подключения*.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="0ff6c-143">**Подключение SignalR** — это логическая связь между клиентом и URL-адресом сервера, обслуживаемая API SignalR и уникально идентифицируемая по идентификатору соединения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="0ff6c-144">Данные об этой связи обслуживаются SignalR и используются для установления транспортного соединения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="0ff6c-145">Связь завершается и SignalR уничтожает данные, когда клиент вызывает метод `Stop` или достигается предельное время ожидания, когда SignalR пытается восстановить потерянное транспортное соединение.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="0ff6c-146">**Транспортное соединение** — это логическая связь между клиентом и сервером, обслуживаемая одним из четырех транспортных API-интерфейсов: WebSockets, серверные события, бесконечный кадр или длительный опрос.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="0ff6c-147">SignalR использует транспортный интерфейс API для создания транспортного соединения, а API транспорта зависит от наличия физического сетевого подключения для создания транспортного соединения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="0ff6c-148">Транспортное соединение завершается, когда SignalR завершает его работу или если транспортный API обнаруживает, что физическое подключение разорвано.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="0ff6c-149">**Физическое подключение** относится к физическим сетевым связям — беспроводным, радиосигналам, маршрутизаторам и т. д., которые упрощают обмен данными между клиентским компьютером и компьютером сервера.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="0ff6c-150">Для установления транспортного соединения должно присутствовать физическое подключение, а для установления соединения SignalR должно быть установлено транспортное соединение.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="0ff6c-151">Однако разрыв физического подключения не всегда немедленно завершает подключение транспорта или подключение SignalR, как будет объяснено далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="0ff6c-152">На следующей схеме подключение SignalR представлено API концентраторов и уровнем SignalR API Персистентконнектион, транспортное соединение представлено уровнем транспорта, а физическое соединение представляется линиями между сервером. и клиентов.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![Схема архитектуры SignalR](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="0ff6c-154">При вызове метода `Start` в клиенте SignalR вы предоставляете коду клиента SignalR все необходимые сведения для установления физического подключения к серверу.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="0ff6c-155">Клиентский код SignalR использует эти сведения для выполнения HTTP-запроса и установления физического соединения, использующего один из четырех транспортных методов.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="0ff6c-156">В случае сбоя транспортного соединения или сбоя сервера подключение SignalR не происходит немедленно, так как у клиента все еще есть сведения, необходимые для автоматического повторного создания нового транспортного соединения с одним и тем же URL-адресом SignalR.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="0ff6c-157">В этом случае вмешательство пользователя из пользовательского приложения не происходит, и когда код клиента SignalR устанавливает новое транспортное соединение, он не запускает новое подключение SignalR.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="0ff6c-158">Непрерывность соединения SignalR отражается на том факте, что идентификатор соединения, который создается при вызове метода `Start`, не изменяется.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="0ff6c-159">Обработчик событий `OnReconnected` в концентраторе выполняется, когда транспортное соединение автоматически повторно устанавливается после потери.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="0ff6c-160">Обработчик событий `OnDisconnected` выполняется в конце соединения SignalR.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="0ff6c-161">Подключение SignalR может завершиться любым из следующих способов:</span><span class="sxs-lookup"><span data-stu-id="0ff6c-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="0ff6c-162">Если клиент вызывает метод `Stop`, на сервер отправляется сообщение об ошибке, и клиент и сервер завершают подключение SignalR немедленно.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="0ff6c-163">После потери соединения между клиентом и сервером клиент пытается повторно подключиться, и сервер ожидает повторного подключения клиента.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="0ff6c-164">Если попытки повторного подключения завершаются неудачей и время ожидания отключения истекло, то клиент и сервер завершают подключение SignalR.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="0ff6c-165">Клиент прекращает попытки повторного подключения, а сервер уничтожает его представление о подключении SignalR.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="0ff6c-166">Если клиент прекращает выполнение без возможности вызова метода `Stop`, сервер ожидает повторного подключения клиента, а затем завершает подключение SignalR после истечения времени ожидания отключения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="0ff6c-167">Если сервер перестает работать, клиент пытается повторно подключиться (заново создать транспортное соединение), а затем завершает подключение SignalR после истечения времени ожидания отключения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="0ff6c-168">При отсутствии проблем с подключением пользовательское приложение завершает подключение SignalR, вызывая метод `Stop`, подключение SignalR и начало и конец транспортного соединения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="0ff6c-169">В следующих разделах более подробно описаны другие сценарии.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="0ff6c-170">Сценарии отключения транспорта</span><span class="sxs-lookup"><span data-stu-id="0ff6c-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="0ff6c-171">Физические подключения могут быть слишком высокой, иначе могут возникнуть перерывы в связи.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="0ff6c-172">В зависимости от таких факторов, как продолжительность прерывания, транспортное соединение может быть удалено.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="0ff6c-173">Затем SignalR пытается повторно установить транспортное соединение.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="0ff6c-174">Иногда интерфейс транспортного подключения обнаруживает прерывание и удаляет транспортное соединение, а SignalR сразу же обнаруживает, что подключение потеряно.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="0ff6c-175">В других сценариях ни API транспортного подключения, ни SignalR не сообщают о том, что подключение потеряно.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="0ff6c-176">Для всех транспортов, за исключением длительного опроса, клиент SignalR использует функцию *KeepAlive* для проверки потери подключения, которую транспортный API не удается обнаружить.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="0ff6c-177">Сведения о длительных подключениях см. в подразделе [Параметры времени ожидания и KeepAlive](#timeoutkeepalive) далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="0ff6c-178">Если соединение неактивно, периодически сервер отправляет клиенту пакет KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="0ff6c-179">Начиная с даты написания этой статьи периодичность по умолчанию составляет 10 секунд.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="0ff6c-180">Прослушивая эти пакеты, клиенты могут определить, существует ли проблема с подключением.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="0ff6c-181">Если пакет KeepAlive не получен, когда он ожидается, через некоторое время клиент считает, что возникают проблемы с подключением, например медленная работа или прерывания.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="0ff6c-182">Если KeepAlive по-прежнему не получается через более длительное время, клиент предполагает, что соединение было разорвано и начинается попытка повторного подключения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="0ff6c-183">На следующей схеме показаны события клиента и сервера, которые возникают в типичном сценарии при возникновении проблем с физическим подключением, которые не распознаются API транспорта немедленно.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="0ff6c-184">Схема применяется к следующим обстоятельствам.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="0ff6c-185">Транспорт — это WebSocket, бесконечный кадр или события, отправленные сервером.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="0ff6c-186">В физическом сетевом подключении есть различные периоды прерывания.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="0ff6c-187">Транспортный API не знает о прерываниях, поэтому для их обнаружения SignalR полагается на функцию KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Отключения транспорта](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="0ff6c-189">Если клиент переходит в режим повторного подключения, но не может установить транспортное соединение в течение времени ожидания разъединения, сервер прерывает подключение SignalR.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="0ff6c-190">В этом случае сервер выполняет метод `OnDisconnected` концентратора и помещает в очередь сообщение об отключении для отправки клиенту в случае, если клиент управляет подключением позже.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="0ff6c-191">Если клиент затем выполняет повторное соединение, он получает команду Disconnect и вызывает метод `Stop`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="0ff6c-192">В этом сценарии `OnReconnected` не выполняется при повторном подключении клиента, и `OnDisconnected` не выполняется, когда клиент вызывает `Stop`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="0ff6c-193">Этот сценарий показан на следующей схеме.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-193">The following diagram illustrates this scenario.</span></span>

![Перебои в транспортировке — время ожидания сервера](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="0ff6c-195">События времени жизни подключения SignalR, которые могут быть вызваны на клиенте, следующие:</span><span class="sxs-lookup"><span data-stu-id="0ff6c-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="0ff6c-196">`ConnectionSlow`ное событие клиента.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="0ff6c-197">Вызывается, когда с момента получения последнего сообщения или проверки связи KeepAlive прошло предустановленная доля времени ожидания KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="0ff6c-198">Период предупреждения о времени ожидания проверки активности по умолчанию равен 2/3 времени ожидания KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="0ff6c-199">Время ожидания KeepAlive составляет 20 секунд, поэтому предупреждение возникает примерно через 13 секунд.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="0ff6c-200">По умолчанию сервер отправляет проверки связи на KeepAlive каждые 10 секунд, а клиент проверяет наличие проверок связи для проверки активности примерно каждые 2 секунды (третья из различий между значением времени ожидания KeepAlive и значением предупреждения о времени ожидания KeepAlive).</span><span class="sxs-lookup"><span data-stu-id="0ff6c-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="0ff6c-201">Если транспортный API сообщает об отсутствии соединения, то SignalR может быть уведомлен о соединении до того, как будет пройден период предупреждения об истечении времени ожидания KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="0ff6c-202">В этом случае событие `ConnectionSlow` не будет вызвано, а SignalR перейдет непосредственно к событию `Reconnecting`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="0ff6c-203">`Reconnecting`ное событие клиента.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="0ff6c-204">Вызывается, когда (a) транспортный API обнаруживает, что соединение потеряно, или (б) время ожидания KeepAlive прошло с момента получения последнего сообщения или проверки связи с KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="0ff6c-205">Код клиента SignalR начинает попытки повторно подключиться.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="0ff6c-206">Это событие можно решить, если требуется, чтобы приложение заработало какие-либо действия при потере транспортного соединения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="0ff6c-207">Время ожидания проверки активности по умолчанию составляет 20 секунд.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="0ff6c-208">Если клиентский код пытается вызвать метод концентратора, когда SignalR находится в режиме повторного подключения, SignalR попытается отправить команду.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="0ff6c-209">В большинстве случаев такие попытки завершатся ошибкой, но в некоторых обстоятельствах они могут завершиться успешно.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="0ff6c-210">Для событий, отправленных сервером, непрерывных кадров и длительных опросов, SignalR использует два канала связи, один из которых используется для отправки сообщений, а другой — для получения сообщений.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="0ff6c-211">Канал, используемый для получения, является безвозвратным открытым, и это тот, который закрывается при прерывании физического подключения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="0ff6c-212">Канал, используемый для отправки, остается доступным, поэтому при восстановлении физического подключения вызов метода от клиента к серверу может быть успешным до восстановления канала получения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="0ff6c-213">Возвращаемое значение не будет получено, пока SignalR повторно не откроет канал, используемый для приема.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="0ff6c-214">`Reconnected`ное событие клиента.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="0ff6c-215">Возникает при восстановлении транспортного соединения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="0ff6c-216">Обработчик событий `OnReconnected` в концентраторе выполняется.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="0ff6c-217">событие `Closed` клиента (событие`disconnected` в JavaScript).</span><span class="sxs-lookup"><span data-stu-id="0ff6c-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="0ff6c-218">Возникает, когда истекает время ожидания отключения, пока клиентский код SignalR пытается повторно подключиться после потери транспортного соединения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="0ff6c-219">Время ожидания отключения по умолчанию составляет 30 секунд.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="0ff6c-220">(Это событие также возникает, когда соединение завершается из-за вызова метода `Stop`.)</span><span class="sxs-lookup"><span data-stu-id="0ff6c-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="0ff6c-221">Соединения транспорта, которые не обнаруживаются транспортным ИНТЕРФЕЙСом транспорта, и не задерживают получение проверок связи для проверки активности с сервера дольше, чем период предупреждения об истечении времени ожидания, может не привести к возникновению каких-либо событий времени жизни соединения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="0ff6c-222">Некоторые сетевые среды намеренно закрывают неактивные подключения, а еще одна функция пакетов KeepAlive заключается в предотвращении этой ситуации, разрешая этим сетям знание того, что подключение SignalR используется.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="0ff6c-223">В экстремальных случаях частота по умолчанию для проверки связи по KeepAlive может быть недостаточной для предотвращения закрытых соединений.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="0ff6c-224">В этом случае можно настроить отправку проверок связи для проверки активности.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="0ff6c-225">Дополнительные сведения см. в подразделе [Параметры времени ожидания и KeepAlive](#timeoutkeepalive) далее в этой статье.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="0ff6c-226">**Важно**. последовательность событий, описанных здесь, не гарантируется.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="0ff6c-227">SignalR делает каждую попытку создавать события времени жизни соединения предсказуемым образом в соответствии с этой схемой, но существует множество разновидностей сетевых событий и многих способов, с помощью которых базовые платформы связи, такие как транспортные интерфейсы API, обрабатывают их.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="0ff6c-228">Например, событие `Reconnected` может не вызываться при повторном подключении клиента, или если попытка установить соединение завершается неудачей, может запуститься обработчик `OnConnected` на сервере.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="0ff6c-229">В этом разделе описываются только те эффекты, которые обычно производятся в некоторых типичных обстоятельствах.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="0ff6c-230">Сценарии отключения клиента</span><span class="sxs-lookup"><span data-stu-id="0ff6c-230">Client disconnection scenarios</span></span>

<span data-ttu-id="0ff6c-231">В клиенте браузера код клиента SignalR, поддерживающий подключение SignalR, выполняется в контексте JavaScript веб-страницы.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="0ff6c-232">Именно поэтому подключение SignalR должно закончиться при переходе с одной страницы на другую, и вот почему у вас есть несколько соединений с несколькими идентификаторами подключений при подключении из нескольких окон или вкладок браузера.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="0ff6c-233">Когда пользователь закрывает окно или вкладку браузера либо переходит на новую страницу или обновляет страницу, подключение SignalR немедленно завершается, так как клиентский код SignalR обрабатывает это событие браузера и вызывает метод `Stop`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="0ff6c-234">В этих сценариях или на любой клиентской платформе, когда приложение вызывает метод `Stop`, обработчик событий `OnDisconnected` немедленно выполняется на сервере, а клиент вызывает событие `Closed` (событие называется `disconnected` в JavaScript).</span><span class="sxs-lookup"><span data-stu-id="0ff6c-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="0ff6c-235">Если клиентское приложение или компьютер, на котором оно выполняется, зависает или переходит в спящий режим (например, когда пользователь закрывает переносной компьютер), сервер не получает сведений о том, что произошло.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="0ff6c-236">Как только сервер знает, потери клиента могут быть вызваны прерыванием подключения, и клиент может пытаться повторно подключиться.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="0ff6c-237">Таким образом, в этих сценариях сервер ожидает, чтобы клиент получил возможность повторного подключения, а `OnDisconnected` не выполняется до истечения времени ожидания отключения (по умолчанию около 30 секунд).</span><span class="sxs-lookup"><span data-stu-id="0ff6c-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="0ff6c-238">Этот сценарий показан на следующей схеме.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-238">The following diagram illustrates this scenario.</span></span>

![Сбой клиентского компьютера](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="0ff6c-240">Сценарии отключения сервера</span><span class="sxs-lookup"><span data-stu-id="0ff6c-240">Server disconnection scenarios</span></span>

<span data-ttu-id="0ff6c-241">Когда сервер переходит в автономный режим, он перезапускается, завершается с ошибкой, перезапускается домен приложения и т. д. — результат может быть похож на потерянное подключение, или API транспорта и SignalR могут сразу же выяснить, что сервер отсутствует, и SignalR может начать попытки повторного подключения, не вызывая событие `ConnectionSlow`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="0ff6c-242">Если клиент переключается в режим повторного подключения и сервер восстанавливается или перезапускается, а новый сервер переходит в режим «в сети» до истечения времени ожидания отключения, клиент повторно подключится к восстановленному или новому серверу.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="0ff6c-243">В этом случае подключение SignalR будет продолжаться на клиенте и будет вызвано событие `Reconnected`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="0ff6c-244">На первом сервере `OnDisconnected` никогда не выполняется, и на новом сервере `OnReconnected` выполняется, несмотря на то, что `OnConnected` ранее не выполнялся для этого клиента на этом сервере.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="0ff6c-245">(Результат аналогичен, если клиент повторно подключится к тому же серверу после перезапуска или очистки домена приложений, так как при перезапуске сервера он не имеет памяти.) На следующей схеме предполагается, что транспортный API немедленно сообщает о потерянном соединении, поэтому событие `ConnectionSlow` не возникает.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Сбой и повторное подключение сервера](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="0ff6c-247">Если сервер не будет доступен в течение времени ожидания отключения, подключение SignalR завершается.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="0ff6c-248">В этом сценарии событие `Closed` (`disconnected` на клиентах JavaScript) вызывается на клиенте, но `OnDisconnected` никогда не вызывается на сервере.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="0ff6c-249">На следующей схеме предполагается, что транспортный интерфейс API не знает о потерянном соединении, поэтому он обнаруживается функцией проверки активности SignalR и вызывается событие `ConnectionSlow`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Сбой и время ожидания сервера](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="0ff6c-251">Параметры времени ожидания и KeepAlive</span><span class="sxs-lookup"><span data-stu-id="0ff6c-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="0ff6c-252">Значения `ConnectionTimeout`, `DisconnectTimeout`и `KeepAlive` по умолчанию подходят для большинства сценариев, но их можно изменить, если в вашей среде есть особые потребности.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="0ff6c-253">Например, если сетевая среда закрывает подключения, которые бездействуют в течение 5 секунд, может потребоваться уменьшить значение KeepAlive.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="0ff6c-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="0ff6c-254">ConnectionTimeout</span></span>

<span data-ttu-id="0ff6c-255">Этот параметр представляет период времени, в течение которого необходимо открыть транспортное соединение и ожидать ответа перед его закрытием и открытием нового соединения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="0ff6c-256">Значение по умолчанию — 110 секунд.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="0ff6c-257">Этот параметр применяется только в том случае, если отключена функция KeepAlive, которая обычно применяется только к долгосрочному транспортному потоку.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="0ff6c-258">На следующей схеме показан результат этого параметра для соединения с длительным опросом.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Долгосрочное подключение к транспортному протоколу](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="0ff6c-260">дисконнекттимеаут</span><span class="sxs-lookup"><span data-stu-id="0ff6c-260">DisconnectTimeout</span></span>

<span data-ttu-id="0ff6c-261">Этот параметр представляет период времени ожидания после потери транспортного соединения перед вызовом события `Disconnected`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="0ff6c-262">Значение по умолчанию — 30 секунд.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-262">The default value is 30 seconds.</span></span> <span data-ttu-id="0ff6c-263">При установке `DisconnectTimeout``KeepAlive` автоматически задается значение 1/3 `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="0ff6c-264">Проверки</span><span class="sxs-lookup"><span data-stu-id="0ff6c-264">KeepAlive</span></span>

<span data-ttu-id="0ff6c-265">Этот параметр представляет время ожидания перед отправкой пакета KeepAlive через неактивное соединение.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="0ff6c-266">Значение по умолчанию — 10 секунд.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-266">The default value is 10 seconds.</span></span> <span data-ttu-id="0ff6c-267">Это значение не должно превышать 1/3 значения `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="0ff6c-268">Если необходимо задать оба `DisconnectTimeout` и `KeepAlive`, установите `KeepAlive` после `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="0ff6c-269">В противном случае параметр `KeepAlive` будет перезаписан, когда `DisconnectTimeout` автоматически задаст `KeepAlive` значение времени ожидания 1/3.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="0ff6c-270">Если вы хотите отключить функцию KeepAlive, присвойте параметру `KeepAlive` значение null.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="0ff6c-271">Функция KeepAlive автоматически отключается для длинного транспорта с длительным опросом.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="0ff6c-272">Изменение параметров времени ожидания и активности</span><span class="sxs-lookup"><span data-stu-id="0ff6c-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="0ff6c-273">Чтобы изменить значения по умолчанию для этих параметров, задайте их в `Application_Start` в файле *Global. asax* , как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="0ff6c-274">Значения, показанные в образце кода, совпадают со значениями по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="0ff6c-275">Уведомление пользователя о отключении</span><span class="sxs-lookup"><span data-stu-id="0ff6c-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="0ff6c-276">В некоторых приложениях может потребоваться отображение сообщения пользователю при возникновении проблем с подключением.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="0ff6c-277">Существует несколько вариантов того, как и когда это сделать.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="0ff6c-278">Приведенные ниже примеры кода предназначены для клиента JavaScript, использующего созданный прокси-сервер.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="0ff6c-279">Обрабатывайте событие `connectionSlow`, чтобы отобразить сообщение, как только SignalR сообщает о проблемах с подключением, прежде чем он перейдет в режим повторного подключения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="0ff6c-280">Обрабатывает событие `reconnecting` для вывода сообщения, когда SignalR сообщает о разрыве соединения и переходит в режим повторного подключения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="0ff6c-281">Обрабатывает событие `disconnected` для вывода сообщения при превышении времени ожидания попытки повторного подключения. В этом сценарии единственный способ повторно установить соединение с сервером — перезапустить подключение SignalR, вызвав метод `Start`, который создаст новый идентификатор подключения.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="0ff6c-282">В следующем примере кода используется флаг, чтобы гарантировать, что уведомление будет выдаваться только после истечения времени ожидания повторного подключения, а не после обычного окончания соединения SignalR, вызванного вызовом метода `Stop`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="0ff6c-283">Непрерывное повторное подключение</span><span class="sxs-lookup"><span data-stu-id="0ff6c-283">How to continuously reconnect</span></span>

<span data-ttu-id="0ff6c-284">В некоторых приложениях может потребоваться автоматически восстановить подключение после того, как оно будет потеряно, и время ожидания попытки повторного подключения истекло. Для этого можно вызвать метод `Start` из обработчика событий `Closed` (`disconnected` обработчика событий на клиентах JavaScript).</span><span class="sxs-lookup"><span data-stu-id="0ff6c-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="0ff6c-285">Вы можете подождать период времени, прежде чем вызывать `Start`, чтобы избежать этого слишком часто, если сервер или физическое подключение недоступны.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="0ff6c-286">Следующий пример кода предназначен для клиента JavaScript, использующего созданный прокси-сервер.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="0ff6c-287">Потенциальная проблема, которую следует учитывать в мобильных клиентах, заключается в том, что непрерывные попытки повторного подключения при недоступности сервера или физического подключения могут привести к ненужному истощению аккумулятора.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="0ff6c-288">Отключение клиента в серверном коде</span><span class="sxs-lookup"><span data-stu-id="0ff6c-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="0ff6c-289">SignalR версии 2 не имеет встроенного API сервера для отключения клиентов.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="0ff6c-290">Существуют [планы по добавлению этой функции в будущем](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="0ff6c-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="0ff6c-291">В текущем выпуске SignalR самым простым способом отключения клиента от сервера является реализация метода отключения на клиенте и вызов этого метода с сервера.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="0ff6c-292">В следующем примере кода показан метод Disconnect для клиента JavaScript с использованием созданного прокси-сервера.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="0ff6c-293">Безопасность. ни один из методов отключения клиентов, ни предлагаемого встроенного API не будет решать ситуацию с взломанными клиентами, на которых выполняется вредоносный код, так как клиенты могут повторно подключаться или злонамеренный код мог удалить `stopClient` метод или изменить то, что он делает.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="0ff6c-294">Подходящее место для реализации защиты типа "отказ в обслуживании" (DOS) не находится на уровне платформы или сервера, а не в инфраструктуре внешнего интерфейса.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="0ff6c-295">Определение причины отключения</span><span class="sxs-lookup"><span data-stu-id="0ff6c-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="0ff6c-296">SignalR 2,1 добавляет перегрузку в событие сервера `OnDisconnect`, которое указывает, что клиент намеренно отключен, а не истекает. Параметр `StopCalled` имеет значение true, если клиент явным образом закрыл соединение.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="0ff6c-297">В JavaScript, если ошибка сервера привела к отключению клиента, сведения об ошибке передаются клиенту в качестве `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="0ff6c-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="0ff6c-298">**C#код сервера: `stopCalled` параметр**</span><span class="sxs-lookup"><span data-stu-id="0ff6c-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="0ff6c-299">**Клиентский код JavaScript: доступ к `lastError` в событии `disconnect`.**</span><span class="sxs-lookup"><span data-stu-id="0ff6c-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
