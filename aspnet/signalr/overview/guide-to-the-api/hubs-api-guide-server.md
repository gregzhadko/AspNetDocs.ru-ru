---
uid: signalr/overview/guide-to-the-api/hubs-api-guide-server
title: ASP.NET руководство aPI концентратов SignalR - Сервер (C) Документы Майкрософт
author: bradygaster
description: Этот документ содержит введение в программирование серверной стороны ASP.NET SignalR Концентраты API для SignalR версии 2, с образцами кода, демонстрирующими...
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: b19913e5-cd8a-4e4b-a872-5ac7a858a934
msc.legacyurl: /signalr/overview/guide-to-the-api/hubs-api-guide-server
msc.type: authoredcontent
ms.openlocfilehash: c681b104b15bfc4a04587c7abf685dcf20def2ca
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675805"
---
# <a name="aspnet-signalr-hubs-api-guide---server-c"></a>ASP.NET руководство aPI концентратов SignalR - Сервер (C)

[Патрик Флетчер](https://github.com/pfletcher), [Том Дикстра](https://github.com/tdykstra)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> Этот документ содержит введение в программирование серверной стороны ASP.NET SignalR Концентраты API для SignalR версии 2, с образцами кода, демонстрирующими общие варианты.
> 
> API Концентраторов SignalR позволяет совершать удаленные процедурные звонки (RPCs) с сервера для подключенных клиентов и от клиентов к серверу. В коде сервера вы определяете методы, которые могут вызываться клиентами, и вызываете методы, которые работают на клиенте. В клиентском коде вы определяете методы, которые можно вызывать с сервера, и вызываете методы, которые работают на сервере. SignalR заботится о всех клиента к серверу сантехника для вас.
> 
> SignalR также предлагает API более низкого уровня под названием Persistent Connections. Для введения в SignalR, концентраторы, и стойкие соединения, [см.](../getting-started/introduction-to-signalr.md)
> 
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемые в этой теме
> 
> 
> - [Visual Studio 2013](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - .NET 4.5
> - Версия SignalR 2
>   
> 
> 
> ## <a name="topic-versions"></a>Версии тем
> 
> Для получения информации о более ранних версиях SignalR, см [SignalR Старые версии](../older-versions/index.md).
> 
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
> 
> Пожалуйста, оставьте обратную связь о том, как вам понравился этот учебник и что мы могли бы улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, которые не имеют прямого отношения к учебнику, вы можете разместить их на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com.](http://stackoverflow.com/)

## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Как зарегистрировать промежуточное программное обеспечение SignalR](#route)

    - [URL/сигнальщик](#signalrurl)
    - [Настройка параметров SignalR](#options)
- [Как создавать и использовать классы концентраторов](#hubclass)

    - [Срок службы объекта концентратора](#transience)
    - [Верблюжья оболочка имен концентраторов в клиентах JavaScript](#hubnames)
    - [Несколько концентратов](#multiplehubs)
    - [Сильно набранные концентраторы](#stronglytypedhubs)
- [Как определить методы в классе концентратора, которые клиенты могут вызвать](#hubmethods)

    - [Верблюжья оболочка имен методов в клиентах JavaScript](#methodnames)
    - [Когда выполнять асинхронно](#asyncmethods)
    - [Определение перегрузок](#overloads)
    - [Отчетность о прогрессе от вызовов метода концентратора](#progress)
- [Как вызвать методы клиента из класса концентратора](#callfromhub)

    - [Выбор клиентов, которые получат RPC](#selectingclients)
    - [Отсутствие проверки времени компиляции для имен методов](#dynamicmethodnames)
    - [Соответствие имени нечувствительных методов для дел](#caseinsensitive)
    - [Асинхронное исполнение](#asyncclient)
- [Как управлять членством в группе из класса концентратор](#groupsfromhub)

    - [Асинхронное выполнение методов добавления и удаления](#asyncgroupmethods)
    - [Сохранение членства в группе](#grouppersistence)
    - [Группы для пользователей](#singleusergroups)
- [Как обрабатывать события жизни соединения в классе концентратора](#connectionlifetime)

    - [При вызове OnConnected, OnDisconnected и OnReconnected](#onreconnected)
    - [Состояние вызываемого абонента не заселены](#nocallerstate)
- [Как получить информацию о клиенте из свойства Контекста](#contextproperty)
- [Как передать состояние между клиентами и классом концентратора](#passstate)
- [Как обрабатывать ошибки в классе концентратор](#handleErrors)
- [Как вызвать методы клиентов и управлять группами из-за пределов класса концентратора](#callfromoutsidehub)

    - [Вызов методов клиента](#callingclientsoutsidehub)
    - [Управление членством в группе](#managinggroupsoutsidehub)
- [Как включить трассировку](#tracing)
- [Как настроить конвейер концентров](#hubpipeline)

Для получения документации о том, как программировать клиентов, см.

- [Руководство По API Концентратов SignalR - Клиент JavaScript](hubs-api-guide-javascript-client.md)
- [Руководство По API Концентраторов SignalR - Клиент .NET](hubs-api-guide-net-client.md)

Компоненты сервера для SignalR 2 доступны только в .NET 4.5. Серверы под управлением .NET 4.0 должны использовать SignalR v1.x.

<a id="route"></a>

## <a name="how-to-register-signalr-middleware"></a>Как зарегистрировать промежуточное программное обеспечение SignalR

Чтобы определить маршрут, который клиенты будут использовать `MapSignalR` для подключения к концентратору, позвоните в метод, когда приложение начинает сятворное. `MapSignalR`— [это метод](https://msdn.microsoft.com/library/vstudio/bb383977.aspx) `OwinExtensions` расширения для класса. Ниже приводится следующий пример, как определить маршрут концентраторов SignalR с помощью класса запуска OWIN.

[!code-csharp[Main](hubs-api-guide-server/samples/sample1.cs)]

Если вы добавляете функциональность SignalR в ASP.NET приложение MVC, убедитесь, что маршрут SignalR добавляется перед другими маршрутами. Для получения дополнительной информации [см.](../getting-started/tutorial-getting-started-with-signalr-and-mvc.md)

<a id="signalrurl"></a>

### <a name="the-signalr-url"></a>URL/сигнальщик

По умолчанию URL-адрес маршрута, который клиенты будут использовать для подключения к концентратору, является "/сигнальным". (Не путайте этот URL с URL-адресом "/signalr/hubs", который предназначен для автоматического генерируемого файла JavaScript. Для получения дополнительной информации о сгенерированном прокси-сервере см. Руководство [SignalR Hubs API - JavaScript Client - Сгенерированный прокси и что он делает для вас.)](hubs-api-guide-javascript-client.md#genproxy)

Там могут быть чрезвычайные обстоятельства, которые делают этот базовый URL не приговочен к удобосона для SignalR; например, у вас есть папка в проекте под названием *сигнальный сигнализатор,* и вы не хотите менять имя. В этом случае можно изменить базовый URL, как показано в следующих примерах (заменить "/сигнализатор" в коде образца нужным URL).

**Код сервера, который определяет URL**

[!code-csharp[Main](hubs-api-guide-server/samples/sample2.cs?highlight=1)]

**Клиентский код JavaScript, который определяет URL (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-server/samples/sample3.js?highlight=1)]

**Клиентский код JavaScript, который определяет URL (без генерируемого прокси)**

[!code-javascript[Main](hubs-api-guide-server/samples/sample4.js?highlight=1)]

**клиентский код .NET, который определяет URL**

[!code-csharp[Main](hubs-api-guide-server/samples/sample5.cs?highlight=1)]

<a id="options"></a>

### <a name="configuring-signalr-options"></a>Настройка параметров SignalR

Перегрузки `MapSignalR` метода позволяют указать пользовательский URL-адрес, разрешитель пользовательских зависимостей и следующие параметры:

- Включите кросс-домен ныевызови с помощью CORS или JSONP от клиентов браузера.

    Обычно, если браузер загружает страницу с `http://contoso.com`, соединение `http://contoso.com/signalr`SignalR находится в том же домене, в . Если страница `http://contoso.com` из делает `http://fabrikam.com/signalr`подключение к, то есть кросс-домен соединения. По соображениям безопасности соединения кросс-домена отключены по умолчанию. Для получения дополнительной информации смотрите [ASP.NET Руководство API Концентраторки SignalR - JavaScript Клиент - Как установить кросс-домен соединение](hubs-api-guide-javascript-client.md#crossdomain).
- Включить подробные сообщения об ошибках.

    При возникновении ошибок поведение SignalR по умолчанию заключается в отправке клиентам уведомления без подробной информации о том, что произошло. Отправка подробной информации об ошибках клиентам не рекомендуется в производстве, так как вредоносные пользователи могут использовать эту информацию при атаках на ваше приложение. Для устранения неполадок можно использовать эту опцию для временного включения более информативной отчетности об ошибках.
- Отключить автоматически генерируемые прокси-файлы JavaScript.

    По умолчанию файл JavaScript с прокси-файлами для классов концентратора генерируется в ответ на URL "/сигнальщик/концентратор". Если вы не хотите использовать прокси JavaScript, или если вы хотите создать этот файл вручную и обратиться к физическому файлу в ваших клиентах, вы можете использовать эту опцию, чтобы отключить генерацию прокси. Для получения дополнительной информации см. [Руководство SignalR Hubs API - JavaScript Client - Как создать физический файл для прокси-сервера SignalR.](hubs-api-guide-javascript-client.md#manualproxy)

В следующем примере показано, как указать URL-адрес соединения `MapSignalR` SignalR и эти параметры в вызове к методу. Чтобы указать пользовательский URL, замените "/сигнализатор" в примере URL-адресом, который вы хотите использовать.

[!code-csharp[Main](hubs-api-guide-server/samples/sample6.cs)]

<a id="hubclass"></a>

## <a name="how-to-create-and-use-hub-classes"></a>Как создавать и использовать классы концентраторов

Чтобы создать концентратор, создайте класс, который происходит от [Microsoft.Aspnet.Signalr.Hub](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hub(v=vs.111).aspx). Ниже приводится простой класс концентратора для приложения чата.

[!code-csharp[Main](hubs-api-guide-server/samples/sample7.cs)]

В этом примере подключенный `NewContosoChatMessage` клиент может вызвать метод, и когда он это делает, полученные данные передаются всем подключенным клиентам.

<a id="transience"></a>

### <a name="hub-object-lifetime"></a>Срок службы объекта концентратора

Вы не вызываете класс концентратора и не вызываете его методы из собственного кода на сервере; все, что делается для вас конвейером Концентраторов SignalR. SignalR создает новый экземпляр класса концентратора каждый раз, когда ему необходимо обрабатывать операцию концентратора, например, когда клиент подключается, отключается или делает вызов метода на сервер.

Поскольку экземпляры класса концентратора являются временными, их нельзя использовать для поддержания состояния от одного вызова метода к другому. Каждый раз, когда сервер получает вызов метода от клиента, новый экземпляр класса концентратора обрабатывает сообщение. Для поддержания состояния через несколько вызовов соединений и методов используйте некоторый другой метод, такой `Hub`как база данных, или статическая переменная на классе концентратора, или другой класс, который не вытекает из. Если вы сохраняете данные в памяти, используя такой метод, как статическая переменная в классе концентратора, данные будут потеряны при переработке домена приложения.

Если вы хотите отправлять сообщения клиентам из собственного кода, который работает за пределами класса концентратора, вы не можете сделать это, мгновенно экземпляр класса концентратор, но вы можете сделать это, получив ссылку на контекстный объект SignalR для вашего класса концентратора. Для получения дополнительной информации смотрите [Как вызвать методы клиента и управлять группами из-за пределов класса концентратора](#callfromoutsidehub) позже в этой теме.

<a id="hubnames"></a>

### <a name="camel-casing-of-hub-names-in-javascript-clients"></a>Верблюжья оболочка имен концентраторов в клиентах JavaScript

По умолчанию клиенты JavaScript ссылаются на концентраторы, используя верблюжью версию имени класса. SignalR автоматически вносит это изменение, чтобы код JavaScript мог соответствовать конвенциям JavaScript. Предыдущий пример будет отсутстать в `contosoChatHub` коде JavaScript.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample8.cs?highlight=1)]

**Клиент JavaScript с помощью генерируемого прокси**

[!code-javascript[Main](hubs-api-guide-server/samples/sample9.js?highlight=1)]

Если требуется указать другое имя для `HubName` клиентов, добавьте атрибут. При использовании `HubName` атрибута имя не изменяется для случаес верблюда на клиентах JavaScript.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample10.cs?highlight=1)]

**Клиент JavaScript с помощью генерируемого прокси**

[!code-javascript[Main](hubs-api-guide-server/samples/sample11.js?highlight=1)]

<a id="multiplehubs"></a>

### <a name="multiple-hubs"></a>Несколько концентратов

Можно определить несколько классов концентраторов в приложении. При этом соединение является общим, но группы разделены:

- Все клиенты будут использовать один и тот же URL для установления соединения SignalR с вашим сервисом ("/сигнализатор" или пользовательский URL, если вы указали один), и это соединение используется для всех концентраторов, определенных службой.

    Для нескольких концентратов разница в производительности не существует по сравнению с определением всех функциональных возможностей концентратора в одном классе.
- Все концентраторы получают одинаковую информацию о запросе HTTP.

    Поскольку все концентраторы имеют одно и то же соединение, единственная информация о запросе HTTP, которую получает сервер, это то, что входит в исходный запрос HTTP, который устанавливает соединение SignalR. Если вы используете запрос на подключение для передачи информации от клиента серверу, указывая строку запроса, вы не можете предоставить различные строки запроса для различных концентраторов. Все концентраторы получат одну и ту же информацию.
- Сгенерированный файл прокси JavaScript будет содержать прокси для всех концентраторов в одном файле.

    Для получения информации о прокси JavaScript, см [SignalR концентраторов API Руководство - JavaScript Клиент - Сгенерированный прокси и что он делает для вас](hubs-api-guide-javascript-client.md#genproxy).
- Группы определяются в концентрах.

    В SignalR вы можете определить группы именованных для трансляции подмножества подключенных клиентов. Группы поддерживаются отдельно для каждого концентратора. Например, группа под названием "Администраторы" будет `ContosoChatHub` включать в себя один набор клиентов для вашего `StockTickerHub` класса, и одно и то же имя группы будет относиться к другому набору клиентов для вашего класса.

<a id="stronglytypedhubs"></a>
### <a name="strongly-typed-hubs"></a>Сильно набранные концентраторы

Чтобы определить интерфейс для методов концентратора, на которые клиент может ссылаться (и `Hub<T>` включить Intellisense на методах концентратора), вывемите концентратор из (введенного в SignalR 2.1), а `Hub`не:

[!code-csharp[Main](hubs-api-guide-server/samples/sample12.cs)]

<a id="hubmethods"></a>

## <a name="how-to-define-methods-in-the-hub-class-that-clients-can-call"></a>Как определить методы в классе концентратора, которые клиенты могут вызвать

Чтобы разоблачить метод в концентраторе, который вы хотите быть callable от клиента, объявить общедоступный метод, как показано в следующих примерах.

[!code-csharp[Main](hubs-api-guide-server/samples/sample13.cs?highlight=3)]

[!code-csharp[Main](hubs-api-guide-server/samples/sample14.cs?highlight=3)]

Можно указать тип возврата и параметры, включая сложные типы и массивы, как в любом методе C. Любые данные, которые вы получаете по параметрам или возвращаетесь к вызывающему абоненту, передаются между клиентом и сервером с помощью JSON, а SignalR автоматически обрабатывает привязку сложных объектов и массивов объектов.

<a id="methodnames"></a>

### <a name="camel-casing-of-method-names-in-javascript-clients"></a>Верблюжья оболочка имен методов в клиентах JavaScript

По умолчанию клиенты JavaScript ссылаются на методы концентратора, используя верблюжью версию имени метода. SignalR автоматически вносит это изменение, чтобы код JavaScript мог соответствовать конвенциям JavaScript.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample15.cs?highlight=1)]

**Клиент JavaScript с помощью генерируемого прокси**

[!code-javascript[Main](hubs-api-guide-server/samples/sample16.js?highlight=1)]

Если требуется указать другое имя для `HubMethodName` клиентов, добавьте атрибут.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample17.cs?highlight=1)]

**Клиент JavaScript с помощью генерируемого прокси**

[!code-javascript[Main](hubs-api-guide-server/samples/sample18.js?highlight=1)]

<a id="asyncmethods"></a>

### <a name="when-to-execute-asynchronously"></a>Когда выполнять асинхронно

Если метод будет длительным или должен выполнять работу, которая предполагает ожидание, например, поиск базы данных или вызов веб-службы, `void` сделайте метод концентратора асинхронным, вернув [задачу](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) (вместо возврата) или объект [Task&lt;&gt; T](https://msdn.microsoft.com/library/dd321424.aspx) (вместо типа `T` возврата). При возвращении `Task` объекта из метода SignalR `Task` ждет завершения, а затем отправляет необернутый результат клиенту, поэтому нет никакой разницы в том, как кодировать вызов метода в клиенте.

Создание асинхронного метода концентратора позволяет избежать блокировки соединения при использовании транспорта WebSocket. Когда метод концентратора выполняется синхронно, а перенос — WebSocket, последующие вызовы методов на концентраторе из одного и того же клиента блокируются до завершения метода концентратора.

В следующем примере показан тот же метод, закодированный для синхронного или асинхронного запуска, за которым следует клиентский код JavaScript, который работает для вызова любой из версий.

**Синхронный**

[!code-csharp[Main](hubs-api-guide-server/samples/sample19.cs)]

**Асинхронных**

[!code-csharp[Main](hubs-api-guide-server/samples/sample20.cs?highlight=1,7-8)]

**Клиент JavaScript с помощью генерируемого прокси**

[!code-javascript[Main](hubs-api-guide-server/samples/sample21.js)]

Для получения дополнительной информации о том, как использовать асинхронные методы в ASP.NET 4.5, см [ASP.NET.](../../../mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4.md)

<a id="overloads"></a>

### <a name="defining-overloads"></a>Определение перегрузок

Если вы хотите определить перегрузки для метода, количество параметров в каждой перегрузке должно быть разным. Если вы дифференцируете перегрузку, просто указав различные типы параметров, ваш класс концентратора будет компилироваться, но служба SignalR будет забрасывать исключение во время выполнения, когда клиенты пытаются вызвать одну из перегрузок.

<a id="progress"></a>
### <a name="reporting-progress-from-hub-method-invocations"></a>Отчетность о прогрессе от вызовов метода концентратора

SignalR 2.1 добавляет поддержку [модели представления о ходе работы,](https://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx) введенной в .NET 4.5. Для реализации отчетов `IProgress<T>` о ходе работы определите параметр для метода концентратора, к который клиент может получить доступ:

[!code-csharp[Main](hubs-api-guide-server/samples/sample22.cs)]

При написании длительного метода сервера важно использовать асинхронный шаблон программирования, такой как Async/Await, а не блокировать поток концентратора.

<a id="callfromhub"></a>

## <a name="how-to-call-client-methods-from-the-hub-class"></a>Как вызвать методы клиента из класса концентратора

Чтобы вызвать методы клиента с `Clients` сервера, используйте свойство в методе в классе концентратора. В следующем примере показан `addNewMessageToPage` серверный код, который вызывает всех подключенных клиентов, и клиентский код, определяющий метод в клиенте JavaScript.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample23.cs?highlight=5)]

Ссылаясь на метод клиента является асинхронной `Task`операцией и возвращает . Используйте `await` в следующих случаях:

* Чтобы убедиться, что сообщение отправлено без ошибочной ошибки. 
* Включить ошибки в ловле и обработке ошибок в блоке try-catch.

**Клиент JavaScript с помощью генерируемого прокси**

[!code-html[Main](hubs-api-guide-server/samples/sample24.html?highlight=1)]

Вы не можете получить значение возврата от метода клиента; синтаксис, `int x = Clients.All.add(1,1)` такой как не работает.

Можно указать сложные типы и массивы для параметров. Следующий пример передает сложный тип клиенту в параметре метода.

**Код сервера, который вызывает метод клиента с помощью сложного объекта**

[!code-csharp[Main](hubs-api-guide-server/samples/sample25.cs?highlight=3)]

**Код сервера, определяющий сложный объект**

[!code-csharp[Main](hubs-api-guide-server/samples/sample26.cs?highlight=1)]

**Клиент JavaScript с помощью генерируемого прокси**

[!code-javascript[Main](hubs-api-guide-server/samples/sample27.js?highlight=2-3)]

<a id="selectingclients"></a>

### <a name="selecting-which-clients-will-receive-the-rpc"></a>Выбор клиентов, которые получат RPC

Свойство Клиентов возвращает объект [HubConnectionContext,](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.hubconnectioncontext(v=vs.111).aspx) который предоставляет несколько вариантов указания, какие клиенты получат RPC:

- Все подключенные клиенты.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample28.cs)]
- Только звоняющий клиент.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample29.cs)]
- Все клиенты, кроме вызываемого клиента.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample30.cs)]
- Конкретный клиент, идентифицированный по идентификатору соединения.

    [!code-css[Main](hubs-api-guide-server/samples/sample31.css)]

    Этот пример `addContosoChatMessageToPage` вызывает вызываемого клиента и `Clients.Caller`имеет такой же эффект как использование .
- Все подключенные клиенты, за исключением указанных клиентов, идентифицируются по идентификатору подключения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample32.cs)]
- Все подключенные клиенты в определенной группе.

    [!code-css[Main](hubs-api-guide-server/samples/sample33.css)]
- Все подключенные клиенты в указанной группе, за исключением указанных клиентов, идентифицированных по идентификатору подключения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample34.cs)]
- Все подключенные клиенты в указанной группе, кроме вызываемого клиента.

    [!code-css[Main](hubs-api-guide-server/samples/sample35.css)]
- Конкретный пользователь, идентифицированный userId.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample36.cs)]

    По умолчанию `IPrincipal.Identity.Name`это, но это может быть изменено путем [регистрации реализации IUserIdProvider с глобальным хостом.](mapping-users-to-connections.md#IUserIdProvider)
- Все клиенты и группы в списке идентимативных идентипов связи.

    [!code-css[Main](hubs-api-guide-server/samples/sample37.css)]
- Список групп.

    [!code-css[Main](hubs-api-guide-server/samples/sample38.css)]
- Пользователь по имени.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample39.cs)]
- Список имен пользователей (введен в SignalR 2.1).

    [!code-csharp[Main](hubs-api-guide-server/samples/sample40.cs)]

<a id="dynamicmethodnames"></a>

### <a name="no-compile-time-validation-for-method-names"></a>Отсутствие проверки времени компиляции для имен методов

Имя метода, указанное, интерпретируется как динамический объект, что означает отсутствие IntelliSense или проверки времени компиляции для него. Выражение оценивается во время выполнения. Когда вызов метода выполняется, SignalR отправляет клиенту имя метода и значения параметров, и если у клиента есть метод, который соответствует имени, этот метод вызывается и значения параметра передаются ему. Если на клиенте не найдено подходящего метода, ошибка не возникает. Для получения информации о формате данных, которые SignalR передает клиенту за кулисами при вызове метода клиента, [см.](../getting-started/introduction-to-signalr.md)

<a id="caseinsensitive"></a>

### <a name="case-insensitive-method-name-matching"></a>Соответствие имени нечувствительных методов для дел

Сопоставление имен метода является нечувствительным. Например, `Clients.All.addContosoChatMessageToPage` на сервере `AddContosoChatMessageToPage` `addcontosochatmessagetopage`будет `addContosoChatMessageToPage` выполняться, или на клиенте.

<a id="asyncclient"></a>

### <a name="asynchronous-execution"></a>Асинхронное исполнение

Метод, который вы называете, выполняется асинхронно. Любой код, который приходит после вызова метода клиенту, будет выполняться немедленно, не дожидаясь, пока SignalR закончит передачу данных клиентам, если только вы не укажете, что последующие строки кода должны ждать завершения метода. Следующий пример кода показывает, как последовательно выполнять два метода клиента.

**Использование Await (.NET 4.5)**

[!code-csharp[Main](hubs-api-guide-server/samples/sample41.cs?highlight=1,3)]

Если вы `await` используете, чтобы ждать, пока клиент метод заканчивается до следующей строки кода выполняет, это не означает, что клиенты будут на самом деле получить сообщение до следующей строки кода выполняет. "Завершение" вызова метода клиента означает только то, что SignalR сделал все необходимое для отправки сообщения. Если вам нужна проверка, что клиенты получили сообщение, вы должны запрограммировать этот механизм самостоятельно. Например, можно закодировать `MessageReceived` метод в концентраторе, а в `addContosoChatMessageToPage` методе клиента вы можете вызвать `MessageReceived` после того, как вы сделаете любую работу, которую вам нужно сделать для клиента. В `MessageReceived` концентраторе вы можете выполнять любую работу, зависят от фактического приема клиента и обработки первоначального вызова метода.

### <a name="how-to-use-a-string-variable-as-the-method-name"></a>Как использовать переменную строки в качестве имени метода

Если вы хотите вызвать метод клиента, используя строку переменной, `Clients.Others`как `Clients.Caller`имя метода, литые `Clients.All` (или , и т.д.), а `IClientProxy` затем вызвать вызов вызова [(методИг, args...)](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.iclientproxy.invoke(v=vs.111).aspx).

[!code-csharp[Main](hubs-api-guide-server/samples/sample42.cs)]

<a id="groupsfromhub"></a>

## <a name="how-to-manage-group-membership-from-the-hub-class"></a>Как управлять членством в группе из класса концентратор

Группы в SignalR предоставляют метод передачи сообщений указанным подмноещем подключенных клиентов. Группа может иметь любое количество клиентов, а клиент может быть членом любого количества групп.

Для управления членством в группе используйте `Groups` методы [добавления](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.igroupmanager.add(v=vs.111).aspx) и [удаления,](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.igroupmanager.remove(v=vs.111).aspx) предоставляемые свойством класса концентратора. В следующем примере показаны `Groups.Add` `Groups.Remove` методы и методы, используемые в методах концентратора, которые называются кодом клиента, а затем клиентским кодом JavaScript, который их вызывает.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample43.cs?highlight=5,10)]

**Клиент JavaScript с помощью генерируемого прокси**

[!code-javascript[Main](hubs-api-guide-server/samples/sample44.js)]

[!code-javascript[Main](hubs-api-guide-server/samples/sample45.js)]

Не нужно явно создавать группы. Фактически группа автоматически создается при первом удеворе `Groups.Add`в вызове, и она удаляется при удалении последнего соединения из членства в ней.

API не может получить список членов группы или список групп. SignalR отправляет сообщения клиентам и группам на основе [модели паб/суб,](http://en.wikipedia.org/wiki/Publish/subscribe)а сервер не ведет списки групп или групп. Это помогает максимизировать масштабируемость, потому что всякий раз, когда вы добавляете узел на веб-ферму, любое состояние, которое поддерживает SignalR, должно распространяться на новый узел.

<a id="asyncgroupmethods"></a>

### <a name="asynchronous-execution-of-add-and-remove-methods"></a>Асинхронное выполнение методов добавления и удаления

И `Groups.Add` `Groups.Remove` методы выполняют асинхронно. Если вы хотите добавить клиента в группу и немедленно отправить сообщение клиенту с помощью группы, вы должны убедиться, что `Groups.Add` метод заканчивается первым. Следующий пример кода показывает, как это сделать.

**Добавление клиента в группу, а затем обмен сообщениями с этим клиентом**

[!code-csharp[Main](hubs-api-guide-server/samples/sample46.cs?highlight=1,3)]

<a id="grouppersistence"></a>

### <a name="group-membership-persistence"></a>Сохранение членства в группе

SignalR отслеживает соединения, а не пользователей, так что если вы хотите, чтобы пользователь был `Groups.Add` в одной группе каждый раз, когда пользователь устанавливает соединение, вы должны звонить каждый раз, когда пользователь устанавливает новое соединение.

После временной потери подключения, иногда SignalR может восстановить соединение автоматически. В этом случае SignalR восстанавливает одно и то же соединение, не устанавливая новое соединение, и поэтому членство клиента в группе автоматически восстанавливается. Это возможно даже в том случае, если временный сбой является результатом перезагрузки сервера или сбоя, потому что состояние соединения для каждого клиента, включая членство в группе, округло ежектно езнадля клиенту. Если сервер выходит из системы и заменяется новым сервером до отключения соединения, клиент может автоматически подключиться к новому серверу и повторно зарегистрироваться в группах, членами которыми он является.

Когда соединение не может быть восстановлено автоматически после потери подключения, или когда время подключения, или когда клиент отключается (например, когда браузер переходит на новую страницу), членство в группе теряется. В следующий раз, когда пользователь подключится, появится новое соединение. Для поддержания членства в группе, когда один и тот же пользователь устанавливает новое соединение, приложение должно отслеживать связи между пользователями и группами и восстанавливать членство в группе каждый раз, когда пользователь устанавливает новое соединение.

Более подробную информацию о соединениях и ресоединениях можно узнать по этой теме, [как обрабатывать события жизни соединения в классе концентраторов.](#connectionlifetime)

<a id="singleusergroups"></a>

### <a name="single-user-groups"></a>Группы для пользователей

Приложения, которые используют SignalR, как правило, должны отслеживать связи между пользователями и соединениями, чтобы знать, какой пользователь отправил сообщение и какой пользователь (ы) должен получать сообщение. Для этого группы используются в одном из двух часто используемых шаблонов.

- Группы для пользователей.

    Вы можете указать имя пользователя в качестве имени группы и добавить идентификатор текущего соединения в группу каждый раз, когда пользователь подключается или подключается. Отправка сообщений пользователю, который вы отправляете группе. Недостатком этого метода является то, что группа не предоставляет вам способ узнать, находится ли пользователь в сети или в автономном режиме.
- Отслеживание ассоциаций между именами пользователей и идентизацией соединения.

    Вы можете хранить связь между именем каждого пользователя и одним или более идентизациями связи в словаре или базе данных, а также обновлять сохраненные данные каждый раз, когда пользователь подключается или отключается. Для отправки сообщений пользователю указаны иноъемые данные соединения. Недостатком этого метода является то, что он занимает больше памяти.

<a id="connectionlifetime"></a>

## <a name="how-to-handle-connection-lifetime-events-in-the-hub-class"></a>Как обрабатывать события жизни соединения в классе концентратора

Типичными причинами обработки событий жизни соединения являются отслеживание того, подключен пользователь или нет, а также отслеживание связи между именами пользователей и идентимативами связи. Чтобы запустить свой собственный код, когда клиенты `OnConnected` `OnDisconnected`подключаются или отключаются, переопределить , и `OnReconnected` виртуальные методы класса концентратора, как показано в следующем примере.

[!code-csharp[Main](hubs-api-guide-server/samples/sample47.cs?highlight=3,14,22)]

<a id="onreconnected"></a>

### <a name="when-onconnected-ondisconnected-and-onreconnected-are-called"></a>При вызове OnConnected, OnDisconnected и OnReconnected

Каждый раз, когда браузер переходит на новую страницу, необходимо установить `OnDisconnected` новое соединение, `OnConnected` что означает, что SignalR будет выполнять метод с последующим методом. SignalR всегда создает новый идентификатор соединения при установлении нового соединения.

Метод `OnReconnected` вызывается, когда произошел временный перерыв в подключении, который SignalR может автоматически восстановить, например, когда кабель временно отключен и восстановлен до отключения соединения. Метод `OnDisconnected` вызывается при отключении клиента и включении SignalR в автоматическое соединение, например, при переходе браузера на новую страницу. Таким образом, возможная последовательность событий `OnConnected` `OnReconnected`для `OnDisconnected`данного клиента, ; или `OnConnected` `OnDisconnected`, . Вы не увидите `OnConnected`последовательность, `OnDisconnected` `OnReconnected` для данного соединения.

Метод `OnDisconnected` не вызывается в некоторых сценариях, например, когда сервер выходит из-под засетки или домен приложения перерабатывается. Когда другой сервер выходит в линию или домен App завершает переработку, некоторые `OnReconnected` клиенты могут восстановить соединение и запустить событие.

Для получения дополнительной информации, см [Понимание и обработка подключения Пожизненные события в SignalR](handling-connection-lifetime-events.md).

<a id="nocallerstate"></a>

### <a name="caller-state-not-populated"></a>Состояние вызываемого абонента не заселены

Методы обработчика событий срока службы соединения вызываются с сервера, что означает, что любое состояние, которое вы размещаете в `state` объекте на клиенте, не будет заполнено в `Caller` свойстве на сервере. Для получения `state` информации `Caller` об объекте и свойстве, см. [Как передать состояние между клиентами и классом концентратора](#passstate) позже в этой теме.

<a id="contextproperty"></a>

## <a name="how-to-get-information-about-the-client-from-the-context-property"></a>Как получить информацию о клиенте из свойства Контекста

Чтобы получить информацию о `Context` клиенте, используйте свойство класса концентратор. Свойство `Context` возвращает объект [HubCallerContext,](https://msdn.microsoft.com/library/jj890883(v=vs.111).aspx) который предоставляет доступ к следующей информации:

- Идентификатор подключения вызывающего клиента.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample48.cs?highlight=1)]

    Идентификатор соединения — это GUID, назначенный SignalR (вы не можете указать значение в собственном коде). Для каждого соединения имеется один идентификатор соединения, и один идентификатор соединения используется всеми концентраторами, если в приложении есть несколько концентраторов.
- Данные заголовка HTTP.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample49.cs?highlight=1)]

    Вы также можете получить `Context.Headers`http заголовки от . Причина нескольких ссылок на одно и `Context.Headers` то же, `Context.Request` что был создан `Context.Headers` во-первых, свойство было добавлено позже, и был сохранен для обратной совместимости.
- Данные строки запроса.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample50.cs?highlight=1)]

    Вы также можете получить данные строки запроса от `Context.QueryString`.

    Строка запроса, которую вы получаете в этом свойстве, используется с запросом HTTP, который установил соединение SignalR. Параметры строки запроса можно добавить в клиенте, настроив соединение, которое является удобным способом передачи данных о клиенте от клиента на сервер. Ниже приводится один из способов добавления строки запроса в клиент JavaScript при использовании сгенерированного прокси.

    [!code-javascript[Main](hubs-api-guide-server/samples/sample51.js?highlight=1)]

    Для получения дополнительной информации о параметрах строки запроса смотрите руководства API для клиентов [JavaScript](hubs-api-guide-javascript-client.md) и [.NET.](hubs-api-guide-net-client.md)

    Можно найти метод транспортировки, используемый для соединения в данных строки запроса, а также некоторые другие значения, используемые внутри SignalR:

    [!code-csharp[Main](hubs-api-guide-server/samples/sample52.cs)]

    Значение `transportMethod` будет "webSockets", "serverSentEvents", "foreverFrame" или "longPolling". Обратите внимание, что если `OnConnected` вы проверите это значение в методе обработчика событий, то в некоторых сценариях вы можете получить транспортное значение, которое не является окончательным согласованным методом транспортировки для соединения. В этом случае метод будет закидывать исключение и будет вызван позже, когда будет установлен окончательный метод транспортировки.
- Печенье.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample53.cs?highlight=1)]

    Вы также можете получить `Context.RequestCookies`печенье от .
- сведения о пользователе.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample54.cs?highlight=1)]
- Объект HttpContext для запроса:

    [!code-csharp[Main](hubs-api-guide-server/samples/sample55.cs?highlight=1)]

    Используйте этот метод `HttpContext.Current` вместо `HttpContext` того, чтобы получить объект для подключения SignalR.

<a id="passstate"></a>

## <a name="how-to-pass-state-between-clients-and-the-hub-class"></a>Как передать состояние между клиентами и классом концентратора

Клиент прокси предоставляет `state` объект, в котором вы можете хранить данные, которые вы хотите быть переданы на сервер с каждым методом вызова. На сервере вы можете получить `Clients.Caller` доступ к этим данным в свойстве в методах концентратора, которые вызываются клиентами. Свойство `Clients.Caller` не заселены для методов `OnConnected`обработчика событий срока службы соединения, `OnDisconnected`и `OnReconnected`.

Создание или обновление данных в объекте `state` и свойстве `Clients.Caller` работает в обоих направлениях. Вы можете обновить значения на сервере, и они передаются обратно клиенту.

В следующем примере показан клиентский код JavaScript, который хранит состояние для передачи на сервер с каждым вызовом метода.

[!code-javascript[Main](hubs-api-guide-server/samples/sample56.js?highlight=1-2)]

В следующем примере показан эквивалентный код в клиенте .NET.

[!code-csharp[Main](hubs-api-guide-server/samples/sample57.cs?highlight=1-2)]

В классе концентратора вы `Clients.Caller` можете получить доступ к этим данным в свойстве. В следующем примере показан код, который извлекает состояние, упомянутое в предыдущем примере.

[!code-csharp[Main](hubs-api-guide-server/samples/sample58.cs?highlight=3-4)]

> [!NOTE]
> Этот механизм для сохраняющегося состояния не предназначен для больших объемов данных, так как все, что вы кладете в свойство `state` или `Clients.Caller` свойство, округляется с каждым вызовом метода. Это полезно для небольших элементов, таких как имена пользователей или счетчики.

В VB.NET или в концентраторе сильного типа, объект состояния `Clients.Caller`вызываемого не может быть доступен через; вместо этого, использование `Clients.CallerState` (введено в SignalR 2.1):

**Использование состояния Caller в C #**

[!code-csharp[Main](hubs-api-guide-server/samples/sample59.cs?highlight=3-4)]

**Использование CallerState в визуальном базовом**

[!code-vb[Main](hubs-api-guide-server/samples/sample60.vb)]

<a id="handleErrors"></a>

## <a name="how-to-handle-errors-in-the-hub-class"></a>Как обрабатывать ошибки в классе концентратор

Для обработки ошибок, возникающих в методах класса концентратора, сначала убедитесь, что вы «наблюдаете» любые исключения из операций async (например, ссылаясь на клиентские методы) с помощью. `await` Затем используйте один или несколько из следующих методов:

- Оберните код метода в блоки try-catch и ввейди объект исключения. Для отладки можно отправить исключение клиенту, но по соображениям безопасности отправка подробной информации клиентам в производстве не рекомендуется.
- Создайте модуль конвейера концентраторов, который обрабатывает метод [OnIncomingError.](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.hubpipelinemodule.onincomingerror(v=vs.111).aspx) В следующем примере показан модуль конвейера, который регистрирует ошибки, а затем код в Startup.cs который вводит модуль в конвейер концентраторов.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample61.cs)]

    [!code-csharp[Main](hubs-api-guide-server/samples/sample62.cs?highlight=4)]
- Используйте `HubException` класс (введен в SignalR 2). Эта ошибка может быть брошена из любого вызова концентратора. Конструктор `HubError` принимает строку сообщения и объект для хранения дополнительных данных об ошибке. SignalR автоматически заследует исключение и отправляет его клиенту, где он будет использоваться для отклонения или отказа вызова метода концентратора.

    Следующие примеры кода демонстрируют, как бросить вызов `HubException` во время вызова концентратора и как обрабатывать исключение для клиентов JavaScript и .NET.

    **Серверный код, демонстрирующий класс HubException**

    [!code-csharp[Main](hubs-api-guide-server/samples/sample63.cs)]

    **Клиентский код JavaScript, демонстрирующий реакцию на бросание HubException в концентратор**

    [!code-html[Main](hubs-api-guide-server/samples/sample64.html)]

    **клиентский код .NET демонстрирует реакцию на бросание HubException в концентратор**

    [!code-csharp[Main](hubs-api-guide-server/samples/sample65.cs)]

Более подробную информацию о модулях конвейера концентратора можно [найти](#hubpipeline) в этой теме позже.

<a id="tracing"></a>

## <a name="how-to-enable-tracing"></a>Как включить трассировку

Чтобы включить отслеживание сервера, добавьте элемент system.diagnostics в файл Web.config, как показано в этом примере:

[!code-html[Main](hubs-api-guide-server/samples/sample66.html?highlight=17-72)]

При запуске приложения в Visual Studio можно просматривать журналы в окне **вывода.**

<a id="callfromoutsidehub"></a>

## <a name="how-to-call-client-methods-and-manage-groups-from-outside-the-hub-class"></a>Как вызвать методы клиентов и управлять группами из-за пределов класса концентратора

Чтобы вызвать методы клиента из другого класса, чем класс концентратора, получите ссылку на контекстный объект SignalR для концентратора и используйте его для вызова методов клиента или управления группами.

Следующий `StockTicker` класс примера получает объект контекста, хранит его в экземпляре класса, хранит экземпляр класса в статичном `updateStockPrice` свойстве и использует контекст из `StockTickerHub`экземпляра класса singleton для вызова метода на клиентов, подключенных к названному концентратору.

[!code-csharp[Main](hubs-api-guide-server/samples/sample67.cs?highlight=8,24)]

Если вам нужно использовать контекст несколько раз в долгоживущих объекта, получить ссылку один раз и сохранить его, а не получать его снова каждый раз. Получение контекста один раз гарантирует, что SignalR отправляет сообщения клиентам в той же последовательности, в которой методы концентратора делают вызовы метода клиента. Для учебника, который показывает, как использовать контекст SignalR для концентратора, см [ASP.NET.](../getting-started/tutorial-server-broadcast-with-signalr.md)

<a id="callingclientsoutsidehub"></a>

### <a name="calling-client-methods"></a>Вызов методов клиента

Вы можете указать, какие клиенты получат RPC, но у вас меньше вариантов, чем при вызове из класса концентратора. Причиной этого является то, что контекст не связан с конкретным вызовом от клиента, поэтому любые `Clients.Others`методы, которые требуют знания текущего идентификатора соединения, такие как, или `Clients.Caller` `Clients.OthersInGroup`, не доступны. Доступны следующие варианты:

- Все подключенные клиенты.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample68.cs)]
- Конкретный клиент, идентифицированный по идентификатору соединения.

    [!code-css[Main](hubs-api-guide-server/samples/sample69.css)]
- Все подключенные клиенты, за исключением указанных клиентов, идентифицируются по идентификатору подключения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample70.cs)]
- Все подключенные клиенты в определенной группе.

    [!code-css[Main](hubs-api-guide-server/samples/sample71.css)]
- Все подключенные клиенты в указанной группе, за исключением указанных клиентов, идентифицированных по идентификатору соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample72.cs)]

Если вы звоните в свой класс, не являющийся концентратором, из методов `Clients.AllExcept`в `Clients.Group` классе концентратора, вы можете сдать идентификатор текущего соединения и использовать его с `Clients.Client`помощью, или для имитации, `Clients.Caller` `Clients.Others`или `Clients.OthersInGroup`. В следующем примере `MoveShapeHub` класс передает идентификатор соединения классу, `Broadcaster` чтобы `Broadcaster` класс мог имитировать. `Clients.Others`

[!code-csharp[Main](hubs-api-guide-server/samples/sample73.cs?highlight=12,36)]

<a id="managinggroupsoutsidehub"></a>

### <a name="managing-group-membership"></a>Управление членством в группе

Для управления группами у вас есть те же варианты, что и в классе концентраторов.

- Добавление клиента в группу

    [!code-csharp[Main](hubs-api-guide-server/samples/sample74.cs)]
- Удалить клиента из группы

    [!code-css[Main](hubs-api-guide-server/samples/sample75.css)]

<a id="hubpipeline"></a>

## <a name="how-to-customize-the-hubs-pipeline"></a>Как настроить конвейер концентров

SignalR позволяет вводить свой собственный код в конвейер концентратора. В следующем примере показан модуль конвейера пользовательского центра, который регистрирует каждый входящий вызов метода, полученный от вызова клиента и исходящего вызова метода, вызываемого на клиента:

[!code-csharp[Main](hubs-api-guide-server/samples/sample76.cs)]

Следующий код в *файле Startup.cs* регистрирует модуль для запуска в конвейере концентратора:

[!code-csharp[Main](hubs-api-guide-server/samples/sample77.cs?highlight=3)]

Есть много различных методов, которые можно переопределить. Для получения полного [HubPipelineModule Methods](https://msdn.microsoft.com/library/jj918633(v=vs.111).aspx)списка см.
