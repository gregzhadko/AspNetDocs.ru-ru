---
uid: signalr/overview/guide-to-the-api/hubs-api-guide-server
title: Руководство по API концентраторов ASP.NET SignalR - Server (C#) | Документация Майкрософт
author: bradygaster
description: Этот документ содержит общие сведения о программировании серверной части API концентраторов SignalR ASP.NET для версии 2, SignalR с образцы кода, демонстрирующие...
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: b19913e5-cd8a-4e4b-a872-5ac7a858a934
msc.legacyurl: /signalr/overview/guide-to-the-api/hubs-api-guide-server
msc.type: authoredcontent
ms.openlocfilehash: c681b104b15bfc4a04587c7abf685dcf20def2ca
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65112789"
---
# <a name="aspnet-signalr-hubs-api-guide---server-c"></a>Руководство по API концентраторов ASP.NET SignalR - Server (C#)

по [Флетчера Патрик](https://github.com/pfletcher), [том Дайкстра](https://github.com/tdykstra)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> Этот документ содержит общие сведения о программировании серверной части API концентраторов SignalR ASP.NET для SignalR версии 2, примеры программного кода, демонстрирующий общих параметров.
> 
> API концентраторов SignalR позволяет вам выбрать удаленные вызовы процедур (RPC), с сервера подключенным клиентам и от клиентов к серверу. В серверном коде определяют методы, которые могут быть вызваны клиентов и вызывать методы, которые выполняются на клиенте. В клиентском коде определяют методы, которые могут вызываться с сервера и вызывать методы, которые выполняются на сервере. SignalR берет на себя все необходимое для вас клиент сервер.
> 
> SignalR также предлагает API низкого уровня, вызывается постоянные подключения. Введение в SignalR, концентраторы и постоянные подключения, см. в разделе [введение в SignalR 2](../getting-started/introduction-to-signalr.md).
> 
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемого в этом разделе
> 
> 
> - [Visual Studio 2013](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - .NET 4.5
> - SignalR версии 2
>   
> 
> 
> ## <a name="topic-versions"></a>Версии раздела
> 
> Сведения о более ранних версий SignalR, см. в разделе [более старых версий SignalR](../older-versions/index.md).
> 
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
> 
> Оставьте свои отзывы на том, как вам понравилось, и этот учебник и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, которые не имеют отношения к руководству, их можно разместить [форум по ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).

## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Как зарегистрировать по промежуточного слоя SignalR](#route)

    - [URL-адрес /signalr](#signalrurl)
    - [Настройка параметров SignalR](#options)
- [Как создать и использовать классы концентратора](#hubclass)

    - [Время жизни объекта концентратора](#transience)
    - [Венгерской имена центров в клиентах JavaScript](#hubnames)
    - [Multiple Hubs](#multiplehubs)
    - [Концентраторы со строгой типизацией](#stronglytypedhubs)
- [Как определить методы в классе концентратора, который клиенты могут вызывать](#hubmethods)

    - [Венгерской имена методов в клиентах JavaScript](#methodnames)
    - [Когда следует выполнить асинхронно](#asyncmethods)
    - [Определение перегрузки](#overloads)
    - [Отчеты о ходе выполнения из вызовы методов концентратора](#progress)
- [Порядок вызова методов клиента от концентратора класса](#callfromhub)

    - [Выбор клиентов, которые будут получать RPC](#selectingclients)
    - [Имена методов не проверяются во время компиляции](#dynamicmethodnames)
    - [Совпадение имен метода, без учета регистра](#caseinsensitive)
    - [Асинхронное выполнение](#asyncclient)
- [Как управлять членством в группах от класса концентратора](#groupsfromhub)

    - [Асинхронное выполнение методов Add и Remove](#asyncgroupmethods)
    - [Сохраняемость членство группы](#grouppersistence)
    - [Группы в однопользовательском режиме](#singleusergroups)
- [Способ обработки событий времени существования подключений в классе концентратора](#connectionlifetime)

    - [При вызове OnConnected OnDisconnected и OnReconnected](#onreconnected)
    - [Состояние вызывающего объекта не заполнен](#nocallerstate)
- [Как получить сведения о клиенте из контекстного свойства](#contextproperty)
- [Способ передачи состояния между клиентами и классу Hub](#passstate)
- [Способ обработки ошибок в классе концентратора](#handleErrors)
- [Как вызывать методы клиента и управлять ими групп за пределами классу Hub](#callfromoutsidehub)

    - [Вызов методов клиента](#callingclientsoutsidehub)
    - [Управление членством в группе](#managinggroupsoutsidehub)
- [Включение трассировки](#tracing)
- [Настройка конвейера концентраторов](#hubpipeline)

Документацию о том, как клиенты программы см. следующие ресурсы:

- [Руководство по API концентраторов SignalR — клиент JavaScript](hubs-api-guide-javascript-client.md)
- [Руководство по API концентраторов SignalR — клиент .NET](hubs-api-guide-net-client.md)

Серверные компоненты для SignalR 2 доступны только в .NET 4.5. Серверы под управлением .NET 4.0 необходимо использовать версии 1.х SignalR.

<a id="route"></a>

## <a name="how-to-register-signalr-middleware"></a>Как зарегистрировать по промежуточного слоя SignalR

Чтобы определить маршрут, который будет использоваться клиентами для подключения к центру, вызовите `MapSignalR` метод при запуске приложения. `MapSignalR` — [метод расширения](https://msdn.microsoft.com/library/vstudio/bb383977.aspx) для `OwinExtensions` класса. В следующем примере показано определение концентраторов SignalR маршрут, используя класс запуска OWIN.

[!code-csharp[Main](hubs-api-guide-server/samples/sample1.cs)]

Функциональные возможности SignalR при добавлении в приложение ASP.NET MVC, убедитесь, что раньше, чем другие маршруты добавляется маршрут SignalR. Дополнительные сведения см. в статье [Руководство Начало работы с SignalR 2 и MVC 5](../getting-started/tutorial-getting-started-with-signalr-and-mvc.md).

<a id="signalrurl"></a>

### <a name="the-signalr-url"></a>URL-адрес /signalr

По умолчанию является URL-адрес маршрута, который клиенты будут использовать для подключения к центру «/ signalr». (Не путайте этот URL-адрес с URL-адрес «/ signalr/концентраторы», который является для автоматически создаваемого файла JavaScript. Дополнительные сведения о созданном прокси, см. в разделе [руководство по API концентраторов SignalR — клиент JavaScript - созданный прокси и что он делает для вас](hubs-api-guide-javascript-client.md#genproxy).)

Могут возникнуть непредвиденные обстоятельства, которые делают этот базовый URL-адрес не может использоваться для SignalR; Например, у вас есть папка в проекте с именем *signalr* и вы не хотите изменить имя. В этом случае можно изменить базовый URL-адрес, как показано в следующих примерах (Замените «/ signalr» в образце кода с нужный URL-адрес).

**Код сервера, который указывает URL-адрес**

[!code-csharp[Main](hubs-api-guide-server/samples/sample2.cs?highlight=1)]

**Клиентский код JavaScript, который указывает URL-адрес (с помощью созданного прокси-сервер)**

[!code-javascript[Main](hubs-api-guide-server/samples/sample3.js?highlight=1)]

**Клиентский код JavaScript, который указывает URL-адрес (без созданный прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-server/samples/sample4.js?highlight=1)]

**Код клиента .NET, который указывает URL-адрес**

[!code-csharp[Main](hubs-api-guide-server/samples/sample5.cs?highlight=1)]

<a id="options"></a>

### <a name="configuring-signalr-options"></a>Настройка параметров SignalR

Перегруженные версии `MapSignalR` метод дают возможность задать пользовательский URL-адрес сопоставителя пользовательскую зависимость и следующие параметры:

- Разрешить междоменные вызовы, с помощью CORS и JSONP из клиентского обозревателя.

    Обычно если браузер загружает страницу из `http://contoso.com`, подключении SignalR находится в том же домене, в `http://contoso.com/signalr`. Если страницы от `http://contoso.com` подключается к `http://fabrikam.com/signalr`, то есть соединение между доменами. По соображениям безопасности подключений между доменами отключены по умолчанию. Дополнительные сведения см. в разделе [ASP.NET руководство по API концентраторов SignalR — клиент JavaScript - как для установления соединения между доменами](hubs-api-guide-javascript-client.md#crossdomain).
- Включите подробные сообщения об ошибках.

    При возникновении ошибок, для отправки клиентам сообщение уведомления без подробной информации о произошедшее является поведение по умолчанию SignalR. Отправки клиентам подробные сведения об ошибке в рабочей среде, не рекомендуется, поскольку пользователи-злоумышленники, можно использовать информацию в атаки, направленные на приложение. Для устранения неполадок, можно использовать этот параметр временно включить более информативные отчеты об ошибках.
- Отключите автоматически созданные файлы прокси JavaScript.

    По умолчанию файл JavaScript с прокси-серверы для классов концентратор создается в ответ на URL-адрес «/ signalr/концентраторы». Если вы не хотите использовать прокси-серверы JavaScript, или если вы хотите создать этот файл вручную и ссылаться на физическом файле в ваших клиентов, можно использовать этот параметр, чтобы отключить создание прокси-сервера. Дополнительные сведения см. в разделе [руководство по API концентраторов SignalR — клиент JavaScript - прокси, созданного как создать физический файл для SignalR](hubs-api-guide-javascript-client.md#manualproxy).

Приведенный ниже показано, как указать URL-адрес подключения SignalR и эти параметры в вызове `MapSignalR` метод. Чтобы задать пользовательский URL-адрес, замените «/ signalr» в примере с URL-адрес, который вы хотите использовать.

[!code-csharp[Main](hubs-api-guide-server/samples/sample6.cs)]

<a id="hubclass"></a>

## <a name="how-to-create-and-use-hub-classes"></a>Как создать и использовать классы концентратора

Чтобы создать концентратор, создайте класс, производный от [Microsoft.Aspnet.Signalr.Hub](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hub(v=vs.111).aspx). В следующем примере показан простой класс концентратора для приложения разговора.

[!code-csharp[Main](hubs-api-guide-server/samples/sample7.cs)]

В этом примере подключенный клиент может вызвать `NewContosoChatMessage` метод, и когда это происходит, данные, полученные широковещательная рассылка на всех подключенных клиентов.

<a id="transience"></a>

### <a name="hub-object-lifetime"></a>Время жизни объекта концентратора

Не создавать экземпляр класса концентратора или вызывать его методы из собственного кода на сервере; все это выполняется автоматически конвейером концентраторов SignalR. SignalR создает новый экземпляр класса концентратора каждый раз, когда оно будет обрабатывать операции концентратора, например когда клиент подключается, отключается или выполняет вызов метода к серверу.

Так как экземпляры класса концентратора являются временными, их нельзя использовать для поддержания состояния от одного вызова метода к другому. Каждый раз, сервер получает вызов метода из клиента, новый экземпляр класса процессов центра сообщения. Для поддержания состояния, через несколько подключений и вызовы методов, использовать другой метод, например базы данных или статической переменной на класс концентратора или другого класса, который является производным от `Hub`. Если сохранить данные в памяти, с помощью метода, например в статической переменной класса концентратора, данные будут потеряны при очистке домена приложения.

Если вы хотите отправлять сообщения на клиентах из собственного кода, запускаемый за пределами классу Hub, это нельзя сделать, создание экземпляра класса концентратора, но это можно сделать, получив ссылку на объект контекста SignalR для класса концентратора. Дополнительные сведения см. в разделе [как вызывать методы клиента и управлять ими групп за пределами классу Hub](#callfromoutsidehub) далее в этом разделе.

<a id="hubnames"></a>

### <a name="camel-casing-of-hub-names-in-javascript-clients"></a>Венгерской имена центров в клиентах JavaScript

По умолчанию клиенты JavaScript ссылаются концентраторов с использованием версии стиле Camel имени класса. SignalR автоматически делает это изменение, чтобы код JavaScript может соответствовать соглашениям JavaScript. Предыдущий пример будет называться `contosoChatHub` в коде JavaScript.

**Сервер**

[!code-csharp[Main](hubs-api-guide-server/samples/sample8.cs?highlight=1)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample9.js?highlight=1)]

Если вы хотите указать другое имя для клиентов для использования, добавьте `HubName` атрибута. При использовании `HubName` атрибут, никак не изменяется имя в стиль Camel в клиентах JavaScript.

**Сервер**

[!code-csharp[Main](hubs-api-guide-server/samples/sample10.cs?highlight=1)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample11.js?highlight=1)]

<a id="multiplehubs"></a>

### <a name="multiple-hubs"></a>Несколько концентраторов

Можно определить несколько классов концентратора в приложении. При этом общий доступ к подключению, но отделены групп:

- Все клиенты будут использовать же URL-адрес для подключения SignalR с вашей службой («/ signalr» или пользовательский URL-адрес, если вы ее указали), и что соединение используется для всех концентраторов, определенной службой.

    Нет никакой разницы производительности для нескольких центров, по сравнению с определение все функциональные возможности центра в одном классе.
- Все центры получить те же сведения запроса HTTP.

    Так как все концентраторы используют то же подключение, только сведения о запросе HTTP, сервер возвращает становится поставляются в исходном запросе HTTP, который устанавливает соединение SignalR. Если запрос на подключение используется для передачи данных из клиента на сервер, указав строку запроса, не может предоставить различные строки запроса для разных концентраторов. Все концентраторы будут получать те же сведения.
- Созданный файл прокси JavaScript будет содержать учетные записи-посредники для всех концентраторов в одном файле.

    Сведения о прокси JavaScript, см. в разделе [руководство по API концентраторов SignalR — клиент JavaScript - созданный прокси и что он делает для вас](hubs-api-guide-javascript-client.md#genproxy).
- Группы определяются в пределах концентраторов.

    В SignalR, которые можно определить именованные группы, чтобы вещать на подмножества подключенных клиентов. Группы поддерживаются отдельно для каждого центра. Например, группу с именем «Администраторы» будет включать в себя набор клиентов для вашего `ContosoChatHub` класс и имя группы ссылаетесь на другой набор клиентов для вашего `StockTickerHub` класса.

<a id="stronglytypedhubs"></a>
### <a name="strongly-typed-hubs"></a>Концентраторы со строгой типизацией

Определение интерфейса для своих методов концентратора, которые клиент может ссылки (и включить Intellisense в методах hub), являются производными вашего концентратора `Hub<T>` (впервые представлено в SignalR 2.1) вместо `Hub`:

[!code-csharp[Main](hubs-api-guide-server/samples/sample12.cs)]

<a id="hubmethods"></a>

## <a name="how-to-define-methods-in-the-hub-class-that-clients-can-call"></a>Как определить методы в классе концентратора, который клиенты могут вызывать

Чтобы предоставить метод на концентраторе, который будет вызываться из клиента, объявите открытый метод, как показано в следующих примерах.

[!code-csharp[Main](hubs-api-guide-server/samples/sample13.cs?highlight=3)]

[!code-csharp[Main](hubs-api-guide-server/samples/sample14.cs?highlight=3)]

Можно указать тип возвращаемого значения и параметры, включая сложные типы и массивы, как это делается в любом методе C#. Любые данные, которые вы получаете в параметрах или возвращать вызывающей стороне передается между клиентом и сервером с помощью JSON и SignalR обрабатывает привязки сложных объектов и массивов объектов автоматически.

<a id="methodnames"></a>

### <a name="camel-casing-of-method-names-in-javascript-clients"></a>Венгерской имена методов в клиентах JavaScript

По умолчанию клиенты JavaScript ссылаются методов концентратора с помощью версии стиле Camel имени метода. SignalR автоматически делает это изменение, чтобы код JavaScript может соответствовать соглашениям JavaScript.

**Сервер**

[!code-csharp[Main](hubs-api-guide-server/samples/sample15.cs?highlight=1)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample16.js?highlight=1)]

Если вы хотите указать другое имя для клиентов для использования, добавьте `HubMethodName` атрибута.

**Сервер**

[!code-csharp[Main](hubs-api-guide-server/samples/sample17.cs?highlight=1)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample18.js?highlight=1)]

<a id="asyncmethods"></a>

### <a name="when-to-execute-asynchronously"></a>Когда следует выполнить асинхронно

Если метод будет иметь долго выполняющиеся или должен работать будет включать оповещения, такие как поиск в базе данных или вызов веб-службы, сделать асинхронного метода концентратора, возвращая [задачи](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) (вместо `void` возврата) или [ Задача&lt;T&gt; ](https://msdn.microsoft.com/library/dd321424.aspx) объектов (вместо `T` тип возвращаемого значения). При возврате `Task` ожидает объект из метода, SignalR `Task` для завершения, а затем отправляет без оболочки результат обратно клиенту, поэтому нет никакой разницы в как кода вызов метода в клиенте.

Что делает метод концентратора на асинхронных позволяет избежать блокирует подключения, когда используется транспорт WebSocket. Когда метод концентратора выполняется синхронно и транспортом является WebSocket, последующие вызовы методов концентратора от одного клиента блокируются до завершения метода концентратора.

В следующем примере показано, тот же метод в коде выполняются синхронно или асинхронно, а затем клиентский код JavaScript, подходящий для вызова любой из версий.

**Синхронный**

[!code-csharp[Main](hubs-api-guide-server/samples/sample19.cs)]

**Асинхронный**

[!code-csharp[Main](hubs-api-guide-server/samples/sample20.cs?highlight=1,7-8)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample21.js)]

Дополнительные сведения о способах использования асинхронных методов в ASP.NET 4.5 см. в разделе [использование асинхронных методов в ASP.NET MVC 4](../../../mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4.md).

<a id="overloads"></a>

### <a name="defining-overloads"></a>Определение перегрузки

Если вы хотите определить перегрузок для метода, число параметров в каждой перегрузке должны быть разными. Если отличить перегрузку, просто указав разные типы параметров, ваш класс концентратора скомпилируется, но служба SignalR приведет к возникновению исключения во время выполнения, когда клиенты пытаются для вызова одной из перегрузок.

<a id="progress"></a>
### <a name="reporting-progress-from-hub-method-invocations"></a>Отчеты о ходе выполнения из вызовы методов концентратора

SignalR 2.1 добавлена поддержка [шаблон отчета о состоянии](https://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx) появился в .NET 4.5. Чтобы реализовать отчетов о ходе выполнения, определять `IProgress<T>` параметра для метода концентратора, которые для клиента:

[!code-csharp[Main](hubs-api-guide-server/samples/sample22.cs)]

При написании метода server выполняющейся длительное время, важно использовать шаблон асинхронного программирования как Async / Await вместо блокировки потока концентратора.

<a id="callfromhub"></a>

## <a name="how-to-call-client-methods-from-the-hub-class"></a>Порядок вызова методов клиента от концентратора класса

Чтобы вызвать методы клиента с сервера, используйте `Clients` свойство в метод в классе концентратора. В следующем примере показано код сервера, который вызывает `addNewMessageToPage` на всех подключенных клиентах и код клиента, который определяет метод, в клиенте JavaScript.

**Сервер**

[!code-csharp[Main](hubs-api-guide-server/samples/sample23.cs?highlight=5)]

Вызов метода клиента представляет собой асинхронную операцию и возвращает `Task`. Используйте `await`:

* Чтобы убедиться, сообщение отправляется без ошибок. 
* Чтобы включить перехват и обработка ошибок в блоке try-catch.

**С помощью созданного прокси клиента JavaScript**

[!code-html[Main](hubs-api-guide-server/samples/sample24.html?highlight=1)]

Не удается получить значение, возвращаемое из метода клиента; синтаксис, такие как `int x = Clients.All.add(1,1)` не работает.

Можно указать сложные типы и массивы параметров. В следующем примере передается сложный тип клиенту в параметре метода.

**Код сервера, который вызывает клиентский метод, с помощью сложного объекта**

[!code-csharp[Main](hubs-api-guide-server/samples/sample25.cs?highlight=3)]

**Код сервера, который определяет сложный объект**

[!code-csharp[Main](hubs-api-guide-server/samples/sample26.cs?highlight=1)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample27.js?highlight=2-3)]

<a id="selectingclients"></a>

### <a name="selecting-which-clients-will-receive-the-rpc"></a>Выбор клиентов, которые будут получать RPC

Это свойство возвращает клиентов [HubConnectionContext](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.hubconnectioncontext(v=vs.111).aspx) объект, который предоставляет несколько вариантов для указания, какие клиенты будут получать RPC:

- Все подключенные клиенты.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample28.cs)]
- Вызывающий клиент.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample29.cs)]
- Все клиенты, кроме вызывающего клиента.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample30.cs)]
- Конкретного клиента, определяемого по идентификатору подключения.

    [!code-css[Main](hubs-api-guide-server/samples/sample31.css)]

    В этом примере вызывается `addContosoChatMessageToPage` вызывающему клиенту и имеет тот же эффект, как с помощью `Clients.Caller`.
- Все подключенные клиенты, кроме указанным клиентам, идентифицируемый идентификатор соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample32.cs)]
- Все подключенные клиенты в указанной группе.

    [!code-css[Main](hubs-api-guide-server/samples/sample33.css)]
- Все подключенные клиенты в указанной группе, кроме указанным клиентам, идентифицируемый идентификатор соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample34.cs)]
- Все подключенные клиенты в указанной группе, кроме вызывающего клиента.

    [!code-css[Main](hubs-api-guide-server/samples/sample35.css)]
- Пользователь, определяемый userId.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample36.cs)]

    По умолчанию, это `IPrincipal.Identity.Name`, но его можно изменить, [регистрации реализацию IUserIdProvider глобального узла](mapping-users-to-connections.md#IUserIdProvider).
- Все клиенты и группы в списке идентификаторов подключений.

    [!code-css[Main](hubs-api-guide-server/samples/sample37.css)]
- Список групп.

    [!code-css[Main](hubs-api-guide-server/samples/sample38.css)]
- Пользователь по имени.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample39.cs)]
- Список имен пользователей (впервые представлено в SignalR 2.1).

    [!code-csharp[Main](hubs-api-guide-server/samples/sample40.cs)]

<a id="dynamicmethodnames"></a>

### <a name="no-compile-time-validation-for-method-names"></a>Имена методов не проверяются во время компиляции

Имя метода, указать интерпретируется как динамический объект, это означает, что нет IntelliSense или проверку во время компиляции. Выражение вычисляется во время выполнения. При выполнении вызова метода, SignalR отправляет имя метода и значения параметров клиента, а если клиент имеет метод, совпадающий с именем, что метод вызывается и значения параметров передаются в него. Если отсутствует соответствующий метод находится на стороне клиента, ошибка не возникает. Сведения о формате данных, SignalR передает клиенту за кулисами при вызове метода клиента, см. в разделе [введение в SignalR](../getting-started/introduction-to-signalr.md).

<a id="caseinsensitive"></a>

### <a name="case-insensitive-method-name-matching"></a>Совпадение имен метода, без учета регистра

Совпадение имен метод не учитывает регистр. Например `Clients.All.addContosoChatMessageToPage` будет выполняться на сервере `AddContosoChatMessageToPage`, `addcontosochatmessagetopage`, или `addContosoChatMessageToPage` на стороне клиента.

<a id="asyncclient"></a>

### <a name="asynchronous-execution"></a>Асинхронное выполнение

Асинхронно выполняет метод, который вы вызываете. Любой код, который после вызова метода клиенту начинается немедленно без ожидания SignalR для завершения передачи данных для клиентов в том случае, если не указано, в последующих строках кода следует подождать завершения метода. В следующем примере кода показано, как для последовательного выполнения двух методов клиента.

**С помощью Await (.NET 4.5)**

[!code-csharp[Main](hubs-api-guide-server/samples/sample41.cs?highlight=1,3)]

Если вы используете `await` подождать, пока клиентский метод завершения до выполнения следующей строке кода, это не означает, что клиенты фактически будут получать сообщение перед выполнением следующей строке кода. «Дополнение» клиентского вызова метода только означает, что SignalR выполняться все компоненты, необходимые для отправки сообщения. Если вам нужна проверка, что клиенты получили сообщение, вам нужно программировать этот механизм самостоятельно. Например, вы кода `MessageReceived` метод на концентраторе и в `addContosoChatMessageToPage` метод на стороне клиента, можно вызвать `MessageReceived` после выполнения работа вам нужно сделать на стороне клиента. В `MessageReceived` концентратора можно делать любые зависят от фактического клиентского приема и обработки исходного вызова метода.

### <a name="how-to-use-a-string-variable-as-the-method-name"></a>Использование строковой переменной в качестве имени метода

Если вы хотите вызвать клиентский метод, используя строковую переменную в качестве имени метода, приведение `Clients.All` (или `Clients.Others`, `Clients.Caller`т. д.) для `IClientProxy` , а затем вызвать [Invoke (methodName, args...) ](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.iclientproxy.invoke(v=vs.111).aspx).

[!code-csharp[Main](hubs-api-guide-server/samples/sample42.cs)]

<a id="groupsfromhub"></a>

## <a name="how-to-manage-group-membership-from-the-hub-class"></a>Как управлять членством в группах от класса концентратора

Группами в SignalR предоставляют метод широковещательная рассылка сообщений для заданного подмножества подключенных клиентов. Группа может иметь любое число клиентов, и клиент может быть членом любое количество групп.

Чтобы управлять членством в группах, используйте [добавить](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.igroupmanager.add(v=vs.111).aspx) и [удалить](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.igroupmanager.remove(v=vs.111).aspx) методы, предоставляемые `Groups` свойство класса концентратора. В следующем примере показан `Groups.Add` и `Groups.Remove` методы, используемые в методах Hub, которые вызываются в клиентском коде, следуют клиентского кода JavaScript, который вызывает их.

**Сервер**

[!code-csharp[Main](hubs-api-guide-server/samples/sample43.cs?highlight=5,10)]

**С помощью созданного прокси клиента JavaScript**

[!code-javascript[Main](hubs-api-guide-server/samples/sample44.js)]

[!code-javascript[Main](hubs-api-guide-server/samples/sample45.js)]

Не нужно явно создавать группы. Фактически группа автоматически создается первый раз, укажите его имя в вызове `Groups.Add`, и она будет удалена при удалении последнего соединения из членства в ней.

Не существует API для получения списка членства в группе или список групп. SignalR отправляет сообщения клиентам и группам на основе [модели публикации и подписки](http://en.wikipedia.org/wiki/Publish/subscribe), и сервер не ведет список групп или членства в группах. Это помогает добиться максимальной масштабируемости, так как каждый раз при добавлении узла к веб-ферме, любое состояние, которое поддерживает SignalR должен быть распространены на новый узел.

<a id="asyncgroupmethods"></a>

### <a name="asynchronous-execution-of-add-and-remove-methods"></a>Асинхронное выполнение методов Add и Remove

`Groups.Add` И `Groups.Remove` методы асинхронного выполнения. Если вы хотите добавить в клиент группу и немедленно отправить клиенту сообщение с помощью в группу, необходимо убедиться, что `Groups.Add` метод завершается первой. В следующем примере кода показано, как это сделать.

**Добавление клиента в группу и затем обмена сообщениями этого клиента**

[!code-csharp[Main](hubs-api-guide-server/samples/sample46.cs?highlight=1,3)]

<a id="grouppersistence"></a>

### <a name="group-membership-persistence"></a>Сохраняемость членство группы

SignalR отслеживает подключений, которые не пользователей, поэтому, если пользователь должны находиться в той же группе каждый раз, когда пользователь выполняет подключение, должен быть вызван `Groups.Add` каждый раз, он устанавливает новое подключение.

После временной потери связи иногда SignalR можно восстановить подключение автоматически. В этом случае SignalR восстановление одно и то же подключение, не создания нового подключения, и таким образом, членство в группе клиента восстанавливается автоматически. Это возможно даже в том случае, если временный разрыв не в результате перезагрузки сервера или сбой, так как состояние подключения для каждого клиента, включая членство в группах, обхода клиенту. Если сервер выйдет из строя и заменяется на новый сервер до истечения времени ожидания соединения, клиент можно автоматически повторно подключиться к новому серверу и повторно зарегистрировать в группах, в которых он участвует.

Если соединение невозможно восстановить автоматически после потери подключения, или когда время ожидания соединения или при отключении клиента (например, когда браузер переходит на новую страницу), членства в группах, будут потеряны. При очередном подключении будет новое соединение. Для обеспечения членства в группах при тот же пользователь устанавливает новое соединение, приложение должно отслеживать связи между пользователями и группами и восстановление членства в группах каждый раз, пользователь устанавливает новое соединение.

Дополнительные сведения о подключениях и переподключения см. в разделе [способ обработки событий времени существования подключений в классе концентратора](#connectionlifetime) далее в этом разделе.

<a id="singleusergroups"></a>

### <a name="single-user-groups"></a>Группы в однопользовательском режиме

Приложения, использующие SignalR обычно имеют для отслеживания сопоставлений пользователей и подключений, чтобы знать, какой пользователь отправил сообщение и какие пользователи должны получать сообщения. Группы используются в одном из двух часто используемых шаблонов для соответствующей.

- Группы в однопользовательском режиме.

    Можно указать имя пользователя в качестве имени группы и добавить идентификатор текущего подключения к группе, каждый раз пользователь подключается или повторном подключении. Для отправки сообщений пользователю отправлять в группу. Недостатком этого метода является то, что группе не предоставляет вам способ проверить, является ли пользователь интерактивном или автономном режиме.
- Отслеживать связи между имена пользователей и идентификаторов подключений.

    Можно хранить ассоциацию между каждого имени пользователя и один или несколько идентификаторов подключений в словарь или базы данных и обновлять сохраненные данные каждый раз, пользователь подключении или отключении. Для отправки сообщений пользователю указать идентификаторов подключений. Недостатком этого метода является то, что занимает больше памяти.

<a id="connectionlifetime"></a>

## <a name="how-to-handle-connection-lifetime-events-in-the-hub-class"></a>Способ обработки событий времени существования подключений в классе концентратора

Типичной причиной для обработки события времени жизни соединения: для отслеживания ли пользователь подключен или не и для отслеживания сопоставление имен пользователей и идентификаторов подключений. Для выполнения собственного кода, когда клиенты подключиться или отключиться, переопределите `OnConnected`, `OnDisconnected`, и `OnReconnected` класса виртуальных методов концентратора, как показано в следующем примере.

[!code-csharp[Main](hubs-api-guide-server/samples/sample47.cs?highlight=3,14,22)]

<a id="onreconnected"></a>

### <a name="when-onconnected-ondisconnected-and-onreconnected-are-called"></a>При вызове OnConnected OnDisconnected и OnReconnected

Каждый раз, когда браузер переходит на новую страницу, новое соединение имеет установления, означающее, что будет выполняться SignalR `OnDisconnected` метода, за которым следует `OnConnected` метод. SignalR всегда создает новый идентификатор соединения, если установлено новое соединение.

`OnReconnected` Метод вызывается в том случае, когда произошел временный разрыв подключения, можно автоматически восстановить SignalR, например когда кабель временно отключен и использовать подключение до истечения времени ожидания соединения. `OnDisconnected` Метод вызывается в том случае, когда клиент отключен и SignalR невозможностью автоматически, например когда браузер переходит на новую страницу. Таким образом, возможно последовательность событий для данного клиента — `OnConnected`, `OnReconnected`, `OnDisconnected`; или `OnConnected`, `OnDisconnected`. Вы не увидите последовательность `OnConnected`, `OnDisconnected`, `OnReconnected` для данного соединения.

`OnDisconnected` Метод не вызывается в некоторых сценариях, например если сервер выйдет из строя или домен приложения получает перезапущен. Когда другой сервер переходит в оперативный или домена приложения по завершении его повторный запуск, некоторые клиенты могут иметь возможность повторного подключения и инициировать `OnReconnected` событий.

Дополнительные сведения см. в разделе [понимание и обработка событий времени существования подключений в SignalR](handling-connection-lifetime-events.md).

<a id="nocallerstate"></a>

### <a name="caller-state-not-populated"></a>Состояние вызывающего объекта не заполнен

Методы обработчиков событий времени существования соединения вызываются на сервере, это означает, что любое состояние, которое необходимо поместить в `state` объекта на стороне клиента не будут указаны в `Caller` свойство на сервере. Сведения о `state` объекта и `Caller` свойство, см. в разделе [как для передачи состояния между клиентами и классу Hub](#passstate) далее в этом разделе.

<a id="contextproperty"></a>

## <a name="how-to-get-information-about-the-client-from-the-context-property"></a>Как получить сведения о клиенте из контекстного свойства

Чтобы получить сведения о клиенте, используйте `Context` свойство класса концентратора. `Context` Возвращает [HubCallerContext](https://msdn.microsoft.com/library/jj890883(v=vs.111).aspx) объект, который предоставляет доступ к следующим сведениям:

- Идентификатор подключения вызывающего клиента.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample48.cs?highlight=1)]

    Идентификатор подключения — это GUID, назначенный SignalR (в собственном коде невозможно задать значение). Есть один идентификатор подключения для каждого подключения и то же подключение, он используется во всех концентраторах, если у вас есть несколько концентраторов в приложении.
- Данные заголовка HTTP.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample49.cs?highlight=1)]

    Можно также получить заголовки HTTP из `Context.Headers`. Причина для нескольких ссылок на тот же том, что `Context.Headers` была создана, во-первых, `Context.Request` свойство было добавлено позже, и `Context.Headers` был сохранен для обратной совместимости.
- Запрос данных строки.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample50.cs?highlight=1)]

    Можно также получить данные строки запроса из `Context.QueryString`.

    Строка запроса, которую можно получить в этом свойстве является тот, который использовался с HTTP-запроса, установленного подключения SignalR. Можно добавить параметры строки запроса в клиенте, настроив подключения, которая является удобным способом для передачи данных о клиенте от клиента к серверу. В следующем примере показан один способ добавления строки запроса в клиенте JavaScript, при использовании созданного прокси.

    [!code-javascript[Main](hubs-api-guide-server/samples/sample51.js?highlight=1)]

    Дополнительные сведения о настройке параметров строки запроса см. в разделе руководства по API для [JavaScript](hubs-api-guide-javascript-client.md) и [.NET](hubs-api-guide-net-client.md) клиентов.

    Вы можете найти метод транспорта, используемый для соединения в данные строки запроса, а также некоторые другие значения, используемые внутри SignalR:

    [!code-csharp[Main](hubs-api-guide-server/samples/sample52.cs)]

    Значение `transportMethod` будет «webSockets», «serverSentEvents», «foreverFrame» или «longPolling». Обратите внимание, что если вы установите это значение `OnConnected` метод обработчика событий, в некоторых сценариях может изначально получить значение транспорта, не является методом окончательного согласованного транспорта для подключения. В этом случае метод вызовет исключение и вызывается позже при установлении метод окончательный транспорта.
- Файлы cookie.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample53.cs?highlight=1)]

    Также можно получить файлы cookie из `Context.RequestCookies`.
- Сведения о пользователе.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample54.cs?highlight=1)]
- Для запроса объекта HttpContext:

    [!code-csharp[Main](hubs-api-guide-server/samples/sample55.cs?highlight=1)]

    Используйте этот метод вместо получения `HttpContext.Current` для получения `HttpContext` объект для подключения SignalR.

<a id="passstate"></a>

## <a name="how-to-pass-state-between-clients-and-the-hub-class"></a>Способ передачи состояния между клиентами и классу Hub

Предоставляет клиентский прокси `state` объекта, в котором можно хранить данные, которые могут передаваться на сервер с каждым вызовом метода. На сервере можно получить доступ к данным в `Clients.Caller` свойство в методах Hub, которые вызываются клиентами. `Clients.Caller` Свойство не заполняется для методов обработчиков событий времени существования соединения `OnConnected`, `OnDisconnected`, и `OnReconnected`.

Создание или обновление данных в `state` объекта и `Clients.Caller` свойство работает в обоих направлениях. Можно обновить значения на сервере, и они передаются обратно клиенту.

В примере показан клиентский код JavaScript, который хранит состояние для передачи на сервер при каждом вызове метода.

[!code-javascript[Main](hubs-api-guide-server/samples/sample56.js?highlight=1-2)]

В следующем примере эквивалентный код в клиенте .NET.

[!code-csharp[Main](hubs-api-guide-server/samples/sample57.cs?highlight=1-2)]

В классе концентратора, можно получить доступ к эти данные в `Clients.Caller` свойство. В примере показан код, который получает состояние, в предыдущем примере.

[!code-csharp[Main](hubs-api-guide-server/samples/sample58.cs?highlight=3-4)]

> [!NOTE]
> Этот механизм для сохранения состояния не предназначен для больших объемов данных, так как все, что вы поместите в `state` или `Clients.Caller` свойства обхода с каждого вызова метода. Это полезно для небольших элементов, таких как имена пользователей или счетчики.

В VB.NET или концентратор со строгой типизацией, состояние вызывающий объект не может осуществляться через `Clients.Caller`; вместо этого используйте `Clients.CallerState` (впервые представлено в SignalR 2.1):

**С помощью CallerState в C#**

[!code-csharp[Main](hubs-api-guide-server/samples/sample59.cs?highlight=3-4)]

**С помощью CallerState в Visual Basic**

[!code-vb[Main](hubs-api-guide-server/samples/sample60.vb)]

<a id="handleErrors"></a>

## <a name="how-to-handle-errors-in-the-hub-class"></a>Способ обработки ошибок в классе концентратора

Для обработки ошибок, возникающих в методах класса концентратора, сначала убедитесь, вы «наблюдать» за любые исключения из асинхронных операций (например, вызов клиентских методов) с помощью `await`. Затем можно используйте один или несколько из следующих методов:

- Перенос кода метода в блоки try-catch и войдите в объекте исключения. Для целей отладки исключения можно отправить клиенту, но для обеспечения безопасности причин отправки подробные сведения клиентам в рабочей среде не рекомендуется.
- Создание модуля концентраторов конвейера, который будет обрабатывать [OnIncomingError](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.hubpipelinemodule.onincomingerror(v=vs.111).aspx) метод. В следующем примере показано модуль конвейера, который регистрирует ошибки, Далее следует код в файле Startup.cs, который внедряет модуля в конвейере концентраторов.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample61.cs)]

    [!code-csharp[Main](hubs-api-guide-server/samples/sample62.cs?highlight=4)]
- Используйте `HubException` класс (впервые представлено в SignalR 2). Эта ошибка может быть создано из любого вызова концентратора. `HubError` Конструктор принимает строковое сообщение и объект для хранения дополнительные данные ошибки. SignalR будет автоматически сериализации исключения и отправить его клиенту, где он будет использоваться на отклонение или сбой вызова метода концентратора.

    В следующих примерах кода показано, как вызывать `HubException` во время вызова концентратора и как обрабатывать исключение в клиентах JavaScript и .NET.

    **Серверный код, демонстрирующий класс HubException**

    [!code-csharp[Main](hubs-api-guide-server/samples/sample63.cs)]

    **Клиентский код JavaScript, демонстрации ответа порождение HubException в центре**

    [!code-html[Main](hubs-api-guide-server/samples/sample64.html)]

    **.NET клиентского кода, демонстрирующий ответ на вызов HubException в центре**

    [!code-csharp[Main](hubs-api-guide-server/samples/sample65.cs)]

Дополнительные сведения о модулях центра конвейера см. в разделе [способы настройки конвейера концентраторов](#hubpipeline) далее в этом разделе.

<a id="tracing"></a>

## <a name="how-to-enable-tracing"></a>Включение трассировки

Чтобы включить трассировку на стороне сервера, добавьте system.diagnostics-элемент в файл Web.config, как показано в следующем примере:

[!code-html[Main](hubs-api-guide-server/samples/sample66.html?highlight=17-72)]

При запуске приложения в Visual Studio, можно просмотреть журналы в **вывода** окна.

<a id="callfromoutsidehub"></a>

## <a name="how-to-call-client-methods-and-manage-groups-from-outside-the-hub-class"></a>Как вызывать методы клиента и управлять ими групп за пределами классу Hub

Для вызова методов клиента от другого класса, чем класс концентратора, получить ссылку на объект контекста SignalR для центра и использовать его для вызова методов на стороне клиента и управление группами.

Следующий пример `StockTicker` класса возвращает объект контекста, сохраняет его в экземпляр класса, хранит экземпляр класса в статическое свойство и использует контекст из одноэлементный экземпляр класса для вызова `updateStockPrice` метод на клиентах, которые являются подключение к концентратору с именем `StockTickerHub`.

[!code-csharp[Main](hubs-api-guide-server/samples/sample67.cs?highlight=8,24)]

Если вам нужно использовать время несколько контекста в долгоживущих объектов, получить ссылку на один раз и сохраните его вместо получения его каждый раз. Получение контекста один раз гарантирует, что SignalR отправляет сообщения на клиентах в той же последовательности, в которой ваши методы концентратора выполнять клиентские вызовы методов. Учебник, в котором показано, как использовать контекст SignalR для концентратора, см. в разделе [передача сообщений с сервера с помощью SignalR](../getting-started/tutorial-server-broadcast-with-signalr.md).

<a id="callingclientsoutsidehub"></a>

### <a name="calling-client-methods"></a>Вызов методов клиента

Можно указать, какие клиенты будут получать RPC, но имеется меньше возможностей, чем при вызове из класса концентратора. Причиной этого является то, что контекст связан не конкретный вызов от клиента, поэтому любые методы, требуется знание текущий идентификатор соединения, такие как `Clients.Others`, или `Clients.Caller`, или `Clients.OthersInGroup`, недоступны. Доступны следующие параметры.

- Все подключенные клиенты.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample68.cs)]
- Конкретного клиента, определяемого по идентификатору подключения.

    [!code-css[Main](hubs-api-guide-server/samples/sample69.css)]
- Все подключенные клиенты, кроме указанным клиентам, идентифицируемый идентификатор соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample70.cs)]
- Все подключенные клиенты в указанной группе.

    [!code-css[Main](hubs-api-guide-server/samples/sample71.css)]
- Все подключенные клиенты в указанной группе, кроме указанным клиентам, идентифицируемый идентификатор соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample72.cs)]

При вызове в не Hub класс из методов в классе концентратора, вы можете передать в идентификатор текущего соединения и использовать его с `Clients.Client`, `Clients.AllExcept`, или `Clients.Group` для имитации `Clients.Caller`, `Clients.Others`, или `Clients.OthersInGroup`. В следующем примере `MoveShapeHub` класс передает идентификатор подключения для `Broadcaster` класс таким образом, чтобы `Broadcaster` класса можно имитировать `Clients.Others`.

[!code-csharp[Main](hubs-api-guide-server/samples/sample73.cs?highlight=12,36)]

<a id="managinggroupsoutsidehub"></a>

### <a name="managing-group-membership"></a>Управление членством в группе

Для управления группами имеют одинаковые параметры, как в класс концентратора.

- Добавление клиента в группу

    [!code-csharp[Main](hubs-api-guide-server/samples/sample74.cs)]
- Удаление клиента из группы

    [!code-css[Main](hubs-api-guide-server/samples/sample75.css)]

<a id="hubpipeline"></a>

## <a name="how-to-customize-the-hubs-pipeline"></a>Настройка конвейера концентраторов

SignalR позволяет ввести собственный код в конвейер концентратора. В следующем примере показано пользовательский модуль конвейер концентратора, который регистрирует каждого входящего вызова метода, полученных от клиента и исходящий вызов метода, вызывается на стороне клиента:

[!code-csharp[Main](hubs-api-guide-server/samples/sample76.cs)]

В следующем коде в *Startup.cs* файла регистрирует модуль для выполнения в конвейер концентратора:

[!code-csharp[Main](hubs-api-guide-server/samples/sample77.cs?highlight=3)]

Существует множество различных методов, которые можно переопределить. Полный список см. в разделе [HubPipelineModule методы](https://msdn.microsoft.com/library/jj918633(v=vs.111).aspx).
