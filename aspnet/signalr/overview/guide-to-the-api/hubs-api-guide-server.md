---
uid: signalr/overview/guide-to-the-api/hubs-api-guide-server
title: Путеводитель по API концентраторов SignalR ASP.NET — серверC#() | Документация Майкрософт
author: bradygaster
description: В этом документе приводятся общие сведения о программировании на стороне сервера API концентраторов SignalR ASP.NET для SignalR версии 2 с примерами кода...
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: b19913e5-cd8a-4e4b-a872-5ac7a858a934
msc.legacyurl: /signalr/overview/guide-to-the-api/hubs-api-guide-server
msc.type: authoredcontent
ms.openlocfilehash: c681b104b15bfc4a04587c7abf685dcf20def2ca
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78431370"
---
# <a name="aspnet-signalr-hubs-api-guide---server-c"></a>Путеводитель по API концентраторов SignalR ASP.NET — серверC#()

[Патрик Флетчера](https://github.com/pfletcher), [Tom Dykstra)](https://github.com/tdykstra)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этом документе приводятся общие сведения о программировании на стороне сервера API концентраторов SignalR ASP.NET для SignalR версии 2 с примерами кода, демонстрирующими общие параметры.
> 
> API концентраторов SignalR позволяет выполнять удаленные вызовы процедур (RPC) с сервера на подключенные клиенты и с клиентов на сервер. В серверном коде определяются методы, которые могут вызываться клиентами, и вызываются методы, которые выполняются на клиенте. В клиентском коде определяются методы, которые могут быть вызваны с сервера, а также вызываются методы, которые выполняются на сервере. Этот механизм отвечает за все клиентские коммуникации.
> 
> SignalR также предлагает интерфейс API более низкого уровня, называемый постоянными подключениями. Общие сведения о SignalR, концентраторах и постоянных подключениях см. [в статье Введение в SignalR 2](../getting-started/introduction-to-signalr.md).
> 
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемые в этом разделе
> 
> 
> - [Visual Studio 2013](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - .NET 4.5
> - SignalR версии 2
>   
> 
> 
> ## <a name="topic-versions"></a>Версии разделов
> 
> Сведения о более ранних версиях SignalR см. в статье о [старых версиях](../older-versions/index.md)SignalR.
> 
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
> 
> Оставьте отзыв о том, как вы понравится вам в этом учебнике, и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, не связанные непосредственно с этим руководством, их можно опубликовать на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).

## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Регистрация по промежуточного слоя SignalR](#route)

    - [URL-адрес/SignalR](#signalrurl)
    - [Настройка параметров SignalR](#options)
- [Создание и использование классов концентратора](#hubclass)

    - [Время существования объекта концентратора](#transience)
    - [Неоднородный регистр имен концентраторов в клиентах JavaScript](#hubnames)
    - [Несколько концентраторов](#multiplehubs)
    - [Строго типизированные концентраторы](#stronglytypedhubs)
- [Определение методов в классе Hub, которые могут вызываться клиентами](#hubmethods)

    - [Неоднородный регистр имен методов в клиентах JavaScript](#methodnames)
    - [Время асинхронного выполнения](#asyncmethods)
    - [Определение перегрузок](#overloads)
    - [Отчет о ходе выполнения вызовов метода концентратора](#progress)
- [Вызов клиентских методов из класса HUB](#callfromhub)

    - [Выбор клиентов, получающих RPC](#selectingclients)
    - [Нет проверки во время компиляции для имен методов](#dynamicmethodnames)
    - [Сопоставление имен методов без учета регистра](#caseinsensitive)
    - [Асинхронное выполнение](#asyncclient)
- [Управление членством в группах из класса HUB](#groupsfromhub)

    - [Асинхронное выполнение методов Add и Remove](#asyncgroupmethods)
    - [Сохранение членства в группах](#grouppersistence)
    - [Группы с одним пользователем](#singleusergroups)
- [Как управлять событиями времени жизни соединения в классе HUB](#connectionlifetime)

    - [При вызове onconnected, OnDisconnection и Онреконнектед](#onreconnected)
    - [Состояние вызывающего объекта не заполнено](#nocallerstate)
- [Получение сведений о клиенте из свойства Context](#contextproperty)
- [Передача состояния между клиентами и классом HUB](#passstate)
- [Как выполнять обработку ошибок в классе HUB](#handleErrors)
- [Вызов клиентских методов и управление группами извне класса HUB](#callfromoutsidehub)

    - [Вызов методов клиента](#callingclientsoutsidehub)
    - [Управление членством в группе](#managinggroupsoutsidehub)
- [Включение трассировки](#tracing)
- [Настройка конвейера концентраторов](#hubpipeline)

Документацию по программированию клиентов см. в следующих ресурсах:

- [Путеводитель по API концентраторов SignalR — клиент JavaScript](hubs-api-guide-javascript-client.md)
- [Путеводитель по API концентраторов SignalR — клиент .NET](hubs-api-guide-net-client.md)

Серверные компоненты SignalR 2 доступны только в .NET 4,5. Серверы, на которых работает .NET 4,0, должны использовать SignalR v1. x.

<a id="route"></a>

## <a name="how-to-register-signalr-middleware"></a>Регистрация по промежуточного слоя SignalR

Чтобы определить маршрут, который клиенты будут использовать для подключения к концентратору, вызовите метод `MapSignalR` при запуске приложения. `MapSignalR` является [методом расширения](https://msdn.microsoft.com/library/vstudio/bb383977.aspx) для класса `OwinExtensions`. В следующем примере показано, как определить маршрут концентраторов SignalR с помощью класса Startup OWIN.

[!code-csharp[Main](hubs-api-guide-server/samples/sample1.cs)]

При добавлении функций SignalR в приложение ASP.NET MVC убедитесь, что маршрут SignalR добавлен перед другими маршрутами. Дополнительные сведения см. в разделе [учебник. Начало работы с SignalR 2 и MVC 5](../getting-started/tutorial-getting-started-with-signalr-and-mvc.md).

<a id="signalrurl"></a>

### <a name="the-signalr-url"></a>URL-адрес/SignalR

По умолчанию URL-адрес маршрута, который будет использоваться клиентами для подключения к концентратору, — "/SignalR". (Не путайте этот URL-адрес с URL-адресом "/сигналр/хубс", который предназначен для автоматически созданного файла JavaScript. Дополнительные сведения о созданном прокси-сервере см. в статье [Путеводитель по API концентраторов SignalR — клиент JavaScript — созданный прокси-сервер и его назначение](hubs-api-guide-javascript-client.md#genproxy).)

В некоторых случаях этот базовый URL-адрес не может использоваться для SignalR; Например, в проекте есть папка с именем *SignalR* , и вы не хотите изменять имя. В этом случае можно изменить базовый URL-адрес, как показано в следующих примерах (замените "/SignalR" в примере кода на нужный URL-адрес).

**Серверный код, указывающий URL-адрес**

[!code-csharp[Main](hubs-api-guide-server/samples/sample2.cs?highlight=1)]

**Клиентский код JavaScript, указывающий URL-адрес (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-server/samples/sample3.js?highlight=1)]

**Клиентский код JavaScript, указывающий URL-адрес (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-server/samples/sample4.js?highlight=1)]

**Клиентский код .NET, указывающий URL-адрес**

[!code-csharp[Main](hubs-api-guide-server/samples/sample5.cs?highlight=1)]

<a id="options"></a>

### <a name="configuring-signalr-options"></a>Настройка параметров SignalR

Перегрузки метода `MapSignalR` позволяют указать настраиваемый URL-адрес, Пользовательский сопоставитель зависимостей и следующие параметры.

- Включение междоменных вызовов с помощью CORS или JSONP от клиентов браузера.

    Как правило, если браузер загружает страницу из `http://contoso.com`, то подключение SignalR находится в том же домене, в `http://contoso.com/signalr`. Если страница из `http://contoso.com` устанавливает подключение к `http://fabrikam.com/signalr`, то есть подключение между доменами. По соображениям безопасности междоменные соединения отключены по умолчанию. Дополнительные сведения см. в статье [руководство по API концентраторов signalr ASP.NET. клиент JavaScript — как установить междоменное подключение](hubs-api-guide-javascript-client.md#crossdomain).
- Включить подробные сообщения об ошибках.

    При возникновении ошибок поведение SignalR по умолчанию — отправить клиенту сообщение уведомления без подробностей о том, что произошло. Отправка подробных сведений об ошибках клиентам не рекомендуется в рабочей среде, так как пользователи-злоумышленники могут использовать эти сведения в атаках приложения. Для устранения неполадок можно использовать этот параметр, чтобы временно включить более информативные отчеты об ошибках.
- Отключите автоматически создаваемые прокси-файлы JavaScript.

    По умолчанию файл JavaScript с прокси для классов концентратора создается в ответ на URL-адрес «/сигналр/хубс». Если вы не хотите использовать прокси-серверы JavaScript или хотите создать этот файл вручную и ссылаться на физический файл в клиентах, можно использовать этот параметр, чтобы отключить создание прокси-сервера. Дополнительные сведения см. в статье [руководство по API концентраторов SignalR — клиент JavaScript. Создание физического файла для прокси-сервера, созданного SignalR](hubs-api-guide-javascript-client.md#manualproxy).

В следующем примере показано, как указать URL-адрес подключения SignalR и эти параметры в вызове метода `MapSignalR`. Чтобы указать пользовательский URL-адрес, замените "/SignalR" в примере на URL-адрес, который вы хотите использовать.

[!code-csharp[Main](hubs-api-guide-server/samples/sample6.cs)]

<a id="hubclass"></a>

## <a name="how-to-create-and-use-hub-classes"></a>Создание и использование классов концентратора

Чтобы создать концентратор, создайте класс, производный от [Microsoft. ASPNET. SignalR. Hub](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hub(v=vs.111).aspx). В следующем примере показан простой класс концентратора для приложения разговора.

[!code-csharp[Main](hubs-api-guide-server/samples/sample7.cs)]

В этом примере подключенный клиент может вызвать метод `NewContosoChatMessage`, а когда это происходит, полученные данные передаются на все подключенные клиенты.

<a id="transience"></a>

### <a name="hub-object-lifetime"></a>Время существования объекта концентратора

Вы не создаете экземпляр класса HUB или вызываете его методы из собственного кода на сервере. Все это выполняется конвейером концентраторов SignalR. SignalR создает новый экземпляр класса Hub каждый раз, когда ему требуется выполнять операции концентратора, например, когда клиент подключается, отключается или вызывает метод на сервере.

Поскольку экземпляры класса Hub являются временными, их нельзя использовать для поддержания состояния от одного вызова метода к следующему. Каждый раз, когда сервер получает вызов метода от клиента, новый экземпляр класса Hub обрабатывает сообщение. Чтобы сохранить состояние через несколько соединений и вызовов методов, используйте другой метод, например базу данных или статическую переменную в классе Hub, или другой класс, который не является производным от `Hub`. При сохранении данных в памяти с помощью метода, такого как статическая переменная в классе Hub, данные будут потеряны при очистке домена приложения.

Если вы хотите отправить сообщения клиентам из собственного кода, который выполняется вне класса Hub, это невозможно сделать, создав экземпляр класса концентратора, но это можно сделать, получив ссылку на объект контекста SignalR для класса Hub. Дополнительные сведения см. в разделе [как вызывать клиентские методы и управлять группами за пределами класса Hub](#callfromoutsidehub) далее в этой статье.

<a id="hubnames"></a>

### <a name="camel-casing-of-hub-names-in-javascript-clients"></a>Неоднородный регистр имен концентраторов в клиентах JavaScript

По умолчанию клиенты JavaScript ссылаются на концентраторы, используя версию имени класса в стиле Camel. SignalR автоматически вносит это изменение, чтобы код JavaScript мог соответствовать соглашениям JavaScript. Предыдущий пример будет называться `contosoChatHub` в коде JavaScript.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample8.cs?highlight=1)]

**Клиент JavaScript, использующий созданный прокси-сервер**

[!code-javascript[Main](hubs-api-guide-server/samples/sample9.js?highlight=1)]

Если необходимо указать другое имя для использования клиентами, добавьте атрибут `HubName`. При использовании атрибута `HubName` в клиентах JavaScript нет необходимости изменять имя на Camel.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample10.cs?highlight=1)]

**Клиент JavaScript, использующий созданный прокси-сервер**

[!code-javascript[Main](hubs-api-guide-server/samples/sample11.js?highlight=1)]

<a id="multiplehubs"></a>

### <a name="multiple-hubs"></a>Несколько концентраторов

В приложении можно определить несколько классов концентратора. При этом соединение является общим, но группы являются отдельными:

- Все клиенты будут использовать один и тот же URL-адрес для установления подключения SignalR со службой ("/SignalR" или настраиваемого URL-адреса, если он указан), и это соединение используется для всех центров, определенных службой.

    По сравнению с определением всех функций концентратора в одном классе нет разницы в производительности для нескольких концентраторов.
- Все концентраторы получают одинаковые сведения о запросе HTTP.

    Так как все концентраторы используют одно и то же соединение, единственными данными HTTP-запроса, которые получает сервер, является исходный HTTP-запрос, который устанавливает подключение SignalR. При использовании запроса на подключение для передачи информации от клиента на сервер путем указания строки запроса нельзя указывать разные строки запроса для разных концентраторов. Все концентраторы получат одну и ту же информацию.
- Созданный файл прокси-серверов JavaScript будет содержать учетные записи-посредники для всех концентраторов в одном файле.

    Сведения о прокси-серверах JavaScript см. [в статье Путеводитель по API концентраторов SignalR — клиент JavaScript — созданный прокси-сервер и его назначение](hubs-api-guide-javascript-client.md#genproxy).
- Группы определяются в центрах.

    В SignalR вы можете определить именованные группы для широковещательной рассылки подмножествам подключенных клиентов. Группы обслуживаются отдельно для каждого концентратора. Например, группа с именем "Администраторы" будет включать в себя один набор клиентов для `ContosoChatHub` класса, и одно и то же имя группы будет ссылаться на другой набор клиентов для класса `StockTickerHub`.

<a id="stronglytypedhubs"></a>
### <a name="strongly-typed-hubs"></a>Строго типизированные концентраторы

Чтобы определить интерфейс для методов концентратора, на которые может ссылаться клиент (и включить IntelliSense в методах концентратора), выберете концентратор из `Hub<T>` (который появился в SignalR 2,1), а не `Hub`.

[!code-csharp[Main](hubs-api-guide-server/samples/sample12.cs)]

<a id="hubmethods"></a>

## <a name="how-to-define-methods-in-the-hub-class-that-clients-can-call"></a>Определение методов в классе Hub, которые могут вызываться клиентами

Чтобы предоставить метод в концентраторе, который должен быть вызываемым из клиента, объявите открытый метод, как показано в следующих примерах.

[!code-csharp[Main](hubs-api-guide-server/samples/sample13.cs?highlight=3)]

[!code-csharp[Main](hubs-api-guide-server/samples/sample14.cs?highlight=3)]

Можно указать тип возвращаемого значения и параметры, включая сложные типы и массивы, как в любом C# методе. Все данные, получаемые в параметрах или возвращаемые вызывающему объекту, передаются между клиентом и сервером с помощью JSON, а SignalR обрабатывает привязку сложных объектов и массивов объектов автоматически.

<a id="methodnames"></a>

### <a name="camel-casing-of-method-names-in-javascript-clients"></a>Неоднородный регистр имен методов в клиентах JavaScript

По умолчанию клиенты JavaScript ссылаются на методы концентратора, используя версию имени метода в стиле Camel. SignalR автоматически вносит это изменение, чтобы код JavaScript мог соответствовать соглашениям JavaScript.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample15.cs?highlight=1)]

**Клиент JavaScript, использующий созданный прокси-сервер**

[!code-javascript[Main](hubs-api-guide-server/samples/sample16.js?highlight=1)]

Если необходимо указать другое имя для использования клиентами, добавьте атрибут `HubMethodName`.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample17.cs?highlight=1)]

**Клиент JavaScript, использующий созданный прокси-сервер**

[!code-javascript[Main](hubs-api-guide-server/samples/sample18.js?highlight=1)]

<a id="asyncmethods"></a>

### <a name="when-to-execute-asynchronously"></a>Время асинхронного выполнения

Если метод будет длительно выполнен или должен выполнить работу, которая будет заключаться в ожидании (например, при поиске базы данных или вызове веб-службы), сделайте метод концентратора асинхронным, возвращая [задачу](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx) (вместо `void` Return) или [Task&lt;t&gt;](https://msdn.microsoft.com/library/dd321424.aspx) объект (вместо `T`ного типа). Когда вы возвращаете объект `Task` из метода, SignalR ожидает завершения `Task`, а затем отправляет неупакованный результат обратно клиенту, поэтому нет никакой разницы в способе кодирования вызова метода в клиенте.

Создание метода концентратора асинхронно позволяет избежать блокировки соединения при использовании транспорта WebSocket. Если метод концентратора выполняется синхронно, а транспорт — WebSocket, последующие вызовы методов в концентраторе от одного клиента блокируются до завершения метода концентратора.

В следующем примере показан тот же метод, закодированный для синхронного или асинхронного выполнения, за которым следует код клиента JavaScript, который работает для вызова любой версии.

**Рабатывают**

[!code-csharp[Main](hubs-api-guide-server/samples/sample19.cs)]

**Асинхронной**

[!code-csharp[Main](hubs-api-guide-server/samples/sample20.cs?highlight=1,7-8)]

**Клиент JavaScript, использующий созданный прокси-сервер**

[!code-javascript[Main](hubs-api-guide-server/samples/sample21.js)]

Дополнительные сведения об использовании асинхронных методов в ASP.NET 4,5 см. в разделе [Использование асинхронных методов в ASP.NET MVC 4](../../../mvc/overview/performance/using-asynchronous-methods-in-aspnet-mvc-4.md).

<a id="overloads"></a>

### <a name="defining-overloads"></a>Определение перегрузок

Если требуется определить перегрузки для метода, количество параметров в каждой перегрузке должно отличаться. Если вы отличаете перегрузку только путем указания других типов параметров, класс Hub будет компилироваться, но служба SignalR выдаст исключение во время выполнения, когда клиенты пытаются вызвать одну из перегрузок.

<a id="progress"></a>
### <a name="reporting-progress-from-hub-method-invocations"></a>Отчет о ходе выполнения вызовов метода концентратора

SignalR 2,1 добавляет поддержку [шаблона отчетов о ходе выполнения](https://blogs.msdn.com/b/dotnet/archive/2012/06/06/async-in-4-5-enabling-progress-and-cancellation-in-async-apis.aspx) , представленного в .NET 4,5. Чтобы реализовать отчеты о ходе выполнения, определите параметр `IProgress<T>` для метода концентратора, к которому клиент имеет доступ.

[!code-csharp[Main](hubs-api-guide-server/samples/sample22.cs)]

При написании длительно выполняемого сервера важно использовать асинхронный шаблон программирования, такой как async/await, а не блокировать поток концентратора.

<a id="callfromhub"></a>

## <a name="how-to-call-client-methods-from-the-hub-class"></a>Вызов клиентских методов из класса HUB

Чтобы вызывать клиентские методы с сервера, используйте свойство `Clients` в методе в классе Hub. В следующем примере показан серверный код, который вызывает `addNewMessageToPage` на всех подключенных клиентах, и клиентский код, определяющий метод в клиенте JavaScript.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample23.cs?highlight=5)]

Вызов клиентского метода является асинхронной операцией и возвращает `Task`. Используйте `await` в следующих случаях:

* Чтобы убедиться, что сообщение отправлено без ошибок. 
* Для включения перехвата и обработки ошибок в блоке try-catch.

**Клиент JavaScript, использующий созданный прокси-сервер**

[!code-html[Main](hubs-api-guide-server/samples/sample24.html?highlight=1)]

Невозможно получить возвращаемое значение из клиентского метода. такой синтаксис, как `int x = Clients.All.add(1,1)`, не работает.

Для параметров можно указать сложные типы и массивы. В следующем примере сложный тип передается клиенту в параметре метода.

**Серверный код, вызывающий клиентский метод с помощью сложного объекта**

[!code-csharp[Main](hubs-api-guide-server/samples/sample25.cs?highlight=3)]

**Серверный код, определяющий сложный объект**

[!code-csharp[Main](hubs-api-guide-server/samples/sample26.cs?highlight=1)]

**Клиент JavaScript, использующий созданный прокси-сервер**

[!code-javascript[Main](hubs-api-guide-server/samples/sample27.js?highlight=2-3)]

<a id="selectingclients"></a>

### <a name="selecting-which-clients-will-receive-the-rpc"></a>Выбор клиентов, получающих RPC

Свойство Clients возвращает объект [хубконнектионконтекст](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.hubconnectioncontext(v=vs.111).aspx) , который предоставляет несколько параметров для указания клиентов, которые будут принимать RPC:

- Все подключенные клиенты.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample28.cs)]
- Только вызывающий клиент.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample29.cs)]
- Все клиенты, кроме вызывающего клиента.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample30.cs)]
- Конкретный клиент, идентифицируемый по ИДЕНТИФИКАТОРу соединения.

    [!code-css[Main](hubs-api-guide-server/samples/sample31.css)]

    В этом примере вызывается `addContosoChatMessageToPage` на вызывающем клиенте и действует тот же результат, что и при использовании `Clients.Caller`.
- Все подключенные клиенты, за исключением указанных клиентов, идентифицируемые по ИДЕНТИФИКАТОРу соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample32.cs)]
- Все подключенные клиенты в указанной группе.

    [!code-css[Main](hubs-api-guide-server/samples/sample33.css)]
- Все подключенные клиенты в указанной группе, за исключением указанных клиентов, идентифицируемые по ИДЕНТИФИКАТОРу соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample34.cs)]
- Все подключенные клиенты в указанной группе, кроме вызывающего клиента.

    [!code-css[Main](hubs-api-guide-server/samples/sample35.css)]
- Конкретный пользователь, идентифицируемый userId.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample36.cs)]

    По умолчанию это `IPrincipal.Identity.Name`, но его можно изменить, [зарегистрировав реализацию иусеридпровидер с глобальным узлом](mapping-users-to-connections.md#IUserIdProvider).
- Все клиенты и группы в списке идентификаторов подключений.

    [!code-css[Main](hubs-api-guide-server/samples/sample37.css)]
- Список групп.

    [!code-css[Main](hubs-api-guide-server/samples/sample38.css)]
- Пользователь по имени.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample39.cs)]
- Список имен пользователей (введенных в SignalR 2,1).

    [!code-csharp[Main](hubs-api-guide-server/samples/sample40.cs)]

<a id="dynamicmethodnames"></a>

### <a name="no-compile-time-validation-for-method-names"></a>Нет проверки во время компиляции для имен методов

Указанное имя метода интерпретируется как динамический объект, что означает отсутствие в нем IntelliSense или проверку во время компиляции. Выражение вычисляется во время выполнения. При вызове метода SignalR отправляет клиенту имя метода и значения параметров, а если клиент имеет метод, совпадающий с именем, вызывается метод и ему передаются значения параметров. Если на клиенте не найден соответствующий метод, ошибка не возникает. Сведения о формате данных, которые SignalR передает клиенту в фоновом режиме при вызове клиентского метода, см. [в разделе Общие](../getting-started/introduction-to-signalr.md)сведения о SignalR.

<a id="caseinsensitive"></a>

### <a name="case-insensitive-method-name-matching"></a>Сопоставление имен методов без учета регистра

Сопоставление имен методов не учитывает регистр. Например, `Clients.All.addContosoChatMessageToPage` на сервере будет выполнять `AddContosoChatMessageToPage`, `addcontosochatmessagetopage`или `addContosoChatMessageToPage` на клиенте.

<a id="asyncclient"></a>

### <a name="asynchronous-execution"></a>Асинхронное выполнение

Вызываемый метод выполняется асинхронно. Любой код, который поступает после вызова метода клиенту, будет выполняться немедленно, не дожидаясь завершения передачи данных для клиентов SignalR, если не указать, что последующие строки кода должны ожидать завершения метода. В следующем примере кода показано, как выполнять два метода клиента последовательно.

**Использование await (.NET 4,5)**

[!code-csharp[Main](hubs-api-guide-server/samples/sample41.cs?highlight=1,3)]

Если вы используете `await`, чтобы дождаться завершения клиентского метода до выполнения следующей строки кода, это не означает, что клиенты фактически получат сообщение перед выполнением следующей строки кода. "Завершение" вызова клиентского метода означает только то, что SignalR выполнил все необходимое для отправки сообщения. Если требуется проверка того, что клиенты получили сообщение, необходимо программировать механизм самостоятельно. Например, можно закодировать метод `MessageReceived` в концентраторе, а в методе `addContosoChatMessageToPage` на клиенте можно вызвать `MessageReceived` после выполнения любой работы, которую необходимо выполнить на клиенте. В `MessageReceived` в центре можно выполнять любые действия, зависящие от фактического приема и обработки исходного вызова метода.

### <a name="how-to-use-a-string-variable-as-the-method-name"></a>Использование строковой переменной в качестве имени метода

Если вы хотите вызвать клиентский метод, используя строковую переменную в качестве имени метода, приведите `Clients.All` (или `Clients.Others`, `Clients.Caller`и т. д.) `IClientProxy`, а затем вызовите [Invoke (имя_метода, args...)](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.iclientproxy.invoke(v=vs.111).aspx).

[!code-csharp[Main](hubs-api-guide-server/samples/sample42.cs)]

<a id="groupsfromhub"></a>

## <a name="how-to-manage-group-membership-from-the-hub-class"></a>Управление членством в группах из класса HUB

Группы в SignalR предоставляют метод для вещания сообщений в указанные подмножества подключенных клиентов. Группа может иметь любое количество клиентов, а клиент может быть членом любого числа групп.

Для управления членством в группе используйте методы [Add](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.igroupmanager.add(v=vs.111).aspx) и [Remove](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.igroupmanager.remove(v=vs.111).aspx) , предоставляемые свойством `Groups` класса Hub. В следующем примере показаны методы `Groups.Add` и `Groups.Remove`, используемые в методах концентратора, которые вызываются клиентским кодом, а затем — клиентский код JavaScript, который вызывает их.

**Server**

[!code-csharp[Main](hubs-api-guide-server/samples/sample43.cs?highlight=5,10)]

**Клиент JavaScript, использующий созданный прокси-сервер**

[!code-javascript[Main](hubs-api-guide-server/samples/sample44.js)]

[!code-javascript[Main](hubs-api-guide-server/samples/sample45.js)]

Вам не нужно явно создавать группы. Фактически группа создается автоматически при первом указании имени в вызове `Groups.Add`и удаляется при удалении последнего подключения из членства в нем.

Отсутствует API для получения списка членства в группе или списка групп. SignalR отправляет сообщения клиентам и группам, основанным на [модели публикации и подтипа](http://en.wikipedia.org/wiki/Publish/subscribe), а сервер не поддерживает списки групп или членства в группах. Это обеспечивает максимальную масштабируемость, так как при добавлении узла в веб-ферму любое состояние, которое обслуживает SignalR, должно быть распространено на новый узел.

<a id="asyncgroupmethods"></a>

### <a name="asynchronous-execution-of-add-and-remove-methods"></a>Асинхронное выполнение методов Add и Remove

Методы `Groups.Add` и `Groups.Remove` выполняются асинхронно. Если вы хотите добавить клиент в группу и сразу же отправить сообщение клиенту с помощью группы, необходимо убедиться в том, что метод `Groups.Add` завершается первым. В следующем примере кода показано, как это сделать.

**Добавление клиента в группу и последующее переобмен сообщениями от клиента**

[!code-csharp[Main](hubs-api-guide-server/samples/sample46.cs?highlight=1,3)]

<a id="grouppersistence"></a>

### <a name="group-membership-persistence"></a>Сохранение членства в группах

SignalR отслеживает соединения, а не пользователей, поэтому, если требуется, чтобы пользователь настроился в одной группе каждый раз, когда пользователь устанавливает соединение, необходимо вызывать `Groups.Add` каждый раз, когда пользователь устанавливает новое соединение.

После временной потери подключения иногда SignalR может автоматически восстановить подключение. В этом случае SignalR восстанавливает одно и то же подключение, не устанавливая новое подключение, поэтому членство в группе клиента автоматически восстанавливается. Это возможно даже в том случае, если временный перерыв является результатом перезагрузки или сбоя сервера, так как состояние подключения для каждого клиента, включая членство в группах, передается клиенту. Если сервер выходит из строя и заменяется новым сервером до истечения времени ожидания подключения, клиент может автоматически подключиться к новому серверу и повторно зарегистрировать в группах, членом которых он является.

Если подключение не может быть восстановлено автоматически после потери подключения или истечения времени ожидания соединения или когда клиент отключается (например, когда браузер переходит на новую страницу), членство в группах теряется. При следующем подключении пользователя будет установлено новое подключение. Чтобы обеспечить членство в группах, когда один и тот же пользователь устанавливает новое подключение, приложение должно отслеживание взаимосвязей между пользователями и группами и восстанавливать членство в группах каждый раз, когда пользователь устанавливает новое подключение.

Дополнительные сведения о подключениях и повторном подключении см. в разделе [как управлять событиями времени существования соединения в классе Hub](#connectionlifetime) далее в этой статье.

<a id="singleusergroups"></a>

### <a name="single-user-groups"></a>Группы с одним пользователем

Приложения, использующие SignalR, обычно должны вести отслеживание взаимосвязей между пользователями и соединениями, чтобы узнать, какой пользователь отправил сообщение и какие пользователи должны получать сообщение. Группы используются в одном из двух часто используемых шаблонов.

- Группы с одним пользователем.

    Можно указать имя пользователя в качестве имени группы и добавить текущий идентификатор подключения в группу при каждом подключении или повторном подключении пользователя. Для отправки сообщений пользователю, который отправляется в группу. Недостаток этого метода заключается в том, что группа не дает вам способа выяснить, находится ли пользователь в сети или в автономном режиме.
- Следите за связями между именами пользователей и идентификаторами подключений.

    Можно сохранить связь между именем пользователя и одним или несколькими идентификаторами соединения в словаре или базе данных, а также обновлять сохраненные данные при каждом подключении или отключении пользователя. Чтобы отправить сообщения пользователю, укажите идентификаторы соединения. Недостаток этого метода заключается в том, что он занимает больше памяти.

<a id="connectionlifetime"></a>

## <a name="how-to-handle-connection-lifetime-events-in-the-hub-class"></a>Как управлять событиями времени жизни соединения в классе HUB

Типичными причинами обработки событий времени существования соединения являются отслеживание того, подключено ли пользователь, а также отслеживается связь между именами пользователей и идентификаторами подключений. Чтобы запустить собственный код при подключении или отключении клиентов, переопределите `OnConnected`, `OnDisconnected`и `OnReconnected` виртуальные методы класса Hub, как показано в следующем примере.

[!code-csharp[Main](hubs-api-guide-server/samples/sample47.cs?highlight=3,14,22)]

<a id="onreconnected"></a>

### <a name="when-onconnected-ondisconnected-and-onreconnected-are-called"></a>При вызове onconnected, OnDisconnection и Онреконнектед

Каждый раз, когда браузер переходит на новую страницу, необходимо установить новое соединение, означающее, что SignalR выполнит метод `OnDisconnected`, а затем метод `OnConnected`. SignalR всегда создает новый идентификатор подключения при установлении нового соединения.

Метод `OnReconnected` вызывается при временном разрыве соединения, при котором SignalR может автоматически восстановиться из, например при временном отключении и повторном подключении кабеля до истечения времени ожидания соединения. Метод `OnDisconnected` вызывается, когда клиент отключается, и SignalR не может автоматически подключиться, например, когда браузер переходит на новую страницу. Таким образом, возможная последовательность событий для данного клиента — `OnConnected`, `OnReconnected`, `OnDisconnected`; или `OnConnected``OnDisconnected`. Вы не увидите последовательность `OnConnected`, `OnDisconnected``OnReconnected` для данного подключения.

Метод `OnDisconnected` не вызывается в некоторых сценариях, например при отключении сервера или при перезапуске домена приложения. Когда другой сервер поступает в сети или домен приложения завершает свой перезапуск, некоторые клиенты могут повторно подключиться и запустить событие `OnReconnected`.

Дополнительные сведения см. [в разделе Основные сведения и обработка событий времени жизни подключения в SignalR](handling-connection-lifetime-events.md).

<a id="nocallerstate"></a>

### <a name="caller-state-not-populated"></a>Состояние вызывающего объекта не заполнено

Методы обработчика событий времени жизни соединения вызываются с сервера. Это означает, что любое состояние, помещаемое в объект `state` на клиенте, не будет заполнено в свойстве `Caller` на сервере. Дополнительные сведения об объекте `state` и свойстве `Caller` см. в разделе [Передача состояния между клиентами и классом Hub](#passstate) далее в этой статье.

<a id="contextproperty"></a>

## <a name="how-to-get-information-about-the-client-from-the-context-property"></a>Получение сведений о клиенте из свойства Context

Чтобы получить сведения о клиенте, используйте свойство `Context` класса Hub. Свойство `Context` возвращает объект [хубкаллерконтекст](https://msdn.microsoft.com/library/jj890883(v=vs.111).aspx) , который предоставляет доступ к следующим сведениям:

- Идентификатор подключения вызывающего клиента.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample48.cs?highlight=1)]

    Идентификатор подключения — это идентификатор GUID, назначенный SignalR (вы не можете указать значение в своем коде). Для каждого подключения существует один идентификатор подключения, и один и тот же идентификатор подключения используется всеми концентраторами, если в приложении имеется несколько концентраторов.
- Данные заголовка HTTP.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample49.cs?highlight=1)]

    Также можно получить заголовки HTTP из `Context.Headers`. Причиной нескольких ссылок на одно и то же самое является то, что `Context.Headers` был создан первым, свойство `Context.Request` было добавлено позже и `Context.Headers` было сохранено для обеспечения обратной совместимости.
- Данные строки запроса.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample50.cs?highlight=1)]

    Можно также получить данные строки запроса из `Context.QueryString`.

    Строка запроса, полученная в этом свойстве, используется с HTTP-запросом, который установил подключение SignalR. Можно добавить параметры строки запроса в клиент, настроив соединение, что является удобным способом передачи данных о клиенте с клиента на сервер. В следующем примере показан один из способов добавления строки запроса в клиент JavaScript при использовании созданного прокси.

    [!code-javascript[Main](hubs-api-guide-server/samples/sample51.js?highlight=1)]

    Дополнительные сведения о настройке параметров строки запроса см. в руководствах по API для клиентов [JavaScript](hubs-api-guide-javascript-client.md) и [.NET](hubs-api-guide-net-client.md) .

    Метод перевозки, используемый для соединения, можно найти в данных строки запроса, а также с другими внутренними значениями, используемыми SignalR:

    [!code-csharp[Main](hubs-api-guide-server/samples/sample52.cs)]

    Значение `transportMethod` будет равно "WebSockets", "Серверсентевентс", "Фореверфраме" или "Лонгполлинг". Обратите внимание, что если проверить это значение в методе обработчика событий `OnConnected`, то в некоторых сценариях можно изначально получить значение транспорта, которое не является окончательным согласованным транспортным методом для соединения. В этом случае метод выдаст исключение и будет вызван позже, когда будет установлен окончательный метод транспортировки.
- Сеанс.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample53.cs?highlight=1)]

    Вы также можете получать файлы cookie из `Context.RequestCookies`.
- сведения о пользователе.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample54.cs?highlight=1)]
- Объект HttpContext для запроса:

    [!code-csharp[Main](hubs-api-guide-server/samples/sample55.cs?highlight=1)]

    Используйте этот метод вместо получения `HttpContext.Current` для получения объекта `HttpContext` для подключения SignalR.

<a id="passstate"></a>

## <a name="how-to-pass-state-between-clients-and-the-hub-class"></a>Передача состояния между клиентами и классом HUB

Прокси клиента предоставляет объект `state`, в котором можно хранить данные, которые необходимо передать на сервер при каждом вызове метода. На сервере эти данные можно получить в свойстве `Clients.Caller` в методах концентратора, которые вызываются клиентами. Свойство `Clients.Caller` не заполняется методами обработчика событий времени жизни соединения `OnConnected`, `OnDisconnected`и `OnReconnected`.

Создание или обновление данных в объекте `state`, а свойство `Clients.Caller` работает в обоих направлениях. Можно обновить значения на сервере и передать их обратно клиенту.

В следующем примере показан код клиента JavaScript, который сохраняет состояние для передачи на сервер при каждом вызове метода.

[!code-javascript[Main](hubs-api-guide-server/samples/sample56.js?highlight=1-2)]

В следующем примере показан эквивалентный код в клиенте .NET.

[!code-csharp[Main](hubs-api-guide-server/samples/sample57.cs?highlight=1-2)]

В классе Hub можно получить доступ к этим данным в свойстве `Clients.Caller`. В следующем примере показан код, который извлекает состояние, на которое ссылается предыдущий пример.

[!code-csharp[Main](hubs-api-guide-server/samples/sample58.cs?highlight=3-4)]

> [!NOTE]
> Этот механизм для сохранения состояния не предназначен для больших объемов данных, так как все, что вы поместили в `state` или `Clients.Caller` свойство, обложились с помощью каждого вызова метода. Это удобно для небольших элементов, таких как имена пользователей или счетчики.

В VB.NET или в концентраторе со строгой типизацией объект состояния вызывающего объекта не может быть доступен через `Clients.Caller`; Вместо этого используйте `Clients.CallerState` (появилось в SignalR 2,1):

**Использование Каллерстате вC#**

[!code-csharp[Main](hubs-api-guide-server/samples/sample59.cs?highlight=3-4)]

**Использование Каллерстате в Visual Basic**

[!code-vb[Main](hubs-api-guide-server/samples/sample60.vb)]

<a id="handleErrors"></a>

## <a name="how-to-handle-errors-in-the-hub-class"></a>Как выполнять обработку ошибок в классе HUB

Чтобы обрабатывались ошибки, возникающие в методах класса Hub, сначала убедитесь, что все исключения из асинхронных операций (например, вызов методов клиента) используются `await`. Затем используйте один или несколько следующих методов.

- Заключите код метода в блоки try-catch и заносите в журнал объект исключения. В целях отладки можно отправить исключение клиенту, но в целях безопасности не рекомендуется отправлять подробные сведения клиентам в рабочей среде.
- Создайте модуль конвейера концентраторов, который обрабатывает метод [онинкоминжеррор](https://msdn.microsoft.com/library/microsoft.aspnet.signalr.hubs.hubpipelinemodule.onincomingerror(v=vs.111).aspx) . В следующем примере показан модуль конвейера, в котором регистрируются ошибки, а затем код в Startup.cs, который внедряет модуль в конвейер концентраторов.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample61.cs)]

    [!code-csharp[Main](hubs-api-guide-server/samples/sample62.cs?highlight=4)]
- Используйте класс `HubException` (представленный в SignalR 2). Эта ошибка может быть вызвана любым вызовом концентратора. Конструктор `HubError` принимает строковое сообщение и объект для хранения дополнительных данных об ошибке. SignalR выполнит автоматическую сериализацию исключения и отправит его клиенту, где он будет использоваться для отклонения или отказа в вызове метода концентратора.

    В следующих примерах кода показано, как создавать `HubException` во время вызова концентратора, а также как управлять исключениями на клиентах JavaScript и .NET.

    **Серверный код, демонстрирующий класс Хубексцептион**

    [!code-csharp[Main](hubs-api-guide-server/samples/sample63.cs)]

    **Клиентский код JavaScript, демонстрирующий ответ на создание Хубексцептион в концентраторе**

    [!code-html[Main](hubs-api-guide-server/samples/sample64.html)]

    **Клиентский код .NET, демонстрирующий ответ на создание Хубексцептион в концентраторе**

    [!code-csharp[Main](hubs-api-guide-server/samples/sample65.cs)]

Дополнительные сведения о модулях конвейера концентратора см. в подразделе [Настройка конвейера](#hubpipeline) концентраторов далее в этой статье.

<a id="tracing"></a>

## <a name="how-to-enable-tracing"></a>Включение трассировки

Чтобы включить трассировку на стороне сервера, добавьте элемент System. Diagnostics в файл Web. config, как показано в следующем примере:

[!code-html[Main](hubs-api-guide-server/samples/sample66.html?highlight=17-72)]

При запуске приложения в Visual Studio журналы можно просмотреть в окне **вывод** .

<a id="callfromoutsidehub"></a>

## <a name="how-to-call-client-methods-and-manage-groups-from-outside-the-hub-class"></a>Вызов клиентских методов и управление группами извне класса HUB

Чтобы вызвать клиентские методы из другого класса, чем класс Hub, получите ссылку на объект контекста SignalR для концентратора и используйте его для вызова методов в клиенте или для управления группами.

Следующий пример `StockTicker` класс получает объект контекста, сохраняет его в экземпляре класса, сохраняет экземпляр класса в статическом свойстве и использует контекст из экземпляра одноэлементного класса для вызова метода `updateStockPrice` на клиентах, подключенных к концентратору с именем `StockTickerHub`.

[!code-csharp[Main](hubs-api-guide-server/samples/sample67.cs?highlight=8,24)]

Если необходимо использовать контекст несколько раз в долгосрочном объекте, получите ссылку один раз и сохраните его вместо того, чтобы повторно получать его каждый раз. Получение контекста однократно гарантирует, что SignalR отправляет сообщения клиентам в той же последовательности, в которой методы концентратора выполняют вызовы клиентских методов. Руководство, в котором показано, как использовать контекст SignalR для концентратора, см. в разделе [серверное вещание с помощью ASP.NET SignalR](../getting-started/tutorial-server-broadcast-with-signalr.md).

<a id="callingclientsoutsidehub"></a>

### <a name="calling-client-methods"></a>Вызов методов клиента

Вы можете указать, какие клиенты будут принимать RPC, но при этом у вас будет меньше параметров, чем при вызове из класса Hub. Причина в том, что контекст не связан с определенным вызовом от клиента, поэтому все методы, которым требуются знания о текущем ИДЕНТИФИКАТОРе соединения, такие как `Clients.Others`или `Clients.Caller`или `Clients.OthersInGroup`, недоступны. Доступны следующие варианты:

- Все подключенные клиенты.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample68.cs)]
- Конкретный клиент, идентифицируемый по ИДЕНТИФИКАТОРу соединения.

    [!code-css[Main](hubs-api-guide-server/samples/sample69.css)]
- Все подключенные клиенты, за исключением указанных клиентов, идентифицируемые по ИДЕНТИФИКАТОРу соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample70.cs)]
- Все подключенные клиенты в указанной группе.

    [!code-css[Main](hubs-api-guide-server/samples/sample71.css)]
- Все подключенные клиенты в указанной группе, за исключением указанных клиентов, идентифицируемые по ИДЕНТИФИКАТОРу соединения.

    [!code-csharp[Main](hubs-api-guide-server/samples/sample72.cs)]

При вызове класса, не являющегося концентратором, из методов класса Hub можно передать текущий идентификатор соединения и использовать его с `Clients.Client`, `Clients.AllExcept`или `Clients.Group` для имитации `Clients.Caller`, `Clients.Others`или `Clients.OthersInGroup`. В следующем примере класс `MoveShapeHub` передает идентификатор подключения классу `Broadcaster`, чтобы класс `Broadcaster` мог имитировать `Clients.Others`.

[!code-csharp[Main](hubs-api-guide-server/samples/sample73.cs?highlight=12,36)]

<a id="managinggroupsoutsidehub"></a>

### <a name="managing-group-membership"></a>Управление членством в группе

Для управления группами доступны те же параметры, что и в классе Hub.

- Добавление клиента в группу

    [!code-csharp[Main](hubs-api-guide-server/samples/sample74.cs)]
- Удаление клиента из группы

    [!code-css[Main](hubs-api-guide-server/samples/sample75.css)]

<a id="hubpipeline"></a>

## <a name="how-to-customize-the-hubs-pipeline"></a>Настройка конвейера концентраторов

SignalR позволяет внедрять собственный код в конвейер концентратора. В следующем примере показан пользовательский модуль конвейера концентратора, который регистрирует каждый входящий вызов метода, полученный от клиента, и вызов исходящего метода, вызываемого на клиенте:

[!code-csharp[Main](hubs-api-guide-server/samples/sample76.cs)]

Следующий код в файле *Startup.CS* регистрирует модуль для запуска в конвейере концентратора:

[!code-csharp[Main](hubs-api-guide-server/samples/sample77.cs?highlight=3)]

Существует множество различных методов, которые можно переопределить. Полный список см. в разделе [методы хубпипелинемодуле](https://msdn.microsoft.com/library/jj918633(v=vs.111).aspx).
