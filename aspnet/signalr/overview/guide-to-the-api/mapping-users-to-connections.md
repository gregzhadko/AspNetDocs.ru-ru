---
uid: signalr/overview/guide-to-the-api/mapping-users-to-connections
title: Сопоставление пользователей SignalR с подключениями | Документация Майкрософт
author: bradygaster
description: В этом разделе показано, как сохранить сведения о пользователях и их подключений. Патрик Флетчера помогла записи в этом разделе. Версии программного обеспечения, используемые в данном разделе...
ms.author: bradyg
ms.date: 12/30/2014
ms.assetid: f80c08b1-3f1f-432c-980c-c7b6edeb31b1
msc.legacyurl: /signalr/overview/guide-to-the-api/mapping-users-to-connections
msc.type: authoredcontent
ms.openlocfilehash: d55d40848e1e9d40570850c3552b225235c5e814
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59389795"
---
# <a name="mapping-signalr-users-to-connections"></a>Сопоставление пользователей SignalR с подключениями

по [Tom FitzMacken](https://github.com/tfitzmac)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этом разделе показано, как сохранить сведения о пользователях и их подключений.
>
> Патрик Флетчера помогла записи в этом разделе.
>
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемого в этом разделе
>
>
> - [Visual Studio 2013](https://my.visualstudio.com/Downloads?q=visual%20studio%202013)
> - .NET 4.5
> - SignalR версии 2
>
>
>
> ## <a name="previous-versions-of-this-topic"></a>Предыдущие версии этого раздела
>
> Сведения о более ранних версий SignalR, см. в разделе [более старых версий SignalR](../older-versions/index.md).
>
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
>
> Оставьте свои отзывы на том, как вам понравилось, и этот учебник и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, которые не имеют отношения к руководству, их можно разместить [форум по ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).

## <a name="introduction"></a>Вступление

Каждый клиент, подключающийся к концентратору передает уникальный идентификатор соединения. Можно получить это значение в `Context.ConnectionId` свойство контекста концентратора. Если приложению требуется сопоставить пользователя с идентификатором соединения и сохранить это сопоставление, можно использовать один из следующих:

- [Поставщик идентификатора пользователя (SignalR 2)](#IUserIdProvider)
- [Хранилища in-memory](#inmemory), такие как словарь
- [Группа SignalR для каждого пользователя](#groups)
- [Постоянная, внешние хранилища](#database), например таблицы базы данных или хранилище таблиц Azure

Каждая из этих реализаций будет показано в этом разделе. Использовании `OnConnected`, `OnDisconnected`, и `OnReconnected` методы `Hub` класса для отслеживания состояния подключения пользователя.

Зависит от оптимального подхода для приложения:

- Число веб-серверов, размещение приложения.
- Нужно ли получить список подключенных пользователей.
- Нужно ли сохранять данные пользователей и групп, после перезапуска приложения или сервера.
- Задержка при вызове внешнего сервера, является ли проблема.

В следующей таблице показано, какой метод подходит для этих факторов.

|  | Более одного сервера | Получить список подключенных пользователей | Сохранять данные после перезагрузки | Оптимальной производительности |
| --- | --- | --- | --- | --- |
| Идентификатор пользователя поставщика | ![](mapping-users-to-connections/_static/image1.png) |  |  | ![](mapping-users-to-connections/_static/image2.png) |
| In-memory |  | ![](mapping-users-to-connections/_static/image3.png) |  | ![](mapping-users-to-connections/_static/image4.png) |
| Группы в однопользовательском режиме | ![](mapping-users-to-connections/_static/image5.png) |  |  | ![](mapping-users-to-connections/_static/image6.png) |
| Постоянные, внешние | ![](mapping-users-to-connections/_static/image7.png) | ![](mapping-users-to-connections/_static/image8.png) | ![](mapping-users-to-connections/_static/image9.png) |  |

<a id="IUserIdProvider"></a>

## <a name="iuserid-provider"></a>Поставщик IUserID

Эта функция позволяет пользователю указать, что такое идентификатор пользователя на IRequest через новый интерфейс IUserIdProvider основе.

**IUserIdProvider**

[!code-csharp[Main](mapping-users-to-connections/samples/sample1.cs)]

По умолчанию, будет реализация, которая использует пользователя `IPrincipal.Identity.Name` имени пользователя. Чтобы изменить этот параметр, зарегистрировать вашу реализацию `IUserIdProvider` с глобального узла при запуске приложения:

[!code-csharp[Main](mapping-users-to-connections/samples/sample2.cs)]

Из в пределах концентратора, вы сможете отправлять сообщения для этих пользователей с помощью следующего API:

**Отправка сообщения конкретному пользователю**

[!code-csharp[Main](mapping-users-to-connections/samples/sample3.cs?highlight=5)]

<a id="inmemory"></a>

## <a name="in-memory-storage"></a>Хранилище в памяти

Следующие примеры показывают, как сохранить сведения о соединении и пользователя в словаре, который хранится в памяти. Словарь использует `HashSet` для хранения идентификатор подключения. В любой момент пользователь может иметь несколько подключений к приложению SignalR. Например пользователь, подключенный через несколько устройств или несколько вкладок браузера будет иметь более одного идентификатор подключения.

Если приложение завершает работу, все данные теряются, но он будет повторно заполнен как пользователям восстановить свои соединения. Хранилище в памяти не работает, если в среде имеются несколько веб-сервер, поскольку каждый сервер в отдельной коллекции подключений.

В первом примере класс, который управляет сопоставление пользователей для подключения. Ключ для класса HashSet будет имя пользователя.

[!code-csharp[Main](mapping-users-to-connections/samples/sample4.cs)]

Далее примере показано, как использовать класс сопоставление подключения с помощью центра. Экземпляр класса хранится в переменной с именем `_connections`.

[!code-csharp[Main](mapping-users-to-connections/samples/sample5.cs)]

<a id="groups"></a>

## <a name="single-user-groups"></a>Группы в однопользовательском режиме

Можно создать группу для каждого пользователя и отправить сообщение в эту группу, если вы хотите связаться только этот пользователь. Имя каждой группы — это имя пользователя. Если у пользователя есть больше одного соединения, каждый идентификатор соединения добавляется к группе пользователей.

Не следует удалять вручную пользователь из группы при отключении пользователя. Это действие автоматически выполняется платформой SignalR.

Приведенный ниже показано, как реализовывать группы одного пользователя.

[!code-csharp[Main](mapping-users-to-connections/samples/sample6.cs)]

<a id="database"></a>

## <a name="permanent-external-storage"></a>Постоянная, внешнего хранилища

В этом разделе показано, как использовать хранилище таблиц Azure или базы данных для хранения сведений о соединении. Этот подход работает при наличии нескольких веб-серверов, так как каждый веб-сервер может взаимодействовать с один и тот же репозиторий данных. Если остановить веб-серверов, работает или повторного запуска приложения, `OnDisconnected` метод не вызывается. Таким образом существует возможность, что репозиторий данных будет иметь записи идентификаторов подключений, которые больше не являются допустимыми. Чтобы очистить эти потерянные записи, вы можете сделать недействительным любые соединения, который был создан за пределами периодичностью, необходимые для вашего приложения. В примерах этого раздела включают в себя значение для отслеживания при создании подключения, но не показано, как удалить старые записи, поскольку вы можете сделать это в фоновом процессе.

### <a name="database"></a>База данных

Следующие примеры показывают, как сохранить сведения о соединении и пользователя в базе данных. Можно использовать любые технологии доступа к данным; Тем не менее в приведенном ниже примере показано, как для определения моделей с помощью Entity Framework. Эти модели сущности соответствуют таблиц базы данных и полей. Структуру данных может значительно изменяться в зависимости от требований приложения.

Первый пример показано, как определить Пользовательская сущность, которая может быть связан с нескольких сущностей соединения.

[!code-csharp[Main](mapping-users-to-connections/samples/sample7.cs)]

Затем из вещей, отслеживать состояние каждого подключения с кодом, показанным ниже.

[!code-csharp[Main](mapping-users-to-connections/samples/sample8.cs)]

<a id="azure"></a>
### <a name="azure-table-storage"></a>Хранилище таблиц Azure

В следующем примере хранилища таблиц Azure как в примере базы данных. Он не включает все сведения, которые необходимо приступить к работе со службой хранилища таблиц Azure. Сведения см. в разделе [Практическое использование табличного хранилища из .NET](https://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-tables/).

В следующем примере показано сущности таблицы для хранения сведений о соединении. Он разбивает данные по имени пользователя и определяет каждую сущность по идентификатор подключения, поэтому пользователь может иметь несколько подключений в любое время.

[!code-csharp[Main](mapping-users-to-connections/samples/sample9.cs)]

В концентраторе отслеживать состояние соединения каждого пользователя.

[!code-csharp[Main](mapping-users-to-connections/samples/sample10.cs)]
