---
uid: signalr/overview/guide-to-the-api/mapping-users-to-connections
title: Сопоставление пользователей SignalR с подключениями | Документация Майкрософт
author: bradygaster
description: В этом разделе показано, как хранить сведения о пользователях и их подключениях. Патрик Флетчера помогло написать этот раздел. Версии программного обеспечения, используемые в этом разделе...
ms.author: bradyg
ms.date: 12/30/2014
ms.assetid: f80c08b1-3f1f-432c-980c-c7b6edeb31b1
msc.legacyurl: /signalr/overview/guide-to-the-api/mapping-users-to-connections
msc.type: authoredcontent
ms.openlocfilehash: d55d40848e1e9d40570850c3552b225235c5e814
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78431394"
---
# <a name="mapping-signalr-users-to-connections"></a>Сопоставление пользователей SignalR с подключениями

от [Tom фитзмаккен](https://github.com/tfitzmac)

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этом разделе показано, как хранить сведения о пользователях и их подключениях.
>
> Патрик Флетчера помогло написать этот раздел.
>
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемые в этом разделе
>
>
> - [Visual Studio 2013](https://my.visualstudio.com/Downloads?q=visual%20studio%202013)
> - .NET 4.5
> - SignalR версии 2
>
>
>
> ## <a name="previous-versions-of-this-topic"></a>Предыдущие версии этого раздела
>
> Сведения о более ранних версиях SignalR см. в статье о [старых версиях](../older-versions/index.md)SignalR.
>
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
>
> Оставьте отзыв о том, как вы понравится вам в этом учебнике, и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, не связанные непосредственно с этим руководством, их можно опубликовать на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).

## <a name="introduction"></a>Введение

Каждый клиент, подключающийся к концентратору, передает уникальный идентификатор соединения. Это значение можно получить в свойстве `Context.ConnectionId` контекста концентратора. Если приложению необходимо сопоставить пользователя с идентификатором подключения и сохранить это сопоставление, можно использовать один из следующих способов.

- [Поставщик ИДЕНТИФИКАТОРов пользователей (SignalR 2)](#IUserIdProvider)
- [Хранилище в памяти](#inmemory), например словарь
- [Группа SignalR для каждого пользователя](#groups)
- [Постоянное внешнее хранилище](#database), например таблица базы данных или хранилище таблиц Azure

Каждая из этих реализаций показана в этом разделе. Для наблюдения за состоянием подключения пользователя используются методы `OnConnected`, `OnDisconnected`и `OnReconnected` класса `Hub`.

Оптимальный подход для вашего приложения зависит от следующих факторов.

- Число веб-серверов, на которых размещено приложение.
- Требуется ли получить список подключенных в данный момент пользователей.
- Необходимость сохранения сведений о группах и пользователях при перезапуске приложения или сервера.
- Является ли причиной проблемы задержка вызова внешнего сервера.

В следующей таблице показано, какой подход подходит для этих вопросов.

|  | Более одного сервера | Получение списка подключенных в данный момент пользователей | Сохранять сведения после перезагрузки | Оптимальная производительность |
| --- | --- | --- | --- | --- |
| Поставщик UserID | ![](mapping-users-to-connections/_static/image1.png) |  |  | ![](mapping-users-to-connections/_static/image2.png) |
| В памяти |  | ![](mapping-users-to-connections/_static/image3.png) |  | ![](mapping-users-to-connections/_static/image4.png) |
| Группы с одним пользователем | ![](mapping-users-to-connections/_static/image5.png) |  |  | ![](mapping-users-to-connections/_static/image6.png) |
| Постоянный, внешний | ![](mapping-users-to-connections/_static/image7.png) | ![](mapping-users-to-connections/_static/image8.png) | ![](mapping-users-to-connections/_static/image9.png) |  |

<a id="IUserIdProvider"></a>

## <a name="iuserid-provider"></a>Поставщик Иусерид

Эта функция позволяет пользователям указать, какой идентификатор userId основан на IRequest с помощью нового интерфейса Иусеридпровидер.

**Иусеридпровидер**

[!code-csharp[Main](mapping-users-to-connections/samples/sample1.cs)]

По умолчанию будет использоваться реализация, которая использует `IPrincipal.Identity.Name` пользователя в качестве имени пользователя. Чтобы изменить это, зарегистрируйте свою реализацию `IUserIdProvider` с помощью глобального узла при запуске приложения:

[!code-csharp[Main](mapping-users-to-connections/samples/sample2.cs)]

В центре вы сможете отправить сообщения этим пользователям через следующий API:

**Отправка сообщения определенному пользователю**

[!code-csharp[Main](mapping-users-to-connections/samples/sample3.cs?highlight=5)]

<a id="inmemory"></a>

## <a name="in-memory-storage"></a>Хранилище в памяти

В следующих примерах показано, как сохранить данные соединения и пользователя в словаре, который хранится в памяти. Словарь использует `HashSet` для хранения идентификатора соединения. В любой момент времени у пользователя может быть несколько подключений к приложению SignalR. Например, пользователь, который подключен через несколько устройств или несколько вкладок браузера, может иметь несколько идентификаторов подключения.

Если приложение завершает работу, вся информация теряется, но будет повторно заполнена при повторной установке подключений пользователями. Хранилище в памяти не работает, если в вашей среде имеется несколько веб-серверов, поскольку каждый сервер будет иметь отдельную коллекцию подключений.

В первом примере показан класс, который управляет сопоставлением пользователей с соединениями. Ключом для хэширования будет имя пользователя.

[!code-csharp[Main](mapping-users-to-connections/samples/sample4.cs)]

В следующем примере показано, как использовать класс сопоставления соединения из концентратора. Экземпляр класса хранится в имени переменной `_connections`.

[!code-csharp[Main](mapping-users-to-connections/samples/sample5.cs)]

<a id="groups"></a>

## <a name="single-user-groups"></a>Группы с одним пользователем

Вы можете создать группу для каждого пользователя, а затем отправить сообщение в эту группу, когда хотите обратиться только к этому пользователю. Имя каждой группы является именем пользователя. Если пользователь имеет более одного подключения, каждый идентификатор подключения добавляется в группу пользователя.

Не следует удалять вручную пользователя из группы при отключении пользователя. Это действие автоматически выполняется платформой SignalR.

В следующем примере показано, как реализовать однопользовательскую группу.

[!code-csharp[Main](mapping-users-to-connections/samples/sample6.cs)]

<a id="database"></a>

## <a name="permanent-external-storage"></a>Постоянное внешнее хранилище

В этом разделе показано, как использовать базу данных или хранилище таблиц Azure для хранения сведений о соединении. Этот подход работает при наличии нескольких веб-серверов, поскольку каждый веб-сервер может взаимодействовать с одним и тем же репозиторием данных. Если веб-серверы не работают или приложение перезапускается, метод `OnDisconnected` не вызывается. Таким образом, в репозитории данных могут быть записи для идентификаторов соединений, которые больше не действительны. Чтобы очистить эти потерянные записи, может потребоваться сделать недействительным любое подключение, созданное за пределами времени, относящегося к вашему приложению. Примеры в этом разделе включают значение для отслеживания при создании соединения, но не показывают, как очищать старые записи, так как это может потребоваться в качестве фонового процесса.

### <a name="database"></a>База данных

В следующих примерах показано, как хранить соединения и сведения о пользователях в базе данных. Можно использовать любую технологию доступа к данным. Однако в приведенном ниже примере показано, как определить модели с помощью Entity Framework. Эти модели сущностей соответствуют таблицам и полям базы данных. Структура данных может значительно варьироваться в зависимости от требований приложения.

В первом примере показано, как определить сущность пользователя, которая может быть связана с множеством сущностей соединения.

[!code-csharp[Main](mapping-users-to-connections/samples/sample7.cs)]

Затем из центра можно отвести отслеживание состояния каждого подключения с помощью приведенного ниже кода.

[!code-csharp[Main](mapping-users-to-connections/samples/sample8.cs)]

<a id="azure"></a>
### <a name="azure-table-storage"></a>Хранилище таблиц Azure

Следующий пример хранилища таблиц Azure похож на пример базы данных. Она не включает все сведения, необходимые для начала работы со службой хранилища таблиц Azure. Дополнительные сведения см. [в статье Использование табличного хранилища из .NET](https://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-tables/).

В следующем примере показана сущность таблицы для хранения сведений о соединении. Он разделяет данные по имени пользователя и определяет каждую сущность по идентификатору соединения, чтобы пользователь мог в любое время иметь несколько подключений.

[!code-csharp[Main](mapping-users-to-connections/samples/sample9.cs)]

В центре вы следите за состоянием подключения каждого пользователя.

[!code-csharp[Main](mapping-users-to-connections/samples/sample10.cs)]
