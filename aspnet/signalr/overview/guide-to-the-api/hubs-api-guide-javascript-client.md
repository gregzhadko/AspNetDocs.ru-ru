---
uid: signalr/overview/guide-to-the-api/hubs-api-guide-javascript-client
title: ASP.NET SignalR Концентраторы API Руководство - JavaScript Клиент (ru) Документы Майкрософт
author: bradygaster
description: Этот документ содержит введение в использование API-интерфейса концентратов для версии SignalR 2 у клиентов JavaScript, таких как браузеры и приложение Windows Store (WinJS).
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: a9fd4dc0-1b96-4443-82ca-932a5b4a8ea4
msc.legacyurl: /signalr/overview/guide-to-the-api/hubs-api-guide-javascript-client
msc.type: authoredcontent
ms.openlocfilehash: 8befe133c3627dac1f7d011959c68e2054d345da
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675715"
---
# <a name="aspnet-signalr-hubs-api-guide---javascript-client"></a>ASP.NET SignalR Концентраторы API Руководство - JavaScript Клиент

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> Этот документ предусматривает введение в использование API-интерфейса концентратов для версии SignalR 2 у клиентов JavaScript, таких как браузеры и приложения Windows Store (WinJS).
>
> API Концентраторов SignalR позволяет совершать удаленные процедурные звонки (RPCs) с сервера для подключенных клиентов и от клиентов к серверу. В коде сервера вы определяете методы, которые могут вызываться клиентами, и вызываете методы, которые работают на клиенте. В клиентском коде вы определяете методы, которые можно вызывать с сервера, и вызываете методы, которые работают на сервере. SignalR заботится о всех клиента к серверу сантехника для вас.
>
> SignalR также предлагает API более низкого уровня под названием Persistent Connections. Для введения в SignalR, концентраторы, и стойкие соединения, [см.](../getting-started/introduction-to-signalr.md)
>
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемые в этой теме
>
>
> - [Visual Studio 2017](https://visualstudio.microsoft.com/downloads/)
> - .NET 4.5
> - Версия SignalR 2
>
>
>
> ## <a name="previous-versions-of-this-topic"></a>Предыдущие версии этой темы
>
> Для получения информации о более ранних версиях SignalR, см [SignalR Старые версии](../older-versions/index.md).
>
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
>
> Пожалуйста, оставьте обратную связь о том, как вам понравился этот учебник и что мы могли бы улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, которые не имеют прямого отношения к учебнику, вы можете разместить их на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com.](http://stackoverflow.com/)

## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Сгенерированный прокси и то, что он делает для вас](#genproxy)

    - [Когда использовать генерируемый прокси](#cantusegenproxy)
- [Настройка клиента](#clientsetup)

    - [Как ссылаться на динамически сгенерированный прокси](#dynamicproxy)
    - [Как создать физический файл для прокси-сервера SignalR](#manualproxy)
- [Как установить соединение](#establishconnection)

    - [$.connection.hub - это тот же объект, который создает $.hubConnection()](#connequivalence)
    - [Асинхронное выполнение метода старта](#asyncstart)
- [Как установить кросс-доменсоединение](#crossdomain)
- [Как настроить соединение](#configureconnection)

    - [Как указать параметры строки запроса](#querystring)
    - [Как указать транспортный метод](#transport)
- [Как получить прокси для класса концентратор](#getproxy)
- [Как определить методы на клиенте, который может вызвать сервер](#callclient)
- [Как вызвать методы сервера от клиента](#callserver)
- [Как обрабатывать события жизни соединения](#connectionlifetime)
- [Как обрабатывать ошибки](#handleerrors)
- [Как включить журналирование на стороне клиента](#logging)

Для получения документации о том, как запрограммировать сервер или клиентов .NET, см.

- [Руководство По API Концентратов SignalR - Сервер](hubs-api-guide-server.md)
- [Руководство По API Концентраторов SignalR - Клиент .NET](hubs-api-guide-net-client.md)

Компонент сервера SignalR 2 доступен только на .NET 4.5 (хотя есть клиент .NET для SignalR 2 на .NET 4.0).

<a id="genproxy"></a>

## <a name="the-generated-proxy-and-what-it-does-for-you"></a>Сгенерированный прокси и то, что он делает для вас

Вы можете запрограммировать клиента JavaScript для связи с службой SignalR с прокси или без нее, который SignalR генерирует для вас. Прокси-сервер упрощает синтаксис кода, который используется для подключения, записывает методы, которые вызывает сервер, и методы вызова на сервере.

Когда вы пишете код для вызова методов вызова сервера, генерируемый `serverMethod(arg1, arg2)` `invoke('serverMethod', arg1, arg2)`прокси позволяет использовать синтаксис, который выглядит так, как будто вы исполняете локальную функцию: вы можете писать вместо . Сгенерированный прокси-синтаксис также допускает немедленную и понятную ошибку на стороне клиента, если вы неправильно введите имя метода сервера. И если вы вручную создаете файл, который определяет прокси, вы также можете получить поддержку IntelliSense для написания кода, который вызывает методы сервера.

Например, предположим, что на сервере есть следующий класс концентратора:

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample1.cs?highlight=1,3,5)]

Следующие примеры кода показывают, как выглядит код `NewContosoChatMessage` JavaScript для вызова метода `addContosoChatMessageToPage` на сервере и получения вызовов метода с сервера.

**С генерируемым прокси**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample2.js?highlight=1-2,8)]

**Без сгенерированного прокси**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample3.js?highlight=2-3,9)]

<a id="cantusegenproxy"></a>

### <a name="when-to-use-the-generated-proxy"></a>Когда использовать генерируемый прокси

Если вы хотите зарегистрировать несколько обработчиков событий для метода клиента, который вызывает сервер, вы не можете использовать генерируемый прокси. В противном случае можно использовать генерируемый прокси или не основываться на предпочтениях кодирования. Если вы решите не использовать его, вам не нужно ссылаться на URL-адрес "signalr/hubs" в элементе `script` в ашего клиентском коде.

<a id="clientsetup"></a>

## <a name="client-setup"></a>Настройка клиента

Клиенту JavaScript требуются ссылки на j''s и ядро JavaScript файла SignalR. Версия j'query должна быть 1.6.4 или основных более поздних версий, таких как 1.7.2, 1.8.2, или 1.9.1. Если вы решили использовать сгенерированный прокси- и справку о сгенерированном файле JavaScript SignalR. Ниже приводится следующий пример, как могут выглядеть ссылки на странице HTML, использующей генерируемый прокси.

[!code-html[Main](hubs-api-guide-javascript-client/samples/sample4.html)]

Эти ссылки должны быть включены в этот порядок: j''sfirst, ядро SignalR после этого, и прокси SignalR последние.

<a id="dynamicproxy"></a>

### <a name="how-to-reference-the-dynamically-generated-proxy"></a>Как ссылаться на динамически сгенерированный прокси

В предыдущем примере ссылка на прокси SignalR— динамически сгенерированный код JavaScript, а не на физический файл. SignalR создает код JavaScript для прокси на лету и подает его клиенту в ответ на URL-адрес "/signalr/hubs". Если в `MapSignalR` методе указан другой базовый URL для соединений SignalR на сервере, URL-адрес для динамического прокси-файла является пользовательским URL-адресом с приложеным к нему "/концентратами".

> [!NOTE]
> Для клиентов JavaScript Windows 8 (Windows Store) используйте физический прокси-файл вместо динамического файла. Для получения дополнительной информации, см [Как создать физический файл для SignalR генерируется прокси](#manualproxy) позже в этой теме.

В ASP.NET MVC 4 или 5 Razor view, используйте tilde для обозначения корня приложения в вашем справочнике файла прокси:

[!code-html[Main](hubs-api-guide-javascript-client/samples/sample5.html)]

Для получения дополнительной информации об использовании SignalR в MVC 5, см. [Начало работы с SignalR и MVC 5](../getting-started/tutorial-getting-started-with-signalr-and-mvc.md).

В ASP.NET MVC 3 Razor, используйте `Url.Content` для вашего прокси-файла:

[!code-cshtml[Main](hubs-api-guide-javascript-client/samples/sample6.cshtml)]

В ASP.NET приложения Web `ResolveClientUrl` Forms используйте для своих прокси-файлов или зарегистрируйте ее через ScriptManager, используя относительный путь root app (начиная с tilde):

[!code-aspx[Main](hubs-api-guide-javascript-client/samples/sample7.aspx)]

Как правило, используйте тот же метод для указания URL-адреса "/signalr/hubs", который используется для файлов CSS или JavaScript. Если вы указали URL-адрес без использования tilde, в некоторых сценариях ваше приложение будет работать правильно при тестировании в Visual Studio с помощью IIS Express, но не сошибкой при развертывании на полном IIS. Для получения дополнительной информации смотрите **разрешение ссылок на ресурсы корневого уровня** в [веб-серверах в Visual Studio для ASP.NET web-проектов](https://msdn.microsoft.com/library/58wxa9w5.aspx) на сайте MSDN.

При запуске веб-проекта в Visual Studio 2017 в режиме отладки, и если вы используете Internet Explorer в качестве браузера, вы можете увидеть прокси-файл в **Solution Explorer** под **скриптами.**

Чтобы увидеть содержимое файла, дважды щелкните **концентраторов.** Если вы не используете Visual Studio 2012 или 2013 и Internet Explorer, или если вы не находитесь в режиме отладки, вы также можете получить содержимое файла, просматривая URL"/signalR/hubs. Например, если ваш сайт `http://localhost:56699`работает `http://localhost:56699/SignalR/hubs` на , перейдите в вашем браузере.

<a id="manualproxy"></a>

### <a name="how-to-create-a-physical-file-for-the-signalr-generated-proxy"></a>Как создать физический файл для прокси-сервера SignalR

В качестве альтернативы динамически сгенерированному прокси можно создать физический файл с прокси-кодом и ссылкой на этот файл. Вы можете сделать это для контроля над поведением кэширования или комплектации, или получить IntelliSense, когда вы кодирования вызовов для серверных методов.

Чтобы создать прокси-файл, выполните следующие действия:

1. Установите пакет [Microsoft.AspNet.Signalr.Utils](https://nuget.org/packages/Microsoft.AspNet.SignalR.Utils/) NuGet.
2. Откройте запрос команды и просмотрите папку *инструментов,* содержащую файл SignalR.exe. Папка инструментов находится в следующем месте:

    `[your solution folder]\packages\Microsoft.AspNet.SignalR.Utils.2.1.0\tools`
3. Введите следующую команду:

    `signalr ghp /path:[path to the .dll that contains your Hub class]`

    Путь к *вашему .dll* обычно является папкой *бен* в папке проекта.

    Эта команда создает файл под названием *server.js* в той же папке *с signalr.exe.*
4. Поместите файл *server.js* в соответствующую папку в проекте, переименуйте его по мере необходимости для приложения и добавьте ссылку на него вместо ссылки "сигнал"/концентраторы" ссылки.

<a id="establishconnection"></a>

## <a name="how-to-establish-a-connection"></a>Как установить соединение

Прежде чем установить соединение, необходимо создать объект соединения, создать прокси-сервер и зарегистрировать обработчики событий для методов, которые можно вызвать с сервера. При настройке обработчиков прокси и событий установите соединение, вызывая `start` метод.

Если вы используете сгенерированный прокси-сервер, вам не нужно создавать объект соединения в своем собственном коде, потому что сгенерированный прокси-код делает это за вас.

<a id="nogenconnection"></a>

**Установить соединение (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample8.js?highlight=5)]

**Установить соединение (без генерируемого прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample9.js?highlight=1,6)]

Пример кода использует URL-адрес по умолчанию "/сигнальщик" для подключения к службе SignalR. Для получения информации о том, как указать другой базовый URL, см [ASP.NET.](hubs-api-guide-server.md#signalrurl)

По умолчанию местоположение концентратора является текущим сервером; если вы подключаетесь к другому серверу, укажите URL перед вызовом метода, `start` как показано в следующем примере:

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample10.js)]

> [!NOTE]
> Обычно вы регистрируете обработчики событий перед вызовом метода `start` для установления соединения. Если вы хотите зарегистрировать некоторые обработчики событий после установления соединения, вы можете сделать это, но `start` вы должны зарегистрировать по крайней мере один из обработчика событий (ы) перед вызовом метода. Одной из причин этого является то, что в приложении может быть много `OnConnected` концентратов, но вы не хотели бы запускать событие в каждом концентраторе, если вы собираетесь использовать только один из них. Когда соединение установлено, наличие метода клиента на прокси концентратора является `OnConnected` то, что говорит SignalR, чтобы вызвать событие. Если вы не зарегистрируете обработчики событий перед вызовом `start` метода, вы сможете вызвать `OnConnected` методы на концентраторе, но метод концентратора не будет вызываться, и никакие клиентские методы не будут вызываться с сервера.

<a id="connequivalence"></a>

### <a name="connectionhub-is-the-same-object-that-hubconnection-creates"></a>$.connection.hub - это тот же объект, который создает $.hubConnection()

Как вы можете видеть на примерах, при `$.connection.hub` использовании генерируемого прокси относится к объекту соединения. Это тот же объект, который `$.hubConnection()` вы получаете, позвонив, когда вы не используете сгенерированный прокси. Сгенерированный прокси-код создает соединение для вас, выполняя следующее утверждение:

![Создание соединения в генерируемом файле прокси](hubs-api-guide-javascript-client/_static/image3.png)

Когда вы используете сгенерированный прокси, `$.connection.hub` вы можете сделать что-нибудь с тем, что вы можете сделать с объектом соединения, когда вы не используете сгенерированный прокси.

<a id="asyncstart"></a>

### <a name="asynchronous-execution-of-the-start-method"></a>Асинхронное выполнение метода старта

Метод `start` выполняется асинхронно. Он возвращает [объект j's'ry Отложенный,](http://api.jquery.com/category/deferred-object/)что означает, что вы `pipe`можете `done`добавить функции обратного вызова, такие как , и `fail`. Если у вас есть код, который вы хотите выполнить после создания соединения, например, вызов на сервер, поместите этот код в функцию обратного вызова или позвоните ему из функции обратного вызова. Метод `.done` обратного вызова выполняется после создания соединения, и после того, `OnConnected` как любой код, который у вас есть в методе обработчика событий на сервере, завершает выполнение.

Если вы поместите заявление "Now connected" из предыдущего примера в качестве следующей строки кода после вызова `start` метода (не в обратном `.done` деле), `console.log` строка будет выполняться до создания соединения, как показано в следующем примере:

![Неправильный способ записи кода, который работает после установления соединения](hubs-api-guide-javascript-client/_static/image5.png)

<a id="crossdomain"></a>

## <a name="how-to-establish-a-cross-domain-connection"></a>Как установить кросс-доменсоединение

Обычно, если браузер загружает страницу с `http://contoso.com`, соединение `http://contoso.com/signalr`SignalR находится в том же домене, в . Если страница `http://contoso.com` из делает `http://fabrikam.com/signalr`подключение к, то есть кросс-домен соединения. По соображениям безопасности соединения кросс-домена отключены по умолчанию.

В SignalR 1.x запросы на перекрестный домен контролировались одним флагом EnableCrossDomain. Этот флаг контролировал запросы JSONP и CORS. Для большей гибкости вся поддержка CORS была удалена из серверного компонента SignalR (клиенты JavaScript по-прежнему используют CORS обычно, если обнаруживается, что браузер поддерживает его), и для поддержки этих сценариев было предоставлено новое промежуточное программное обеспечение OWIN.

Если JSONP требуется для клиента (для поддержки запросов кросс-домена в старых `EnableJSONP` браузерах), он должен быть включен явно, установив на `HubConfiguration` объекте, как `true`показано ниже. JSONP отключен по умолчанию, так как он менее безопасен, чем CORS.

**Добавление В свой проект Microsoft.Owin.Cors:** Чтобы установить эту библиотеку, запустите следующую команду в консоли менеджера пакетов:

`Install-Package Microsoft.Owin.Cors`

Эта команда добавит версию пакета 2.1.0 в проект.

### <a name="calling-usecors"></a>Вызов UseCors

 Следующий фрагмент кода демонстрирует, как реализовать соединения кросс-домена в SignalR 2.

**Реализация запросов кросс-домена в SignalR 2**

Следующий код показывает, как включить CORS или JSONP в проекте SignalR 2. Этот образец `Map` `RunSignalR` кода `MapSignalR`использует и вместо , так что CORS промежуточное программное обеспечение работает только для `MapSignalR`запросов SignalR, которые требуют поддержки CORS (а не для всего трафика на пути, указанном в .) Карта также может быть использована для любого другого промежуточного посуды, которая должна работать для конкретного приставки URL, а не для всего приложения.

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample11.cs)]

> [!NOTE]
>
> - Не устанавливайте `jQuery.support.cors` к истине в вашем коде.
>
>     ![Не устанавливайте j'sry.support.cors на истину](hubs-api-guide-javascript-client/_static/image7.png)
>
>     SignalR обрабатывает использование CORS. Установка `jQuery.support.cors` на истинное отскакивает JSONP, потому что это заставляет SignalR предположить, что браузер поддерживает CORS.
> - При подключении к URL-адресу localhost Internet Explorer 10 не будет считать его кросс-доменом, поэтому приложение будет работать локально с IE 10, даже если вы не включили кросс-доменсоединения на сервере.
> - Для получения информации об использовании кросс-доменных соединений с Internet Explorer 9, [см.](http://stackoverflow.com/questions/13573397/siganlr-ie9-cross-domain-request-dont-work)
> - Для получения информации об использовании кросс-доменсоединений с Chrome, [см.](http://stackoverflow.com/questions/15467373/signalr-1-0-1-cross-domain-request-cors-with-chrome)
> - Пример кода использует URL-адрес по умолчанию "/сигнальщик" для подключения к службе SignalR. Для получения информации о том, как указать другой базовый URL, см [ASP.NET.](hubs-api-guide-server.md#signalrurl)

<a id="configureconnection"></a>

## <a name="how-to-configure-the-connection"></a>Как настроить соединение

Прежде чем установить соединение, можно указать параметры строки запроса или указать метод транспортировки.

<a id="querystring"></a>

### <a name="how-to-specify-query-string-parameters"></a>Как указать параметры строки запроса

Если вы хотите отправить данные на сервер при подключении клиента, можно добавить параметры строки запроса к объекту соединения. Ниже приведены следующие примеры, как установить параметр строки запроса в клиентском коде.

**Установите значение строки запроса перед вызовом метода запуска (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample12.js?highlight=1)]

**Установите значение строки запроса перед вызовом метода запуска (без сгенерированного прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample13.js?highlight=2)]

В следующем примере показано, как прочитать параметр строки запроса в коде сервера.

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample14.cs?highlight=5)]

<a id="transport"></a>

### <a name="how-to-specify-the-transport-method"></a>Как указать транспортный метод

В процессе подключения клиент SignalR обычно ведет переговоры с сервером, чтобы определить наилучший транспорт, который поддерживается как сервером, так и клиентом. Если вы уже знаете, какой транспорт вы хотите использовать, вы можете обойти этот `start` процесс переговоров, указав метод транспортировки при вызове метода.

**Код клиента, который определяет способ транспортировки (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample15.js?highlight=1)]

**Код клиента, который определяет способ транспортировки (без генерируемого прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample16.js?highlight=2)]

В качестве альтернативы можно указать несколько методов транспортировки в порядке, в котором вы хотите SignalR попробовать их:

**Код клиента, который определяет пользовательскую схему резервного копирования транспорта (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample17.js?highlight=1)]

**Код клиента, который определяет пользовательскую схему резервного копирования транспорта (без генерируемого прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample18.js?highlight=2)]

Для указания метода транспортировки можно использовать следующие значения:

- "webSockets"
- "навсегдаФрейм"
- "серверСентСобытия"
- "ДлинныйОпрос"

Ниже приведены следующие примеры, как узнать, какой способ транспортировки используется соединением.

**Клиентский код, отображающие транспортный метод, используемый соединением (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample19.js?highlight=2)]

**Клиентский код, отображающие транспортный метод, используемый соединением (без генерируемого прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample20.js?highlight=3)]

Подробнее о том, как проверить метод транспортировки в серверном коде, смотрите [ASP.NET Руководство по aPI SignalR Hubs API - Server - Как получить информацию о клиенте из свойства Контекста.](hubs-api-guide-server.md#contextproperty) Для получения дополнительной информации о транспорте и откатов, [см. Введение в SignalR - Транспорт и Fallbacks](../getting-started/introduction-to-signalr.md#transports).

<a id="getproxy"></a>

## <a name="how-to-get-a-proxy-for-a-hub-class"></a>Как получить прокси для класса концентратор

Каждый объект соединения, который создается, инкапсулирует информацию о подключении к службе SignalR, содержащей один или несколько классов концентраторов. Для связи с классом концентратора используется прокси-объект, который вы создаете самостоятельно (если вы не используете сгенерированный прокси) или который генерируется для вас.

На клиенте прокси-имя — это верблюжья версия названия класса Концентратор. SignalR автоматически вносит это изменение, чтобы код JavaScript мог соответствовать конвенциям JavaScript.

**Класс концентратора на сервере**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample21.cs?highlight=1)]

**Получить ссылку на сгенерированный прокси клиента для концентратора**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample22.js?highlight=1)]

**Создание клиентского прокси для класса концентратора (без сгенерированного прокси)**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample23.cs?highlight=1)]

Если вы украсите `HubName` свой класс концентратора атрибутом, используйте точное имя, не меняя чехол.

**Класс концентратора на сервере с атрибутом HubName**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample24.cs?highlight=1)]

**Получить ссылку на сгенерированный прокси клиента для концентратора**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample25.js?highlight=1)]

**Создание клиентского прокси для класса концентратора (без сгенерированного прокси)**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample26.cs?highlight=1)]

<a id="callclient"></a>

## <a name="how-to-define-methods-on-the-client-that-the-server-can-call"></a>Как определить методы на клиенте, который может вызвать сервер

Чтобы определить метод, который сервер может вызвать из концентратора, `client` добавьте обработчик событий `on` в прокси-сервер концентратора, используя свойство генерируемого прокси, или позвоните по этому методу, если вы не используете генерируемый прокси. Параметры могут быть сложными объектами.

До вызова метода `start` для установления соединения добавьте обработчик события. (Если вы хотите добавить обработчики событий после вызова `start` метода, см. заметку в Как [установить соединение](#establishconnection) ранее в этом документе, и использовать синтаксис, показанный для определения метода без использования генерируемого прокси.)

Сопоставление имен метода является нечувствительным. Например, `Clients.All.addContosoChatMessageToPage` на сервере `AddContosoChatMessageToPage` `addContosoChatMessageToPage`будет `addcontosochatmessagetopage` выполняться, или на клиенте.

**Определение метода на клиенте (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample27.js?highlight=2)]

**Альтернативный способ определения метода на клиенте (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample28.js?highlight=1-2)]

**Определите метод на клиенте (без сгенерированного прокси или при добавлении после вызова метода запуска)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample29.js?highlight=3)]

**Код сервера, который вызывает метод клиента**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample30.cs?highlight=5)]

Следующие примеры включают сложный объект в качестве параметра метода.

**Определение метода на клиенте, который принимает сложный объект (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample31.js?highlight=2-3)]

**Определение метода по клиенту, который принимает сложный объект (без генерируемого прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample32.js?highlight=3-4)]

**Код сервера, определяющий сложный объект**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample33.cs?highlight=1)]

**Код сервера, который вызывает метод клиента с помощью сложного объекта**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample34.cs?highlight=3)]

<a id="callserver"></a>

## <a name="how-to-call-server-methods-from-the-client"></a>Как вызвать методы сервера от клиента

Чтобы вызвать метод сервера от `server` клиента, используйте `invoke` свойство генерируемого прокси или метод на прокси-концентраторе, если вы не используете сгенерированный прокси. Значение возврата или параметры могут быть сложными объектами.

Передайте в верблюжьем корпусе версию названия метода на концентраторе. SignalR автоматически вносит это изменение, чтобы код JavaScript мог соответствовать конвенциям JavaScript.

Ниже приведены приведенные примеры, как вызвать метод сервера, который не имеет значения возврата, и как вызвать метод сервера, который имеет значение возврата.

**Метод сервера без атрибута HubMethodName**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample35.cs?highlight=3)]

**Код сервера, определяющий сложный объект, передаваемый в параметре**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample36.cs)]

**Клиентский код, который вызывает метод сервера (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample37.js?highlight=1)]

**Клиентский код, который вызывает метод сервера (без генерируемого прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample38.js?highlight=1)]

Если вы украсили `HubMethodName` метод концентратора атрибутом, используйте это имя без изменения случая.

**Метод сервера** с атрибутом HubMethodName

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample39.cs?highlight=3)]

**Клиентский код, который вызывает метод сервера (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample40.js?highlight=1)]

**Клиентский код, который вызывает метод сервера (без генерируемого прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample41.js?highlight=1)]

Предыдущие примеры показывают, как вызвать метод сервера, не имеющий значения возврата. Ниже приведены приведенные примеры, как вызвать метод сервера с обратным значением.

**Код сервера для метода, который имеет значение возврата**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample42.cs?highlight=3)]

**Класс акции, используемый для** значения возврата

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample43.cs?highlight=1)]

**Клиентский код, который вызывает метод сервера (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample44.js?highlight=2,4-5)]

**Клиентский код, который вызывает метод сервера (без генерируемого прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample45.js?highlight=2,4-5)]

<a id="connectionlifetime"></a>

## <a name="how-to-handle-connection-lifetime-events"></a>Как обрабатывать события жизни соединения

SignalR предоставляет следующие события жизни соединения, которые вы можете обрабатывать:

- `starting`: Поднятые перед отправкой данных по подключению.
- `received`: Поднятыпри получать какие-либо данные о подключении. Предоставляет полученные данные.
- `connectionSlow`: Поднят, когда клиент обнаруживает медленное или часто падающее соединение.
- `reconnecting`: Поднятый, когда базовый транспорт начинает воссоединение.
- `reconnected`: Поднятый при повторном подключении основного транспорта.
- `stateChanged`: Поднят при изменении состояния соединения. Обеспечивает старое состояние и новое состояние (подключение, подключение, воссоединение или отключение).
- `disconnected`: Поднят освоено при отключении соединения.

Например, если вы хотите отображать предупреждающие сообщения при возникновении проблем `connectionSlow` с подключением, которые могут привести к заметным задержкам, свяжетесь с событием.

**Обработка события connectionSlow (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample46.js?highlight=1)]

**Обработка события connectionSlow (без генерируемого прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample47.js?highlight=2)]

Для получения дополнительной информации, см [Понимание и обработка подключения Пожизненные события в SignalR](handling-connection-lifetime-events.md).

<a id="handleerrors"></a>

## <a name="how-to-handle-errors"></a>Как обрабатывать ошибки

Клиент SignalR JavaScript `error` предоставляет событие, для которого можно добавить обработчик. Можно также использовать метод сбоя для добавления обработчика для ошибок, которые являются результатом вызова метода сервера.

Если вы явно не включаете подробные сообщения об ошибке на сервере, объект исключения, который возвращает SignalR после ошибки, содержит минимальную информацию об ошибке. Например, если вызов `newContosoChatMessage` не удается, сообщение об`There was an error invoking Hub method 'contosoChatHub.newContosoChatMessage'.`ошибке в объекте ошибки содержит " Отправка подробных сообщений об ошибках клиентам в производственной сфере не рекомендуется по соображениям безопасности, но если вы хотите включить подробные сообщения об ошибках для устранения неполадок, используйте следующий код на сервере.

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample48.cs?highlight=2)]

В следующем примере показано, как добавить обработчик для события ошибки.

**Добавить обработчик ошибок (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample49.js?highlight=1)]

**Добавить обработчик ошибок (без сгенерированного прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample50.js?highlight=2)]

В следующем примере показано, как обрабатывать ошибку из вызова метода.

**Обработка ошибки от вызова метода (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample51.js?highlight=2)]

**Обработка ошибки от вызова метода (без сгенерированного прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample52.js?highlight=2)]

Если вызов метода не `error` удается, событие также поднимается, поэтому ваш код в обработчике `error` метода и в обратном `.fail` вызове метода будет выполняться.

<a id="logging"></a>

## <a name="how-to-enable-client-side-logging"></a>Как включить журналирование на стороне клиента

Чтобы включить систему входа в систему на стороне клиента на соединение, установите `logging` свойство на объекте соединения перед вызовом метода `start` для установления соединения.

**Включить журнал (с генерируемым прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample53.js?highlight=1)]

**Включить журнал (без генерируемого прокси)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample54.js?highlight=2)]

Чтобы увидеть журналы, откройте инструменты разработчика браузера и перейдите на вкладку Console. Для учебника, который показывает пошаговые инструкции и скриншоты, которые показывают, как это сделать, см [ASP.NET.](../getting-started/tutorial-server-broadcast-with-signalr.md#enable-logging)
