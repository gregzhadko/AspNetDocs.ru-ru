---
uid: signalr/overview/guide-to-the-api/hubs-api-guide-javascript-client
title: Путеводитель по API концентраторов SignalR ASP.NET — клиент JavaScript | Документация Майкрософт
author: bradygaster
description: В этом документе содержатся общие сведения об использовании API концентраторов для SignalR версии 2 в клиентах JavaScript, таких как браузеры и магазин Windows (WinJS) аппликат...
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: a9fd4dc0-1b96-4443-82ca-932a5b4a8ea4
msc.legacyurl: /signalr/overview/guide-to-the-api/hubs-api-guide-javascript-client
msc.type: authoredcontent
ms.openlocfilehash: 8befe133c3627dac1f7d011959c68e2054d345da
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78431292"
---
# <a name="aspnet-signalr-hubs-api-guide---javascript-client"></a>Путеводитель по API концентраторов SignalR ASP.NET — клиент JavaScript

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> В этом документе содержатся общие сведения об использовании API концентраторов для SignalR версии 2 в клиентах JavaScript, таких как браузеры и приложения Магазина Windows (WinJS).
>
> API концентраторов SignalR позволяет выполнять удаленные вызовы процедур (RPC) с сервера на подключенные клиенты и с клиентов на сервер. В серверном коде определяются методы, которые могут вызываться клиентами, и вызываются методы, которые выполняются на клиенте. В клиентском коде определяются методы, которые могут быть вызваны с сервера, а также вызываются методы, которые выполняются на сервере. Этот механизм отвечает за все клиентские коммуникации.
>
> SignalR также предлагает интерфейс API более низкого уровня, называемый постоянными подключениями. Общие сведения о SignalR, концентраторах и постоянных подключениях см. [в статье Общие сведения о SignalR](../getting-started/introduction-to-signalr.md).
>
> ## <a name="software-versions-used-in-this-topic"></a>Версии программного обеспечения, используемые в этом разделе
>
>
> - [Visual Studio 2017](https://visualstudio.microsoft.com/downloads/)
> - .NET 4.5
> - SignalR версии 2
>
>
>
> ## <a name="previous-versions-of-this-topic"></a>Предыдущие версии этого раздела
>
> Сведения о более ранних версиях SignalR см. в статье о [старых версиях](../older-versions/index.md)SignalR.
>
> ## <a name="questions-and-comments"></a>Вопросы и комментарии
>
> Оставьте отзыв о том, как вы понравится вам в этом учебнике, и что можно улучшить в комментариях в нижней части страницы. Если у вас есть вопросы, не связанные непосредственно с этим руководством, их можно опубликовать на [форуме ASP.NET SignalR](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) или [StackOverflow.com](http://stackoverflow.com/).

## <a name="overview"></a>Обзор

Этот документ содержит следующие разделы.

- [Созданный прокси-сервер и его назначение](#genproxy)

    - [Когда следует использовать созданный прокси-сервер](#cantusegenproxy)
- [Установка клиента](#clientsetup)

    - [Как ссылаться на динамически создаваемый прокси-сервер](#dynamicproxy)
    - [Создание физического файла для прокси-сервера, созданного SignalR](#manualproxy)
- [Как установить соединение](#establishconnection)

    - [$. Connection. Hub — это тот же объект, который создает $. Хубконнектион ()](#connequivalence)
    - [Асинхронное выполнение метода Start](#asyncstart)
- [Как установить междоменное подключение](#crossdomain)
- [Настройка подключения](#configureconnection)

    - [Указание параметров строки запроса](#querystring)
    - [Как указать метод перевозки](#transport)
- [Как получить учетную запись-посредник для класса HUB](#getproxy)
- [Определение методов на клиенте, который может вызывать сервер](#callclient)
- [Вызов методов сервера из клиента](#callserver)
- [Как работать с событиями времени жизни соединения](#connectionlifetime)
- [Как обрабатывались ошибки](#handleerrors)
- [Как включить ведение журнала на стороне клиента](#logging)

Документацию по программированию клиентов сервера или .NET см. в следующих ресурсах:

- [Путеводитель по API концентраторов SignalR — сервер](hubs-api-guide-server.md)
- [Путеводитель по API концентраторов SignalR — клиент .NET](hubs-api-guide-net-client.md)

Серверный компонент SignalR 2 доступен только в .NET 4,5 (хотя существует клиент .NET для SignalR 2 в .NET 4,0).

<a id="genproxy"></a>

## <a name="the-generated-proxy-and-what-it-does-for-you"></a>Созданный прокси-сервер и его назначение

Вы можете программировать клиент JavaScript для взаимодействия со службой SignalR с прокси-сервером, который генерирует SignalR, или без него. То, что делает прокси-сервер, упрощает синтаксис кода, используемого для соединения, создания методов, которые сервер вызывает, и вызова методов на сервере.

При написании кода для вызова методов сервера созданный прокси-сервер позволяет использовать синтаксис, который выглядит так, как если бы выполнялась локальная функция: можно написать `serverMethod(arg1, arg2)` вместо `invoke('serverMethod', arg1, arg2)`. Сформированный синтаксис прокси-сервера также позволяет немедленно и расшифровать ошибку на стороне клиента при ошибочном вводе имени метода сервера. Если вы вручную создаете файл, который определяет прокси-серверы, можно также получить поддержку IntelliSense для написания кода, который вызывает методы сервера.

Например, предположим, что на сервере имеется следующий класс концентратора:

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample1.cs?highlight=1,3,5)]

В следующих примерах кода показано, как выглядит код JavaScript для вызова метода `NewContosoChatMessage` на сервере и получения вызовов метода `addContosoChatMessageToPage` с сервера.

**С созданным прокси-сервером**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample2.js?highlight=1-2,8)]

**Без созданного прокси-сервера**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample3.js?highlight=2-3,9)]

<a id="cantusegenproxy"></a>

### <a name="when-to-use-the-generated-proxy"></a>Когда следует использовать созданный прокси-сервер

Если требуется зарегистрировать несколько обработчиков событий для клиентского метода, который вызывается сервером, то созданный прокси-сервер использовать нельзя. В противном случае можно выбрать использование созданного прокси-сервера или не в зависимости от предпочтений в коде. Если вы решили не использовать его, не нужно ссылаться на URL-адрес "SignalR/Hubs" в элементе `script` в клиентском коде.

<a id="clientsetup"></a>

## <a name="client-setup"></a>Настройка клиента

Клиенту JavaScript требуются ссылки на jQuery и основной файл JavaScript SignalR. Версия jQuery должна быть 1.6.4 или крупными более поздними версиями, такими как 1.7.2, 1.8.2 или 1.9.1. Если вы решили использовать созданный прокси-сервер, вам также потребуется ссылка на файл JavaScript, созданный SignalR. В следующем примере показано, как могут выглядеть ссылки на HTML-странице, использующей созданный прокси-сервер.

[!code-html[Main](hubs-api-guide-javascript-client/samples/sample4.html)]

Эти ссылки должны включаться в следующий порядок: jQuery First, SignalR Core после этого и, наконец, прокси-серверы SignalR.

<a id="dynamicproxy"></a>

### <a name="how-to-reference-the-dynamically-generated-proxy"></a>Как ссылаться на динамически создаваемый прокси-сервер

В предыдущем примере ссылка на прокси-сервер, созданный SignalR, — это динамически созданный код JavaScript, а не физический файл. SignalR создает код JavaScript для прокси на лету и обслуживает его клиенту в ответ на URL-адрес "/сигналр/хубс". Если вы указали другой базовый URL-адрес для соединений SignalR на сервере в методе `MapSignalR`, URL-адрес динамически создаваемого прокси-файла — это пользовательский URL-адрес, к которому добавляется "/хубс".

> [!NOTE]
> Для клиентов JavaScript Windows 8 (Windows Store) используйте файл физического прокси-сервера вместо динамически созданного. Дополнительные сведения см. в подразделе [Создание физического файла для прокси-сервера, созданного SignalR](#manualproxy) далее в этой статье.

В представлении Razor ASP.NET 4 или 5 Используйте символ тильды для ссылки на корень приложения в ссылке на файл прокси-сервера:

[!code-html[Main](hubs-api-guide-javascript-client/samples/sample5.html)]

Дополнительные сведения об использовании SignalR в MVC 5 см. в разделе [Начало работы с SignalR и MVC 5](../getting-started/tutorial-getting-started-with-signalr-and-mvc.md).

В представлении Razor ASP.NET 3 Используйте `Url.Content` для ссылки на прокси-файл:

[!code-cshtml[Main](hubs-api-guide-javascript-client/samples/sample6.cshtml)]

В приложении ASP.NET Web Forms используйте `ResolveClientUrl` для доступа к файлу прокси-сервера или зарегистрируйте его через ScriptManager с помощью относительного пути к корню приложения (начиная с тильды):

[!code-aspx[Main](hubs-api-guide-javascript-client/samples/sample7.aspx)]

Как правило, используйте тот же метод для указания URL-адреса "/сигналр/хубс", который используется для файлов CSS или JavaScript. Если вы указали URL-адрес без использования символа тильды, в некоторых сценариях приложение будет работать правильно при тестировании в Visual Studio с помощью IIS Express, но при развертывании в полной службе IIS произойдет ошибка 404. Дополнительные сведения см. в разделе **разрешение ссылок на ресурсы корневого уровня** на [веб-серверах в Visual Studio для веб-проектов ASP.NET](https://msdn.microsoft.com/library/58wxa9w5.aspx) на сайте MSDN.

При запуске веб-проекта в Visual Studio 2017 в режиме отладки и при использовании Internet Explorer в качестве браузера можно просмотреть файл прокси-сервера в **Обозреватель решений** в разделе **Scripts**.

Чтобы просмотреть содержимое файла, дважды щелкните элемент **концентраторы**. Если вы не используете Visual Studio 2012 или 2013 и Internet Explorer или если вы не в режиме отладки, можно также получить содержимое файла, перейдя по URL-адресу "/Сигналр/хубс". Например, если сайт работает на `http://localhost:56699`, перейдите в раздел `http://localhost:56699/SignalR/hubs` в браузере.

<a id="manualproxy"></a>

### <a name="how-to-create-a-physical-file-for-the-signalr-generated-proxy"></a>Создание физического файла для прокси-сервера, созданного SignalR

В качестве альтернативы динамически создаваемому прокси-серверу можно создать физический файл с кодом прокси-сервера и ссылаться на этот файл. Это может потребоваться для контроля над кэшированием или объединением, а также для получения IntelliSense при кодировании вызовов к методам сервера.

Чтобы создать прокси-файл, выполните следующие действия.

1. Установите пакет NuGet [Microsoft. AspNet. SignalR. utils](https://nuget.org/packages/Microsoft.AspNet.SignalR.Utils/) .
2. Откройте командную строку и перейдите в папку *Tools* , содержащую файл SignalR. exe. Папка Tools находится в следующем расположении:

    `[your solution folder]\packages\Microsoft.AspNet.SignalR.Utils.2.1.0\tools`
3. Введите следующую команду:

    `signalr ghp /path:[path to the .dll that contains your Hub class]`

    Путь к *DLL* -файлу обычно является папкой *bin* в папке проекта.

    Эта команда создает файл с именем *Server. js* в той же папке, что и *SignalR. exe*.
4. Поместите файл *Server. js* в соответствующую папку в проекте, переименуйте его в соответствии с вашими приложениями и добавьте ссылку на него вместо ссылки "SignalR/Hubs".

<a id="establishconnection"></a>

## <a name="how-to-establish-a-connection"></a>Как установить соединение

Прежде чем установить соединение, необходимо создать объект соединения, создать прокси-сервер и зарегистрировать обработчики событий для методов, которые могут быть вызваны с сервера. При настройке прокси-сервера и обработчиков событий установите соединение, вызвав метод `start`.

Если вы используете созданный прокси-сервер, то не нужно создавать объект подключения в собственном коде, поскольку созданный код прокси делает это автоматически.

<a id="nogenconnection"></a>

**Установить соединение (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample8.js?highlight=5)]

**Установить соединение (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample9.js?highlight=1,6)]

В примере кода для подключения к службе SignalR используется URL-адрес по умолчанию "/SignalR". Сведения о том, как указать другой базовый URL-адрес, см. [в разделе ASP.NET SignalR Hub API Guide-Server-URL-адрес/SignalR](hubs-api-guide-server.md#signalrurl).

По умолчанию расположением концентратора является текущий сервер. При подключении к другому серверу укажите URL-адрес перед вызовом метода `start`, как показано в следующем примере:

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample10.js)]

> [!NOTE]
> Обычно обработчики событий регистрируются перед вызовом метода `start` для установления соединения. Если вы хотите зарегистрировать некоторые обработчики событий после установления соединения, это можно сделать, но необходимо зарегистрировать по крайней мере один из обработчиков событий перед вызовом метода `start`. Одна из причин этого заключается в том, что в приложении может быть много концентраторов, но не требуется запускать событие `OnConnected` на каждом концентраторе, если вы собираетесь использовать только один из них. Когда соединение установлено, присутствие клиентского метода на прокси-сервере концентратора сообщает SignalR о необходимости активировать событие `OnConnected`. Если вы не зарегистрировали обработчики событий перед вызовом метода `start`, вы сможете вызывать методы в центре, но метод `OnConnected` центра не будет вызываться, а клиентские методы не будут вызываться с сервера.

<a id="connequivalence"></a>

### <a name="connectionhub-is-the-same-object-that-hubconnection-creates"></a>$. Connection. Hub — это тот же объект, который создает $. Хубконнектион ()

Как видно из примеров, при использовании созданного прокси-сервера `$.connection.hub` ссылается на объект Connection. Это тот же объект, который можно получить, вызвав `$.hubConnection()`, если не используется созданный прокси-сервер. Созданный код прокси создает подключение для вас, выполняя следующую инструкцию:

![Создание подключения в созданном прокси-файле](hubs-api-guide-javascript-client/_static/image3.png)

При использовании созданного прокси-сервера можно выполнять любые действия с `$.connection.hub`, которые можно выполнять с помощью объекта соединения, если не используется созданный прокси-сервер.

<a id="asyncstart"></a>

### <a name="asynchronous-execution-of-the-start-method"></a>Асинхронное выполнение метода Start

Метод `start` выполняется асинхронно. Он возвращает [отложенный объект jQuery](http://api.jquery.com/category/deferred-object/). Это означает, что можно добавлять функции обратного вызова, вызывая такие методы, как `pipe`, `done`и `fail`. Если имеется код, который необходимо выполнить после установления соединения, например вызов метода сервера, вставьте этот код в функцию обратного вызова или вызовите его из функции обратного вызова. Метод обратного вызова `.done` выполняется после установления соединения и после завершения выполнения любого кода в `OnConnected` метода обработчика событий на сервере.

Если перед `.done` вызовом метода `start` вы поместили оператор "Now Connected" из предыдущего примера в качестве следующей строки кода, то `console.log`ная строка будет выполнена до установки соединения, как показано в следующем примере:

![Неправильный способ написания кода, который выполняется после установления соединения](hubs-api-guide-javascript-client/_static/image5.png)

<a id="crossdomain"></a>

## <a name="how-to-establish-a-cross-domain-connection"></a>Как установить междоменное подключение

Как правило, если браузер загружает страницу из `http://contoso.com`, то подключение SignalR находится в том же домене, в `http://contoso.com/signalr`. Если страница из `http://contoso.com` устанавливает подключение к `http://fabrikam.com/signalr`, то есть подключение между доменами. По соображениям безопасности междоменные соединения отключены по умолчанию.

В SignalR 1. x запросы между доменами управляются одним флагом Енаблекроссдомаин. Этот флаг управляет запросами JSONP и CORS. Для большей гибкости вся поддержка CORS была удалена из серверного компонента SignalR (клиенты JavaScript по-прежнему используют CORS обычным образом, если обнаружено, что браузер поддерживает его), а новое по промежуточного слоя OWIN доступно для поддержки этих сценариев.

Если для клиента требуется поддержка JSONP (для поддержки междоменных запросов в более старых браузерах), ее необходимо включить явным образом, установив `EnableJSONP` для объекта `HubConfiguration` в значение `true`, как показано ниже. JSONP по умолчанию отключен, так как он менее безопасен, чем CORS.

**Добавление Microsoft. Owin. CORS в проект:** Чтобы установить эту библиотеку, выполните в консоли диспетчера пакетов следующую команду:

`Install-Package Microsoft.Owin.Cors`

Эта команда добавит версию пакета 2.1.0 в проект.

### <a name="calling-usecors"></a>Вызов UseCors

 В следующем фрагменте кода показано, как реализовать междоменные соединения в SignalR 2.

**Реализация запросов между доменами в SignalR 2**

В следующем коде показано, как включить CORS или JSONP в проекте SignalR 2. В этом примере кода используется `Map` и `RunSignalR` вместо `MapSignalR`, чтобы по промежуточного слоя CORS выполнялось только для запросов SignalR, требующих поддержки CORS (а не для всего трафика по пути, указанному в `MapSignalR`). Map можно также использовать для любого другого по промежуточного слоя, который должен выполняться для конкретного префикса URL-адреса, а не для всего приложения.

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample11.cs)]

> [!NOTE]
>
> - Не устанавливайте в коде значение true для `jQuery.support.cors`.
>
>     ![Не устанавливайте jQuery. support. CORS в значение true](hubs-api-guide-javascript-client/_static/image7.png)
>
>     SignalR обрабатывает использование CORS. Если присвоить параметру `jQuery.support.cors` значение true, JSONP отключается, так как в этом случае SignalR считает, что браузер поддерживает CORS.
> - При подключении к URL-адресу localhost Internet Explorer 10 не будет считать его междоменным подключением, поэтому приложение будет работать локально с IE 10, даже если на сервере не включены междоменные соединения.
> - Сведения об использовании междоменных соединений с Internet Explorer 9 см. в [этом потоке StackOverflow](http://stackoverflow.com/questions/13573397/siganlr-ie9-cross-domain-request-dont-work).
> - Сведения об использовании междоменных соединений с Chrome см. в [этом потоке StackOverflow](http://stackoverflow.com/questions/15467373/signalr-1-0-1-cross-domain-request-cors-with-chrome).
> - В примере кода для подключения к службе SignalR используется URL-адрес по умолчанию "/SignalR". Сведения о том, как указать другой базовый URL-адрес, см. [в разделе ASP.NET SignalR Hub API Guide-Server-URL-адрес/SignalR](hubs-api-guide-server.md#signalrurl).

<a id="configureconnection"></a>

## <a name="how-to-configure-the-connection"></a>Настройка подключения

Прежде чем устанавливать соединение, можно указать параметры строки запроса или указать метод перевозки.

<a id="querystring"></a>

### <a name="how-to-specify-query-string-parameters"></a>Указание параметров строки запроса

Если требуется отправлять данные на сервер при подключении клиента, можно добавить параметры строки запроса в объект соединения. В следующих примерах показано, как задать параметр строки запроса в клиентском коде.

**Задать значение строки запроса перед вызовом метода Start (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample12.js?highlight=1)]

**Задать значение строки запроса перед вызовом метода Start (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample13.js?highlight=2)]

В следующем примере показано, как считать параметр строки запроса в серверном коде.

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample14.cs?highlight=5)]

<a id="transport"></a>

### <a name="how-to-specify-the-transport-method"></a>Как указать метод перевозки

В рамках процесса подключения клиент SignalR обычно согласовывается с сервером для определения наилучшего транспорта, поддерживаемого как сервером, так и клиентом. Если вы уже уверены, какой транспорт вы хотите использовать, можно обойти этот процесс согласования, указав метод перевозки при вызове метода `start`.

**Клиентский код, указывающий транспортный метод (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample15.js?highlight=1)]

**Клиентский код, указывающий транспортный метод (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample16.js?highlight=2)]

В качестве альтернативы можно указать несколько методов транспорта в том порядке, в котором вы хотите, чтобы SignalR помогла их использовать.

**Клиентский код, указывающий настраиваемую схему резервного транспорта (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample17.js?highlight=1)]

**Клиентский код, указывающий настраиваемую схему резервного транспорта (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample18.js?highlight=2)]

Для указания транспортного метода можно использовать следующие значения:

- WebSockets
- "Фореверфраме"
- "Серверсентевентс"
- "Лонгполлинг"

В следующих примерах показано, как узнать, какой транспортный метод используется соединением.

**Клиентский код, отображающий транспортный метод, используемый соединением (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample19.js?highlight=2)]

**Клиентский код, отображающий транспортный метод, используемый соединением (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample20.js?highlight=3)]

Сведения о том, как проверить транспортный метод в коде сервера, см. в разделе [ASP.NET SignalR Hub API Guide-Server-как получить сведения о клиенте из свойства Context](hubs-api-guide-server.md#contextproperty). Дополнительные сведения о транспортировках и резервных запасах см. [в статье Введение в SignalR-транспорты и резервные стратегии](../getting-started/introduction-to-signalr.md#transports).

<a id="getproxy"></a>

## <a name="how-to-get-a-proxy-for-a-hub-class"></a>Как получить учетную запись-посредник для класса HUB

Каждый созданный объект соединения инкапсулирует сведения о соединении со службой SignalR, которая содержит один или несколько классов концентратора. Для взаимодействия с классом концентратора используется прокси-объект, создаваемый самостоятельно (если вы не используете созданный прокси) или который создается автоматически.

На клиенте имя прокси-сервера — это версия имени класса концентратора в стиле Camel. SignalR автоматически вносит это изменение, чтобы код JavaScript мог соответствовать соглашениям JavaScript.

**Класс Hub на сервере**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample21.cs?highlight=1)]

**Получение ссылки на созданный прокси клиента для концентратора**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample22.js?highlight=1)]

**Создание прокси клиента для класса Hub (без созданного прокси-сервера)**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample23.cs?highlight=1)]

Если класс Hub доменяется атрибутом `HubName`, используйте точное имя без изменения регистра.

**Класс Hub на сервере с атрибутом HubName**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample24.cs?highlight=1)]

**Получение ссылки на созданный прокси клиента для концентратора**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample25.js?highlight=1)]

**Создание прокси клиента для класса Hub (без созданного прокси-сервера)**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample26.cs?highlight=1)]

<a id="callclient"></a>

## <a name="how-to-define-methods-on-the-client-that-the-server-can-call"></a>Определение методов на клиенте, который может вызывать сервер

Чтобы определить метод, который сервер может вызывать из концентратора, добавьте обработчик событий в прокси-сервер концентратора с помощью свойства `client` созданного прокси-сервера или вызовите метод `on`, если не используется созданный прокси-сервер. Параметры могут быть сложными объектами.

Добавьте обработчик событий перед вызовом метода `start` для установления соединения. (Если вы хотите добавить обработчики событий после вызова метода `start`, см. Примечание в статье [о том, как установить соединение](#establishconnection) ранее в этом документе, и используйте синтаксис, показанный для определения метода без использования созданного прокси-сервера.)

Сопоставление имен методов не учитывает регистр. Например, `Clients.All.addContosoChatMessageToPage` на сервере будет выполнять `AddContosoChatMessageToPage`, `addContosoChatMessageToPage`или `addcontosochatmessagetopage` на клиенте.

**Определение метода на клиенте (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample27.js?highlight=2)]

**Альтернативный способ определения метода на клиенте (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample28.js?highlight=1-2)]

**Определите метод на клиенте (без созданного прокси-сервера или при добавлении после вызова метода Start).**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample29.js?highlight=3)]

**Серверный код, вызывающий метод клиента**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample30.cs?highlight=5)]

Следующие примеры включают сложный объект в качестве параметра метода.

**Определите метод для клиента, который принимает сложный объект (с созданным прокси-сервером).**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample31.js?highlight=2-3)]

**Определите метод для клиента, который принимает сложный объект (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample32.js?highlight=3-4)]

**Серверный код, определяющий сложный объект**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample33.cs?highlight=1)]

**Серверный код, вызывающий метод клиента с помощью сложного объекта**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample34.cs?highlight=3)]

<a id="callserver"></a>

## <a name="how-to-call-server-methods-from-the-client"></a>Вызов методов сервера из клиента

Чтобы вызвать серверный метод из клиента, используйте свойство `server` созданного прокси-сервера или метод `invoke` на прокси-сервере концентратора, если не используется созданный прокси. Возвращаемое значение или параметры могут быть сложными объектами.

Передайте в концентратор имя метода в стиле Camel. SignalR автоматически вносит это изменение, чтобы код JavaScript мог соответствовать соглашениям JavaScript.

В следующих примерах показано, как вызвать метод сервера, не имеющий возвращаемого значения, и как вызвать метод сервера, который имеет возвращаемое значение.

**Серверный метод без атрибута Хубмесоднаме**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample35.cs?highlight=3)]

**Серверный код, определяющий сложный объект, передаваемый в параметре**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample36.cs)]

**Клиентский код, вызывающий метод сервера (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample37.js?highlight=1)]

**Клиентский код, вызывающий метод сервера (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample38.js?highlight=1)]

Если метод концентратора был дополнен атрибутом `HubMethodName`, используйте это имя без изменения регистра.

**Серверный метод** с атрибутом хубмесоднаме

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample39.cs?highlight=3)]

**Клиентский код, вызывающий метод сервера (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample40.js?highlight=1)]

**Клиентский код, вызывающий метод сервера (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample41.js?highlight=1)]

В предыдущих примерах показано, как вызвать метод сервера, не имеющий возвращаемого значения. В следующих примерах показано, как вызвать метод сервера, который имеет возвращаемое значение.

**Серверный код для метода, имеющего возвращаемое значение**

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample42.cs?highlight=3)]

**Класс акции, используемый для** возвращаемого значения

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample43.cs?highlight=1)]

**Клиентский код, вызывающий метод сервера (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample44.js?highlight=2,4-5)]

**Клиентский код, вызывающий метод сервера (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample45.js?highlight=2,4-5)]

<a id="connectionlifetime"></a>

## <a name="how-to-handle-connection-lifetime-events"></a>Как работать с событиями времени жизни соединения

SignalR предоставляет следующие события времени жизни подключения, которые можно выполнять:

- `starting`: возникает перед отправкой данных через соединение.
- `received`: возникает, когда в соединении получены какие-либо данные. Предоставляет полученные данные.
- `connectionSlow`: возникает, когда клиент обнаруживает слишком большое или частое удаление соединения.
- `reconnecting`: возникает, когда начинается повторное подключение базового транспорта.
- `reconnected`: возникает при повторном подключении базового транспорта.
- `stateChanged`: возникает при изменении состояния соединения. Обеспечивает старое состояние и новое состояние (подключение, подключение, повторное подключение или соединение разорвано).
- `disconnected`: возникает при отключении соединения.

Например, если вы хотите отображать предупреждающие сообщения при возникновении проблем с подключением, которые могут привести к заметным задержкам, обработайте событие `connectionSlow`.

**Обрабатывает событие Коннектионслов (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample46.js?highlight=1)]

**Обрабатывает событие Коннектионслов (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample47.js?highlight=2)]

Дополнительные сведения см. [в разделе Основные сведения и обработка событий времени жизни подключения в SignalR](handling-connection-lifetime-events.md).

<a id="handleerrors"></a>

## <a name="how-to-handle-errors"></a>Как обрабатывались ошибки

Клиент JavaScript SignalR предоставляет `error` событие, для которого можно добавить обработчик. Также можно использовать метод Fail, чтобы добавить обработчик для ошибок, возникших в результате вызова метода сервера.

Если на сервере явно не включены подробные сообщения об ошибках, то объект исключения, возвращаемый SignalR после ошибки, содержит минимальные сведения об ошибке. Например, если вызов `newContosoChatMessage` завершается ошибкой, сообщение об ошибке в объекте Error содержит "`There was an error invoking Hub method 'contosoChatHub.newContosoChatMessage'.`" Отправка подробных сообщений об ошибках клиентам в рабочей среде не рекомендуется по соображениям безопасности, но если вы хотите включить подробные сообщения об ошибках для устранения неполадок, используйте следующий код на сервере.

[!code-csharp[Main](hubs-api-guide-javascript-client/samples/sample48.cs?highlight=2)]

В следующем примере показано, как добавить обработчик для события ошибки.

**Добавление обработчика ошибок (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample49.js?highlight=1)]

**Добавление обработчика ошибок (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample50.js?highlight=2)]

В следующем примере показано, как выполнить обработку ошибки из вызова метода.

**Обрабатывает ошибку при вызове метода (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample51.js?highlight=2)]

**Обрабатывает ошибку при вызове метода (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample52.js?highlight=2)]

При сбое вызова метода также вызывается событие `error`, поэтому код в обработчике метода `error` и в обратном вызове метода `.fail` будет выполняться.

<a id="logging"></a>

## <a name="how-to-enable-client-side-logging"></a>Как включить ведение журнала на стороне клиента

Чтобы включить ведение журнала на стороне клиента для соединения, задайте свойство `logging` объекта соединения перед вызовом метода `start` для установления соединения.

**Включить ведение журнала (с созданным прокси-сервером)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample53.js?highlight=1)]

**Включить ведение журнала (без созданного прокси-сервера)**

[!code-javascript[Main](hubs-api-guide-javascript-client/samples/sample54.js?highlight=2)]

Чтобы просмотреть журналы, откройте средства разработчика в браузере и перейдите на вкладку "консоль". Руководство, в котором показаны пошаговые инструкции и снимки экрана, в которых показано, как это сделать, см. в разделе [серверное вещание с помощью ASP.NET SignalR. Включение ведения журнала](../getting-started/tutorial-server-broadcast-with-signalr.md#enable-logging).
