---
uid: mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/advanced-entity-framework-scenarios-for-an-mvc-web-application
title: Расширенные сценарии Entity Framework для веб-приложения MVC (10 из 10) | Документация Майкрософт
author: tdykstra
description: Пример веб-приложение университета Contoso демонстрирует создание приложения ASP.NET MVC 4, с помощью Entity Framework 5 Code First и Visual Studio...
ms.author: riande
ms.date: 07/30/2013
ms.assetid: 64906a1d-f734-41cf-9615-ee95f8740996
msc.legacyurl: /mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/advanced-entity-framework-scenarios-for-an-mvc-web-application
msc.type: authoredcontent
ms.openlocfilehash: a1218b1fb5a8ee28ea6ee3d3c5af979e86821ed7
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59391199"
---
# <a name="advanced-entity-framework-scenarios-for-an-mvc-web-application-10-of-10"></a>Сценарии расширенные Entity Framework для веб-приложения MVC (10 из 10)

по [том Дайкстра](https://github.com/tdykstra)

[Скачать завершенный проект](http://code.msdn.microsoft.com/Getting-Started-with-dd0e2ed8)

> Пример веб-приложение университета Contoso демонстрирует создание приложения ASP.NET MVC 4, используя Entity Framework 5 Code First и Visual Studio 2012. Сведения о серии руководств см. в [первом руководстве серии](creating-an-entity-framework-data-model-for-an-asp-net-mvc-application.md). Серии руководств можно начать с самого начала или [Загрузите начальный проект для этой главы](building-the-ef5-mvc4-chapter-downloads.md) и начните здесь.
> 
> > [!NOTE] 
> > 
> > Если вы столкнулись с проблемами, не удается устранить, [скачать завершенного глава](building-the-ef5-mvc4-chapter-downloads.md) и попробуйте воспроизвести проблему. Обычно можно найти решение проблемы, сравнивая код, чтобы полный код. Некоторые распространенные ошибки и способы их устранения, см. в разделе [ошибки и способы их устранения.](advanced-entity-framework-scenarios-for-an-mvc-web-application.md#errors)


В предыдущем учебнике было реализовано репозиторий и блок рабочих шаблонов. Этом руководстве рассматриваются следующие темы:

- Выполняет необработанные запросы SQL.
- Выполняет отключение отслеживания запросов.
- Проверка запросов отправки в базу данных.
- Работа с прокси-классы.
- Отключить автоматическое обнаружение изменений.
- Отключение проверки при сохранении изменения.
- [Ошибки и способы](#errors)

Для большинства из этих разделов вы будете работать со страницами, которые уже созданы. Чтобы использовать необработанный SQL для проведения массовых обновлений вы создадите новую страницу, которая обновляет количество кредиты на сумму всех курсов в базе данных:

![Update_Course_Credits_initial_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image1.png)

Затем использовать запрос Отключение отслеживания добавляется новая логика проверки на страницу изменения кафедры:

![Department_Edit_page_with_duplicate_administrator_error_message](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image2.png)

## <a name="performing-raw-sql-queries"></a>Выполнение необработанные SQL-запросы

Entity Framework API для Code First включает методы, которые позволяют передавать команды SQL непосредственно к базе данных. Можно выбрать один из следующих параметров.

- Использование метода `DbSet.SqlQuery` для запросов, которые возвращают типы сущностей. Возвращаемые объекты должен иметь тип, ожидаемый `DbSet` объекта и они автоматически отслеживаются контекстом базы данных пока не отключена отслеживания. (См. в разделе `AsNoTracking` метод.)
- Используйте `Database.SqlQuery` метод для запросов, возвращающих типы, не являющиеся сущностями. Возвращаемые данные не отслеживаются контекстом базы данных, даже если вы используете этот метод для извлечения типов сущностей.
- Используйте [Database.ExecuteSqlCommand](https://msdn.microsoft.com/library/gg679456(v=vs.103).aspx) для команд не связанным с запросом.

Одним из преимуществ использования платформы Entity Framework является возможность избежать слишком тесной привязки кода к конкретному способу хранения данных. Это достигается путем автоматического создания запросов и команд SQL, что позволяет упростить написание кода. Но существуют менее в редких случаях, когда необходимо выполнить SQL-запросы, созданные вручную, и эти методы позволяют обрабатывать такие исключения.

Как и всегда при выполнении команд SQL в веб-приложении, необходимо принимать меры предосторожности для защиты сайта от атак путем внедрения кода SQL. Одним из способов защиты является применение параметризованных запросов, которые гарантируют, что строки, отправляемые веб-страницей, не могут быть интерпретированы как команды SQL. В рамках этого учебника вы будете использовать параметризованные запросы при интеграции вводимых пользователем данных в запрос.

### <a name="calling-a-query-that-returns-entities"></a>Вызов запроса, которая возвращает сущности

Предположим, что нужно `GenericRepository` класс, предоставляющий дополнительную фильтрацию и сортировку гибкость без необходимости создать производный класс дополнительных методов. Одним из способов добиться, следовало бы добавить в метод, принимающий запрос SQL. Вы можете указать любого типа, фильтрации и сортировки, вам необходимо включить в контроллере, например `Where` предложение, зависящий от соединения или вложенный запрос. В этом разделе вы увидите, как реализовать такой метод.

Создание `GetWithRawSql` метод, добавив следующий код, чтобы *GenericRepository.cs*:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample1.cs)]

В *CourseController.cs*, вызовите новый метод из `Details` метод, как показано в следующем примере:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample2.cs)]

В этом случае можно использовать `GetByID` метод, но вы используете `GetWithRawSql` метод, чтобы убедиться, что `GetWithRawSQL` работает метод.

Запустить эту страницу сведений, чтобы убедиться, что принцип работы запроса select (выбрать **курс** вкладку и затем **сведения** для одного курса).

![Course_Details_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image3.png)

### <a name="calling-a-query-that-returns-other-types-of-objects"></a>Вызов запроса, возвращающего другие типы объектов

Ранее вы создали таблицу статистики учащихся на странице сведений, в которой было показано число учащихся на каждую дату регистрации. Код, который делает это в *HomeController.cs* использует LINQ:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample3.cs)]

Предположим, что вы хотите написать код, извлекающий эти данные непосредственно в SQL, а не с помощью LINQ. Для этого необходим для выполнения запроса, возвращающего отличные от сущностей, то есть необходимо использовать `Database.SqlQuery` метод.

В *HomeController.cs*, замените оператор LINQ в `About` метод следующим кодом:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample4.cs)]

Откройте страницу About. На экран будут выведены те же данные, что и ранее.

![About_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image4.png)

### <a name="calling-an-update-query"></a>Вызов запроса на обновление

Предположим, что администраторам университета Suppose необходимо иметь возможность выполнять массовые изменения в базе данных, например изменить число зачетных баллов для каждого курса. Поскольку в университете ведется множество курсов, будет неэффективно извлекать их в виде сущностей и изменять по отдельности. В этом разделе вы реализуете веб-страницы, которая позволяет пользователю указать коэффициент, используемый для изменить число зачетных баллов для каждого курса, и вам предстоит изменения, выполнив SQL `UPDATE` инструкции. Веб-страница должна выглядеть так, как показано на следующем рисунке:

![Update_Course_Credits_initial_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image5.png)

В предыдущем руководстве вы использовали универсального репозитория для чтения и обновления `Course` сущностей в `Course` контроллера. Для этой операции массового обновления необходимо создать новый метод репозитория, который не находится в универсального репозитория. Чтобы сделать это, вы создадите выделенное `CourseRepository` класс, производный от `GenericRepository` класса.

В *DAL* папке создайте *CourseRepository.cs* и замените существующий код следующим кодом:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample5.cs)]

В *UnitOfWork.cs*, изменить `Course` тип репозитория из `GenericRepository<Course>` для `CourseRepository:`

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample6.cs)]

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample7.cs)]

В *CourseController.cs*, добавьте `UpdateCourseCredits` метод:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample8.cs)]

Этот метод будет использоваться для обоих `HttpGet` и `HttpPost`. Когда `HttpGet` `UpdateCourseCredits` выполнении метода `multiplier` переменной будет иметь значение null, и в представлении отображается пустое текстовое поле и кнопка отправки, как показано на предыдущем рисунке.

Когда **обновление** кнопки и `HttpPost` выполнении метода `multiplier` будет иметь значение, введенное в текстовое поле. Затем код вызывает репозитории `UpdateCourseCredits` метод, который возвращает количество обработанных строк, и это значение хранится в `ViewBag` объекта. Когда представление получает число затронутых строк в `ViewBag` объекта, он отображает это число, а не текстового поля и отправьте кнопки, как показано на следующем рисунке:

![Update_Course_Credits_rows_affected_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image6.png)

Создание представления в *Views\Course* папку отзывы о курсе обновления страницы:

![Add_View_dialog_box_for_Update_Course_Credits](https://asp.net/media/2578203/Windows-Live-Writer_Advanced-Entity-Framework-Scenarios-for-_CEF8_Add_View_dialog_box_for_Update_Course_Credits.png)

В *Views\Course\UpdateCourseCredits.cshtml*, замените код шаблона следующим кодом:

[!code-cshtml[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample9.cshtml)]

Выполните метод `UpdateCourseCredits`, выбрав вкладку **Courses** (Курсы), а затем добавив "/UpdateCourseCredits" в конец URL-адреса в адресной строке браузера (например, `http://localhost:50205/Course/UpdateCourseCredits`). Введите число в текстовое поле:

![Update_Course_Credits_initial_page_with_2_entered](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image7.png)

Нажмите кнопку **Обновить**. Отобразится число обработанных строк:

![Update_Course_Credits_rows_affected_page](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image8.png)

Нажмите кнопку **Back to List** (Вернуться к списку), чтобы просмотреть список курсов с измененным числом зачетных баллов.

![Courses_Index_page_showing_revised_credits](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image9.png)

Дополнительные сведения о необработанных SQL-запросы, см. в разделе [необработанные запросы SQL](https://blogs.msdn.com/b/adonet/archive/2011/02/04/using-dbcontext-in-ef-feature-ctp5-part-10-raw-sql-queries.aspx) в блоге группы Entity Framework.

## <a name="no-tracking-queries"></a>и без отслеживания

Когда контекст базы данных извлекает строки базы данных и создает представляющие их объекты сущностей, по умолчанию данные о ли сущностей в памяти находятся в синхронизированном с содержимым базы данных. При обновлении сущности данные в памяти выступают в роли кэша. В веб-приложении такое кэширование часто не нужно, поскольку экземпляры контекста, как правило, существуют недолго (для каждого запроса создается и ликвидируется собственный экземпляр), и контекст, считывающий сущность, как правило, ликвидируется до того, как сущность будет использована снова.

Можно указать, отслеживает ли контекст объектов сущностей для запроса с помощью `AsNoTracking` метод. Как правило, это требуется в следующих сценариях:

- Запрос извлекает такого большого объема данных, отключение отслеживания может заметно повысить производительность.
- Вы хотите присоединить сущность для его обновления, но ранее полученные той же сущности для разных целей. Поскольку сущность уже отслеживается контекстом базы данных, присоединить сущность, которую требуется изменить, нельзя. Один из способов предотвратить возникновение этой ситуации является использование `AsNoTracking` параметр с предыдущий запрос.

В этом разделе вы реализуете бизнес-логики, который иллюстрирует второй из этих сценариев. В частности вы будете применять бизнес-правило, говорит, что преподаватель не может быть администратор отдела более одного.

В *DepartmentController.cs*, добавьте новый метод, который можно вызвать из `Edit` и `Create` методы, чтобы не двух отделов должны иметь того же администратора:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample10.cs)]

Добавьте код в `try` блока `HttpPost` `Edit` метод для вызова этого нового метода, если нет ошибок проверки. `try` Блок теперь выглядит как в следующем примере:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample11.cs?highlight=9-12)]

Запустите страницу изменения кафедры и попробуйте изменить администратора отдела с преподавателем, уже является администратором другое подразделение. Вы получаете сообщение ожидаемых ошибок:

![Department_Edit_page_with_duplicate_administrator_error_message](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image10.png)

Теперь запустите еще раз страницу изменения кафедры и это изменение времени **бюджета** сумма. При нажатии кнопки **Сохранить**, отобразится страница ошибки:

![Department_Edit_page_with_object_state_manager_error_message](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image11.png)

Сообщение об ошибке исключения "`An object with the same key already exists in the ObjectStateManager. The ObjectStateManager cannot track multiple objects with the same key.`" это произошло из-за следующая последовательность событий:

- `Edit` Вызовы методов `ValidateOneAdministratorAssignmentPerInstructor` метод, который извлекает все отделы, которые имеют Kim Abercrombie их администратор. Что вызывает кафедры английского языка для чтения. Так как это подразделение редактируемого, ошибка не возникает. В результате этой операции чтения Однако сущность кафедры английского языка, который был прочитан из базы данных теперь отслеживается контекстом базы данных.
- `Edit` Пытается задать метод `Modified` флаг в английском языке сущность department, созданный связывателем модели MVC, но это не удается, так как контекст уже отслеживает сущность для кафедры английского языка.

Для предотвращения контекст отслеживания сущности отделов в памяти, полученных запросом проверки, является одним из решений этой проблемы. Нет не недостаток таким образом, так как не будет обновляться этой сущности или считываете их снова способом, который целесообразно кэширования в памяти.

В *DepartmentController.cs*в `ValidateOneAdministratorAssignmentPerInstructor` метод, укажите нет, как показано в следующем:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample12.cs?highlight=4)]

Повторите попытку изменить **бюджета** объем отдел. Это время операция выполнена успешно, и сайт возвращает правильно на страницу индекса кафедр, отображающий значение пересмотренного бюджета.

## <a name="examining-queries-sent-to-the-database"></a>Анализ запросов, отправляемых в базу данных

В некоторых случаях полезно иметь возможность просмотреть фактические SQL-запросы, отправляемые в базу данных. Чтобы сделать это, можно проверить переменную запроса в отладчике или вызов запроса `ToString` метод. Чтобы испытать эту возможность, будет рассмотрим простой запрос и взгляну на дальнейшие действия с его по мере добавления вариантов такого безотложной загрузки, фильтрации и сортировки.

В *контроллеров/CourseController*, замените `Index` метод следующим кодом:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample13.cs?highlight=3)]

Теперь установите точку останова в *GenericRepository.cs* на `return query.ToList();` и `return orderBy(query).ToList();` констатация `Get` метод. Запустите проект в режиме отладки и выберите на странице индекса курсов. Когда код достигает точки останова, изучите `query` переменной. Появится запрос, который отправляется в SQL Server. Это простой `Select` инструкции:

[!code-json[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample14.json)]

![](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image12.png)

Запросы могут быть слишком много времени для отображения в окнах отладки в Visual Studio. Чтобы просмотреть весь запрос, можно скопировать значения переменной и вставьте его в текстовом редакторе:

![Copy_value_of_variable_in_debug_mode](https://asp.net/media/2578239/Windows-Live-Writer_Advanced-Entity-Framework-Scenarios-for-_CEF8_Copy_value_of_variable_in_debug_mode_0902a2b1-b799-47a6-9b4b-f266c79d83c1.png)

Теперь добавим стрелку раскрывающегося списка на страницу индекса курс, чтобы пользователи могут выполнять фильтрацию определенного отдела. Нужно отсортировать курсы по названию, и потребуется указать упреждающую загрузку для `Department` свойства навигации. В *CourseController.cs*, замените `Index` метод следующим кодом:

[!code-csharp[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample15.cs)]

Метод получает выбранное значение из раскрывающегося списка в `SelectedDepartment` параметра. Если ничего не выбрано, этот параметр будет иметь значение null.

Объект `SelectList` коллекцию, содержащую все отделы передается в представление для раскрывающегося списка. Параметры, передаваемые `SelectList` конструктор укажите значение имени поля, имя текстового поля и выбранного элемента.

Для `Get` метод `Course` репозитория, код задает критерий фильтра, порядок сортировки и Безотложная загрузка для `Department` свойства навигации. Возвращает критерий фильтра всегда `true` Если ничего не выбрано в раскрывающемся списке (то есть `SelectedDepartment` имеет значение null).

В *Views\Course\Index.cshtml*, непосредственно перед открытием `table` , добавьте следующий код для создания раскрывающегося списка и кнопка отправки:

[!code-cshtml[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample16.cshtml)]

С точки останова, по-прежнему установленные `GenericRepository` выполнения страница индекса курсов класса. Выполните остальные указания первые два раза, что код достигает точки останова, чтобы отобразить страницу в браузере. Выберите отдел в раскрывающемся списке и нажмите кнопку **фильтра**:

![Course_Index_page_with_department_selected](advanced-entity-framework-scenarios-for-an-mvc-web-application/_static/image13.png)

Это время для запроса отделов для раскрывающегося списка будет первой точке останова. Пропустите и просмотрите `query` переменной очередном код достигает точки останова для см. в разделе, что `Course` запроса теперь выглядит примерно как. Вы увидите примерно следующим образом:

[!code-json[Main](advanced-entity-framework-scenarios-for-an-mvc-web-application/samples/sample17.json)]

Вы увидите, что запрос является теперь `JOIN` запрос, который загружает `Department` вместе с данными `Course` данных, и что он включает `WHERE` предложение.

<a id="proxyclasses"></a>

## <a name="working-with-proxy-classes"></a>Работа с прокси-классы

Когда платформа Entity Framework создает экземпляры сущностей (например, при выполнении запроса), он часто создает их как экземпляры динамически создаваемого производный тип, который выступает в качестве прокси для сущности. Этот прокси-сервер переопределяет некоторые виртуальные свойства сущности, которую нужно вставить обработчик для выполнения действий автоматически, при обращении к свойству. Например этот механизм используется для поддержки отложенная загрузка связей.

В большинстве случаев не требуется учитывать такое использование учетных записей-посредников, но существуют исключения:

- В некоторых сценариях может потребоваться запретить Entity Framework создавать экземпляры прокси-сервера. Например сериализации экземпляров без прокси-сервера может быть более эффективным, чем сериализации экземпляров прокси-сервера.
- При создании экземпляра класса сущности с помощью `new` оператор, вы не получаете экземпляр прокси-сервера. Это означает, что вы не получаете функциональные возможности, такие как отложенная загрузка и автоматическое отслеживание изменений. Обычно это хорошо; обычно не требуется отложенной загрузки, так как вы создаете новую сущность, которые не находятся в базе данных, и обычно не требуется отслеживания изменений, если явным образом пометить сущности как `Added`. Тем не менее, если вам нужен отложенную загрузку, и требуется отслеживание изменений, можно создать экземпляры этой сущности с помощью прокси- `Create` метод `DbSet` класса.
- Может потребоваться получить тип фактические сущности из прокси-типа. Можно использовать `GetObjectType` метод `ObjectContext` класса для получения фактического объекта типа экземпляра типа прокси-сервера.

Дополнительные сведения см. в разделе [работа с прокси](https://blogs.msdn.com/b/adonet/archive/2011/02/02/using-dbcontext-in-ef-feature-ctp5-part-8-working-with-proxies.aspx) в блоге группы Entity Framework.

## <a name="disabling-automatic-detection-of-changes"></a>Отключить автоматическое обнаружение изменений

Платформа Entity Framework определяет, как была изменена сущность (и, соответственно, какие обновления требуется отправить в базу данных), сравнивая текущие значения сущности с исходными. Исходные значения сохраняются в том случае, когда был запросе или присоединении сущности. Ниже перечислены некоторые из методов, которые приводят к автоматическому обнаружению изменений:

- `DbSet.Find`
- `DbSet.Local`
- `DbSet.Remove`
- `DbSet.Add`
- `DbSet.Attach`
- `DbContext.SaveChanges`
- `DbContext.GetValidationErrors`
- `DbContext.Entry`
- `DbChangeTracker.Entries`

Если вы отслеживаете большое количество сущностей и вызовите один из этих методов много раз в цикле, можно получить значительно большую производительность, временно отключив автоматическое изменение обнаружения с помощью метода [autodetectchangesenabled в свойстве](https://msdn.microsoft.com/library/system.data.entity.infrastructure.dbcontextconfiguration.autodetectchangesenabled(VS.103).aspx) свойство. Дополнительные сведения см. в разделе [автоматическое обнаружение изменений](https://blogs.msdn.com/b/adonet/archive/2011/02/06/using-dbcontext-in-ef-feature-ctp5-part-12-automatically-detecting-changes.aspx).

## <a name="disabling-validation-when-saving-changes"></a>Отключение проверки при сохранении изменения

При вызове `SaveChanges` метод, по умолчанию Entity Framework проверяет данные в все свойства всех измененных сущностей перед обновлением базы данных. Если вы обновили большое количество сущностей и вы уже проверили данные, эта работа необязателен и может сделать процесс сохранения изменений обрабатываются быстрее, временно отключив проверки. Можно сделать с помощью [ValidateOnSaveEnabled](https://msdn.microsoft.com/library/system.data.entity.infrastructure.dbcontextconfiguration.validateonsaveenabled(VS.103).aspx) свойство. Дополнительные сведения см. в разделе [проверки](https://blogs.msdn.com/b/adonet/archive/2010/12/15/ef-feature-ctp5-validation.aspx).

## <a name="summary"></a>Сводка

На этом завершается этой серии руководств по использованию Entity Framework в приложении ASP.NET MVC. Ссылки на другие ресурсы Entity Framework можно найти в [схема содержимого для доступа к данным ASP.NET](../../../../whitepapers/aspnet-data-access-content-map.md).

Дополнительные сведения о развертывании веб-приложения после его создания см. в разделе [Карта содержимого развертывания ASP.NET](https://msdn.microsoft.com/library/bb386521.aspx) в библиотеке MSDN.

Сведения по другим вопросам, связанных с MVC, таких как проверка подлинности и авторизации, см. в разделе [MVC рекомендуемые ресурсы](../../getting-started/recommended-resources-for-mvc.md).

<a id="acknowledgments"></a>

## <a name="acknowledgments"></a>Благодарности

- Том Дайкстра написал исходной версии этого учебника и — старший разработчик программирования на веб-платформы Майкрософт и группа разработки содержимого программных средств.
- [Рик Андерсон](https://blogs.msdn.com/b/rickandy/) (twitter [ @RickAndMSFT ](http://twitter.com/RickAndMSFT)) соавтором этого руководства, и была большая часть работы, для EF 5 и MVC 4. Рик — старший разработчик программирования для Microsoft Azure и MVC.
- [Роуэн Миллер](http://www.romiller.com) и другие участники команды Entity Framework assisted с проверками кода и помогли многих проблемах отладки со миграций, которые возникли во время мы обновляли руководства для EF 5.

## <a name="vb"></a>VB

При этом руководстве была разработана, мы предоставили версии C# и VB проекта Загрузка завершена. Это обновление предоставляет проект C# загружаемые для каждой главы, чтобы было проще приступить к работе в любом из серии, но из-за ограничения времени и других приоритетов, мы не сделали, для Visual Basic. При сборке проекта VB с помощью этих учебников и возможно, захотят, поделиться с другими пользователями, свяжитесь с нами.

<a id="errors"></a>

## <a name="errors-and-workarounds"></a>Ошибки и способы их устранения

### <a name="cannot-createshadow-copy"></a>Не удается создать теневую копию

Сообщение об ошибке:

*Не удается создать теневую копию «DotNetOpenAuth.OpenId», так как он уже существует.*

Решение:

Подождите несколько секунд и обновите страницу.

### <a name="update-database-not-recognized"></a>Update-Database не распознан

Сообщение об ошибке:

*Термин «Update-Database» не распознан как имя командлета, функции, файла скрипта или действующей программы. Проверьте правильность написания имени или если был задан путь, проверьте правильность пути и повторите попытку.* (Из *`Update-Database`* команду в PMC.)

Решение:

Закройте Visual Studio. Повторно откройте проект и повторите попытку.

### <a name="validation-failed"></a>Сбой проверки

Сообщение об ошибке:

*Не удалось проверить один или несколько сущностей. Свойству «EntityValidationErrors» Дополнительные сведения см.* (Из *`Update-Database`* команду в PMC.)

Решение:

Одной из причин этой проблемы является ошибки проверки при `Seed` выполнения метода. См. в разделе [заполнения и отладка Entity Framework (EF) DBs](https://blogs.msdn.com/b/rickandy/archive/2013/02/12/seeding-and-debugging-entity-framework-ef-dbs.aspx) советы по отладке `Seed` метод.

### <a name="http-50019-error"></a>HTTP 500.19 ошибки

Сообщение об ошибке:

*Ошибка HTTP 500.19 — Внутренняя ошибка сервера запрошенную страницу не может быть недоступна из-за неверной конфигурации данных для страницы.*

Решение:

Один из способов, эта ошибка может возникнуть — от использования нескольких копий решение, каждый из них используют тот же номер порта. Как правило, эту проблему можно решить, выход из всех экземпляров Visual Studio, а затем перезапуска на работу с вашего проекта. Если это не поможет, попробуйте изменить номер порта. Щелкните правой кнопкой файл проекта и выберите пункт Свойства. Выберите **Web** вкладку и измените номер порта в **URL-адрес проекта** текстовое поле.

### <a name="error-locating-sql-server-instance"></a>Ошибка при обнаружении экземпляра SQL Server

Сообщение об ошибке:

*При установлении соединения с SQL Server произошла ошибка с сетью или с определенным экземпляром. Сервер не найден или недоступен. Убедитесь, что имя экземпляра указано правильно и что SQL Server настроен для удаленных подключений. (поставщик: сетевые интерфейсы SQL, ошибка: 26 — ошибка при поиске указанного сервера/экземпляра)*

Решение:

Проверьте строку подключения. Если вы вручную удалили базы данных, измените имя базы данных в строке подключения.

> [!div class="step-by-step"]
> [Назад](implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application.md)
> [Вперед](building-the-ef5-mvc4-chapter-downloads.md)
