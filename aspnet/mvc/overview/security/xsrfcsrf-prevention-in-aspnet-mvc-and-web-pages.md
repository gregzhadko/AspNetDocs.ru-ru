---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: Предотвращение XSRF/CSRF в ASP.NET MVC и веб-страницах | Документация Майкрософт
author: Rick-Anderson
description: Подделка межсайтовых запросов (также известная как XSRF или CSRF) — это атака на веб-приложения, в результате чего вредоносный веб-узел может повлиять на интеракти...
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: fb7e76101cbe6a874ddf5b3429ca2dc6d474334b
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2019
ms.locfileid: "74595764"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a>Предотвращение атак XSRF и CSRF в ASP.NET MVC и на веб-страницах

по [Рик Андерсон (]((https://twitter.com/RickAndMSFT))

> Подделка межсайтовых запросов (также известная как XSRF или CSRF) — это атака на веб-приложения, с помощью которых вредоносный веб-узел может повлиять на взаимодействие между браузером клиента и веб-сайтом, которому доверяет этот браузер. Эти атаки становятся возможными, так как веб-браузеры автоматически отправляют маркеры проверки подлинности при каждом запросе к веб-сайту. Каноническим примером является файл cookie проверки подлинности, например ASP. Билет проверки подлинности с помощью форм NET. Однако веб-сайты, использующие любой постоянный механизм проверки подлинности (например, проверку подлинности Windows, базовый и т. д.), могут быть нацелены на эти атаки.
> 
> Атака XSRF отличается от фишинговой атаки. Для атак с фишингом требуется вмешательство из жертвы. При атаке с фишингом вредоносный веб-узел имитирует целевой веб-узел, и жертва обманным путем является предоставление злоумышленнику конфиденциальной информации. При атаке XSRF часто нет необходимости в взаимодействии с жертвой. Скорее, злоумышленник полагается на то, что браузер автоматически отправляет все соответствующие файлы cookie на конечный веб-сайт.
> 
> Дополнительные сведения см. в статье [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).

## <a name="anatomy-of-an-attack"></a>Анатомия атаки

Чтобы проанализировать атаку XSRF, рассмотрим пользователя, который хочет выполнить некоторые банковские транзакции в сети. Этот пользователь сначала посещает WoodgroveBank.com и входит в систему. в этом случае заголовок ответа будет содержать файл cookie проверки подлинности:

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

Так как файл cookie для проверки подлинности является файлом cookie сеанса, он автоматически удаляется браузером при выходе из процесса браузера. Однако до этого времени браузер автоматически включит файл cookie с каждым запросом в WoodgroveBank.com. Теперь пользователь хочет переместить $1000 в другую учетную запись, поэтому он заполняет форму на банковском сайте, а браузер выполняет этот запрос к серверу:

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

Так как эта операция имеет побочный результат (она инициирует денежную транзакцию), на веб-узле банка выбрано требование HTTP POST для запуска этой операции. Сервер считывает маркер проверки подлинности из запроса, ищет номер учетной записи текущего пользователя, проверяет наличие достаточного количества фондов, а затем инициирует транзакцию в целевой учетной записи.

Его интерактивный банк завершен, пользователь выходит с веб-узла банка и посещает другие расположения в Интернете. Один из этих сайтов — fabrikam.com — включает следующую разметку на странице, внедренной в &lt;IFRAME&gt;:

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

После чего браузер сделает запрос:

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

Злоумышленник может использовать тот факт, что у пользователя по-прежнему есть действительный маркер проверки подлинности для целевого веб-сайта, и он использует небольшой фрагмент кода JavaScript, чтобы браузер мог автоматически выполнить HTTP-запрос POST к целевому сайту. Если маркер проверки подлинности по-прежнему действителен, банковский сайт запустит перенос $250 в учетную запись, выбираемую злоумышленником.

### <a name="ineffective-mitigations"></a>Неэффективное устранение рисков

Интересно отметить, что в приведенном выше сценарии тот факт, что доступ к WoodgroveBank.com осуществлялся по протоколу SSL и имел недостаточный файл cookie для проверки подлинности с использованием протокола SSL, чтобы предотвратить атаку. Злоумышленник может указать [схему универсального кода ресурса (URI](http://en.wikipedia.org/wiki/URI_scheme) ) в своей &lt;форме&gt;, и браузер продолжит отсылать файлы cookie с истекшим сроком действия на целевой сайт, если эти файлы cookie согласованы с схемой URI предполагаемой цели.

Можно сказать, что пользователь должен просто не посетить недоверенные сайты, так как посещение только надежных сайтов поможет сохранить безопасность в сети. В этом нет смысла, но к сожалению, этот Совет не всегда практичен. Возможно, пользователь «доверяет» локальным веб-сайтам новостей Консолидатедмессенжер. ConsolidatedMessenger.com и переходит на этот сайт, но на этом сайте есть уязвимость XSS, которая позволяет злоумышленнику внедрить тот же фрагмент кода, который был запущен в fabrikam.com.

Можно проверить, что входящие запросы имеют [заголовок ссылки](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) , ссылающийся на ваш домен. Это приведет к отмене запросов, непреднамеренно отправленных из стороннего домена. Тем не менее некоторые пользователи отключают заголовок ссылки в браузере в соответствии с соображениями конфиденциальности, и злоумышленники иногда могут подменить этот заголовок, если в жертве установлено небезопасное программное обеспечение. Проверка того, что [заголовок ссылки](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) не считается безопасным способом предотвращения атак XSRF.

## <a name="web-stack-runtime-xsrf-mitigations"></a>Устранение рисков XSRF среды выполнения веб-стека

Среда выполнения веб-стека ASP.NET использует вариант [шаблона токена синхронизатора](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) для защиты от атак XSRF. Общая форма шаблона токена синхронизатора состоит в том, что два XSRF токена передаются на сервер с каждым HTTP-запросом POST (в дополнение к маркеру проверки подлинности): один маркер в качестве файла cookie, а другой — как значение формы. Значения токенов, созданные средой выполнения ASP.NET, не являются детерминированными или прогнозируемыми для злоумышленника. При отправке маркеров сервер разрешает выполнение запроса, только если оба токена прошли проверку на равенство.

*Токен сеанса* проверки запроса XSRF хранится как файл cookie HTTP и в настоящее время содержит следующую информацию в полезных данных:

- Маркер безопасности, состоящий из случайного 128-битного идентификатора.   
 На следующем рисунке показан маркер сеанса проверки запроса XSRF, отображаемый в средствах разработчика F12 для Internet Explorer: (Обратите внимание, что это текущая реализация, которая, скорее всего, будет изменена.)

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

*Маркер поля* хранится в виде `<input type="hidden" />` и содержит следующие сведения в полезных данных:

- Имя пользователя, вошедшего в систему (если прошло проверку подлинности).
- Дополнительные данные, предоставляемые [иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).

Полезные данные токенов XSRF шифруются и подписываются, поэтому вы не сможете просмотреть имя пользователя при использовании средств для проверки маркеров. Если веб-приложение предназначено для ASP.NET 4,0, службы шифрования предоставляются подпрограммыми [machineKey. Encoded](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) . Если веб-приложение предназначено для ASP.NET 4,5 или более поздней версии, службы шифрования предоставляются подсистемой [machineKey. Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) , которая обеспечивает лучшую производительность, расширяемость и безопасность. Дополнительные сведения см. в следующих записях блога:

- [Улучшения шифрования в ASP.NET 4,5, PT. 1](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [Улучшения шифрования в ASP.NET 4,5, PT. 2](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [Улучшения шифрования в ASP.NET 4,5, PT. 3](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a>Создание маркеров

Чтобы создать маркеры XSRF, вызовите метод [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) из представления MVC или @AntiForgery.GetHtml() из страницы Razor. Затем среда выполнения выполнит следующие действия:

1. Если текущий HTTP-запрос уже содержит токен сеанса Anti-XSRF (\_\_XSRF Рекуестверификатионтокен), маркер безопасности извлекается из него. Если HTTP-запрос не содержит токен сеанса Anti-XSRF или если не удается извлечь маркер безопасности, будет создан новый случайный токен Anti-XSRF.
2. Токен поля Anti-XSRF создается с использованием маркера безопасности из шага (1) выше и идентификатора текущего вошедшего в систему пользователя. (Дополнительные сведения об определении удостоверения пользователя см. в разделе **[сценарии с поддержкой специальных возможностей](#_Scenarios_with_special)** ниже.) Кроме того, если настроена [иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) , среда выполнения вызывает свой метод [жетаддитионалдата](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) и включает возвращенную строку в маркер поля. (Дополнительные сведения см. в разделе о **[конфигурации и расширяемости](#_Configuration_and_extensibility)** .)
3. Если на шаге (1) был создан новый токен Anti-XSRF, будет создан новый маркер сеанса, содержащий его, который будет добавлен в коллекцию исходящих файлов cookie HTTP. Маркер поля из шага (2) будет заключен в элемент `<input type="hidden" />`, а эта разметка HTML будет возвращаемым значением `Html.AntiForgeryToken()` или `AntiForgery.GetHtml()`.

## <a name="validating-the-tokens"></a>Проверка токенов

Чтобы проверить входящие маркеры XSRF, разработчик включает атрибут [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) на своем действии или контроллере MVC или вызывает `@AntiForgery.Validate()` на странице Razor. Среда выполнения выполнит следующие действия:

1. Выполняется чтение токена входящего сеанса и маркера поля, который извлекается из каждого токена XSRF. Токены Anti-XSRF должны быть идентичными на шаге (2) в подпрограмме создания.
2. Если текущий пользователь прошел проверку подлинности, его имя пользователя сравнивается с именем пользователя, хранящимся в маркере поля. Имена пользователей должны совпадать.
3. Если настроена [иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , среда выполнения вызывает метод *валидатеаддитионалдата* . Метод должен возвращать логическое значение *true*.

Если проверка прошла, запрос может продолжаться. Если проверка завершается неудачно, платформа выдает исключение *хттпантифоржерексцептион*.

## <a name="failure-conditions"></a>Условия сбоя

Начиная с среды выполнения веб-стека ASP.NET версии 2, любые *хттпантифоржерексцептион* , созданные во время проверки, будут содержать подробные сведения о том, что пошло не так. В настоящее время определены следующие условия сбоя:

- Маркер сеанса или маркер формы отсутствует в запросе.
- Маркер сеанса или формы не читается. Наиболее вероятной причиной этого является ферма, выполняющая несовпадающие версии среды выполнения веб-стека ASP.NET или фермы, в которой элемент &lt;machineKey&gt; в файле Web. config отличается между компьютерами. Для принудительного применения этого исключения можно использовать такой инструмент, как Fiddler, с помощью токена Anti-XSRF.
- Маркер сеанса и маркер поля были переключены.
- Маркер сеанса и маркер поля содержат несовпадающие маркеры безопасности.
- Имя пользователя, внедренное в маркер поля, не соответствует имени пользователя текущего вошедшего в систему пользователя.
- Метод *[иантифоржеряддитионалдатапровидер. валидатеаддитионалдата](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* вернул *значение false*.

Средства защиты от XSRF также могут выполнять дополнительную проверку во время создания или проверки маркера, а сбои во время этих проверок могут привести к возникновению исключений. Дополнительные сведения см. в разделах [WIF/ACS/проверка подлинности](#_WIF_ACS) и **[Конфигурация и расширяемость](#_Configuration_and_extensibility)** на основе утверждений.

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a>Сценарии с специальной поддержкой

### <a name="anonymous-authentication"></a>Анонимная проверка подлинности

Система защиты от XSRF содержит специальную поддержку для анонимных пользователей, где "Anonymous" определяется как пользователь, где свойство *IIdentity. Authenticator* возвращает *значение false*. Сценарии включают в себя предоставление защиты XSRF для страницы входа (перед проверкой подлинности пользователя) и пользовательские схемы проверки подлинности, в которых приложение использует механизм, отличный от *IIdentity* , для идентификации пользователей.

Чтобы реализовать эти сценарии, обратите внимание, что маркеры сеанса и поля соединены маркером безопасности, который представляет собой 128-разрядный случайный непрозрачный идентификатор. Этот маркер безопасности используется для наблюдения за сеансом отдельного пользователя при переходе на сайт, чтобы он эффективно использовал анонимный идентификатор. Вместо имени пользователя для подпрограмм создания и проверки, описанных выше, используется пустая строка.

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a>WIF, ACS и аутентификация на основе утверждений

Как правило, классы *IIdentity* , встроенные в .NET Framework, имеют свойство, которое *IIdentity.Name* достаточно для уникальной идентификации конкретного пользователя в определенном приложении. Например, *FormsIdentity.Name* возвращает имя пользователя, хранящееся в базе данных членства (уникальное для всех приложений в зависимости от этой базы данных), *WindowsIdentity.Name* возвращает доменное удостоверение пользователя и т. д. Эти системы обеспечивают не только проверку подлинности; Они также *указывают* пользователей на приложение.

С другой стороны, проверка подлинности на основе утверждений не обязательно требует идентификации конкретного пользователя. Вместо этого типы *ClaimsPrincipal* и *ClaimsIdentity* связаны с набором экземпляров *заявок* , в котором Индивидуальные утверждения могут иметь значение "более 18 лет возраста" или "является администратором". Так как пользователь не был определен, среда выполнения не может использовать свойство *ClaimsIdentity.Name* в качестве уникального идентификатора для этого конкретного пользователя. В реальных примерах команда *ClaimsIdentity.Name* возвращает *значение NULL*, возвращает понятное (отображаемое) имя или, в противном случае, возвращает строку, которая не подходит для использования в качестве уникального идентификатора для пользователя.

Многие из развертываний, использующих проверку подлинности на основе утверждений, в частности используют [службу контроля доступа Azure](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS). ACS позволяет разработчику настраивать отдельных *поставщиков удостоверений* (например, ADFS, поставщика учетных записей Майкрософт, поставщиков OpenID Connect, таких как Yahoo! и т. д.), а поставщики удостоверений возвращают *идентификаторы имен*. Эти идентификаторы имен могут содержать личные сведения (PII), такие как адрес электронной почты, или анонимно, например частный личный идентификатор (PPID). Независимо от этого, кортеж (поставщик удостоверений, идентификатор имени) достаточно подходит как соответствующий маркер отслеживания для конкретного пользователя, пока он выполняет просмотр сайта, поэтому среда выполнения веб-стека ASP.NET может использовать кортеж вместо имени пользователя при создании и Проверка маркеров поля Anti-XSRF. Конкретные URI для поставщика удостоверений и идентификатор имени:

- `https://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

(Дополнительные сведения см. на [странице документации по ACS](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) .)

При создании или проверке маркера среда выполнения веб-стека ASP.NET будет выполнять привязку к типам:

- `Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (для пакета SDK для WIF).
- `System.Security.Claims.ClaimsIdentity` (для .NET 4,5).

Если эти типы существуют и если *иииидентити* текущего пользователя реализуют или подклассы одного из этих типов, при создании и проверке маркеров в средстве защиты от имени пользователя будет использоваться кортеж (поставщик удостоверений, идентификатор имени). Если такого кортежа не существует, запрос завершится с ошибкой, описанной для разработчика как настроить систему XSRF, чтобы понять, какой механизм проверки подлинности на основе утверждений используется. Дополнительные сведения см. в разделе **[Конфигурация и расширяемость](#_Configuration_and_extensibility)** .

### <a name="oauth--openid-authentication"></a>Проверка подлинности OAuth/OpenID Connect

Наконец, средство борьбы-XSRF имеет специальную поддержку для приложений, использующих проверку подлинности OAuth или OpenID Connect. Эта поддержка основана на эвристическом уровне: если текущая *IIdentity.Name* начинается с http://или HTTPS://, то сравнения имен пользователей будут выполняться с использованием компаратора порядковых номеров, а не компаратора OrdinalIgnoreCase по умолчанию.

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a>Конфигурация и расширяемость

Иногда разработчикам может потребоваться более строгий контроль над поведением создания и проверки XSRF. Например, поведение по умолчанию для вспомогательных функций MVC и веб-страниц автоматически добавляет cookie-файлы HTTP в ответ нежелательно, и разработчик может сохранить маркеры в любом расположении. Существует два интерфейса API для помощи с этим:

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

Метод *WebMethod* принимает в качестве входных данных существующий токен сеанса проверки XSRF запроса (который может иметь значение null) и создает в качестве выходных данных новый токен сеанса проверки запроса XSRF и маркер поля. Токены — это просто непрозрачные строки без декорирования. значение *формтокен* для экземпляра не будет упаковано во входной&gt; тег &lt;. Значение *невкукиетокен* может быть равно null. в этом случае значение *олдкукиетокен* остается действительным, и не нужно задавать новый файл cookie ответа. Вызывающий элемент *GetResponse отвечает за* сохранение всех необходимых файлов cookie ответа или создание необходимой разметки. сам *метод GetResponse* не изменит ответ как побочный результат. Метод *Validate* принимает входящие маркеры сеанса и поля и выполняет вышеупомянутые логику проверки.

### <a name="antiforgeryconfig"></a>антифоржериконфиг

Разработчик может настроить XSRF систему из приложения\_запуска. Конфигурация является программной. Ниже описаны свойства статического типа *антифоржериконфиг* . Большинству пользователей, использующих утверждения, необходимо установить свойство Уникуеклаимтипеидентифиер.

| **Property** | **Описание** |
| --- | --- |
| **аддитионалдатапровидер** | Объект [иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , предоставляющий дополнительные данные во время формирования маркера и использующий дополнительные данные во время проверки маркера. Значение по умолчанию — *null*. Дополнительные сведения см. в разделе [иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) . |
| **CookieName** | Строка, которая предоставляет имя файла cookie HTTP, используемого для хранения токена сеанса Anti-XSRF. Если это значение не задано, имя будет создано автоматически на основе развернутого виртуального пути приложения. Значение по умолчанию — *null*. |
| **RequireSsl** | Логическое значение, определяющее, должны ли маркеры защиты XSRF отправляться через канал, защищенный SSL. Если это значение равно *true*, то во всех автоматически создаваемых файлах cookie будет установлен флаг "Secure", а API-интерфейсы XSRF будут вызываться из запроса, который не был отправлен через SSL. Значение по умолчанию — *false*. |
| **суппрессидентитихеуристикчеккс** | Логическое значение, определяющее, должна ли система защиты от XSRF деактивировать поддержку удостоверений на основе утверждений. Если это значение равно *true*, система считает, что *IIdentity.Name* подходит для использования в качестве уникального идентификатора для каждого пользователя, и не будет пытаться использовать особый регистр *IClaimsIdentity* или *КЛКЛАИМСИДЕНТИТИ* , как описано в [WIF/ACS/ раздел аутентификации на основе утверждений](#_WIF_ACS) . Значение по умолчанию — `false`. |
| **уникуеклаимтипеидентифиер** | Строка, указывающая, какой тип утверждения подходит для использования в качестве уникального идентификатора для каждого пользователя. Если это значение задано и текущая *IIdentity* на основе утверждений, система попытается извлечь утверждение типа, указанного параметром *уникуеклаимтипеидентифиер*, а соответствующее значение будет использоваться вместо имени пользователя, когда Создание маркера поля. Если тип утверждения не найден, система не сможет выполнить запрос. Значение по умолчанию — *null*. Это означает, что система должна использовать кортеж (поставщик удостоверений, идентификатор имени), как описано выше, вместо имени пользователя. |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a>иантифоржеряддитионалдатапровидер

Тип *[иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* позволяет разработчикам расширять поведение системы защиты от XSRF, округляя дополнительные данные в каждом маркере. Метод *жетаддитионалдата* вызывается каждый раз при создании маркера поля, а возвращаемое значение внедряется в созданный токен. Разработчик может возвращать метку времени, nonce или любое другое значение, которое ему хочет воспользоваться в этом методе.

Аналогичным образом метод *валидатеаддитионалдата* вызывается каждый раз при проверке маркера поля, а строка "дополнительные данные", внедренная в маркер, передается в метод. Подпрограммы проверки могут реализовать время ожидания (путем проверки текущего времени на время, которое было сохранено при создании маркера), подпрограммы проверки nonce или любую другую требуемую логику.

## <a name="design-decisions-and-security-considerations"></a>Разработка решений и рекомендаций по безопасности

Маркер безопасности, связывающий маркеры сеанса и поля, технически нужен только при попытке защитить анонимные и неаутентифицированные пользователи от атак XSRF. При проверке подлинности пользователя сам маркер проверки подлинности (предположительно Отправленный в виде файла cookie) можно использовать в качестве одной половины пары токенов синхронизатора. Однако существуют допустимые сценарии для защиты страниц входа, непроверенных пользователями, а логика защиты от XSRF была сделана проще, всегда создавая и проверяя маркер безопасности даже для пользователей, прошедших проверку подлинности. Кроме того, она обеспечивает некоторую дополнительную защиту в случае, когда злоумышленник получит маркер поля, так как установка или подбор маркера сеанса будет еще одним препятствием для преодоления злоумышленника.

Разработчики должны соблюдать осторожность, если несколько приложений размещаются в одном домене. Например, несмотря на то, что *example1.cloudapp.NET* и *example2.cloudapp.NET* являются разными узлами, между всеми узлами в домене *\*. cloudapp.NET* существует неявная связь доверия. Это неявное отношение доверия [позволяет потенциально недоверенным узлам повлиять на файлы cookie друг друга](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (те же политики, которые УПРАВЛЯЮТ запросами AJAX, не обязательно применяются к ФАЙЛАМ cookie HTTP). Среда выполнения веб-стека ASP.NET предоставляет ряд мер по предотвращению того, что имя пользователя внедряется в маркер поля, поэтому даже если вредоносный поддомен может перезаписать маркер сеанса, он не сможет создать действительный маркер поля для пользователя. Однако при размещении в такой среде встроенные подпрограммы XSRF по-прежнему не могут защищаться от захвата сеанса или XSRF входа.

Подпрограммы XSRF в настоящее время не защищают от [кликджекинга](https://www.owasp.org/index.php/Clickjacking). Приложения, которые хотят защищать себя от кликджекинга, могут легко сделать это, отправив заголовок X-Frame-Options: САМЕОРИГИН с каждым ответом. Этот заголовок поддерживается во всех последних браузерах. Дополнительные сведения см. в [блоге IE](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), в [блоге SDL](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)и в [OWASP](https://www.owasp.org/index.php/Clickjacking). Среда выполнения веб-стека ASP.NET может в некоторых будущих выпусках сделать так, чтобы вспомогательные приложения MVC и Web Pages Anti-XSRF автоматически задали этот заголовок, чтобы обеспечить автоматическую защиту приложений от атак.

Веб-разработчики должны убедиться, что их сайты не подвержены атакам XSS. Атаки XSS являются очень мощными, и успешная атака также нарушает защиту среды выполнения веб-стека ASP.NET от атак XSRF.

## <a name="acknowledgment"></a>Подтверждение

[@LeviBroderick](https://twitter.com/LeviBroderick), кто написал большую часть кода безопасности ASP.NET, это основная часть этой информации.
