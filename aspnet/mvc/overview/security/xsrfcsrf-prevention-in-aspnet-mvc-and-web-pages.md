---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: Защиты от XSRF/CSRF в ASP.NET MVC и веб-страниц | Документация Майкрософт
author: Rick-Anderson
description: Подделки межсайтовых запросов (также известные как XSRF или CSRF) — это атака, размещенных на веб сервере приложений, при котором злонамеренный веб-узел может влиять на проводятся...
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: de0e9cc168b9f18fd2bd83329106df45d7551b1a
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59386564"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a>Предотвращение атак XSRF и CSRF в ASP.NET MVC и на веб-страницах

по [Рик Андерсон]((https://twitter.com/RickAndMSFT))

> Межсайтовые запросы, что подделки (также известные как XSRF или CSRF) — это атака, размещенных на веб сервере приложений, при котором злонамеренный веб-узел может влиять на взаимодействие между клиентским браузером и веб-сайта доверяет браузер. Эти атаки становятся возможными, потому что веб-браузеры отправляют маркеры аутентификации автоматически при каждом запросе к веб-сайта. Типичный пример — создает файл cookie проверки подлинности, например ASP. Билет проверки подлинности форм NET. Тем не менее веб-сайты, использующие любой надежный способ проверки подлинности (например, проверка подлинности Windows, Basic и т. д.) может быть целью таких атак.
> 
> Атака XSRF отличается от фишинговой атаки. Фишинговые атаки требуют взаимодействия с жертвы. В фишинговой атаке вредоносный веб-узел будет имитировать целевого веб-сайта и жертва предоставляет атакующей конфиденциальную информацию злоумышленнику. При атаке XSRF существует очень часто никаких действий необходимые из жертвы. Вместо этого он полагается на браузер автоматически отправляет все необходимые файлы cookie на целевой веб-сайт.
> 
> Дополнительные сведения см. в разделе [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).


## <a name="anatomy-of-an-attack"></a>Анатомия атаки

Разберем атака XSRF, рассмотрите возможность пользователь, желающий для выполнения некоторых банковских транзакций. Во-первых, этот пользователь посещает WoodgroveBank.com и журналов, после чего заголовок ответа будет содержать ее файла cookie проверки подлинности:

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

Так как файл cookie проверки подлинности файла cookie сеанса, он будет автоматически удалено с помощью браузера при выходе из процесса обозревателя. Тем не менее до этого времени браузер автоматически включит файл cookie при каждом запросе к WoodgroveBank.com. Теперь пользователь хочет перенести 1000 долл. США в другую учетную запись, поэтому она заполняет форму на сайте банковских операций, а браузер выполняет этот запрос к серверу:

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

Так как эта операция имеет побочные эффекты (он инициирует денежные транзакции), узел банка выбрала требуется запрос HTTP POST, чтобы выполнить эту операцию. Сервер считывает маркер проверки подлинности из запроса, ищет номер учетной записи текущего пользователя, проверяет, что существует достаточно средств, а затем инициирует транзакцию на целевой учетной записи.

Ей online банковских завершения, пользователь выходит за пределы узла банковской системы и посещает другие расположения в Интернете. Один из этих сайтов — fabrikam.com — включает в себя следующую разметку страницы, внедренный в &lt;iframe&gt;:

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

Который затем браузер для выполнения этого запроса:

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

Злоумышленник использовать тот факт, что пользователь по-прежнему могут быть маркер аутентификации для целевого веб-сайта, и она работает с небольшой фрагмент кода JavaScript, чтобы в браузере сделать запрос HTTP POST на целевой сайт автоматически. Если маркер проверки подлинности все еще действителен, узла банковской системы будет инициировать передачу 250 долл. США в учетную запись по выбору злоумышленника.

### <a name="ineffective-mitigations"></a>Неэффективной способы их устранения

Это интересно отметить, что в сценарии выше тот факт, что WoodgroveBank.com осуществлялся через SSL и имели файл cookie проверки подлинности только для SSL было недостаточно предотвратить атаки. Злоумышленник имеет возможность указать [схема URI](http://en.wikipedia.org/wiki/URI_scheme) (https) в ней &lt;формы&gt; элемент и браузер будет продолжать отправлять неистекшим сроком действия файлов cookie на целевой сайт до тех пор, пока эти файлы cookie согласованы с URI Схема намеченной цели.

Можно поспорить, что пользователь не просто посетите ненадежных узлов, как посещение только надежных сайтов помогает оставаться безопасном через Интернет. Есть некоторые буду говорить честно: это, но увы этому совету не всегда целесообразно. Возможно пользователя «доверяет» на сайте местные новости ConsolidatedMessenger. ConsolidatedMessenger.com и переходит к посещение, вместо этого сайта, но этот сайт имеет уязвимость XSS, что позволяет злоумышленнику внедрять фрагмент кода, запущенной на fabrikam.com.

Убедитесь, что входящие запросы имеют [заголовок Referer](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) ссылающихся на ваш домен. Это остановит запросы, отправленные невольно из домена независимых производителей. Тем не менее некоторые люди отключить заголовок Referer браузера в целях конфиденциальности и злоумышленники иногда может подделать заголовок, если жертвы имеет определенные небезопасных установлено программное обеспечение. Проверка [заголовок Referer](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) не считается безопасным способом, предотвращение атак XSRF.

## <a name="web-stack-runtime-xsrf-mitigations"></a>Способы устранения рисков Web XSRF стек среды выполнения

Среда выполнения ASP.NET Web стека используется вариант [шаблона токена синхронизатор](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) для защиты от XSRF-атак. Общий вид шаблона токена синхронизатор — что два маркера anti-XSRF отправляются на сервер в каждом запросе HTTP POST (наряду с токеном проверки подлинности): один маркер как файл cookie, а другой — как значение формы. Значения маркера, созданный средой выполнения ASP.NET не детерминированным или какого- либо злоумышленником. Когда токены отправляются, разрешает продолжить обработку только в том случае, если оба маркера проходит проверку сравнения запроса сервер.

Запрос проверки XSRF *маркер сеанса* сохраняется как файл cookie HTTP и в настоящее время содержит следующие сведения в полезные данные:

- Маркер безопасности, состоящую из случайного 128-разрядный идентификатор.   
 На следующем рисунке отображается с помощью средств разработчика Internet Explorer F12 токен сеанса проверки XSRF запроса: (Обратите внимание, это текущая реализация и подчиняется, даже скорее всего изменить.)

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

*Маркер поля* хранится в виде `<input type="hidden" />` и содержит следующую информацию в полезные данные:

- Имя пользователя вошедшего в систему пользователя (если прошел проверку подлинности).
- Любые дополнительные данные, предоставляемые [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).

Полезные данные маркеров защиты от XSRF шифруются и подписываются, поэтому не отображается имя пользователя, при использовании средств для проверки токенов. При веб-приложение предназначено для ASP.NET 4.0, службы шифрования предоставленные [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) подпрограммы. Когда веб-приложение предназначено для ASP.NET 4.5 или более поздней, криптографические предоставляются [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) подпрограмму, которая предлагает лучшую производительность, расширяемости и безопасности. См. в разделе, что в следующих записях блога Дополнительные сведения:

- [Криптографических усовершенствований в ASP.NET 4.5, pt. 1](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [Криптографических усовершенствований в ASP.NET 4.5, pt. 2](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [Криптографических усовершенствований в ASP.NET 4.5, pt. 3](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a>Создания маркеров

Для создания маркеров защиты от XSRF, вызовите [ @Html.AntiForgeryToken ](https://msdn.microsoft.com/library/dd470175.aspx) метода из представления MVC или @AntiForgery.GetHtml() в Razor Pages. Среда выполнения будет затем сделайте следующее:

1. Если текущего HTTP-запроса уже содержит маркер сеанса anti-XSRF (файл cookie защиты от XSRF \_ \_RequestVerificationToken), маркер безопасности извлекается из него. Если HTTP-запроса не содержит маркер сеанса anti-XSRF или извлечение маркера безопасности завершается ошибкой, будет создан новый маркер случайных anti-XSRF.
2. Маркер защиты от XSRF поле создается с помощью токена безопасности из шага (1) выше и удостоверение текущего пользователя, вошедшего в систему. (Дополнительные сведения об определении удостоверение пользователя, см. в разделе **[сценариев со специальной поддержкой](#_Scenarios_with_special)** разделе ниже.) Кроме того Если [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) является настроена, среда выполнения вызовет его [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) метод и включить в маркер поля возвращаемой строки. (См. в разделе **[конфигурации и расширяемость](#_Configuration_and_extensibility)** Дополнительные сведения.)
3. Если нового маркера anti-XSRF, созданный на шаге (1), новый маркер сеанса для него будет создан и добавляется к коллекции файлов cookie исходящего трафика HTTP. Поле маркера, полученного на шаге (2) будет преобразовано в `<input type="hidden" />` элемент и эта разметка HTML будет возвращаемое значение `Html.AntiForgeryToken()` или `AntiForgery.GetHtml()`.

## <a name="validating-the-tokens"></a>Проверка маркеров

Для проверки входящих маркеров защиты от XSRF, включает разработчик [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) атрибут на ее действие MVC, контроллер или она вызывает `@AntiForgery.Validate()` со своей страницы Razor. Среда выполнения будет выполнять следующие действия:

1. Токен входящего сеанса и маркер поля доступны для чтения, и эти маркера anti-XSRF из каждого. Маркеры защиты от XSRF должны быть одинаковыми на каждом шаге (2) в процедуре создания.
2. Если текущий пользователь прошел проверку подлинности, ее имя пользователя сравнивается с именем пользователя, хранящихся в маркере поля. Имена пользователей должны совпадать.
3. Если [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) настроена, среда выполнения вызывает его *ValidateAdditionalData* метод. Метод должен возвращать логическое значение *true*.

Если проверка прошла успешно, запрос может продолжить. Если проверка не пройдена, .NET framework генерирует исключение *HttpAntiForgeryException*.

## <a name="failure-conditions"></a>Условия сбоя

Начиная с версии 2 среды выполнения ASP.NET Web стека, любое *HttpAntiForgeryException* , создаваемое во время проверки будет содержать подробные сведения о причинах сбоя. В настоящее время определены сбоев являются:

- В запросе отсутствует маркер сеанса или маркера формы.
- Токен сеанса или маркера формы не может быть прочитан. Наиболее вероятной причиной этого является несовпадение версий среды выполнения ASP.NET Web стека или фермы с балансированием где &lt;machineKey&gt; элемент в файле Web.config, отличается между компьютерами. Можно использовать такой инструмент, как Fiddler принудительно это исключение путем подделки либо маркера anti-XSRF.
- Перепутаны маркер сеанса и маркер поля.
- Маркер сеанса и маркер поля содержат несоответствия безопасности токены.
- Имя пользователя, внедренные в маркер поля не соответствует имени пользователя текущего вошедшего в систему пользователя.
- *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* возвращаемое значение метода *false*.

Средства защиты от XSRF также могут выполнять дополнительную проверку во время создания токенов или проверки и сбоев, эти проверки может привести к созданию исключений. См. в разделе [WIF и ACS / заявок проверки подлинности](#_WIF_ACS) и **[конфигурации и расширяемость](#_Configuration_and_extensibility)** разделах содержатся дополнительные сведения.

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a>Сценарии со специальной поддержкой

### <a name="anonymous-authentication"></a>Анонимная проверка подлинности

Система защиты от XSRF содержит специальную поддержку для анонимных пользователей, где «anonymous» определяется как пользователь где *IIdentity.IsAuthenticated* возвращает *false*. Сценарии включают в себя предоставление защиты XSRF на страницу входа (до проверки подлинности пользователя) и пользовательских схем проверки подлинности где приложение использует механизм, отличное от *IIdentity* для идентификации пользователей.

Для поддержки следующих сценариев, помните, что маркеры сеанса и поле соединяются с маркер безопасности, — это 128-разрядный созданный случайным образом непрозрачный идентификатор. Этот маркер безопасности используется для отслеживания сеанса отдельного пользователя, так как она перешла сайта, чтобы эффективно служит анонимного идентификатора. Вместо имени пользователя для описанных выше процедур создания и проверки используется пустая строка.

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a>WIF и ACS / заявок проверки подлинности

Как правило *IIdentity* классы, встроенный в .NET Framework имеют свойства, *IIdentity.Name* достаточно для уникальной идентификации конкретного пользователя в определенном приложении. Например *FormsIdentity.Name* возвращает имя пользователя, хранящиеся в базе данных членства (который является уникальным для всех приложений в зависимости от этой базы данных), *WindowsIdentity.Name* возвращает с указанием домена удостоверение пользователя, и т. д. Эти системы позволяют не только проверку подлинности; они также *идентификации* пользователей для приложения.

Проверка подлинности на основе утверждений, с другой стороны, не обязательно выделять идентификации конкретного пользователя. Вместо этого *ClaimsPrincipal* и *ClaimsIdentity* типы связаны с набором *утверждения* экземпляров, в которых отдельные утверждения может быть «— 18 + лет» или " является администратором» на что-нибудь еще. Так как пользователь еще не обязательно определения среда выполнения не может использовать *ClaimsIdentity.Name* свойство в качестве уникального идентификатора для данного пользователя. Команда видел примеры из реальной жизни где *ClaimsIdentity.Name* возвращает *null*, возвращает имя, понятное (экран) или в противном случае возвращает строку, которая не подходит для использования в качестве уникального идентификатора для пользователя.

Многие из развертываний, которые используют проверку подлинности на основе утверждений при использовании [службы контроля доступа Azure](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) в частности. ACS позволяет разработчику настроить отдельные *поставщиков удостоверений* (такие как ADFS, поставщик учетной записи Майкрософт, поставщиков OpenID, например Yahoo!, т. д.), и Поставщики удостоверений, которые возвращают *имя идентификаторы*. Эти идентификаторы имя может содержать личные сведения (PII), адреса электронной почты, или они могут анонимного как частный личный идентификатор (PPID). В любом случае кортежа (поставщик удостоверений, идентификатора имени) достаточно играет роль на соответствующие отслеживания маркер для определенного пользователя, а она просматривает сайт, чтобы среда выполнения ASP.NET Web стека можно было использовать кортеж вместо имени пользователя при создании и Проверка маркеров защиты от XSRF поля. Определенный URI для поставщика удостоверений и идентификатор имени являются:

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

(см. в разделе, это [ACS странице doc](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) Дополнительные сведения.)

При создании или проверке токена, среда выполнения ASP.NET Web стека во время выполнения попытается привязки к типам:

- `Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (Для пакета SDK WIF.)
- `System.Security.Claims.ClaimsIdentity` (Для .NET 4.5).

Если эти типы и в том случае, если текущий пользователь *IIIIdentity* реализует или подклассы один из этих типов, будет использовать средство защиты от XSRF (поставщик удостоверений, идентификатора имени) кортежей вместо имени пользователя, при создании и проверки маркеров. Если нет таких кортежей, запрос будет завершаться ошибкой описания для разработчика, как настроить систему защиты от XSRF, чтобы узнать используемый механизм определенной проверки подлинности на основе утверждений. См. в разделе **[конфигурации и расширяемость](#_Configuration_and_extensibility)** Дополнительные сведения.

### <a name="oauth--openid-authentication"></a>OAuth или OpenID проверки подлинности

Наконец средство защиты от XSRF имеет специальную поддержку для приложения, которые используют проверку подлинности OAuth или OpenID. Эта поддержка основана на эвристике: если текущий *IIdentity.Name* начинается с http:// или https://, а затем выполняется сравнение имени пользователя с помощью компаратор порядкового номера, а не функцию сравнения по умолчанию OrdinalIgnoreCase.

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a>Расширяемость и настройка

В некоторых случаях разработчикам может потребоваться более строгий контроль над созданием anti-XSRF и проверки поведения. Например может быть нежелательно MVC и веб-страниц помощники по умолчанию автоматически добавляя файлы cookie HTTP в ответ, и разработчик может потребоваться сохранить маркеры в другом месте. Существует два API для помощи с этим:

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

*GetTokens* метод принимает в качестве входных существующих XSRF запрос проверки маркер сеанса (которое может иметь значение null) и создает как выходной новый маркер сеанса проверки XSRF запроса и маркер поля. Маркеры — это просто непрозрачный строки без оформления; *formToken* значение для экземпляра не помещаются в &lt;входной&gt; тега. *NewCookieToken* может иметь значение null; Если это происходит, то *oldCookieToken* по-прежнему допустимо значение и не cookie нового отклика необходимо установить. Объект, вызывающий *GetTokens* отвечает за сохранение всех файлов cookie ответа необходимо либо создает все необходимые средства разметки; *GetTokens* сам метод никак не изменит ответа в качестве побочного эффекта. *Validate* метод принимает входящий сеанс, а поле маркеры и запускает логику проверки, упомянутых выше над ними.

### <a name="antiforgeryconfig"></a>AntiForgeryConfig

Разработчик может настроить систему защиты от XSRF из приложения\_запуска. Конфигурация — программный. Свойства статического *AntiForgeryConfig* тип описаны ниже. Большинству пользователей, с помощью утверждений потребуется установить свойство UniqueClaimTypeIdentifier.

| **Свойство** | **Описание** |
| --- | --- |
| **AdditionalDataProvider** | [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , предоставляющий дополнительные данные во время создания токенов и использует дополнительные данные во время проверки маркера. Значение по умолчанию — *null*. Дополнительные сведения см. в разделе [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) раздел. |
| **CookieName** | Строка, которая предоставляет имя файла cookie HTTP, который используется для хранения маркера anti-XSRF сеанса. Если это значение не задано, имя создается автоматически на основе приложения развернутого виртуального пути. Значение по умолчанию — *null*. |
| **RequireSsl** | Логическое значение, который определяет, являются ли маркеры защиты от XSRF должны предоставляться через канал SSL-защитой. Если это значение равно *true*, все файлы cookie, автоматически создаваемые будет установлен флаг «безопасность», и API-интерфейсы защиты от XSRF вызывает исключение при вызове из внутри запроса, не переданных через SSL. Значение по умолчанию — *false*. |
| **SuppressIdentityHeuristicChecks** | Значение типа Boolean, определяет ли система защиты от XSRF следует отключить поддержку удостоверения на основе утверждений. Если это значение равно *true*, система предполагается, что *IIdentity.Name* подходит для использования в качестве идентификатора уникального пользователя и не будет предпринимать попытку особой *IClaimsIdentity*или *ClClaimsIdentity* как описано в разделе [WIF и ACS / заявок проверки подлинности](#_WIF_ACS) раздел. Значение по умолчанию — `false`. |
| **UniqueClaimTypeIdentifier** | Строка, указывающая, какие утверждения введите подходит для использования в качестве идентификатора уникального пользователя. Если это значение равно set и текущий *IIdentity* заявок, система будет пытаться извлечь утверждение типа определяется *UniqueClaimTypeIdentifier*, и соответствующее значение будет использоваться вместо имени пользователя при создании маркер поля. Если тип утверждения не найден, система отклонит запрос. Значение по умолчанию — *null*, который указывает, что система должен использовать (поставщик удостоверений, идентификатора имени) кортежа, как описано выше вместо имени пользователя. |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a>IAntiForgeryAdditionalDataProvider

*[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* типа позволяет разработчикам расширять поведение системы защиты от XSRF, циклической обработки дополнительных данных в каждом маркере. *GetAdditionalData* метод вызывается каждый раз создается маркер поля, и возвращаемое значение внедрены в созданный маркер. Разработчик может вернуть метку времени, nonce или любое другое значение, которые она намерена из этого метода.

Аналогичным образом *ValidateAdditionalData* метод вызывается каждый раз проверяется маркер поля, и строка «дополнительные данные», внедренные в маркер передается в метод. Процедуры проверки удалось реализации времени ожидания (путем проверки текущее время от времени, которое было сохранено при создании маркера), проверка подпрограммы, или любой другой nonce требуемыми логики.

## <a name="design-decisions-and-security-considerations"></a>Проектные решения и рекомендации по безопасности

Токен безопасности, который связывает маркеров сеанса и поля требуется технически только при попытке защитить анонимный / не прошедших проверку подлинности пользователей от XSRF-атак. При проверке подлинности пользователя, маркер проверки подлинности (которые можно отправить в виде файла cookie) можно использовать в качестве одной половине синхронизатор token пары. Тем не менее существуют верные сценарии для защиты страниц входа, сбора, не прошедших проверку пользователей и защиты от XSRF логику было упростить всегда формирования и проверки маркера безопасности, даже для прошедших проверку пользователей. Он также предоставляет некоторую дополнительную защиту в случае, если маркер поля будет скомпрометирован злоумышленником, как установка или подбор маркера сеанса будет другая проблема злоумышленнику преодолеть.

Разработчикам следует проявлять осторожность, когда несколько приложений размещаются в одном домене. Например несмотря на то что *example1.cloudapp.net* и *example2.cloudapp.net* находятся на разных узлах, есть неявные доверительные отношения между всеми узлами в группе  *\*. cloudapp.net* домена. Неявные доверительные отношения с этой [позволяет потенциально небезопасных узлам влияет на файлы cookie друг друга](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (политики одного источника, определяющие запросов AJAX не иметь отношения к файлам cookie HTTP). Среда выполнения ASP.NET Web стека предоставляет исправления в том, что имя пользователя, внедряется в токен поля, даже если вредоносный поддомен возможность перезаписывать токена сеанса он не сможет создать маркер допустимого поля для пользователя. Тем не менее при размещении в такой среде подпрограммы встроенной защиты от XSRF по-прежнему не удается защиту от перехвата сеанса или имя входа XSRF.

Процедуры защиты от XSRF в настоящее время не защиту от [кликджекинга](https://www.owasp.org/index.php/Clickjacking). Приложения, которым необходимо защищать себя от кликджекинга может легко сделать, отправив X-Frame-Options: Заголовок SAMEORIGIN с каждым ответом. Этот заголовок поддерживает все последние браузеры. Дополнительные сведения см. в разделе [блоге IE](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), [блоге SDL](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), и [OWASP](https://www.owasp.org/index.php/Clickjacking). Среда выполнения ASP.NET Web стека может в некоторых будущем выпуске убедитесь MVC и вспомогательные функции защиты от XSRF веб-страниц автоматически задается этот заголовок приложения будут автоматически защищены от этой атаки.

Веб-разработчики должны продолжать их узел не уязвима для атак XSS. Атаки XSS являются очень мощным средством и успешной атаке также нарушит среды выполнения ASP.NET Web стека способы защиты от XSRF-атак.

## <a name="acknowledgment"></a>Подтверждение

[@LeviBroderick](https://twitter.com/LeviBroderick), кто написал много кодов безопасности ASP.NET основная часть этой информации.
