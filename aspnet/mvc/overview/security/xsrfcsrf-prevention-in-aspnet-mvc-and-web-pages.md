---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: Предотвращение XSRF/CSRF в ASP.NET MVC и веб-страницах | Документация Майкрософт
author: Rick-Anderson
description: Подделка межсайтовых запросов (также известная как XSRF или CSRF) — это атака на веб-приложения, в результате чего вредоносный веб-узел может повлиять на интеракти...
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 1965063a9b613d0e2857cddcc2165f5fda64ec0c
ms.sourcegitcommit: 7709c0a091b8d55b7b33bad8849f7b66b23c3d72
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/19/2020
ms.locfileid: "77455533"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="bb78b-103">Предотвращение атак XSRF и CSRF в ASP.NET MVC и на веб-страницах</span><span class="sxs-lookup"><span data-stu-id="bb78b-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="bb78b-104">по [Рик Андерсон (](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="bb78b-104">by [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

> <span data-ttu-id="bb78b-105">Подделка межсайтовых запросов (также известная как XSRF или CSRF) — это атака на веб-приложения, с помощью которых вредоносный веб-узел может повлиять на взаимодействие между браузером клиента и веб-сайтом, которому доверяет этот браузер.</span><span class="sxs-lookup"><span data-stu-id="bb78b-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="bb78b-106">Эти атаки становятся возможными, так как веб-браузеры автоматически отправляют маркеры проверки подлинности при каждом запросе к веб-сайту.</span><span class="sxs-lookup"><span data-stu-id="bb78b-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="bb78b-107">Типичный пример – файл cookie для проверки подлинности, например билет проверки форм ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="bb78b-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="bb78b-108">Однако веб-сайты, использующие любой постоянный механизм проверки подлинности (например, проверку подлинности Windows, базовый и т. д.), могут быть нацелены на эти атаки.</span><span class="sxs-lookup"><span data-stu-id="bb78b-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="bb78b-109">Атака XSRF отличается от фишинговой атаки.</span><span class="sxs-lookup"><span data-stu-id="bb78b-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="bb78b-110">При проведении фишинговой атаки требуется взаимодействие пользователя.</span><span class="sxs-lookup"><span data-stu-id="bb78b-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="bb78b-111">При атаке с фишингом вредоносный веб-узел имитирует целевой веб-узел, и жертва обманным путем является предоставление злоумышленнику конфиденциальной информации.</span><span class="sxs-lookup"><span data-stu-id="bb78b-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="bb78b-112">При атаке XSRF очень часто никаких действий со стороны жертвы не требуется.</span><span class="sxs-lookup"><span data-stu-id="bb78b-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="bb78b-113">Скорее, злоумышленник полагается на то, что браузер автоматически отправляет все соответствующие файлы cookie на конечный веб-сайт.</span><span class="sxs-lookup"><span data-stu-id="bb78b-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="bb78b-114">Дополнительные сведения см. в статье [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span><span class="sxs-lookup"><span data-stu-id="bb78b-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>

## <a name="anatomy-of-an-attack"></a><span data-ttu-id="bb78b-115">Анатомия атаки</span><span class="sxs-lookup"><span data-stu-id="bb78b-115">Anatomy of an attack</span></span>

<span data-ttu-id="bb78b-116">Чтобы проанализировать атаку XSRF, рассмотрим пользователя, который хочет выполнить некоторые банковские транзакции в сети.</span><span class="sxs-lookup"><span data-stu-id="bb78b-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="bb78b-117">Этот пользователь сначала посещает WoodgroveBank.com и входит в систему. в этом случае заголовок ответа будет содержать файл cookie проверки подлинности:</span><span class="sxs-lookup"><span data-stu-id="bb78b-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="bb78b-118">Так как файл cookie для проверки подлинности является файлом cookie сеанса, он автоматически удаляется браузером при выходе из процесса браузера.</span><span class="sxs-lookup"><span data-stu-id="bb78b-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="bb78b-119">Однако до этого времени браузер автоматически включит файл cookie с каждым запросом в WoodgroveBank.com.</span><span class="sxs-lookup"><span data-stu-id="bb78b-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="bb78b-120">Теперь пользователь хочет переместить $1000 в другую учетную запись, поэтому он заполняет форму на банковском сайте, а браузер выполняет этот запрос к серверу:</span><span class="sxs-lookup"><span data-stu-id="bb78b-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="bb78b-121">Так как эта операция имеет побочный результат (она инициирует денежную транзакцию), на веб-узле банка выбрано требование HTTP POST для запуска этой операции.</span><span class="sxs-lookup"><span data-stu-id="bb78b-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="bb78b-122">Сервер считывает маркер проверки подлинности из запроса, ищет номер учетной записи текущего пользователя, проверяет наличие достаточного количества фондов, а затем инициирует транзакцию в целевой учетной записи.</span><span class="sxs-lookup"><span data-stu-id="bb78b-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="bb78b-123">Его интерактивный банк завершен, пользователь выходит с веб-узла банка и посещает другие расположения в Интернете.</span><span class="sxs-lookup"><span data-stu-id="bb78b-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="bb78b-124">Один из этих сайтов — fabrikam.com — включает следующую разметку на странице, внедренной в &lt;IFRAME&gt;:</span><span class="sxs-lookup"><span data-stu-id="bb78b-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="bb78b-125">После чего браузер сделает запрос:</span><span class="sxs-lookup"><span data-stu-id="bb78b-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="bb78b-126">Злоумышленник может использовать тот факт, что у пользователя по-прежнему есть действительный маркер проверки подлинности для целевого веб-сайта, и он использует небольшой фрагмент кода JavaScript, чтобы браузер мог автоматически выполнить HTTP-запрос POST к целевому сайту.</span><span class="sxs-lookup"><span data-stu-id="bb78b-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="bb78b-127">Если маркер проверки подлинности по-прежнему действителен, банковский сайт запустит перенос $250 в учетную запись, выбираемую злоумышленником.</span><span class="sxs-lookup"><span data-stu-id="bb78b-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="bb78b-128">Неэффективное устранение рисков</span><span class="sxs-lookup"><span data-stu-id="bb78b-128">Ineffective mitigations</span></span>

<span data-ttu-id="bb78b-129">Интересно отметить, что в приведенном выше сценарии тот факт, что доступ к WoodgroveBank.com осуществлялся по протоколу SSL и имел недостаточный файл cookie для проверки подлинности с использованием протокола SSL, чтобы предотвратить атаку.</span><span class="sxs-lookup"><span data-stu-id="bb78b-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="bb78b-130">Злоумышленник может указать [схему универсального кода ресурса (URI](http://en.wikipedia.org/wiki/URI_scheme) ) в своей &lt;форме&gt;, и браузер продолжит отсылать файлы cookie с истекшим сроком действия на целевой сайт, если эти файлы cookie согласованы с схемой URI предполагаемой цели.</span><span class="sxs-lookup"><span data-stu-id="bb78b-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="bb78b-131">Можно сказать, что пользователь должен просто не посетить недоверенные сайты, так как посещение только надежных сайтов поможет сохранить безопасность в сети.</span><span class="sxs-lookup"><span data-stu-id="bb78b-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="bb78b-132">В этом нет смысла, но к сожалению, этот Совет не всегда практичен.</span><span class="sxs-lookup"><span data-stu-id="bb78b-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="bb78b-133">Возможно, пользователь «доверяет» локальным веб-сайтам новостей Консолидатедмессенжер.</span><span class="sxs-lookup"><span data-stu-id="bb78b-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="bb78b-134">ConsolidatedMessenger.com и переходит на этот сайт, но на этом сайте есть уязвимость XSS, которая позволяет злоумышленнику внедрить тот же фрагмент кода, который был запущен в fabrikam.com.</span><span class="sxs-lookup"><span data-stu-id="bb78b-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="bb78b-135">Можно проверить, что входящие запросы имеют [заголовок ссылки](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) , ссылающийся на ваш домен.</span><span class="sxs-lookup"><span data-stu-id="bb78b-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="bb78b-136">Это приведет к отмене запросов, непреднамеренно отправленных из стороннего домена.</span><span class="sxs-lookup"><span data-stu-id="bb78b-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="bb78b-137">Тем не менее некоторые пользователи отключают заголовок ссылки в браузере в соответствии с соображениями конфиденциальности, и злоумышленники иногда могут подменить этот заголовок, если в жертве установлено небезопасное программное обеспечение.</span><span class="sxs-lookup"><span data-stu-id="bb78b-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="bb78b-138">Проверка того, что [заголовок ссылки](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) не считается безопасным способом предотвращения атак XSRF.</span><span class="sxs-lookup"><span data-stu-id="bb78b-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="bb78b-139">Устранение рисков XSRF среды выполнения веб-стека</span><span class="sxs-lookup"><span data-stu-id="bb78b-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="bb78b-140">Среда выполнения веб-стека ASP.NET использует вариант [шаблона токена синхронизатора](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) для защиты от атак XSRF.</span><span class="sxs-lookup"><span data-stu-id="bb78b-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="bb78b-141">Общая форма шаблона токена синхронизатора состоит в том, что два XSRF токена передаются на сервер с каждым HTTP-запросом POST (в дополнение к маркеру проверки подлинности): один маркер в качестве файла cookie, а другой — как значение формы.</span><span class="sxs-lookup"><span data-stu-id="bb78b-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="bb78b-142">Значения токенов, созданные средой выполнения ASP.NET, не являются детерминированными или прогнозируемыми для злоумышленника.</span><span class="sxs-lookup"><span data-stu-id="bb78b-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="bb78b-143">При отправке маркеров сервер разрешает выполнение запроса, только если оба токена прошли проверку на равенство.</span><span class="sxs-lookup"><span data-stu-id="bb78b-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="bb78b-144">*Токен сеанса* проверки запроса XSRF хранится как файл cookie HTTP и в настоящее время содержит следующую информацию в полезных данных:</span><span class="sxs-lookup"><span data-stu-id="bb78b-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="bb78b-145">Маркер безопасности, состоящий из случайного 128-битного идентификатора.</span><span class="sxs-lookup"><span data-stu-id="bb78b-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="bb78b-146">На следующем рисунке показан маркер сеанса проверки запроса XSRF, отображаемый в средствах разработчика F12 для Internet Explorer: (Обратите внимание, что это текущая реализация, которая, скорее всего, будет изменена.)</span><span class="sxs-lookup"><span data-stu-id="bb78b-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="bb78b-147">*Маркер поля* хранится в виде `<input type="hidden" />` и содержит следующие сведения в полезных данных:</span><span class="sxs-lookup"><span data-stu-id="bb78b-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="bb78b-148">Имя пользователя, вошедшего в систему (если прошло проверку подлинности).</span><span class="sxs-lookup"><span data-stu-id="bb78b-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="bb78b-149">Дополнительные данные, предоставляемые [иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span><span class="sxs-lookup"><span data-stu-id="bb78b-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="bb78b-150">Полезные данные токенов XSRF шифруются и подписываются, поэтому вы не сможете просмотреть имя пользователя при использовании средств для проверки маркеров.</span><span class="sxs-lookup"><span data-stu-id="bb78b-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="bb78b-151">Если веб-приложение предназначено для ASP.NET 4,0, службы шифрования предоставляются подпрограммыми [machineKey. Encoded](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) .</span><span class="sxs-lookup"><span data-stu-id="bb78b-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="bb78b-152">Если веб-приложение предназначено для ASP.NET 4,5 или более поздней версии, службы шифрования предоставляются подсистемой [machineKey. Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) , которая обеспечивает лучшую производительность, расширяемость и безопасность.</span><span class="sxs-lookup"><span data-stu-id="bb78b-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="bb78b-153">Дополнительные сведения см. в следующих записях блога:</span><span class="sxs-lookup"><span data-stu-id="bb78b-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="bb78b-154">Улучшения шифрования в ASP.NET 4,5, PT. 1</span><span class="sxs-lookup"><span data-stu-id="bb78b-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="bb78b-155">Улучшения шифрования в ASP.NET 4,5, PT. 2</span><span class="sxs-lookup"><span data-stu-id="bb78b-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="bb78b-156">Улучшения шифрования в ASP.NET 4,5, PT. 3</span><span class="sxs-lookup"><span data-stu-id="bb78b-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="bb78b-157">Создание маркеров</span><span class="sxs-lookup"><span data-stu-id="bb78b-157">Generating the tokens</span></span>

<span data-ttu-id="bb78b-158">Чтобы создать маркеры XSRF, вызовите метод [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) из представления MVC или @AntiForgery.GetHtml() из страницы Razor.</span><span class="sxs-lookup"><span data-stu-id="bb78b-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="bb78b-159">Затем среда выполнения выполнит следующие действия:</span><span class="sxs-lookup"><span data-stu-id="bb78b-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="bb78b-160">Если текущий HTTP-запрос уже содержит токен сеанса Anti-XSRF (\_\_XSRF Рекуестверификатионтокен), маркер безопасности извлекается из него.</span><span class="sxs-lookup"><span data-stu-id="bb78b-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="bb78b-161">Если HTTP-запрос не содержит токен сеанса Anti-XSRF или если не удается извлечь маркер безопасности, будет создан новый случайный токен Anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="bb78b-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="bb78b-162">Токен поля Anti-XSRF создается с использованием маркера безопасности из шага (1) выше и идентификатора текущего вошедшего в систему пользователя.</span><span class="sxs-lookup"><span data-stu-id="bb78b-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="bb78b-163">(Дополнительные сведения об определении удостоверения пользователя см. в разделе **[сценарии с поддержкой специальных возможностей](#_Scenarios_with_special)** ниже.) Кроме того, если настроена [иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) , среда выполнения вызывает свой метод [жетаддитионалдата](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) и включает возвращенную строку в маркер поля.</span><span class="sxs-lookup"><span data-stu-id="bb78b-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="bb78b-164">(Дополнительные сведения см. в разделе о **[конфигурации и расширяемости](#_Configuration_and_extensibility)** .)</span><span class="sxs-lookup"><span data-stu-id="bb78b-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="bb78b-165">Если на шаге (1) был создан новый токен Anti-XSRF, будет создан новый маркер сеанса, содержащий его, который будет добавлен в коллекцию исходящих файлов cookie HTTP.</span><span class="sxs-lookup"><span data-stu-id="bb78b-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="bb78b-166">Маркер поля из шага (2) будет заключен в элемент `<input type="hidden" />`, а эта разметка HTML будет возвращаемым значением `Html.AntiForgeryToken()` или `AntiForgery.GetHtml()`.</span><span class="sxs-lookup"><span data-stu-id="bb78b-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="bb78b-167">Проверка токенов</span><span class="sxs-lookup"><span data-stu-id="bb78b-167">Validating the tokens</span></span>

<span data-ttu-id="bb78b-168">Чтобы проверить входящие маркеры XSRF, разработчик включает атрибут [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) на своем действии или контроллере MVC или вызывает `@AntiForgery.Validate()` на странице Razor.</span><span class="sxs-lookup"><span data-stu-id="bb78b-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="bb78b-169">Среда выполнения выполнит следующие действия:</span><span class="sxs-lookup"><span data-stu-id="bb78b-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="bb78b-170">Выполняется чтение токена входящего сеанса и маркера поля, который извлекается из каждого токена XSRF.</span><span class="sxs-lookup"><span data-stu-id="bb78b-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="bb78b-171">Токены Anti-XSRF должны быть идентичными на шаге (2) в подпрограмме создания.</span><span class="sxs-lookup"><span data-stu-id="bb78b-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="bb78b-172">Если текущий пользователь прошел проверку подлинности, его имя пользователя сравнивается с именем пользователя, хранящимся в маркере поля.</span><span class="sxs-lookup"><span data-stu-id="bb78b-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="bb78b-173">Имена пользователей должны совпадать.</span><span class="sxs-lookup"><span data-stu-id="bb78b-173">The usernames must match.</span></span>
3. <span data-ttu-id="bb78b-174">Если настроена [иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , среда выполнения вызывает метод *валидатеаддитионалдата* .</span><span class="sxs-lookup"><span data-stu-id="bb78b-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="bb78b-175">Метод должен возвращать логическое значение *true*.</span><span class="sxs-lookup"><span data-stu-id="bb78b-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="bb78b-176">Если проверка прошла, запрос может продолжаться.</span><span class="sxs-lookup"><span data-stu-id="bb78b-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="bb78b-177">Если проверка завершается неудачно, платформа выдает исключение *хттпантифоржерексцептион*.</span><span class="sxs-lookup"><span data-stu-id="bb78b-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="bb78b-178">Условия сбоя</span><span class="sxs-lookup"><span data-stu-id="bb78b-178">Failure conditions</span></span>

<span data-ttu-id="bb78b-179">Начиная с среды выполнения веб-стека ASP.NET версии 2, любые *хттпантифоржерексцептион* , созданные во время проверки, будут содержать подробные сведения о том, что пошло не так.</span><span class="sxs-lookup"><span data-stu-id="bb78b-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="bb78b-180">В настоящее время определены следующие условия сбоя:</span><span class="sxs-lookup"><span data-stu-id="bb78b-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="bb78b-181">Маркер сеанса или маркер формы отсутствует в запросе.</span><span class="sxs-lookup"><span data-stu-id="bb78b-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="bb78b-182">Маркер сеанса или формы не читается.</span><span class="sxs-lookup"><span data-stu-id="bb78b-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="bb78b-183">Наиболее вероятной причиной этого является ферма, выполняющая несовпадающие версии среды выполнения веб-стека ASP.NET или фермы, в которой элемент &lt;machineKey&gt; в файле Web. config отличается между компьютерами.</span><span class="sxs-lookup"><span data-stu-id="bb78b-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="bb78b-184">Для принудительного применения этого исключения можно использовать такой инструмент, как Fiddler, с помощью токена Anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="bb78b-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="bb78b-185">Маркер сеанса и маркер поля были переключены.</span><span class="sxs-lookup"><span data-stu-id="bb78b-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="bb78b-186">Маркер сеанса и маркер поля содержат несовпадающие маркеры безопасности.</span><span class="sxs-lookup"><span data-stu-id="bb78b-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="bb78b-187">Имя пользователя, внедренное в маркер поля, не соответствует имени пользователя текущего вошедшего в систему пользователя.</span><span class="sxs-lookup"><span data-stu-id="bb78b-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="bb78b-188">Метод *[иантифоржеряддитионалдатапровидер. валидатеаддитионалдата](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* вернул *значение false*.</span><span class="sxs-lookup"><span data-stu-id="bb78b-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="bb78b-189">Средства защиты от XSRF также могут выполнять дополнительную проверку во время создания или проверки маркера, а сбои во время этих проверок могут привести к возникновению исключений.</span><span class="sxs-lookup"><span data-stu-id="bb78b-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="bb78b-190">Дополнительные сведения см. в разделах [WIF/ACS/проверка подлинности](#_WIF_ACS) и **[Конфигурация и расширяемость](#_Configuration_and_extensibility)** на основе утверждений.</span><span class="sxs-lookup"><span data-stu-id="bb78b-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="bb78b-191">Сценарии с специальной поддержкой</span><span class="sxs-lookup"><span data-stu-id="bb78b-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="bb78b-192">анонимная аутентификация;</span><span class="sxs-lookup"><span data-stu-id="bb78b-192">Anonymous authentication</span></span>

<span data-ttu-id="bb78b-193">Система защиты от XSRF содержит специальную поддержку для анонимных пользователей, где "Anonymous" определяется как пользователь, где свойство *IIdentity. Authenticator* возвращает *значение false*.</span><span class="sxs-lookup"><span data-stu-id="bb78b-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="bb78b-194">Сценарии включают в себя предоставление защиты XSRF для страницы входа (перед проверкой подлинности пользователя) и пользовательские схемы проверки подлинности, в которых приложение использует механизм, отличный от *IIdentity* , для идентификации пользователей.</span><span class="sxs-lookup"><span data-stu-id="bb78b-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="bb78b-195">Чтобы реализовать эти сценарии, обратите внимание, что маркеры сеанса и поля соединены маркером безопасности, который представляет собой 128-разрядный случайный непрозрачный идентификатор.</span><span class="sxs-lookup"><span data-stu-id="bb78b-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="bb78b-196">Этот маркер безопасности используется для наблюдения за сеансом отдельного пользователя при переходе на сайт, чтобы он эффективно использовал анонимный идентификатор.</span><span class="sxs-lookup"><span data-stu-id="bb78b-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="bb78b-197">Вместо имени пользователя для подпрограмм создания и проверки, описанных выше, используется пустая строка.</span><span class="sxs-lookup"><span data-stu-id="bb78b-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="bb78b-198">WIF, ACS и аутентификация на основе утверждений</span><span class="sxs-lookup"><span data-stu-id="bb78b-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="bb78b-199">Как правило, классы *IIdentity* , встроенные в .NET Framework, имеют свойство, которое *IIdentity.Name* достаточно для уникальной идентификации конкретного пользователя в определенном приложении.</span><span class="sxs-lookup"><span data-stu-id="bb78b-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="bb78b-200">Например, *FormsIdentity.Name* возвращает имя пользователя, хранящееся в базе данных членства (уникальное для всех приложений в зависимости от этой базы данных), *WindowsIdentity.Name* возвращает доменное удостоверение пользователя и т. д.</span><span class="sxs-lookup"><span data-stu-id="bb78b-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="bb78b-201">Эти системы обеспечивают не только проверку подлинности; Они также *указывают* пользователей на приложение.</span><span class="sxs-lookup"><span data-stu-id="bb78b-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="bb78b-202">С другой стороны, проверка подлинности на основе утверждений не обязательно требует идентификации конкретного пользователя.</span><span class="sxs-lookup"><span data-stu-id="bb78b-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="bb78b-203">Вместо этого типы *ClaimsPrincipal* и *ClaimsIdentity* связаны с набором экземпляров *заявок* , в котором Индивидуальные утверждения могут иметь значение "более 18 лет возраста" или "является администратором".</span><span class="sxs-lookup"><span data-stu-id="bb78b-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="bb78b-204">Так как пользователь не был определен, среда выполнения не может использовать свойство *ClaimsIdentity.Name* в качестве уникального идентификатора для этого конкретного пользователя.</span><span class="sxs-lookup"><span data-stu-id="bb78b-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="bb78b-205">В реальных примерах команда *ClaimsIdentity.Name* возвращает *значение NULL*, возвращает понятное (отображаемое) имя или, в противном случае, возвращает строку, которая не подходит для использования в качестве уникального идентификатора для пользователя.</span><span class="sxs-lookup"><span data-stu-id="bb78b-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="bb78b-206">Многие из развертываний, использующих проверку подлинности на основе утверждений, в частности используют [службу контроля доступа Azure](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS).</span><span class="sxs-lookup"><span data-stu-id="bb78b-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="bb78b-207">ACS позволяет разработчику настраивать отдельных *поставщиков удостоверений* (например, ADFS, поставщика учетных записей Майкрософт, поставщиков OpenID Connect, таких как Yahoo! и т. д.), а поставщики удостоверений возвращают *идентификаторы имен*.</span><span class="sxs-lookup"><span data-stu-id="bb78b-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="bb78b-208">Эти идентификаторы имен могут содержать личные сведения (PII), такие как адрес электронной почты, или анонимно, например частный личный идентификатор (PPID).</span><span class="sxs-lookup"><span data-stu-id="bb78b-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="bb78b-209">Независимо от этого, кортеж (поставщик удостоверений, идентификатор имени) достаточно подходит как соответствующий маркер отслеживания для конкретного пользователя, пока он выполняет просмотр сайта, поэтому среда выполнения веб-стека ASP.NET может использовать кортеж вместо имени пользователя при создании и Проверка маркеров поля Anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="bb78b-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="bb78b-210">Конкретные URI для поставщика удостоверений и идентификатор имени:</span><span class="sxs-lookup"><span data-stu-id="bb78b-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `https://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="bb78b-211">(Дополнительные сведения см. на [странице документации по ACS](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) .)</span><span class="sxs-lookup"><span data-stu-id="bb78b-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="bb78b-212">При создании или проверке маркера среда выполнения веб-стека ASP.NET будет выполнять привязку к типам:</span><span class="sxs-lookup"><span data-stu-id="bb78b-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="bb78b-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (для пакета SDK для WIF).</span><span class="sxs-lookup"><span data-stu-id="bb78b-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="bb78b-214">`System.Security.Claims.ClaimsIdentity` (для .NET 4,5).</span><span class="sxs-lookup"><span data-stu-id="bb78b-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="bb78b-215">Если эти типы существуют и если *иииидентити* текущего пользователя реализуют или подклассы одного из этих типов, при создании и проверке маркеров в средстве защиты от имени пользователя будет использоваться кортеж (поставщик удостоверений, идентификатор имени).</span><span class="sxs-lookup"><span data-stu-id="bb78b-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="bb78b-216">Если такого кортежа не существует, запрос завершится с ошибкой, описанной для разработчика как настроить систему XSRF, чтобы понять, какой механизм проверки подлинности на основе утверждений используется.</span><span class="sxs-lookup"><span data-stu-id="bb78b-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="bb78b-217">Дополнительные сведения см. в разделе **[Конфигурация и расширяемость](#_Configuration_and_extensibility)** .</span><span class="sxs-lookup"><span data-stu-id="bb78b-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="bb78b-218">Проверка подлинности OAuth/OpenID Connect</span><span class="sxs-lookup"><span data-stu-id="bb78b-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="bb78b-219">Наконец, средство борьбы-XSRF имеет специальную поддержку для приложений, использующих проверку подлинности OAuth или OpenID Connect.</span><span class="sxs-lookup"><span data-stu-id="bb78b-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="bb78b-220">Эта поддержка основана на эвристическом уровне: если текущая *IIdentity.Name* начинается с http://или HTTPS://, то сравнения имен пользователей будут выполняться с использованием компаратора порядковых номеров, а не компаратора OrdinalIgnoreCase по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="bb78b-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="bb78b-221">Конфигурация и расширяемость</span><span class="sxs-lookup"><span data-stu-id="bb78b-221">Configuration and extensibility</span></span>

<span data-ttu-id="bb78b-222">Иногда разработчикам может потребоваться более строгий контроль над поведением создания и проверки XSRF.</span><span class="sxs-lookup"><span data-stu-id="bb78b-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="bb78b-223">Например, поведение по умолчанию для вспомогательных функций MVC и веб-страниц автоматически добавляет cookie-файлы HTTP в ответ нежелательно, и разработчик может сохранить маркеры в любом расположении.</span><span class="sxs-lookup"><span data-stu-id="bb78b-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="bb78b-224">Существует два интерфейса API для помощи с этим:</span><span class="sxs-lookup"><span data-stu-id="bb78b-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="bb78b-225">Метод *WebMethod* принимает в качестве входных данных существующий токен сеанса проверки XSRF запроса (который может иметь значение null) и создает в качестве выходных данных новый токен сеанса проверки запроса XSRF и маркер поля.</span><span class="sxs-lookup"><span data-stu-id="bb78b-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="bb78b-226">Токены — это просто непрозрачные строки без декорирования. значение *формтокен* для экземпляра не будет упаковано во входной&gt; тег &lt;.</span><span class="sxs-lookup"><span data-stu-id="bb78b-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="bb78b-227">Значение *невкукиетокен* может быть равно null. в этом случае значение *олдкукиетокен* остается действительным, и не нужно задавать новый файл cookie ответа.</span><span class="sxs-lookup"><span data-stu-id="bb78b-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="bb78b-228">Вызывающий элемент *GetResponse отвечает за* сохранение всех необходимых файлов cookie ответа или создание необходимой разметки. сам *метод GetResponse* не изменит ответ как побочный результат.</span><span class="sxs-lookup"><span data-stu-id="bb78b-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="bb78b-229">Метод *Validate* принимает входящие маркеры сеанса и поля и выполняет вышеупомянутые логику проверки.</span><span class="sxs-lookup"><span data-stu-id="bb78b-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="bb78b-230">антифоржериконфиг</span><span class="sxs-lookup"><span data-stu-id="bb78b-230">AntiForgeryConfig</span></span>

<span data-ttu-id="bb78b-231">Разработчик может настроить XSRF систему из приложения\_запуска.</span><span class="sxs-lookup"><span data-stu-id="bb78b-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="bb78b-232">Конфигурация является программной.</span><span class="sxs-lookup"><span data-stu-id="bb78b-232">Configuration is programmatic.</span></span> <span data-ttu-id="bb78b-233">Ниже описаны свойства статического типа *антифоржериконфиг* .</span><span class="sxs-lookup"><span data-stu-id="bb78b-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="bb78b-234">Большинству пользователей, использующих утверждения, необходимо установить свойство Уникуеклаимтипеидентифиер.</span><span class="sxs-lookup"><span data-stu-id="bb78b-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="bb78b-235">**Свойство**</span><span class="sxs-lookup"><span data-stu-id="bb78b-235">**Property**</span></span> | <span data-ttu-id="bb78b-236">**Описание**</span><span class="sxs-lookup"><span data-stu-id="bb78b-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="bb78b-237">**аддитионалдатапровидер**</span><span class="sxs-lookup"><span data-stu-id="bb78b-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="bb78b-238">Объект [иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) , предоставляющий дополнительные данные во время формирования маркера и использующий дополнительные данные во время проверки маркера.</span><span class="sxs-lookup"><span data-stu-id="bb78b-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="bb78b-239">Значение по умолчанию — *NULL*.</span><span class="sxs-lookup"><span data-stu-id="bb78b-239">The default value is *null*.</span></span> <span data-ttu-id="bb78b-240">Дополнительные сведения см. в разделе [иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) .</span><span class="sxs-lookup"><span data-stu-id="bb78b-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="bb78b-241">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="bb78b-241">**CookieName**</span></span> | <span data-ttu-id="bb78b-242">Строка, которая предоставляет имя файла cookie HTTP, используемого для хранения токена сеанса Anti-XSRF.</span><span class="sxs-lookup"><span data-stu-id="bb78b-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="bb78b-243">Если это значение не задано, имя будет создано автоматически на основе развернутого виртуального пути приложения.</span><span class="sxs-lookup"><span data-stu-id="bb78b-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="bb78b-244">Значение по умолчанию — *NULL*.</span><span class="sxs-lookup"><span data-stu-id="bb78b-244">The default value is *null*.</span></span> |
| <span data-ttu-id="bb78b-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="bb78b-245">**RequireSsl**</span></span> | <span data-ttu-id="bb78b-246">Логическое значение, определяющее, должны ли маркеры защиты XSRF отправляться через канал, защищенный SSL.</span><span class="sxs-lookup"><span data-stu-id="bb78b-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="bb78b-247">Если это значение равно *true*, то во всех автоматически создаваемых файлах cookie будет установлен флаг "Secure", а API-интерфейсы XSRF будут вызываться из запроса, который не был отправлен через SSL.</span><span class="sxs-lookup"><span data-stu-id="bb78b-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="bb78b-248">Значение по умолчанию — *false*.</span><span class="sxs-lookup"><span data-stu-id="bb78b-248">The default value is *false*.</span></span> |
| <span data-ttu-id="bb78b-249">**суппрессидентитихеуристикчеккс**</span><span class="sxs-lookup"><span data-stu-id="bb78b-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="bb78b-250">Логическое значение, определяющее, должна ли система защиты от XSRF деактивировать поддержку удостоверений на основе утверждений.</span><span class="sxs-lookup"><span data-stu-id="bb78b-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="bb78b-251">Если это значение равно *true*, система считает, что *IIdentity.Name* подходит для использования в качестве уникального идентификатора для каждого пользователя, и не будет пытаться использовать особый регистр *IClaimsIdentity* или *клклаимсидентити* , как описано в разделе " [Проверка подлинности на основе WIF/ACS/claims-based](#_WIF_ACS) ".</span><span class="sxs-lookup"><span data-stu-id="bb78b-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="bb78b-252">Значение по умолчанию — `false`.</span><span class="sxs-lookup"><span data-stu-id="bb78b-252">The default value is `false`.</span></span> |
| <span data-ttu-id="bb78b-253">**уникуеклаимтипеидентифиер**</span><span class="sxs-lookup"><span data-stu-id="bb78b-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="bb78b-254">Строка, указывающая, какой тип утверждения подходит для использования в качестве уникального идентификатора для каждого пользователя.</span><span class="sxs-lookup"><span data-stu-id="bb78b-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="bb78b-255">Если это значение задано, а текущая *IIdentity* — на основе утверждений, система попытается извлечь утверждение типа, указанного параметром *уникуеклаимтипеидентифиер*, а соответствующее значение будет использоваться вместо имени пользователя при создании маркера поля.</span><span class="sxs-lookup"><span data-stu-id="bb78b-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="bb78b-256">Если тип утверждения не найден, система не сможет выполнить запрос.</span><span class="sxs-lookup"><span data-stu-id="bb78b-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="bb78b-257">Значение по умолчанию — *null*. Это означает, что система должна использовать кортеж (поставщик удостоверений, идентификатор имени), как описано выше, вместо имени пользователя.</span><span class="sxs-lookup"><span data-stu-id="bb78b-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="bb78b-258">иантифоржеряддитионалдатапровидер</span><span class="sxs-lookup"><span data-stu-id="bb78b-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="bb78b-259">Тип *[иантифоржеряддитионалдатапровидер](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* позволяет разработчикам расширять поведение системы защиты от XSRF, округляя дополнительные данные в каждом маркере.</span><span class="sxs-lookup"><span data-stu-id="bb78b-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="bb78b-260">Метод *жетаддитионалдата* вызывается каждый раз при создании маркера поля, а возвращаемое значение внедряется в созданный токен.</span><span class="sxs-lookup"><span data-stu-id="bb78b-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="bb78b-261">Разработчик может возвращать метку времени, nonce или любое другое значение, которое ему хочет воспользоваться в этом методе.</span><span class="sxs-lookup"><span data-stu-id="bb78b-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="bb78b-262">Аналогичным образом метод *валидатеаддитионалдата* вызывается каждый раз при проверке маркера поля, а строка "дополнительные данные", внедренная в маркер, передается в метод.</span><span class="sxs-lookup"><span data-stu-id="bb78b-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="bb78b-263">Подпрограммы проверки могут реализовать время ожидания (путем проверки текущего времени на время, которое было сохранено при создании маркера), подпрограммы проверки nonce или любую другую требуемую логику.</span><span class="sxs-lookup"><span data-stu-id="bb78b-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="bb78b-264">Разработка решений и рекомендаций по безопасности</span><span class="sxs-lookup"><span data-stu-id="bb78b-264">Design decisions and security considerations</span></span>

<span data-ttu-id="bb78b-265">Маркер безопасности, связывающий маркеры сеанса и поля, технически нужен только при попытке защитить анонимные и неаутентифицированные пользователи от атак XSRF.</span><span class="sxs-lookup"><span data-stu-id="bb78b-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="bb78b-266">При проверке подлинности пользователя сам маркер проверки подлинности (предположительно Отправленный в виде файла cookie) можно использовать в качестве одной половины пары токенов синхронизатора.</span><span class="sxs-lookup"><span data-stu-id="bb78b-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="bb78b-267">Однако существуют допустимые сценарии для защиты страниц входа, непроверенных пользователями, а логика защиты от XSRF была сделана проще, всегда создавая и проверяя маркер безопасности даже для пользователей, прошедших проверку подлинности.</span><span class="sxs-lookup"><span data-stu-id="bb78b-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="bb78b-268">Кроме того, она обеспечивает некоторую дополнительную защиту в случае, когда злоумышленник получит маркер поля, так как установка или подбор маркера сеанса будет еще одним препятствием для преодоления злоумышленника.</span><span class="sxs-lookup"><span data-stu-id="bb78b-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="bb78b-269">Разработчики должны соблюдать осторожность, если несколько приложений размещаются в одном домене.</span><span class="sxs-lookup"><span data-stu-id="bb78b-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="bb78b-270">Например, несмотря на то, что *example1.cloudapp.NET* и *example2.cloudapp.NET* являются разными узлами, между всеми узлами в домене *\*. cloudapp.NET* существует неявная связь доверия.</span><span class="sxs-lookup"><span data-stu-id="bb78b-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="bb78b-271">Это неявное отношение доверия [позволяет потенциально недоверенным узлам повлиять на файлы cookie друг друга](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (те же политики, которые УПРАВЛЯЮТ запросами AJAX, не обязательно применяются к ФАЙЛАМ cookie HTTP).</span><span class="sxs-lookup"><span data-stu-id="bb78b-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="bb78b-272">Среда выполнения веб-стека ASP.NET предоставляет ряд мер по предотвращению того, что имя пользователя внедряется в маркер поля, поэтому даже если вредоносный поддомен может перезаписать маркер сеанса, он не сможет создать действительный маркер поля для пользователя.</span><span class="sxs-lookup"><span data-stu-id="bb78b-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="bb78b-273">Однако при размещении в такой среде встроенные подпрограммы XSRF по-прежнему не могут защищаться от захвата сеанса или XSRF входа.</span><span class="sxs-lookup"><span data-stu-id="bb78b-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="bb78b-274">Подпрограммы XSRF в настоящее время не защищают от [кликджекинга](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="bb78b-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="bb78b-275">Приложения, которые хотят защищать себя от кликджекинга, могут легко сделать это, отправив заголовок X-Frame-Options: САМЕОРИГИН с каждым ответом.</span><span class="sxs-lookup"><span data-stu-id="bb78b-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="bb78b-276">Этот заголовок поддерживается во всех последних браузерах.</span><span class="sxs-lookup"><span data-stu-id="bb78b-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="bb78b-277">Дополнительные сведения см. в [блоге IE](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), в [блоге SDL](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)и в [OWASP](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="bb78b-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="bb78b-278">Среда выполнения веб-стека ASP.NET может в некоторых будущих выпусках сделать так, чтобы вспомогательные приложения MVC и Web Pages Anti-XSRF автоматически задали этот заголовок, чтобы обеспечить автоматическую защиту приложений от атак.</span><span class="sxs-lookup"><span data-stu-id="bb78b-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="bb78b-279">Веб-разработчики должны убедиться, что их сайты не подвержены атакам XSS.</span><span class="sxs-lookup"><span data-stu-id="bb78b-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="bb78b-280">Атаки XSS являются очень мощными, и успешная атака также нарушает защиту среды выполнения веб-стека ASP.NET от атак XSRF.</span><span class="sxs-lookup"><span data-stu-id="bb78b-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="bb78b-281">Acknowledgment (Подтверждение)</span><span class="sxs-lookup"><span data-stu-id="bb78b-281">Acknowledgment</span></span>

<span data-ttu-id="bb78b-282">[@LeviBroderick](https://twitter.com/LeviBroderick), кто написал большую часть кода безопасности ASP.NET, это основная часть этой информации.</span><span class="sxs-lookup"><span data-stu-id="bb78b-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
