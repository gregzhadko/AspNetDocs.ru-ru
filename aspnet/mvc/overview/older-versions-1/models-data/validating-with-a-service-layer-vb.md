---
uid: mvc/overview/older-versions-1/models-data/validating-with-a-service-layer-vb
title: Проверка с помощью уровня службы (Visual Basic) | Документация Майкрософт
author: StephenWalther
description: Узнайте, как переместить логику проверки из действий контроллера и поместить в отдельный слой. В этом руководстве объясняется, Стивен Вальтер как вы...
ms.author: riande
ms.date: 03/02/2009
ms.assetid: 344bb38e-4965-4c47-bda1-f6d29ae5b83a
msc.legacyurl: /mvc/overview/older-versions-1/models-data/validating-with-a-service-layer-vb
msc.type: authoredcontent
ms.openlocfilehash: ecce8e4f0a901ce8c185d2b085f4d706bd57fa1f
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57029141"
---
<a name="validating-with-a-service-layer-vb"></a>Проверка с помощью уровня службы (VB)
====================
по [Стивен Вальтер](https://github.com/StephenWalther)

> Узнайте, как переместить логику проверки из действий контроллера и поместить в отдельный слой. В этом руководстве Стивен Вальтер объясняется, как можно поддерживать резкие Разделение областей ответственности, изолируя уровень службы из вашего уровня контроллера.


Целью данного учебника является описание один из способов выполнения проверки в приложении ASP.NET MVC. В этом руководстве вы узнаете, как переместить логику проверки из контроллеров и поместить в отдельный слой.

## <a name="separating-concerns"></a>Разделение задач

При создании приложения ASP.NET MVC, логику базы данных не следует помещать внутри действий контроллера. Смешивание логику базы данных и контроллера делает более сложным в обслуживании со временем ваше приложение. Рекомендуется поместить все логику базы данных в отдельном репозитории слоя.

Например в листинге 1 содержит простой репозиторий с именем ProductRepository. Репозиторий продукта содержит все код доступа к данным для приложения. Список также включает интерфейс IProductRepository, который реализует хранилище продукта.

**В листинге 1 - Models\ProductRepository.vb**

[!code-vb[Main](validating-with-a-service-layer-vb/samples/sample1.vb)]

Контроллер в листинге 2 использует уровня репозитория в Index() и Create() действия. Обратите внимание на то, что этот контроллер не содержит логику базы данных. Создание уровня хранилища позволяет поддерживать четкое разделение ответственности. Контроллеры отвечают за логику управления потоком приложения и хранилище отвечает за логику доступа к данным.

**В листинге 2 - Controllers\ProductController.vb**

[!code-vb[Main](validating-with-a-service-layer-vb/samples/sample2.vb)]

## <a name="creating-a-service-layer"></a>Создание уровня службы

Таким образом, логику управления потоком приложения входят в контроллере, а логика доступа к данным входят в репозитории. В этом случае, где разместить логику проверки? Один из вариантов — разместить логику проверки в *слой служб*.

Слой служб представляет собой дополнительный уровень в приложении ASP.NET MVC, которое включается в процесс обмена данными между контроллером и уровня репозитория. Слой служб содержит бизнес-логики. В частности он содержит логику проверки.

Например слой служб продукта в листинге 3 имеет метод CreateProduct(). Метод CreateProduct() вызывает метод ValidateProduct() для проверки новый продукт перед их передачей продукта к репозиторию продукта.

**Листинг 3 - Models\ProductService.vb**

[!code-vb[Main](validating-with-a-service-layer-vb/samples/sample3.vb)]

Контроллер продукта была обновлена в листинге 4, чтобы использовать уровень служб вместо уровня репозитория. На уровне контроллер взаимодействует с уровня службы. Слой служб взаимодействует с уровня репозитория. Каждый слой имеет отдельный ответственности.

**Листинг 4 - Controllers\ProductController.vb**

[!code-vb[Main](validating-with-a-service-layer-vb/samples/sample4.vb)]

Обратите внимание, что службы продукции создается в конструкторе контроллера продукта. При создании службы продукции в словарь состояния модели передается в службу. Служба продукта использует состояние модели для передачи сообщения об ошибках проверки обратно к контроллеру.

## <a name="decoupling-the-service-layer"></a>Отделение уровня службы

Мы не изолировать контроллера и слои обслуживания в одном —. На контроллере и уровни службы взаимодействуют через состояние модели. Другими словами уровень служб имеет зависимость от определенная функция платформы ASP.NET MVC.

Мы хотим изолировать слой служб от наших максимально слоя контроллера. В теории мы должны иметь возможность использовать уровень служб с любым типом приложения, а не только приложение ASP.NET MVC. Например в будущем, мы может потребоваться создание WPF, переднего плана для нашего приложения. Мы должны найти состояние модели способ удалить зависимость от ASP.NET MVC от наших уровня службы.

В листинге 5 слой служб был обновлен, чтобы он больше не использует состояние модели. Вместо этого он использует любой класс, реализующий интерфейс IValidationDictionary.

**В листинге 5 - Models\ProductService.vb (в несвязанном состоянии)**

[!code-vb[Main](validating-with-a-service-layer-vb/samples/sample5.vb)]

Интерфейс IValidationDictionary определен в листинге 6. Этот простой интерфейс содержит один метод и одно свойство.

**В листинге 6 - Models\IValidationDictionary.cs**

[!code-vb[Main](validating-with-a-service-layer-vb/samples/sample6.vb)]

В листинге 7, с именем класса ModelStateWrapper, реализует интерфейс IValidationDictionary. Можно создать экземпляр класса ModelStateWrapper, передав словарь состояния модели в конструктор.

**Listing 7 - Models\ModelStateWrapper.vb**

[!code-vb[Main](validating-with-a-service-layer-vb/samples/sample7.vb)]

Наконец обновленного контроллера в листинг 8 использует ModelStateWrapper при создании слой служб в своем конструкторе.

**Листинг 8 - Controllers\ProductController.vb**

[!code-vb[Main](validating-with-a-service-layer-vb/samples/sample8.vb)]

С помощью IValidationDictionary интерфейс и класс ModelStateWrapper позволяет нам полностью изолировать наш слой служб от наш слой контроллера. Слой служб больше не зависит от состояния модели. Можно передать любой класс, реализующий интерфейс IValidationDictionary уровень службы. Например приложения WPF может реализовывать интерфейс IValidationDictionary с простой класс коллекций.

## <a name="summary"></a>Сводка

Цель этого учебника было обсудить одним из подходов к проверке в ASP.NET MVC-приложениях. В этом руководстве вы узнали, как перемещать все обнаруженные логику проверки из контроллеров и поместить в отдельный слой. Вы также узнали, как выделять на уровне службы, от вашего уровня контроллера, создав класс ModelStateWrapper.

> [!div class="step-by-step"]
> [Назад](validating-with-the-idataerrorinfo-interface-vb.md)
> [Вперед](validation-with-the-data-annotation-validators-vb.md)
