---
uid: mvc/overview/older-versions-1/nerddinner/secure-applications-using-authentication-and-authorization
title: Безопасные приложения с использованием аутентификации и авторизации Документы Майкрософт
author: rick-anderson
description: Шаг 9 показывает, как добавить аутентификацию и авторизацию для защиты нашего приложения NerdDinner, так что пользователям необходимо зарегистрироваться и войти на сайт для создания...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: 9e4d5cac-b071-440c-b044-20b6d0c964fb
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/secure-applications-using-authentication-and-authorization
msc.type: authoredcontent
ms.openlocfilehash: d96f2763f6e62f9dd599fdb7977a97993d218305
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542577"
---
# <a name="secure-applications-using-authentication-and-authorization"></a>Защита приложений с помощью проверки подлинности и авторизации

[корпорацией Майкрософт](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 9 бесплатно ["NerdDinner" приложение учебник,](introducing-the-nerddinner-tutorial.md) который ходит через как построить небольшой, но полный, веб-приложение с помощью ASP.NET MVC 1.
> 
> Шаг 9 показывает, как добавить аутентификацию и авторизацию для защиты нашего приложения NerdDinner, так что пользователи должны зарегистрироваться и войти на сайт, чтобы создать новые обеды, и только пользователь, который проводит ужин может отсеить его позже.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем вам следовать [начиная с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.

## <a name="nerddinner-step-9-authentication-and-authorization"></a>NerdDinner Шаг 9: Аутентификация и авторизация

Сейчас наша заявка NerdDinner предоставляет любому, кто посещает сайт, возможность создавать и отсеивать детали любого ужина. Давайте изменим это так, что пользователям необходимо зарегистрироваться и войти на сайт, чтобы создать новые обеды, и добавить ограничение, так что только пользователь, который проводит ужин может изменить его позже.

Для этого мы будем использовать аутентификацию и авторизацию для защиты нашего приложения.

### <a name="understanding-authentication-and-authorization"></a>Понимание аутентификации и авторизации

*Аутентификация* — это процесс идентификации и проверки личности клиента, доступки к приложению. Проще говоря, речь идет об определении "кто" конечный пользователь, когда они посещают веб-сайт. ASP.NET поддерживает несколько способов проверки подлинности пользователей браузера. Для интернет-приложений наиболее распространенный подход аутентификации называется "Формы аутентификации". Формы аутентификации позволяет разработчику автор HTML логин форму в своем приложении, а затем проверить имя пользователя / пароль конечный пользователь представляет в базе данных или других учетных данных пароль магазина. Если комбинация имени пользователя/пароля верна, разработчик может попросить ASP.NET выпустить зашифрованное файлcookieое печенье HTTP для идентификации пользователя в будущих запросах. Мы будем использовать проверку подлинности форм с нашим приложением NerdDinner.

*Авторизация* — это процесс определения того, имеет ли аутентифицированный пользователь разрешение на доступ к определенному URL/ресурсу или на выполнение каких-либо действий. Например, в нашем приложении NerdDinner мы хотим разрешить, что только пользователи, которые вошли в систему, могут получить доступ к *URL/Dinners/Create* и создать новые Dinners. Мы также хотим добавить логику авторизации, чтобы только пользователь, который проводит ужин, мог отседать его и отказывать в доступе к правке всем другим пользователям.

### <a name="forms-authentication-and-the-accountcontroller"></a>Формы аутентификации и учетная записьКонтроллер

Шаблон проекта Visual Studio по умолчанию для ASP.NET MVC автоматически позволяет создавать аутентификацию форм при создании новых ASP.NET приложений MVC. Он также автоматически добавляет в проект заранее построенную страницу входа в систему учетной записи, что позволяет очень легко интегрировать безопасность в сайт.

На главной странице Site.master по умолчанию отображается ссылка "Войти в" в правом верхнем правом доступе к сайту, когда пользователь, обращив его в качестве подлинности, не проверяется:

![](secure-applications-using-authentication-and-authorization/_static/image1.png)

Нажав на ссылку "Войти в систему" принимает пользователя на */Account / LogOn* URL:

![](secure-applications-using-authentication-and-authorization/_static/image2.png)

Посетители, которые не зарегистрировались, могут сделать это, нажав на ссылку "Регистрация", которая переведет их в *URL/Account/Register* и позволит им ввести реквизиты счета:

![](secure-applications-using-authentication-and-authorization/_static/image3.png)

Нажатие кнопки "Регистрация" создаст нового пользователя в системе ASP.NET членства, а также аутентифицировать пользователя на сайте с помощью проверки подлинности форм.

При входе пользователя в систему Site.master изменяет верхний правый от страницы, чтобы вывести "Добро пожаловать (имя пользователя)!" сообщение и отображает ссылку "Log Off" вместо "Log On" один. Нажав на ссылку "Log Off" журналы из пользователя:

![](secure-applications-using-authentication-and-authorization/_static/image4.png)

Вышеупомянутая функциональность входа, выхода и регистрации реализована в классе AccountController, который был добавлен в наш проект Visual Studio при создании проекта. UI для AccountController реализован с использованием шаблонов представления в каталоге «Просмотры»Account:

![](secure-applications-using-authentication-and-authorization/_static/image5.png)

Класс AccountController использует систему проверки подлинности ASP.NET форм для выпуска зашифрованных файлов проверки подлинности, а ASP.NET API членства для хранения и проверки имен/паролей пользователей. API ASP.NET членства является расширяемым и позволяет использовать любой хранилище учетных данных паролей. ASP.NET поставляется со встроенными реализациями поставщика членства, которые хранят имя пользователя/пароли в базе данных S'L или в Active Directory.

Мы можем настроить, какой поставщик членства наше приложение NerdDinner должно использоваться, открыв файл "web.config" в корне проекта и ища раздел &lt;членства&gt; в нем. Веб.конфигурация по умолчанию, добавленная при создании проекта, регистрирует поставщика членства в S'L и настраивает его на использование строки подключения под названием "ApplicationServices" для указания местоположения базы данных.

Строка подключения "ApplicationServices" (которая указана в разделе &lt;connectionStrings&gt; файла web..config) настроена на использование S'L Express. Он указывает на базу данных S'L Express под названием "ASPNETDB. MDF" в каталоге приложения\_"App Data". Если эта база данных не существует в первый раз, когда API членства используется в приложении, ASP.NET автоматически создадут базу данных и предусмотворят соответствующую схему базы данных членства в ней:

![](secure-applications-using-authentication-and-authorization/_static/image6.png)

Если вместо того, чтобы использовать s'L Express, мы хотели бы использовать полный экземпляр сервера S'L (или подключиться к удаленной базе данных), все, что нам нужно сделать, это обновить строку подключения "ApplicationServices" в файле web.config и убедиться, что соответствующая схема членства была добавлена в базу данных, на которую он указывает. Вы можете запустить утилиту\_"aspnet regsql.exe" в каталоге «Windows.NET»Framework'v2.0.50727, чтобы добавить соответствующую схему для членства и других ASP.NET служб ы применения в базу данных.

### <a name="authorizing-the-dinnerscreate-url-using-the-authorize-filter"></a>Авторизация /Dinners/Create URL с помощью фильтра «Авторизовать»

Нам не нужно было писать код, чтобы обеспечить безопасную аутентификацию и реализацию управления учетной записью для приложения NerdDinner. Пользователи могут зарегистрировать новые учетные записи в нашем приложении, а также войти в систему/выйти из сайта.

Теперь мы можем добавить логику авторизации в приложение и использовать статус аутентификации и имя пользователя посетителей, чтобы контролировать то, что они могут и не могут сделать в пределах сайта. Начнем с добавления логики авторизации в методы действий «Создать» нашего класса DinnersController. В частности, мы потребуем, чтобы пользователи, обращающиеся к *URL/Dinners/Create,* были зарегистрированы. Если они не вошли в систему, мы перенаправим их на страницу входа, чтобы они могли войти в систему.

Реализация этой логики довольно проста. Все, что нам нужно сделать, это добавить атрибут фильтра «Авторизовать» в наши методы действий Create, как это:

[!code-csharp[Main](secure-applications-using-authentication-and-authorization/samples/sample1.cs)]

ASP.NET MVC поддерживает возможность создания «фильтров действий», которые могут быть использованы для реализации повторно используемой логики, которая может быть декларативно применена к методам действий. Фильтр «Authorize» является одним из встроенных фильтров действий, предоставляемых ASP.NET MVC, и позволяет разработчику декларативно применять правила авторизации к методам действия и классам контроллеров.

При применении без каких-либо параметров (например, выше) фильтр «Authorize» закрепляет, что пользователь, делающего запрос метода действия, должен быть зарегистрирован и автоматически перенаправит браузер на URL-адрес входа, если он не является. При этом перенаправление первоначально запрошенного URL передается в качестве аргумента запроса (например: /Account/LogOn? ReturnUrl-%2fУжины%2fCreate). Затем accountController перенаправит пользователя обратно на первоначально запрошенный URL-адрес после входа в систему.

Фильтр «Authorize» дополнительно поддерживает возможность указывать свойство «Пользователи» или «Роли», которое может быть использовано для того, чтобы требовать, чтобы пользователь входил как в систему, так и в списке разрешенных пользователей или участника допустимой роли безопасности. Например, приведенный ниже код позволяет двум конкретным пользователям, "scottgu" и "billg", получить доступ к /Dinners/Create URL:

[!code-csharp[Main](secure-applications-using-authentication-and-authorization/samples/sample2.cs)]

Встраивание конкретных имен пользователей в код, как правило, довольно ООН-обслуживания, хотя. Лучшим подходом является определение "ролей" более высокого уровня, против которого код проверяется, а затем для отображения пользователей в роли с помощью базы данных или активной системы каталогов (позволяет хранить фактический список отображения пользователей извне из кода). ASP.NET включает в себя встроенный API управления ролью, а также встроенный набор поставщиков ролей (в том числе для S'L и Active Directory), которые могут помочь выполнить это отображение пользователей/ролей. Затем мы могли бы обновить код, чтобы позволить пользователям в рамках определенной роли "админ" получить доступ к /Dinners/ Создать URL:

[!code-csharp[Main](secure-applications-using-authentication-and-authorization/samples/sample3.cs)]

### <a name="using-the-useridentityname-property-when-creating-dinners"></a>Использование свойства User.Identity.Name при создании ужинов

Мы можем получить имя пользователя в настоящее время зарегистрированного пользователя запроса с помощью User.Identity.Name свойства, выставленного на базовом классе контроллера.

Ранее, когда мы реализовали версию HTTP-POST нашего метода действий Create() мы жестко закодировали свойство "HostedBy" ужина на статическую строку. Теперь мы можем обновить этот код, чтобы вместо этого использовать свойство User.Identity.Name, а также автоматически добавить RSVP для хоста, создающего Ужин:

[!code-csharp[Main](secure-applications-using-authentication-and-authorization/samples/sample4.cs)]

Поскольку мы добавили атрибут «Авторизовать» в метод «Создание»), ASP.NET MVC гарантирует, что метод действия выполняется только в том случае, если пользователь, посещающий URL/Dinners/Create, входит в систему на сайте. Таким образом, значение свойства User.Identity.Name всегда будет содержать действительное имя пользователя.

### <a name="using-the-useridentityname-property-when-editing-dinners"></a>Использование свойства User.Identity.Name при редактировании обедов

Теперь давайте добавим некоторую логику авторизации, которая ограничивает пользователей, чтобы они могли только отомещать свойства обедов, которые они сами размещают.

Чтобы помочь в этом, мы сначала добавим метод помощника "IsHostedBy (username)" к нашему объекту Dinner (в пределах Dinner.cs частичного класса, который мы построили ранее). Этот метод помощника возвращает истинное или ложное в зависимости от того, соответствует ли предоставленное имя пользователя свойству Dinner HostedBy и инкапсулирует логику, необходимую для выполнения нечувствительного сопоставления строк:

[!code-csharp[Main](secure-applications-using-authentication-and-authorization/samples/sample5.cs)]

Затем мы добавим атрибут «Авторизовать» в методы действий Edit() в нашем классе DinnersController. Это гарантирует, что пользователи должны быть зарегистрированы, чтобы запросить */Dinners / Edit / ID"* URL.

Затем мы можем добавить код в наши методы edit, который использует метод помощи Dinner.IsHostedBy (username), чтобы убедиться, что зарегистрированный пользователь соответствует хосту Dinner. Если пользователь не является хост- Код для этого выглядит ниже:

[!code-csharp[Main](secure-applications-using-authentication-and-authorization/samples/sample6.cs)]

Затем мы можем нажать правой кнопкой мыши в каталоге&gt;«Просмотры» и выбрать команду меню Add- View для создания нового представления «InvalidOwner». Мы заселим его с ниже сообщение об ошибке:

[!code-aspx[Main](secure-applications-using-authentication-and-authorization/samples/sample7.aspx)]

И теперь, когда пользователь пытается отсеить ужин, который им не принадлежит, он получит сообщение об ошибке:

![](secure-applications-using-authentication-and-authorization/_static/image7.png)

Мы можем повторить те же шаги для методов действий Delete() в нашем контроллере, чтобы заблокировать разрешение на удаление Dinners, а также гарантировать, что только хозяин ужина может удалить его.

### <a name="showinghiding-edit-and-delete-links"></a>Отображение/скрытие и удаление ссылок

Мы ссылаемся на метод действий по удалению и удалению нашего класса DinnersController из нашего URL-адреса данных:

![](secure-applications-using-authentication-and-authorization/_static/image8.png)

В настоящее время мы показываем ссылки действий edit and Delete независимо от того, является ли посетитель URL-адреса подробной информации хозяином ужина. Давайте изменим это так, чтобы ссылки отображались только в том случае, если владелец ужина является приглашенным пользователем.

Подробная информация () метод действия в нашем DinnersController извлекает объект Ужин, а затем передает его в качестве объекта модели в наш шаблон представления:

[!code-csharp[Main](secure-applications-using-authentication-and-authorization/samples/sample8.cs)]

Мы можем обновить наш шаблон представления, чтобы условно показать/ скрыть ссылки на edit and Delete с помощью метода помощи Dinner.IsHostedBy() помощника, как ниже:

[!code-aspx[Main](secure-applications-using-authentication-and-authorization/samples/sample9.aspx)]

#### <a name="next-steps"></a>Next Steps

Давайте теперь посмотрим, как мы можем включить аутентифицированных пользователей RSVP на обеды с помощью AJAX.

> [!div class="step-by-step"]
> [Назад](implement-efficient-data-paging.md)
> [Вперед](use-ajax-to-deliver-dynamic-updates.md)
