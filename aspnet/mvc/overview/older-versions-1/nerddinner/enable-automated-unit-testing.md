---
uid: mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
title: Включить автоматическое модульное тестирование | Документация Майкрософт
author: microsoft
description: На шаге 12 показано, как разработать набор автоматизированных модульных тестов, которые проверяют нашу функциональность NerdDinner, и что даст нам уверенность в внесении изменений...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: a19ff2ce-3f7e-4358-9a51-a1403da9c63e
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
msc.type: authoredcontent
ms.openlocfilehash: 09a7aa186605a6cce48ee94028425ded957c00d3
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78435594"
---
# <a name="enable-automated-unit-testing"></a>Включение автоматического модульного тестирования

по [Майкрософт](https://github.com/microsoft)

[Скачать в формате PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 12 из бесплатного [учебника по NerdDinner приложению](introducing-the-nerddinner-tutorial.md) , в котором рассматривается создание небольшого, но полного веб-приложения с использованием ASP.NET MVC 1.
> 
> На шаге 12 показано, как разработать набор автоматизированных модульных тестов, которые проверяют нашу функциональность NerdDinner, и что даст нам уверенность в внесении изменений и улучшений в приложение в будущем.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем следовать руководствам по [Начало работы в MVC 3 или в приложении для](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) [музыкального магазина MVC](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) .

## <a name="nerddinner-step-12-unit-testing"></a>NerdDinner шаг 12. модульное тестирование

Давайте разберем набор автоматизированных модульных тестов, которые проверяют наши функции NerdDinner, и что даст нам уверенность в внесении изменений и улучшений в будущее.

### <a name="why-unit-test"></a>Почему модульный тест?

На диске на один утром у вас есть неожиданный вспышка о том, над каким приложением вы работаете. Вы понимаете, что вы можете реализовать это изменение, которое сделает приложение более эффективным. Это может быть рефакторинг, который очищает код, добавляет новую функцию или исправляет ошибку.

Вопрос, который поступает при поступлении на компьютер, – "Насколько надежна это улучшение?" Что делать, если изменение имеет побочные эффекты или нарушает что-то? Это изменение может быть простым, и его реализация займет всего несколько минут, но что делать, если для ручного тестирования всех сценариев приложений требуется время? Что если вы забыли о ситуации и в рабочей среде перейдете неработающее приложение? Действительно ли это улучшение стоит на всех усилиях?

Автоматические модульные тесты могут обеспечить безопасность сети, которая позволяет постоянно улучшать приложения и избегать работы с кодом, над которым вы работаете. Наличие автоматических тестов, которые быстро проверяют функциональность, позволяет коду принимать уверенность, а также вносить улучшения, которые в противном случае могут оказаться неудобными. Они также помогают создавать решения, которые больше поддерживаются и имеют более длительный срок жизни, что приводит к гораздо более высокому доходу инвестиций.

Платформа ASP.NET MVC упрощает и естественным образом выполняет функции приложения модульного тестирования. Он также включает рабочий процесс разработки на основе тестирования (TDD), который обеспечивает разработку на базе тестирования.

### <a name="nerddinnertests-project"></a>Проект NerdDinner. Tests

Когда мы создали приложение NerdDinner в начале этого руководства, мы предложим диалоговое окно с вопросом, нужно ли создать проект модульного теста для перехода к проекту приложения:

![](enable-automated-unit-testing/_static/image1.png)

Выбран переключатель "Да, создать проект модульных тестов", который привел к добавлению проекта "NerdDinner. Tests" в наше решение:

![](enable-automated-unit-testing/_static/image2.png)

Проект NerdDinner. Tests ссылается на сборку проекта приложения NerdDinner и позволяет нам легко добавлять в него автоматические тесты, проверяющие функциональные возможности приложения.

### <a name="creating-unit-tests-for-our-dinner-model-class"></a>Создание модульных тестов для нашего класса модели компании

Давайте добавим несколько тестов в наш проект NerdDinner. Tests, которые проверяют класс ужин, созданный при построении нашего уровня модели.

Начнем с создания новой папки в проекте тестового проекта под названием «Models» (модели), где мы поместим наши тесты, связанные с моделью. Затем щелкните правой кнопкой мыши папку и выберите команду **Добавить новый&gt;меню тест** . Откроется диалоговое окно "Добавление нового теста".

Мы создадим «модульный тест» и назовем его «DinnerTest.cs»:

![](enable-automated-unit-testing/_static/image3.png)

При нажатии кнопки "ОК" Visual Studio добавит (и откроет) файл DinnerTest.cs в проект:

![](enable-automated-unit-testing/_static/image4.png)

Шаблон модульного теста Visual Studio по умолчанию содержит целый ряд стереотипного кода, который я нашел немного запутанным. Очистите его и просто содержали приведенный ниже код:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample1.cs)]

Атрибут [TestClass] класса Диннертест определяет его как класс, который будет содержать тесты, а также необязательный код инициализации и уничтожения теста. Можно определить тесты внутри него, добавив открытые методы, имеющие атрибут [TestMethod].

Ниже приведен первый из двух тестов, которые мы добавим, чтобы применить наш класс Dinner. Первый тест проверяет, является ли наш обед недействительным, если создается новый обед без корректной настройки всех свойств. Второй тест проверяет, является ли наш обед действительным, когда у компании Dinner все свойства с допустимыми значениями:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample2.cs)]

Вы заметите, что наши имена тестов являются очень явными (и несколько подробными). Это делается потому, что мы можем создать сотни или тысячи небольших тестов, и мы хотим быстро определить намерение и поведение каждого из них (особенно при просмотре списка сбоев в средстве выполнения тестов). Имена тестов должны называться после тестируемой функциональности. Выше мы используем шаблон именования "существительное\_\_глагол".

Мы структурированы тесты с помощью шаблона тестирования "AAA", который означает "упорядочение, акт, утверждение":

- Расположение: Настройка тестируемой единицы
- Акт: Упражнение тестируемого элемента и запись результатов
- Assert: проверка поведения

При написании тестов мы хотим избежать слишком большого количества отдельных тестов. Вместо этого каждый тест должен проверять только одну концепцию (что упростит определение причины сбоев). Рекомендуется использовать только одну инструкцию Assert для каждого теста. Если в методе теста имеется несколько операторов Assert, убедитесь, что они используются для проверки одной концепции. В случае сомнений выполните еще один тест.

### <a name="running-tests"></a>Выполнение тестов

Visual Studio 2008 Professional (и более поздние выпуски) включает встроенное средство выполнения тестов, которое можно использовать для запуска проектов модульных тестов Visual Studio в интегрированной среде разработки. Для запуска всех модульных тестов можно выбрать команду меню **тест-&gt;Run-&gt;все тесты в решении** (или нажать клавиши CTRL R, A). Кроме того, можно разместить курсор внутри определенного тестового класса или метода теста и использовать **тест-&gt;Run-&gt;тесты в текущей команде контекстного** меню (или клавишу CTRL R, t) для выполнения подмножества модульных тестов.

Давайте разместите курсор в классе Диннертест и введите "Ctrl R, T", чтобы выполнить два теста, которые были только что определены. Когда мы делаем это, в Visual Studio появится окно "результаты теста", и результаты этого тестового запуска будут показаны в нем.

![](enable-automated-unit-testing/_static/image5.png)

*Примечание. в окне VS Test Results столбец имя класса по умолчанию не отображается. Это можно добавить, щелкнув правой кнопкой мыши в окне результаты теста и выбрав команду меню Добавить или удалить столбцы.*

Два теста заняли лишь часть секунды, и, как видите, они оба были пройдены. Теперь мы можем переключаться и дополнять их, создавая дополнительные тесты, которые проверяют конкретные проверки правил, а также охватывают два вспомогательных метода — Исусерхост () и Исусеррегистеред (), которые мы добавили в класс ужин. Наличие всех этих тестов для класса Dinner будет намного проще и безопасно добавлять новые бизнес-правила и их проверки в будущем. Мы можем добавить новую логику правила в ужин, а затем в течение нескольких секунд убедиться, что она не нарушила ни одну из предыдущих функций логики.

Обратите внимание на то, как использование описательного имени теста упрощает понимание того, что проверяет каждый тест. Я рекомендую использовать команду меню **Сервис-&gt;параметры** , открыв экран "Инструменты тестирования —&gt;конфигурации выполнения тестов" и установив флажок "в результате двойного щелчка в результатах модульного теста с ошибками или неопределенным результатом отображается точка сбоя в тесте". Это позволит дважды щелкнуть ошибку в окне результатов теста и немедленно перейти к ошибке утверждения.

### <a name="creating-dinnerscontroller-unit-tests"></a>Создание модульных тестов Диннерсконтроллер

Теперь создадим несколько модульных тестов, которые проверяют нашу функциональность Диннерсконтроллер. Начнем с того, что щелкните правой кнопкой мыши папку Controllers в нашем тестовом проекте, а затем выберите команду **Добавить-&gt;создать тест** . Мы создадим модульный тест и назовем ему имя «DinnersControllerTest.cs».

Мы создадим два метода теста, которые проверяют метод действия Detail () для Диннерсконтроллер. Первый будет проверять, возвращается ли представление при запросе существующего обеда. Вторая проверка того, что будет возвращено представление "NotFound" при запросе несуществующего обеда:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample3.cs)]

Приведенный выше код компилирует очистку. Однако при выполнении тестов они завершаются сбоем:

![](enable-automated-unit-testing/_static/image6.png)

При рассмотрении сообщений об ошибках мы видим, что причина сбоя тестов вызвана тем, что нашему классу Диннерсрепоситори не удалось подключиться к базе данных. Наше приложение NerdDinner использует строку подключения к локальному файлу SQL Server Express, который находится в каталоге \Апп\_данных проекта приложения NerdDinner. Так как проект NerdDinner. Tests компилируется и выполняется в другом каталоге, то в проекте приложения неверно указана относительная путь к строке подключения.

Мы *смогли* исправить это, скопировав файл базы данных SQL Express в наш тестовый проект, а затем добавим в него соответствующую тестовую строку подключения в файле App. config нашего тестового проекта. Это приведет к разблокированию и запуску перечисленных выше тестов.

Однако код модульного тестирования, использующий реальную базу данных, приносит ряд проблем. В частности:

- Это значительно замедляет время выполнения модульных тестов. Чем больше времени занимает выполнение тестов, тем меньше вероятность их регулярного выполнения. В идеале необходимо, чтобы модульные тесты могли выполняться за считаные секунды, и они должны быть так же, как компиляция проекта.
- Он усложняет логику установки и очистки в тестах. Необходимо, чтобы каждый модульный тест был изолированным и независимым от других (без побочных эффектов или зависимостей). При работе с реальной базой данных необходимо учитывать состояние и сбросить его между тестами.

Рассмотрим шаблон проектирования «внедрение зависимостей», который поможет обойти эти проблемы и избежать необходимости использовать реальную базу данных с нашими тестами.

### <a name="dependency-injection"></a>Внедрение зависимостей

Прямо сейчас Диннерсконтроллер тесно связан с классом Диннеррепоситори. "Присоединение" относится к ситуации, когда класс явно использует другой класс для работы:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample4.cs)]

Поскольку классу Диннеррепоситори требуется доступ к базе данных, тесно связанная зависимость, которую класс Диннерсконтроллер имеет в Диннеррепоситори, в итоге требует, чтобы у нас была база данных, чтобы проверялись методы действия Диннерсконтроллер.

Мы можем обойти это, применив шаблон проектирования "внедрение зависимостей", который является подходом, когда зависимости (например, классы репозитория, предоставляющие доступ к данным) больше не создаются в классах, которые их используют. Вместо этого зависимости можно явно передать в класс, который использует их с помощью аргументов конструктора. Если зависимости определяются с помощью интерфейсов, то у нас есть возможность передавать "фиктивные" реализации зависимостей для сценариев модульных тестов. Это позволяет нам создавать зависящие от тестирования реализации зависимостей, для которых фактически не требуется доступ к базе данных.

Чтобы увидеть это в действии, Давайте реализуем внедрение зависимостей с нашим Диннерсконтроллер.

#### <a name="extracting-an-idinnerrepository-interface"></a>Извлечение интерфейса Идиннеррепоситори

Первым шагом будет создание нового интерфейса Идиннеррепоситори, который инкапсулирует контракт репозитория, необходимые контроллерам для получения и обновления диннерс.

Этот контракт интерфейса можно определить вручную, щелкнув правой кнопкой мыши папку \Моделс, а затем выбрав команду **Добавить-&gt;новый элемент** и создав новый интерфейс с именем IDinnerRepository.cs.

Кроме того, можно использовать средства рефакторинга, встроенные Visual Studio Professional (и более высокие выпуски), чтобы автоматически извлекать и создавать интерфейс для нас из существующего класса Диннеррепоситори. Чтобы извлечь этот интерфейс с помощью Visual Studio, просто поместите курсор в текстовый редактор класса Диннеррепоситори, а затем щелкните правой кнопкой мыши и выберите команду **Рефакторинг-&gt;извлечение интерфейса** .

![](enable-automated-unit-testing/_static/image7.png)

Запустится диалоговое окно "Извлечение интерфейса" и будет предложено ввести имя создаваемого интерфейса. По умолчанию будет Идиннеррепоситори и автоматически выбирать все открытые методы в существующем классе Диннеррепоситори для добавления в интерфейс:

![](enable-automated-unit-testing/_static/image8.png)

Когда мы нажимаем кнопку "ОК", Visual Studio добавит в приложение новый интерфейс Идиннеррепоситори:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample5.cs)]

И наш существующий класс Диннеррепоситори будет обновлен таким образом, чтобы он реализовал интерфейс:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample6.cs)]

#### <a name="updating-dinnerscontroller-to-support-constructor-injection"></a>Обновление Диннерсконтроллер для поддержки внедрения конструктора

Теперь мы будем обновлять класс Диннерсконтроллер для использования нового интерфейса.

В настоящее время Диннерсконтроллер жестко запрограммирован таким образом, что его поле "Диннеррепоситори" всегда является классом Диннеррепоситори:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample7.cs)]

Мы изменим его таким образом, чтобы поле "Диннеррепоситори" было типа Идиннеррепоситори, а не Диннеррепоситори. Затем мы добавим два открытых конструктора Диннерсконтроллер. Один из конструкторов позволяет передавать Идиннеррепоситори в качестве аргумента. Другой является конструктором по умолчанию, который использует нашу существующую реализацию Диннеррепоситори:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample8.cs)]

Так как ASP.NET MVC по умолчанию создает классы контроллеров с помощью конструкторов по умолчанию, наш Диннерсконтроллер во время выполнения будет по-прежнему использовать класс Диннеррепоситори для выполнения доступа к данным.

Однако теперь мы можем обновить модульные тесты, чтобы передать «фиктивную» реализацию репозитория на обед с помощью конструктора параметров. Этот «фиктивный» репозиторий обедов не потребует доступа к реальной базе данных, а вместо этого будет использовать образец данных в памяти.

#### <a name="creating-the-fakedinnerrepository-class"></a>Создание класса Факединнеррепоситори

Давайте создадим класс Факединнеррепоситори.

Начнем с создания "имитации" каталога в проекте NerdDinner. Tests, а затем добавим к нему новый класс Факединнеррепоситори (щелкните правой кнопкой мыши папку и выберите **Добавить-&gt;новый класс**):

![](enable-automated-unit-testing/_static/image9.png)

Мы будем обновлять код таким образом, чтобы класс Факединнеррепоситори реализовал интерфейс Идиннеррепоситори. Затем можно щелкнуть его правой кнопкой мыши и выбрать команду контекстного меню "реализовать интерфейс Идиннеррепоситори":

![](enable-automated-unit-testing/_static/image10.png)

Это приведет к тому, что Visual Studio автоматически добавит все члены интерфейса Идиннеррепоситори в наш класс Факединнеррепоситори с реализациями заглушки по умолчанию:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample9.cs)]

Затем можно обновить реализацию Факединнеррепоситори, чтобы она работала из списка в памяти,&lt;в качестве аргумента конструктора будет передана коллекция&gt;, переданная в нее.

[!code-csharp[Main](enable-automated-unit-testing/samples/sample10.cs)]

Теперь у нас есть фиктивная реализация Идиннеррепоситори, которая не требует базы данных, и вместо нее может работать вне списка в памяти объектов Dinner.

#### <a name="using-the-fakedinnerrepository-with-unit-tests"></a>Использование Факединнеррепоситори с модульными тестами

Давайте вернемся к модульным тестам Диннерсконтроллер, которые завершились сбоем ранее из-за недоступности базы данных. Мы можем обновить методы теста, чтобы использовать Факединнеррепоситори, заполненный примерами данных о обеде в памяти, в Диннерсконтроллер, используя приведенный ниже код.

[!code-csharp[Main](enable-automated-unit-testing/samples/sample11.cs)]

Теперь при выполнении этих тестов оба они проходят:

![](enable-automated-unit-testing/_static/image11.png)

Что лучше всего, они принимают всего лишь часть секунды и не нуждаются в сложной логике настройки и очистки. Теперь мы можем выполнять модульное тестирование всего кода метода действия Диннерсконтроллер (включая листинг, разбиение по страницам, сведения, создание, обновление и удаление) без необходимости подключения к реальной базе данных.

| **Боковая Тема: платформы внедрения зависимостей** |
| --- |
| Ручное внедрение зависимостей (как и мы выше) работает нормально, но становится труднее в обслуживании по мере увеличения количества зависимостей и компонентов в приложении. Существует несколько платформ внедрения зависимостей для .NET, которые могут способствовать обеспечению еще большей гибкости управления зависимостями. Эти платформы, иногда называемые «инверсией управления» (IoC), предоставляют механизмы, обеспечивающие дополнительный уровень поддержки конфигурации для указания и передачи зависимостей объектам во время выполнения (чаще всего с помощью внедрения конструктора ). Вот некоторые из наиболее популярных платформ внедрения и IOC-зависимостей в .NET: AutoFac, Нинжект, Spring.NET, StructureMap и Windsor. ASP.NET MVC предоставляет API-интерфейсы расширения, которые позволяют разработчикам принимать участие в разрешении и создании экземпляров контроллеров, а также позволяют четко интегрировать в этот процесс платформы внедрения зависимостей и IoC. Использование инфраструктуры DI/IOC также позволило бы нам удалить конструктор по умолчанию из нашего Диннерсконтроллер, который полностью удалит связь между ним и Диннеррепоситори. Мы не будем использовать платформу внедрения зависимостей и IOC в нашем приложении NerdDinner. Но мы можем подумать о будущем, если NerdDinner кода и возможности увеличились. |

### <a name="creating-edit-action-unit-tests"></a>Создание модульных тестов действия "изменить действие"

Теперь создадим несколько модульных тестов, проверяющих функциональность редактирования Диннерсконтроллер. Начнем с тестирования версии HTTP-GET нашего действия Edit:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample12.cs)]

Мы создадим тест, проверяющий, что представление, созданное объектом Диннерформвиевмодел, будет отображено обратно, когда запрашивается действительный обед:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample13.cs)]

Однако при выполнении теста мы обнаружите, что он завершается ошибкой, поскольку при обращении метода Edit к свойству User.Identity.Name для выполнения проверки Dinner. Ишостедби () возникает исключение null reference.

Объект User в базовом классе контроллера содержит сведения о вошедшем в систему пользователе и заполняется ASP.NET MVC при создании контроллера во время выполнения. Так как мы тестируем Диннерсконтроллер за пределами среды веб-сервера, объект пользователя не задается (поэтому исключение null reference).

### <a name="mocking-the-useridentityname-property"></a>Имитация свойства User.Identity.Name

Макеты инфраструктуры упрощают тестирование, позволяя динамически создавать фиктивные версии зависимых объектов, которые поддерживают наши тесты. Например, можно использовать структуру макетирования в нашем тесте действий редактирования, чтобы динамически создать объект пользователя, который наш Диннерсконтроллер может использовать для поиска имитации имени пользователя. Это позволит избежать возникновения пустой ссылки при выполнении нашего теста.

Существует множество структур макетирования .NET, которые можно использовать с ASP.NET MVC (список можно просмотреть здесь: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)). Для тестирования нашего приложения NerdDinner мы будем использовать инфраструктуру макетирования с открытым кодом под названием «MOQ», которую можно скачать бесплатно из [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq).

После загрузки мы добавим ссылку в проект NerdDinner. Tests в сборку MOQ. dll:

![](enable-automated-unit-testing/_static/image12.png)

Затем мы добавим вспомогательный метод "Креатединнерсконтроллерас (username)" в наш тестовый класс, который принимает имя пользователя в качестве параметра, а затем "макетирование" свойства User.Identity.Name в экземпляре Диннерсконтроллер:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample14.cs)]

Выше мы используем MOQ для создания макета объекта, который имитирует объект Контроллерконтекст (то есть ASP.NET MVC передается классам контроллеров для предоставления таких объектов среды выполнения, как пользователь, запрос, ответ и сеанс). Мы вызываем метод "Сетупжет" в макете, чтобы указать, что свойство HttpContext.User.Identity.Name в Контроллерконтекст должно возвращать строку имени пользователя, переданную в вспомогательный метод.

Можно макетировать любое количество свойств и методов Контроллерконтекст. Чтобы проиллюстрировать это, я также добавил вызов Сетупжет () для свойства Request. Authenticator (которое на самом деле не требуется для тестов ниже, но это помогает продемонстрировать, как можно макетированиеть свойства запросов). По завершении мы присваиваем экземпляр макета Контроллерконтекст для Диннерсконтроллер, который возвращает наш вспомогательный метод.

Теперь можно написать модульные тесты, которые используют этот вспомогательный метод для тестирования сценариев редактирования, включающих различных пользователей:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample15.cs)]

И теперь, когда мы выполняем тесты, которые они пройдут:

![](enable-automated-unit-testing/_static/image13.png)

### <a name="testing-updatemodel-scenarios"></a>Тестирование сценариев Упдатемодел ()

Мы создали тесты, охватывающие версию действия редактирования HTTP-GET. Теперь создадим несколько тестов, проверяющих версию действия редактирования HTTP-POST:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample16.cs)]

Интересным новым сценарием тестирования, который мы будем поддерживать с помощью этого метода действия, является использование вспомогательного метода Упдатемодел () в базовом классе контроллера. Мы используем этот вспомогательный метод для привязки значений отправки формы к нашему экземпляру объекта Dinner.

Ниже приведены два теста, демонстрирующих, как можно указать форму передаваемых значений для использования вспомогательного метода Упдатемодел (). Для этого нужно создать и заполнить объект Формколлектион, а затем назначить его свойству "значение valueprovider" на контроллере.

Первый тест проверяет, что при успешном сохранении браузер перенаправляется к действию Details. Второй тест проверяет, что при публикации недопустимых входных данных действие повторно отображает представление редактирования с сообщением об ошибке.

[!code-csharp[Main](enable-automated-unit-testing/samples/sample17.cs)]

### <a name="testing-wrap-up"></a>Тестирование оболочки

Мы рассмотрели основные понятия, связанные с классами контроллеров модульного тестирования. Эти методы можно использовать для простого создания сотен простых тестов, которые проверяют поведение нашего приложения.

Поскольку для наших тестов контроллеров и моделей не требуется реальная база данных, они очень просты и легко работают. Мы сможем выполнять сотни автоматических тестов за считаные секунды и незамедлительно получать отзывы о том, произошло ли изменение, которое мы сделали. Это поможет нам убедиться в том, что мы постоянно улучшаем, рефакторинг и уточнение нашего приложения.

Мы охвачены тестирование в качестве последнего раздела в этой главе, но не так как тестирование — это то, что нужно сделать в конце процесса разработки. В противоположность этому, следует создавать автоматические тесты как можно раньше в процессе разработки. Благодаря этому вы сможете получать немедленную обратную связь по мере разработки, помогая думать о сценариях использования приложения и разрабатывать приложение с учетом чистого уровня и взаимосвязей.

В следующей главе книги рассматривается разработка на основе тестирования (TDD) и ее использование с ASP.NET MVC. TDD — это итеративная практика написания кода, в которой сначала записываются тесты, которые будет соответствовать полученному коду. В TDD вы начинаете каждую функцию, создавая тест, который проверяет функциональность, которую вы собираетесь реализовать. Написание модульного теста в первую очередь позволяет убедиться, что функция и как она должна работать. Только после написания теста (и проверки, что он завершается сбоем) вы затем реализуете фактическую функциональность, которую тест проверяет. Так как вы уже потратили время на использование функции, как она должна работать, вы получите более полное представление о требованиях и о том, как лучше их реализовать. После завершения работы с реализацией можно повторно запустить тест и немедленно получить отзыв о том, работает ли функция правильно. Дополнительные сведения о TDD см. в главе 10.

### <a name="next-step"></a>Следующий шаг

В заключение заносятся комментарии.

> [!div class="step-by-step"]
> [Назад](use-ajax-to-implement-mapping-scenarios.md)
> [Вперед](nerddinner-wrap-up.md)
