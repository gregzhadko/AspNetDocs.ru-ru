---
uid: mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
title: Включить автоматическое модульное тестирование | Документация Майкрософт
author: microsoft
description: На шаге 12 показано, как разработать набор автоматизированных модульных тестов, которые проверяют нашу функциональность NerdDinner, и что даст нам уверенность в внесении изменений...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: a19ff2ce-3f7e-4358-9a51-a1403da9c63e
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
msc.type: authoredcontent
ms.openlocfilehash: 09a7aa186605a6cce48ee94028425ded957c00d3
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78435594"
---
# <a name="enable-automated-unit-testing"></a><span data-ttu-id="fe0c1-103">Включение автоматического модульного тестирования</span><span class="sxs-lookup"><span data-stu-id="fe0c1-103">Enable Automated Unit Testing</span></span>

<span data-ttu-id="fe0c1-104">по [Майкрософт](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="fe0c1-104">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="fe0c1-105">Скачать в формате PDF</span><span class="sxs-lookup"><span data-stu-id="fe0c1-105">Download PDF</span></span>](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> <span data-ttu-id="fe0c1-106">Это шаг 12 из бесплатного [учебника по NerdDinner приложению](introducing-the-nerddinner-tutorial.md) , в котором рассматривается создание небольшого, но полного веб-приложения с использованием ASP.NET MVC 1.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-106">This is step 12 of a free ["NerdDinner" application tutorial](introducing-the-nerddinner-tutorial.md) that walks-through how to build a small, but complete, web application using ASP.NET MVC 1.</span></span>
> 
> <span data-ttu-id="fe0c1-107">На шаге 12 показано, как разработать набор автоматизированных модульных тестов, которые проверяют нашу функциональность NerdDinner, и что даст нам уверенность в внесении изменений и улучшений в приложение в будущем.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-107">Step 12 shows how to develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>
> 
> <span data-ttu-id="fe0c1-108">Если вы используете ASP.NET MVC 3, мы рекомендуем следовать руководствам по [Начало работы в MVC 3 или в приложении для](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) [музыкального магазина MVC](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) .</span><span class="sxs-lookup"><span data-stu-id="fe0c1-108">If you are using ASP.NET MVC 3, we recommend you follow the [Getting Started With MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) or [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) tutorials.</span></span>

## <a name="nerddinner-step-12-unit-testing"></a><span data-ttu-id="fe0c1-109">NerdDinner шаг 12. модульное тестирование</span><span class="sxs-lookup"><span data-stu-id="fe0c1-109">NerdDinner Step 12: Unit Testing</span></span>

<span data-ttu-id="fe0c1-110">Давайте разберем набор автоматизированных модульных тестов, которые проверяют наши функции NerdDinner, и что даст нам уверенность в внесении изменений и улучшений в будущее.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-110">Let's develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>

### <a name="why-unit-test"></a><span data-ttu-id="fe0c1-111">Почему модульный тест?</span><span class="sxs-lookup"><span data-stu-id="fe0c1-111">Why Unit Test?</span></span>

<span data-ttu-id="fe0c1-112">На диске на один утром у вас есть неожиданный вспышка о том, над каким приложением вы работаете.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-112">On the drive into work one morning you have a sudden flash of inspiration about an application you are working on.</span></span> <span data-ttu-id="fe0c1-113">Вы понимаете, что вы можете реализовать это изменение, которое сделает приложение более эффективным.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-113">You realize there is a change you can implement that will make the application dramatically better.</span></span> <span data-ttu-id="fe0c1-114">Это может быть рефакторинг, который очищает код, добавляет новую функцию или исправляет ошибку.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-114">It might be a refactoring that cleans up the code, adds a new feature, or fixes a bug.</span></span>

<span data-ttu-id="fe0c1-115">Вопрос, который поступает при поступлении на компьютер, – "Насколько надежна это улучшение?"</span><span class="sxs-lookup"><span data-stu-id="fe0c1-115">The question that confronts you when you arrive at your computer is – "how safe is it to make this improvement?"</span></span> <span data-ttu-id="fe0c1-116">Что делать, если изменение имеет побочные эффекты или нарушает что-то?</span><span class="sxs-lookup"><span data-stu-id="fe0c1-116">What if making the change has side effects or breaks something?</span></span> <span data-ttu-id="fe0c1-117">Это изменение может быть простым, и его реализация займет всего несколько минут, но что делать, если для ручного тестирования всех сценариев приложений требуется время?</span><span class="sxs-lookup"><span data-stu-id="fe0c1-117">The change might be simple and only take a few minutes to implement, but what if it takes hours to manually test out all of the application scenarios?</span></span> <span data-ttu-id="fe0c1-118">Что если вы забыли о ситуации и в рабочей среде перейдете неработающее приложение?</span><span class="sxs-lookup"><span data-stu-id="fe0c1-118">What if you forget to cover a scenario and a broken application goes into production?</span></span> <span data-ttu-id="fe0c1-119">Действительно ли это улучшение стоит на всех усилиях?</span><span class="sxs-lookup"><span data-stu-id="fe0c1-119">Is making this improvement really worth all the effort?</span></span>

<span data-ttu-id="fe0c1-120">Автоматические модульные тесты могут обеспечить безопасность сети, которая позволяет постоянно улучшать приложения и избегать работы с кодом, над которым вы работаете.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-120">Automated unit tests can provide a safety net that enables you to continually enhance your applications, and avoid being afraid of the code you are working on.</span></span> <span data-ttu-id="fe0c1-121">Наличие автоматических тестов, которые быстро проверяют функциональность, позволяет коду принимать уверенность, а также вносить улучшения, которые в противном случае могут оказаться неудобными.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-121">Having automated tests that quickly verify functionality enables you to code with confidence – and empower you to make improvements you might otherwise not have felt comfortable doing.</span></span> <span data-ttu-id="fe0c1-122">Они также помогают создавать решения, которые больше поддерживаются и имеют более длительный срок жизни, что приводит к гораздо более высокому доходу инвестиций.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-122">They also help create solutions that are more maintainable and have a longer lifetime - which leads to a much higher return on investment.</span></span>

<span data-ttu-id="fe0c1-123">Платформа ASP.NET MVC упрощает и естественным образом выполняет функции приложения модульного тестирования.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-123">The ASP.NET MVC Framework makes it easy and natural to unit test application functionality.</span></span> <span data-ttu-id="fe0c1-124">Он также включает рабочий процесс разработки на основе тестирования (TDD), который обеспечивает разработку на базе тестирования.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-124">It also enables a Test Driven Development (TDD) workflow that enables test-first based development.</span></span>

### <a name="nerddinnertests-project"></a><span data-ttu-id="fe0c1-125">Проект NerdDinner. Tests</span><span class="sxs-lookup"><span data-stu-id="fe0c1-125">NerdDinner.Tests Project</span></span>

<span data-ttu-id="fe0c1-126">Когда мы создали приложение NerdDinner в начале этого руководства, мы предложим диалоговое окно с вопросом, нужно ли создать проект модульного теста для перехода к проекту приложения:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-126">When we created our NerdDinner application at the beginning of this tutorial, we were prompted with a dialog asking whether we wanted to create a unit test project to go along with the application project:</span></span>

![](enable-automated-unit-testing/_static/image1.png)

<span data-ttu-id="fe0c1-127">Выбран переключатель "Да, создать проект модульных тестов", который привел к добавлению проекта "NerdDinner. Tests" в наше решение:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-127">We kept the "Yes, create a unit test project" radio button selected – which resulted in a "NerdDinner.Tests" project being added to our solution:</span></span>

![](enable-automated-unit-testing/_static/image2.png)

<span data-ttu-id="fe0c1-128">Проект NerdDinner. Tests ссылается на сборку проекта приложения NerdDinner и позволяет нам легко добавлять в него автоматические тесты, проверяющие функциональные возможности приложения.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-128">The NerdDinner.Tests project references the NerdDinner application project assembly, and enables us to easily add automated tests to it that verify the application functionality.</span></span>

### <a name="creating-unit-tests-for-our-dinner-model-class"></a><span data-ttu-id="fe0c1-129">Создание модульных тестов для нашего класса модели компании</span><span class="sxs-lookup"><span data-stu-id="fe0c1-129">Creating Unit Tests for our Dinner Model Class</span></span>

<span data-ttu-id="fe0c1-130">Давайте добавим несколько тестов в наш проект NerdDinner. Tests, которые проверяют класс ужин, созданный при построении нашего уровня модели.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-130">Let's add some tests to our NerdDinner.Tests project that verify the Dinner class we created when we built our model layer.</span></span>

<span data-ttu-id="fe0c1-131">Начнем с создания новой папки в проекте тестового проекта под названием «Models» (модели), где мы поместим наши тесты, связанные с моделью.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-131">We'll start by creating a new folder within our test project called "Models" where we'll place our model-related tests.</span></span> <span data-ttu-id="fe0c1-132">Затем щелкните правой кнопкой мыши папку и выберите команду **Добавить новый&gt;меню тест** .</span><span class="sxs-lookup"><span data-stu-id="fe0c1-132">We'll then right-click on the folder and choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="fe0c1-133">Откроется диалоговое окно "Добавление нового теста".</span><span class="sxs-lookup"><span data-stu-id="fe0c1-133">This will bring up the "Add New Test" dialog.</span></span>

<span data-ttu-id="fe0c1-134">Мы создадим «модульный тест» и назовем его «DinnerTest.cs»:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-134">We'll choose to create a "Unit Test" and name it "DinnerTest.cs":</span></span>

![](enable-automated-unit-testing/_static/image3.png)

<span data-ttu-id="fe0c1-135">При нажатии кнопки "ОК" Visual Studio добавит (и откроет) файл DinnerTest.cs в проект:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-135">When we click the "ok" button Visual Studio will add (and open) a DinnerTest.cs file to the project:</span></span>

![](enable-automated-unit-testing/_static/image4.png)

<span data-ttu-id="fe0c1-136">Шаблон модульного теста Visual Studio по умолчанию содержит целый ряд стереотипного кода, который я нашел немного запутанным.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-136">The default Visual Studio unit test template has a bunch of boiler-plate code within it that I find a little messy.</span></span> <span data-ttu-id="fe0c1-137">Очистите его и просто содержали приведенный ниже код:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-137">Let's clean it up to just contain the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample1.cs)]

<span data-ttu-id="fe0c1-138">Атрибут [TestClass] класса Диннертест определяет его как класс, который будет содержать тесты, а также необязательный код инициализации и уничтожения теста.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-138">The [TestClass] attribute on the DinnerTest class above identifies it as a class that will contain tests, as well as optional test initialization and teardown code.</span></span> <span data-ttu-id="fe0c1-139">Можно определить тесты внутри него, добавив открытые методы, имеющие атрибут [TestMethod].</span><span class="sxs-lookup"><span data-stu-id="fe0c1-139">We can define tests within it by adding public methods that have a [TestMethod] attribute on them.</span></span>

<span data-ttu-id="fe0c1-140">Ниже приведен первый из двух тестов, которые мы добавим, чтобы применить наш класс Dinner.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-140">Below are the first of two tests we'll add that exercise our Dinner class.</span></span> <span data-ttu-id="fe0c1-141">Первый тест проверяет, является ли наш обед недействительным, если создается новый обед без корректной настройки всех свойств.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-141">The first test verifies that our Dinner is invalid if a new Dinner is created without all properties being set correctly.</span></span> <span data-ttu-id="fe0c1-142">Второй тест проверяет, является ли наш обед действительным, когда у компании Dinner все свойства с допустимыми значениями:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-142">The second test verifies that our Dinner is valid when a Dinner has all properties set with valid values:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample2.cs)]

<span data-ttu-id="fe0c1-143">Вы заметите, что наши имена тестов являются очень явными (и несколько подробными).</span><span class="sxs-lookup"><span data-stu-id="fe0c1-143">You'll notice above that our test names are very explicit (and somewhat verbose).</span></span> <span data-ttu-id="fe0c1-144">Это делается потому, что мы можем создать сотни или тысячи небольших тестов, и мы хотим быстро определить намерение и поведение каждого из них (особенно при просмотре списка сбоев в средстве выполнения тестов).</span><span class="sxs-lookup"><span data-stu-id="fe0c1-144">We are doing this because we might end up creating hundreds or thousands of small tests, and we want to make it easy to quickly determine the intent and behavior of each of them (especially when we are looking through a list of failures in a test runner).</span></span> <span data-ttu-id="fe0c1-145">Имена тестов должны называться после тестируемой функциональности.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-145">The test names should be named after the functionality they are testing.</span></span> <span data-ttu-id="fe0c1-146">Выше мы используем шаблон именования "существительное\_\_глагол".</span><span class="sxs-lookup"><span data-stu-id="fe0c1-146">Above we are using a "Noun\_Should\_Verb" naming pattern.</span></span>

<span data-ttu-id="fe0c1-147">Мы структурированы тесты с помощью шаблона тестирования "AAA", который означает "упорядочение, акт, утверждение":</span><span class="sxs-lookup"><span data-stu-id="fe0c1-147">We are structuring the tests using the "AAA" testing pattern – which stands for "Arrange, Act, Assert":</span></span>

- <span data-ttu-id="fe0c1-148">Расположение: Настройка тестируемой единицы</span><span class="sxs-lookup"><span data-stu-id="fe0c1-148">Arrange: Setup the unit being tested</span></span>
- <span data-ttu-id="fe0c1-149">Акт: Упражнение тестируемого элемента и запись результатов</span><span class="sxs-lookup"><span data-stu-id="fe0c1-149">Act: Exercise the unit under test and capture results</span></span>
- <span data-ttu-id="fe0c1-150">Assert: проверка поведения</span><span class="sxs-lookup"><span data-stu-id="fe0c1-150">Assert: Verify the behavior</span></span>

<span data-ttu-id="fe0c1-151">При написании тестов мы хотим избежать слишком большого количества отдельных тестов.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-151">When we write tests we want to avoid having the individual tests do too much.</span></span> <span data-ttu-id="fe0c1-152">Вместо этого каждый тест должен проверять только одну концепцию (что упростит определение причины сбоев).</span><span class="sxs-lookup"><span data-stu-id="fe0c1-152">Instead each test should verify only a single concept (which will make it much easier to pinpoint the cause of failures).</span></span> <span data-ttu-id="fe0c1-153">Рекомендуется использовать только одну инструкцию Assert для каждого теста.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-153">A good guideline is to try and only have a single assert statement for each test.</span></span> <span data-ttu-id="fe0c1-154">Если в методе теста имеется несколько операторов Assert, убедитесь, что они используются для проверки одной концепции.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-154">If you have more than one assert statement in a test method, make sure they are all being used to test the same concept.</span></span> <span data-ttu-id="fe0c1-155">В случае сомнений выполните еще один тест.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-155">When in doubt, make another test.</span></span>

### <a name="running-tests"></a><span data-ttu-id="fe0c1-156">Выполнение тестов</span><span class="sxs-lookup"><span data-stu-id="fe0c1-156">Running Tests</span></span>

<span data-ttu-id="fe0c1-157">Visual Studio 2008 Professional (и более поздние выпуски) включает встроенное средство выполнения тестов, которое можно использовать для запуска проектов модульных тестов Visual Studio в интегрированной среде разработки.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-157">Visual Studio 2008 Professional (and higher editions) includes a built-in test runner that can be used to run Visual Studio Unit Test projects within the IDE.</span></span> <span data-ttu-id="fe0c1-158">Для запуска всех модульных тестов можно выбрать команду меню **тест-&gt;Run-&gt;все тесты в решении** (или нажать клавиши CTRL R, A).</span><span class="sxs-lookup"><span data-stu-id="fe0c1-158">We can select the **Test-&gt;Run-&gt;All Tests in Solution** menu command (or type Ctrl R, A) to run all of our unit tests.</span></span> <span data-ttu-id="fe0c1-159">Кроме того, можно разместить курсор внутри определенного тестового класса или метода теста и использовать **тест-&gt;Run-&gt;тесты в текущей команде контекстного** меню (или клавишу CTRL R, t) для выполнения подмножества модульных тестов.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-159">Or alternatively we can position our cursor within a specific test class or test method and use the **Test-&gt;Run-&gt;Tests in Current Context** menu command (or type Ctrl R, T) to run a subset of the unit tests.</span></span>

<span data-ttu-id="fe0c1-160">Давайте разместите курсор в классе Диннертест и введите "Ctrl R, T", чтобы выполнить два теста, которые были только что определены.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-160">Let's position our cursor within the DinnerTest class and type "Ctrl R, T" to run the two tests we just defined.</span></span> <span data-ttu-id="fe0c1-161">Когда мы делаем это, в Visual Studio появится окно "результаты теста", и результаты этого тестового запуска будут показаны в нем.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-161">When we do this a "Test Results" window will appear within Visual Studio and we'll see the results of our test run listed within it:</span></span>

![](enable-automated-unit-testing/_static/image5.png)

<span data-ttu-id="fe0c1-162">*Примечание. в окне VS Test Results столбец имя класса по умолчанию не отображается. Это можно добавить, щелкнув правой кнопкой мыши в окне результаты теста и выбрав команду меню Добавить или удалить столбцы.*</span><span class="sxs-lookup"><span data-stu-id="fe0c1-162">*Note: The VS test results window does not show the Class Name column by default. You can add this by right-clicking within the Test Results window and using the Add/Remove Columns menu command.*</span></span>

<span data-ttu-id="fe0c1-163">Два теста заняли лишь часть секунды, и, как видите, они оба были пройдены.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-163">Our two tests took only a fraction of a second to run – and as you can see they both passed.</span></span> <span data-ttu-id="fe0c1-164">Теперь мы можем переключаться и дополнять их, создавая дополнительные тесты, которые проверяют конкретные проверки правил, а также охватывают два вспомогательных метода — Исусерхост () и Исусеррегистеред (), которые мы добавили в класс ужин.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-164">We can now go on and augment them by creating additional tests that verify specific rule validations, as well as cover the two helper methods - IsUserHost() and IsUserRegistered() – that we added to the Dinner class.</span></span> <span data-ttu-id="fe0c1-165">Наличие всех этих тестов для класса Dinner будет намного проще и безопасно добавлять новые бизнес-правила и их проверки в будущем.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-165">Having all these tests in place for the Dinner class will make it much easier and safer to add new business rules and validations to it in the future.</span></span> <span data-ttu-id="fe0c1-166">Мы можем добавить новую логику правила в ужин, а затем в течение нескольких секунд убедиться, что она не нарушила ни одну из предыдущих функций логики.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-166">We can add our new rule logic to Dinner, and then within seconds verify that it hasn't broken any of our previous logic functionality.</span></span>

<span data-ttu-id="fe0c1-167">Обратите внимание на то, как использование описательного имени теста упрощает понимание того, что проверяет каждый тест.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-167">Notice how using a descriptive test name makes it easy to quickly understand what each test is verifying.</span></span> <span data-ttu-id="fe0c1-168">Я рекомендую использовать команду меню **Сервис-&gt;параметры** , открыв экран "Инструменты тестирования —&gt;конфигурации выполнения тестов" и установив флажок "в результате двойного щелчка в результатах модульного теста с ошибками или неопределенным результатом отображается точка сбоя в тесте".</span><span class="sxs-lookup"><span data-stu-id="fe0c1-168">I recommend using the **Tools-&gt;Options** menu command, opening the Test Tools-&gt;Test Execution configuration screen, and checking the "Double-clicking a failed or inconclusive unit test result displays the point of failure in the test" checkbox.</span></span> <span data-ttu-id="fe0c1-169">Это позволит дважды щелкнуть ошибку в окне результатов теста и немедленно перейти к ошибке утверждения.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-169">This will allow you to double-click on a failure in the test results window and jump immediately to the assert failure.</span></span>

### <a name="creating-dinnerscontroller-unit-tests"></a><span data-ttu-id="fe0c1-170">Создание модульных тестов Диннерсконтроллер</span><span class="sxs-lookup"><span data-stu-id="fe0c1-170">Creating DinnersController Unit Tests</span></span>

<span data-ttu-id="fe0c1-171">Теперь создадим несколько модульных тестов, которые проверяют нашу функциональность Диннерсконтроллер.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-171">Let's now create some unit tests that verify our DinnersController functionality.</span></span> <span data-ttu-id="fe0c1-172">Начнем с того, что щелкните правой кнопкой мыши папку Controllers в нашем тестовом проекте, а затем выберите команду **Добавить-&gt;создать тест** .</span><span class="sxs-lookup"><span data-stu-id="fe0c1-172">We'll start by right-clicking on the "Controllers" folder within our Test project and then choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="fe0c1-173">Мы создадим модульный тест и назовем ему имя «DinnersControllerTest.cs».</span><span class="sxs-lookup"><span data-stu-id="fe0c1-173">We'll create a "Unit Test" and name it "DinnersControllerTest.cs".</span></span>

<span data-ttu-id="fe0c1-174">Мы создадим два метода теста, которые проверяют метод действия Detail () для Диннерсконтроллер.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-174">We'll create two test methods that verify the Details() action method on the DinnersController.</span></span> <span data-ttu-id="fe0c1-175">Первый будет проверять, возвращается ли представление при запросе существующего обеда.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-175">The first will verify that a View is returned when an existing Dinner is requested.</span></span> <span data-ttu-id="fe0c1-176">Вторая проверка того, что будет возвращено представление "NotFound" при запросе несуществующего обеда:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-176">The second will verify that a "NotFound" view is returned when a non-existent Dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample3.cs)]

<span data-ttu-id="fe0c1-177">Приведенный выше код компилирует очистку.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-177">The above code compiles clean.</span></span> <span data-ttu-id="fe0c1-178">Однако при выполнении тестов они завершаются сбоем:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-178">When we run the tests, though, they both fail:</span></span>

![](enable-automated-unit-testing/_static/image6.png)

<span data-ttu-id="fe0c1-179">При рассмотрении сообщений об ошибках мы видим, что причина сбоя тестов вызвана тем, что нашему классу Диннерсрепоситори не удалось подключиться к базе данных.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-179">If we look at the error messages, we'll see that the reason the tests failed was because our DinnersRepository class was unable to connect to a database.</span></span> <span data-ttu-id="fe0c1-180">Наше приложение NerdDinner использует строку подключения к локальному файлу SQL Server Express, который находится в каталоге \Апп\_данных проекта приложения NerdDinner.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-180">Our NerdDinner application is using a connection-string to a local SQL Server Express file which lives under the \App\_Data directory of the NerdDinner application project.</span></span> <span data-ttu-id="fe0c1-181">Так как проект NerdDinner. Tests компилируется и выполняется в другом каталоге, то в проекте приложения неверно указана относительная путь к строке подключения.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-181">Because our NerdDinner.Tests project compiles and runs in a different directory then the application project, the relative path location of our connection-string is incorrect.</span></span>

<span data-ttu-id="fe0c1-182">Мы *смогли* исправить это, скопировав файл базы данных SQL Express в наш тестовый проект, а затем добавим в него соответствующую тестовую строку подключения в файле App. config нашего тестового проекта.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-182">We *could* fix this by copying the SQL Express database file to our test project, and then add an appropriate test connection-string to it in the App.config of our test project.</span></span> <span data-ttu-id="fe0c1-183">Это приведет к разблокированию и запуску перечисленных выше тестов.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-183">This would get the above tests unblocked and running.</span></span>

<span data-ttu-id="fe0c1-184">Однако код модульного тестирования, использующий реальную базу данных, приносит ряд проблем.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-184">Unit testing code using a real database, though, brings with it a number of challenges.</span></span> <span data-ttu-id="fe0c1-185">В частности:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-185">Specifically:</span></span>

- <span data-ttu-id="fe0c1-186">Это значительно замедляет время выполнения модульных тестов.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-186">It significantly slows down the execution time of unit tests.</span></span> <span data-ttu-id="fe0c1-187">Чем больше времени занимает выполнение тестов, тем меньше вероятность их регулярного выполнения.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-187">The longer it takes to run tests, the less likely you are to execute them frequently.</span></span> <span data-ttu-id="fe0c1-188">В идеале необходимо, чтобы модульные тесты могли выполняться за считаные секунды, и они должны быть так же, как компиляция проекта.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-188">Ideally you want your unit tests to be able to be run in seconds – and have it be something you do as naturally as compiling the project.</span></span>
- <span data-ttu-id="fe0c1-189">Он усложняет логику установки и очистки в тестах.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-189">It complicates the setup and cleanup logic within tests.</span></span> <span data-ttu-id="fe0c1-190">Необходимо, чтобы каждый модульный тест был изолированным и независимым от других (без побочных эффектов или зависимостей).</span><span class="sxs-lookup"><span data-stu-id="fe0c1-190">You want each unit test to be isolated and independent of others (with no side effects or dependencies).</span></span> <span data-ttu-id="fe0c1-191">При работе с реальной базой данных необходимо учитывать состояние и сбросить его между тестами.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-191">When working against a real database you have to be mindful of state and reset it between tests.</span></span>

<span data-ttu-id="fe0c1-192">Рассмотрим шаблон проектирования «внедрение зависимостей», который поможет обойти эти проблемы и избежать необходимости использовать реальную базу данных с нашими тестами.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-192">Let's look at a design pattern called "dependency injection" that can help us work around these issues and avoid the need to use a real database with our tests.</span></span>

### <a name="dependency-injection"></a><span data-ttu-id="fe0c1-193">Внедрение зависимостей</span><span class="sxs-lookup"><span data-stu-id="fe0c1-193">Dependency Injection</span></span>

<span data-ttu-id="fe0c1-194">Прямо сейчас Диннерсконтроллер тесно связан с классом Диннеррепоситори.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-194">Right now DinnersController is tightly "coupled" to the DinnerRepository class.</span></span> <span data-ttu-id="fe0c1-195">"Присоединение" относится к ситуации, когда класс явно использует другой класс для работы:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-195">"Coupling" refers to a situation where a class explicitly relies on another class in order to work:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample4.cs)]

<span data-ttu-id="fe0c1-196">Поскольку классу Диннеррепоситори требуется доступ к базе данных, тесно связанная зависимость, которую класс Диннерсконтроллер имеет в Диннеррепоситори, в итоге требует, чтобы у нас была база данных, чтобы проверялись методы действия Диннерсконтроллер.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-196">Because the DinnerRepository class requires access to a database, the tightly coupled dependency the DinnersController class has on the DinnerRepository ends up requiring us to have a database in order for the DinnersController action methods to be tested.</span></span>

<span data-ttu-id="fe0c1-197">Мы можем обойти это, применив шаблон проектирования "внедрение зависимостей", который является подходом, когда зависимости (например, классы репозитория, предоставляющие доступ к данным) больше не создаются в классах, которые их используют.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-197">We can get around this by employing a design pattern called "dependency injection" – which is an approach where dependencies (like repository classes that provide data access) are no longer implicitly created within classes that use them.</span></span> <span data-ttu-id="fe0c1-198">Вместо этого зависимости можно явно передать в класс, который использует их с помощью аргументов конструктора.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-198">Instead, dependencies can be explicitly passed to the class that uses them using constructor arguments.</span></span> <span data-ttu-id="fe0c1-199">Если зависимости определяются с помощью интерфейсов, то у нас есть возможность передавать "фиктивные" реализации зависимостей для сценариев модульных тестов.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-199">If the dependencies are defined using interfaces, we then have the flexibility to pass in "fake" dependency implementations for unit test scenarios.</span></span> <span data-ttu-id="fe0c1-200">Это позволяет нам создавать зависящие от тестирования реализации зависимостей, для которых фактически не требуется доступ к базе данных.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-200">This enables us to create test-specific dependency implementations that do not actually require access to a database.</span></span>

<span data-ttu-id="fe0c1-201">Чтобы увидеть это в действии, Давайте реализуем внедрение зависимостей с нашим Диннерсконтроллер.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-201">To see this in action, let's implement dependency injection with our DinnersController.</span></span>

#### <a name="extracting-an-idinnerrepository-interface"></a><span data-ttu-id="fe0c1-202">Извлечение интерфейса Идиннеррепоситори</span><span class="sxs-lookup"><span data-stu-id="fe0c1-202">Extracting an IDinnerRepository interface</span></span>

<span data-ttu-id="fe0c1-203">Первым шагом будет создание нового интерфейса Идиннеррепоситори, который инкапсулирует контракт репозитория, необходимые контроллерам для получения и обновления диннерс.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-203">Our first step will be to create a new IDinnerRepository interface that encapsulates the repository contract our controllers require to retrieve and update Dinners.</span></span>

<span data-ttu-id="fe0c1-204">Этот контракт интерфейса можно определить вручную, щелкнув правой кнопкой мыши папку \Моделс, а затем выбрав команду **Добавить-&gt;новый элемент** и создав новый интерфейс с именем IDinnerRepository.cs.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-204">We can define this interface contract manually by right-clicking on the \Models folder, and then choosing the **Add-&gt;New Item** menu command and creating a new interface named IDinnerRepository.cs.</span></span>

<span data-ttu-id="fe0c1-205">Кроме того, можно использовать средства рефакторинга, встроенные Visual Studio Professional (и более высокие выпуски), чтобы автоматически извлекать и создавать интерфейс для нас из существующего класса Диннеррепоситори.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-205">Alternatively we can use the refactoring tools built-into Visual Studio Professional (and higher editions) to automatically extract and create an interface for us from our existing DinnerRepository class.</span></span> <span data-ttu-id="fe0c1-206">Чтобы извлечь этот интерфейс с помощью Visual Studio, просто поместите курсор в текстовый редактор класса Диннеррепоситори, а затем щелкните правой кнопкой мыши и выберите команду **Рефакторинг-&gt;извлечение интерфейса** .</span><span class="sxs-lookup"><span data-stu-id="fe0c1-206">To extract this interface using VS, simply position the cursor in the text editor on the DinnerRepository class, and then right-click and choose the **Refactor-&gt;Extract Interface** menu command:</span></span>

![](enable-automated-unit-testing/_static/image7.png)

<span data-ttu-id="fe0c1-207">Запустится диалоговое окно "Извлечение интерфейса" и будет предложено ввести имя создаваемого интерфейса.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-207">This will launch the "Extract Interface" dialog and prompt us for the name of the interface to create.</span></span> <span data-ttu-id="fe0c1-208">По умолчанию будет Идиннеррепоситори и автоматически выбирать все открытые методы в существующем классе Диннеррепоситори для добавления в интерфейс:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-208">It will default to IDinnerRepository and automatically select all public methods on the existing DinnerRepository class to add to the interface:</span></span>

![](enable-automated-unit-testing/_static/image8.png)

<span data-ttu-id="fe0c1-209">Когда мы нажимаем кнопку "ОК", Visual Studio добавит в приложение новый интерфейс Идиннеррепоситори:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-209">When we click the "ok" button, Visual Studio will add a new IDinnerRepository interface to our application:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample5.cs)]

<span data-ttu-id="fe0c1-210">И наш существующий класс Диннеррепоситори будет обновлен таким образом, чтобы он реализовал интерфейс:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-210">And our existing DinnerRepository class will be updated so that it implements the interface:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample6.cs)]

#### <a name="updating-dinnerscontroller-to-support-constructor-injection"></a><span data-ttu-id="fe0c1-211">Обновление Диннерсконтроллер для поддержки внедрения конструктора</span><span class="sxs-lookup"><span data-stu-id="fe0c1-211">Updating DinnersController to support constructor injection</span></span>

<span data-ttu-id="fe0c1-212">Теперь мы будем обновлять класс Диннерсконтроллер для использования нового интерфейса.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-212">We'll now update the DinnersController class to use the new interface.</span></span>

<span data-ttu-id="fe0c1-213">В настоящее время Диннерсконтроллер жестко запрограммирован таким образом, что его поле "Диннеррепоситори" всегда является классом Диннеррепоситори:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-213">Currently DinnersController is hard-coded such that its "dinnerRepository" field is always a DinnerRepository class:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample7.cs)]

<span data-ttu-id="fe0c1-214">Мы изменим его таким образом, чтобы поле "Диннеррепоситори" было типа Идиннеррепоситори, а не Диннеррепоситори.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-214">We'll change it so that the "dinnerRepository" field is of type IDinnerRepository instead of DinnerRepository.</span></span> <span data-ttu-id="fe0c1-215">Затем мы добавим два открытых конструктора Диннерсконтроллер.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-215">We'll then add two public DinnersController constructors.</span></span> <span data-ttu-id="fe0c1-216">Один из конструкторов позволяет передавать Идиннеррепоситори в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-216">One of the constructors allows an IDinnerRepository to be passed as an argument.</span></span> <span data-ttu-id="fe0c1-217">Другой является конструктором по умолчанию, который использует нашу существующую реализацию Диннеррепоситори:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-217">The other is a default constructor that uses our existing DinnerRepository implementation:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample8.cs)]

<span data-ttu-id="fe0c1-218">Так как ASP.NET MVC по умолчанию создает классы контроллеров с помощью конструкторов по умолчанию, наш Диннерсконтроллер во время выполнения будет по-прежнему использовать класс Диннеррепоситори для выполнения доступа к данным.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-218">Because ASP.NET MVC by default creates controller classes using default constructors, our DinnersController at runtime will continue to use the DinnerRepository class to perform data access.</span></span>

<span data-ttu-id="fe0c1-219">Однако теперь мы можем обновить модульные тесты, чтобы передать «фиктивную» реализацию репозитория на обед с помощью конструктора параметров.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-219">We can now update our unit tests, though, to pass in a "fake" dinner repository implementation using the parameter constructor.</span></span> <span data-ttu-id="fe0c1-220">Этот «фиктивный» репозиторий обедов не потребует доступа к реальной базе данных, а вместо этого будет использовать образец данных в памяти.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-220">This "fake" dinner repository will not require access to a real database, and instead will use in-memory sample data.</span></span>

#### <a name="creating-the-fakedinnerrepository-class"></a><span data-ttu-id="fe0c1-221">Создание класса Факединнеррепоситори</span><span class="sxs-lookup"><span data-stu-id="fe0c1-221">Creating the FakeDinnerRepository class</span></span>

<span data-ttu-id="fe0c1-222">Давайте создадим класс Факединнеррепоситори.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-222">Let's create a FakeDinnerRepository class.</span></span>

<span data-ttu-id="fe0c1-223">Начнем с создания "имитации" каталога в проекте NerdDinner. Tests, а затем добавим к нему новый класс Факединнеррепоситори (щелкните правой кнопкой мыши папку и выберите **Добавить-&gt;новый класс**):</span><span class="sxs-lookup"><span data-stu-id="fe0c1-223">We'll begin by creating a "Fakes" directory within our NerdDinner.Tests project and then add a new FakeDinnerRepository class to it (right-click on the folder and choose **Add-&gt;New Class**):</span></span>

![](enable-automated-unit-testing/_static/image9.png)

<span data-ttu-id="fe0c1-224">Мы будем обновлять код таким образом, чтобы класс Факединнеррепоситори реализовал интерфейс Идиннеррепоситори.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-224">We'll update the code so that the FakeDinnerRepository class implements the IDinnerRepository interface.</span></span> <span data-ttu-id="fe0c1-225">Затем можно щелкнуть его правой кнопкой мыши и выбрать команду контекстного меню "реализовать интерфейс Идиннеррепоситори":</span><span class="sxs-lookup"><span data-stu-id="fe0c1-225">We can then right-click on it and choose the "Implement interface IDinnerRepository" context menu command:</span></span>

![](enable-automated-unit-testing/_static/image10.png)

<span data-ttu-id="fe0c1-226">Это приведет к тому, что Visual Studio автоматически добавит все члены интерфейса Идиннеррепоситори в наш класс Факединнеррепоситори с реализациями заглушки по умолчанию:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-226">This will cause Visual Studio to automatically add all of the IDinnerRepository interface members to our FakeDinnerRepository class with default "stub out" implementations:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample9.cs)]

<span data-ttu-id="fe0c1-227">Затем можно обновить реализацию Факединнеррепоситори, чтобы она работала из списка в памяти,&lt;в качестве аргумента конструктора будет передана коллекция&gt;, переданная в нее.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-227">We can then update the FakeDinnerRepository implementation to work off of an in-memory List&lt;Dinner&gt; collection passed to it as a constructor argument:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample10.cs)]

<span data-ttu-id="fe0c1-228">Теперь у нас есть фиктивная реализация Идиннеррепоситори, которая не требует базы данных, и вместо нее может работать вне списка в памяти объектов Dinner.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-228">We now have a fake IDinnerRepository implementation that does not require a database, and can instead work off an in-memory list of Dinner objects.</span></span>

#### <a name="using-the-fakedinnerrepository-with-unit-tests"></a><span data-ttu-id="fe0c1-229">Использование Факединнеррепоситори с модульными тестами</span><span class="sxs-lookup"><span data-stu-id="fe0c1-229">Using the FakeDinnerRepository with Unit Tests</span></span>

<span data-ttu-id="fe0c1-230">Давайте вернемся к модульным тестам Диннерсконтроллер, которые завершились сбоем ранее из-за недоступности базы данных.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-230">Let's return to the DinnersController unit tests that failed earlier because the database wasn't available.</span></span> <span data-ttu-id="fe0c1-231">Мы можем обновить методы теста, чтобы использовать Факединнеррепоситори, заполненный примерами данных о обеде в памяти, в Диннерсконтроллер, используя приведенный ниже код.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-231">We can update the test methods to use a FakeDinnerRepository populated with sample in-memory Dinner data to the DinnersController using the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample11.cs)]

<span data-ttu-id="fe0c1-232">Теперь при выполнении этих тестов оба они проходят:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-232">And now when we run these tests they both pass:</span></span>

![](enable-automated-unit-testing/_static/image11.png)

<span data-ttu-id="fe0c1-233">Что лучше всего, они принимают всего лишь часть секунды и не нуждаются в сложной логике настройки и очистки.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-233">Best of all, they take only a fraction of a second to run, and do not require any complicated setup/cleanup logic.</span></span> <span data-ttu-id="fe0c1-234">Теперь мы можем выполнять модульное тестирование всего кода метода действия Диннерсконтроллер (включая листинг, разбиение по страницам, сведения, создание, обновление и удаление) без необходимости подключения к реальной базе данных.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-234">We can now unit test all of our DinnersController action method code (including listing, paging, details, create, update and delete) without ever needing to connect to a real database.</span></span>

| <span data-ttu-id="fe0c1-235">**Боковая Тема: платформы внедрения зависимостей**</span><span class="sxs-lookup"><span data-stu-id="fe0c1-235">**Side Topic: Dependency Injection Frameworks**</span></span> |
| --- |
| <span data-ttu-id="fe0c1-236">Ручное внедрение зависимостей (как и мы выше) работает нормально, но становится труднее в обслуживании по мере увеличения количества зависимостей и компонентов в приложении.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-236">Performing manual dependency injection (like we are above) works fine, but does become harder to maintain as the number of dependencies and components in an application increases.</span></span> <span data-ttu-id="fe0c1-237">Существует несколько платформ внедрения зависимостей для .NET, которые могут способствовать обеспечению еще большей гибкости управления зависимостями.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-237">Several dependency injection frameworks exist for .NET that can help provide even more dependency management flexibility.</span></span> <span data-ttu-id="fe0c1-238">Эти платформы, иногда называемые «инверсией управления» (IoC), предоставляют механизмы, обеспечивающие дополнительный уровень поддержки конфигурации для указания и передачи зависимостей объектам во время выполнения (чаще всего с помощью внедрения конструктора ).</span><span class="sxs-lookup"><span data-stu-id="fe0c1-238">These frameworks, also sometimes called "Inversion of Control" (IoC) containers, provide mechanisms that enable an additional level of configuration support for specifying and passing dependencies to objects at runtime (most often using constructor injection).</span></span> <span data-ttu-id="fe0c1-239">Вот некоторые из наиболее популярных платформ внедрения и IOC-зависимостей в .NET: AutoFac, Нинжект, Spring.NET, StructureMap и Windsor.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-239">Some of the more popular OSS Dependency Injection / IOC frameworks in .NET include: AutoFac, Ninject, Spring.NET, StructureMap, and Windsor.</span></span> <span data-ttu-id="fe0c1-240">ASP.NET MVC предоставляет API-интерфейсы расширения, которые позволяют разработчикам принимать участие в разрешении и создании экземпляров контроллеров, а также позволяют четко интегрировать в этот процесс платформы внедрения зависимостей и IoC.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-240">ASP.NET MVC exposes extensibility APIs that enable developers to participate in the resolution and instantiation of controllers, and which enables Dependency Injection / IoC frameworks to be cleanly integrated within this process.</span></span> <span data-ttu-id="fe0c1-241">Использование инфраструктуры DI/IOC также позволило бы нам удалить конструктор по умолчанию из нашего Диннерсконтроллер, который полностью удалит связь между ним и Диннеррепоситори.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-241">Using a DI/IOC framework would also enable us to remove the default constructor from our DinnersController – which would completely remove the coupling between it and the DinnerRepository.</span></span> <span data-ttu-id="fe0c1-242">Мы не будем использовать платформу внедрения зависимостей и IOC в нашем приложении NerdDinner.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-242">We won't be using a dependency injection / IOC framework with our NerdDinner application.</span></span> <span data-ttu-id="fe0c1-243">Но мы можем подумать о будущем, если NerdDinner кода и возможности увеличились.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-243">But it is something we could consider for the future if the NerdDinner code-base and capabilities grew.</span></span> |

### <a name="creating-edit-action-unit-tests"></a><span data-ttu-id="fe0c1-244">Создание модульных тестов действия "изменить действие"</span><span class="sxs-lookup"><span data-stu-id="fe0c1-244">Creating Edit Action Unit Tests</span></span>

<span data-ttu-id="fe0c1-245">Теперь создадим несколько модульных тестов, проверяющих функциональность редактирования Диннерсконтроллер.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-245">Let's now create some unit tests that verify the Edit functionality of the DinnersController.</span></span> <span data-ttu-id="fe0c1-246">Начнем с тестирования версии HTTP-GET нашего действия Edit:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-246">We'll start by testing the HTTP-GET version of our Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample12.cs)]

<span data-ttu-id="fe0c1-247">Мы создадим тест, проверяющий, что представление, созданное объектом Диннерформвиевмодел, будет отображено обратно, когда запрашивается действительный обед:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-247">We'll create a test that verifies that a View backed by a DinnerFormViewModel object is rendered back when a valid dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample13.cs)]

<span data-ttu-id="fe0c1-248">Однако при выполнении теста мы обнаружите, что он завершается ошибкой, поскольку при обращении метода Edit к свойству User.Identity.Name для выполнения проверки Dinner. Ишостедби () возникает исключение null reference.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-248">When we run the test, though, we'll find that it fails because a null reference exception is thrown when the Edit method accesses the User.Identity.Name property to perform the Dinner.IsHostedBy() check.</span></span>

<span data-ttu-id="fe0c1-249">Объект User в базовом классе контроллера содержит сведения о вошедшем в систему пользователе и заполняется ASP.NET MVC при создании контроллера во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-249">The User object on the Controller base class encapsulates details about the logged-in user, and is populated by ASP.NET MVC when it creates the controller at runtime.</span></span> <span data-ttu-id="fe0c1-250">Так как мы тестируем Диннерсконтроллер за пределами среды веб-сервера, объект пользователя не задается (поэтому исключение null reference).</span><span class="sxs-lookup"><span data-stu-id="fe0c1-250">Because we are testing the DinnersController outside of a web-server environment, the User object isn't set (hence the null reference exception).</span></span>

### <a name="mocking-the-useridentityname-property"></a><span data-ttu-id="fe0c1-251">Имитация свойства User.Identity.Name</span><span class="sxs-lookup"><span data-stu-id="fe0c1-251">Mocking the User.Identity.Name property</span></span>

<span data-ttu-id="fe0c1-252">Макеты инфраструктуры упрощают тестирование, позволяя динамически создавать фиктивные версии зависимых объектов, которые поддерживают наши тесты.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-252">Mocking frameworks make testing easier by enabling us to dynamically create fake versions of dependent objects that support our tests.</span></span> <span data-ttu-id="fe0c1-253">Например, можно использовать структуру макетирования в нашем тесте действий редактирования, чтобы динамически создать объект пользователя, который наш Диннерсконтроллер может использовать для поиска имитации имени пользователя.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-253">For example, we can use a mocking framework in our Edit action test to dynamically create a User object that our DinnersController can use to lookup a simulated username.</span></span> <span data-ttu-id="fe0c1-254">Это позволит избежать возникновения пустой ссылки при выполнении нашего теста.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-254">This will avoid a null reference from being thrown when we run our test.</span></span>

<span data-ttu-id="fe0c1-255">Существует множество структур макетирования .NET, которые можно использовать с ASP.NET MVC (список можно просмотреть здесь: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)).</span><span class="sxs-lookup"><span data-stu-id="fe0c1-255">There are many .NET mocking frameworks that can be used with ASP.NET MVC (you can see a list of them here: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)).</span></span> <span data-ttu-id="fe0c1-256">Для тестирования нашего приложения NerdDinner мы будем использовать инфраструктуру макетирования с открытым кодом под названием «MOQ», которую можно скачать бесплатно из [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq).</span><span class="sxs-lookup"><span data-stu-id="fe0c1-256">For testing our NerdDinner application we'll use an open source mocking framework called "Moq", which can be downloaded for free from [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq).</span></span>

<span data-ttu-id="fe0c1-257">После загрузки мы добавим ссылку в проект NerdDinner. Tests в сборку MOQ. dll:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-257">Once downloaded, we'll add a reference in our NerdDinner.Tests project to the Moq.dll assembly:</span></span>

![](enable-automated-unit-testing/_static/image12.png)

<span data-ttu-id="fe0c1-258">Затем мы добавим вспомогательный метод "Креатединнерсконтроллерас (username)" в наш тестовый класс, который принимает имя пользователя в качестве параметра, а затем "макетирование" свойства User.Identity.Name в экземпляре Диннерсконтроллер:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-258">We'll then add a "CreateDinnersControllerAs(username)" helper method to our test class that takes a username as a parameter, and which then "mocks" the User.Identity.Name property on the DinnersController instance:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample14.cs)]

<span data-ttu-id="fe0c1-259">Выше мы используем MOQ для создания макета объекта, который имитирует объект Контроллерконтекст (то есть ASP.NET MVC передается классам контроллеров для предоставления таких объектов среды выполнения, как пользователь, запрос, ответ и сеанс).</span><span class="sxs-lookup"><span data-stu-id="fe0c1-259">Above we are using Moq to create a Mock object that fakes a ControllerContext object (which is what ASP.NET MVC passes to Controller classes to expose runtime objects like User, Request, Response, and Session).</span></span> <span data-ttu-id="fe0c1-260">Мы вызываем метод "Сетупжет" в макете, чтобы указать, что свойство HttpContext.User.Identity.Name в Контроллерконтекст должно возвращать строку имени пользователя, переданную в вспомогательный метод.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-260">We are calling the "SetupGet" method on the Mock to indicate that the HttpContext.User.Identity.Name property on ControllerContext should return the username string we passed to the helper method.</span></span>

<span data-ttu-id="fe0c1-261">Можно макетировать любое количество свойств и методов Контроллерконтекст.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-261">We can mock any number of ControllerContext properties and methods.</span></span> <span data-ttu-id="fe0c1-262">Чтобы проиллюстрировать это, я также добавил вызов Сетупжет () для свойства Request. Authenticator (которое на самом деле не требуется для тестов ниже, но это помогает продемонстрировать, как можно макетированиеть свойства запросов).</span><span class="sxs-lookup"><span data-stu-id="fe0c1-262">To illustrate this I've also added a SetupGet() call for the Request.IsAuthenticated property (which isn't actually needed for the tests below – but which helps illustrate how you can mock Request properties).</span></span> <span data-ttu-id="fe0c1-263">По завершении мы присваиваем экземпляр макета Контроллерконтекст для Диннерсконтроллер, который возвращает наш вспомогательный метод.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-263">When we are done we assign an instance of the ControllerContext mock to the DinnersController our helper method returns.</span></span>

<span data-ttu-id="fe0c1-264">Теперь можно написать модульные тесты, которые используют этот вспомогательный метод для тестирования сценариев редактирования, включающих различных пользователей:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-264">We can now write unit tests that use this helper method to test Edit scenarios involving different users:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample15.cs)]

<span data-ttu-id="fe0c1-265">И теперь, когда мы выполняем тесты, которые они пройдут:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-265">And now when we run the tests they pass:</span></span>

![](enable-automated-unit-testing/_static/image13.png)

### <a name="testing-updatemodel-scenarios"></a><span data-ttu-id="fe0c1-266">Тестирование сценариев Упдатемодел ()</span><span class="sxs-lookup"><span data-stu-id="fe0c1-266">Testing UpdateModel() scenarios</span></span>

<span data-ttu-id="fe0c1-267">Мы создали тесты, охватывающие версию действия редактирования HTTP-GET.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-267">We've created tests that cover the HTTP-GET version of the Edit action.</span></span> <span data-ttu-id="fe0c1-268">Теперь создадим несколько тестов, проверяющих версию действия редактирования HTTP-POST:</span><span class="sxs-lookup"><span data-stu-id="fe0c1-268">Let's now create some tests that verify the HTTP-POST version of the Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample16.cs)]

<span data-ttu-id="fe0c1-269">Интересным новым сценарием тестирования, который мы будем поддерживать с помощью этого метода действия, является использование вспомогательного метода Упдатемодел () в базовом классе контроллера.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-269">The interesting new testing scenario for us to support with this action method is its usage of the UpdateModel() helper method on the Controller base class.</span></span> <span data-ttu-id="fe0c1-270">Мы используем этот вспомогательный метод для привязки значений отправки формы к нашему экземпляру объекта Dinner.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-270">We are using this helper method to bind form-post values to our Dinner object instance.</span></span>

<span data-ttu-id="fe0c1-271">Ниже приведены два теста, демонстрирующих, как можно указать форму передаваемых значений для использования вспомогательного метода Упдатемодел ().</span><span class="sxs-lookup"><span data-stu-id="fe0c1-271">Below are two tests that demonstrates how we can supply form posted values for the UpdateModel() helper method to use.</span></span> <span data-ttu-id="fe0c1-272">Для этого нужно создать и заполнить объект Формколлектион, а затем назначить его свойству "значение valueprovider" на контроллере.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-272">We'll do this by creating and populating a FormCollection object, and then assign it to the "ValueProvider" property on the Controller.</span></span>

<span data-ttu-id="fe0c1-273">Первый тест проверяет, что при успешном сохранении браузер перенаправляется к действию Details.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-273">The first test verifies that on a successful save the browser is redirected to the details action.</span></span> <span data-ttu-id="fe0c1-274">Второй тест проверяет, что при публикации недопустимых входных данных действие повторно отображает представление редактирования с сообщением об ошибке.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-274">The second test verifies that when invalid input is posted the action redisplays the edit view again with an error message.</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample17.cs)]

### <a name="testing-wrap-up"></a><span data-ttu-id="fe0c1-275">Тестирование оболочки</span><span class="sxs-lookup"><span data-stu-id="fe0c1-275">Testing Wrap-Up</span></span>

<span data-ttu-id="fe0c1-276">Мы рассмотрели основные понятия, связанные с классами контроллеров модульного тестирования.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-276">We've covered the core concepts involved in unit testing controller classes.</span></span> <span data-ttu-id="fe0c1-277">Эти методы можно использовать для простого создания сотен простых тестов, которые проверяют поведение нашего приложения.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-277">We can use these techniques to easily create hundreds of simple tests that verify the behavior of our application.</span></span>

<span data-ttu-id="fe0c1-278">Поскольку для наших тестов контроллеров и моделей не требуется реальная база данных, они очень просты и легко работают.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-278">Because our controller and model tests do not require a real database, they are extremely fast and easy to run.</span></span> <span data-ttu-id="fe0c1-279">Мы сможем выполнять сотни автоматических тестов за считаные секунды и незамедлительно получать отзывы о том, произошло ли изменение, которое мы сделали.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-279">We'll be able to execute hundreds of automated tests in seconds, and immediately get feedback as to whether a change we made broke something.</span></span> <span data-ttu-id="fe0c1-280">Это поможет нам убедиться в том, что мы постоянно улучшаем, рефакторинг и уточнение нашего приложения.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-280">This will help provide us the confidence to continually improve, refactor, and refine our application.</span></span>

<span data-ttu-id="fe0c1-281">Мы охвачены тестирование в качестве последнего раздела в этой главе, но не так как тестирование — это то, что нужно сделать в конце процесса разработки.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-281">We covered testing as the last topic in this chapter – but not because testing is something you should do at the end of a development process!</span></span> <span data-ttu-id="fe0c1-282">В противоположность этому, следует создавать автоматические тесты как можно раньше в процессе разработки.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-282">On the contrary, you should write automated tests as early as possible in your development process.</span></span> <span data-ttu-id="fe0c1-283">Благодаря этому вы сможете получать немедленную обратную связь по мере разработки, помогая думать о сценариях использования приложения и разрабатывать приложение с учетом чистого уровня и взаимосвязей.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-283">Doing so enables you to get immediate feedback as you develop, helps you think thoughtfully about your application's use case scenarios, and guides you to design your application with clean layering and coupling in mind.</span></span>

<span data-ttu-id="fe0c1-284">В следующей главе книги рассматривается разработка на основе тестирования (TDD) и ее использование с ASP.NET MVC.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-284">A later chapter in the book will discuss Test Driven Development (TDD), and how to use it with ASP.NET MVC.</span></span> <span data-ttu-id="fe0c1-285">TDD — это итеративная практика написания кода, в которой сначала записываются тесты, которые будет соответствовать полученному коду.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-285">TDD is an iterative coding practice where you first write the tests that your resulting code will satisfy.</span></span> <span data-ttu-id="fe0c1-286">В TDD вы начинаете каждую функцию, создавая тест, который проверяет функциональность, которую вы собираетесь реализовать.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-286">With TDD you begin each feature by creating a test that verifies the functionality you are about to implement.</span></span> <span data-ttu-id="fe0c1-287">Написание модульного теста в первую очередь позволяет убедиться, что функция и как она должна работать.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-287">Writing the unit test first helps ensure that you clearly understand the feature and how it is supposed to work.</span></span> <span data-ttu-id="fe0c1-288">Только после написания теста (и проверки, что он завершается сбоем) вы затем реализуете фактическую функциональность, которую тест проверяет.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-288">Only after the test is written (and you have verified that it fails) do you then implement the actual functionality the test verifies.</span></span> <span data-ttu-id="fe0c1-289">Так как вы уже потратили время на использование функции, как она должна работать, вы получите более полное представление о требованиях и о том, как лучше их реализовать.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-289">Because you've already spent time thinking about the use case of how the feature is supposed to work, you will have a better understanding of the requirements and how best to implement them.</span></span> <span data-ttu-id="fe0c1-290">После завершения работы с реализацией можно повторно запустить тест и немедленно получить отзыв о том, работает ли функция правильно.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-290">When you are done with the implementation you can re-run the test – and get immediate feedback as to whether the feature works correctly.</span></span> <span data-ttu-id="fe0c1-291">Дополнительные сведения о TDD см. в главе 10.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-291">We'll cover TDD more in Chapter 10.</span></span>

### <a name="next-step"></a><span data-ttu-id="fe0c1-292">Следующий шаг</span><span class="sxs-lookup"><span data-stu-id="fe0c1-292">Next Step</span></span>

<span data-ttu-id="fe0c1-293">В заключение заносятся комментарии.</span><span class="sxs-lookup"><span data-stu-id="fe0c1-293">Some final wrap up comments.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="fe0c1-294">[Назад](use-ajax-to-implement-mapping-scenarios.md)
> [Вперед](nerddinner-wrap-up.md)</span><span class="sxs-lookup"><span data-stu-id="fe0c1-294">[Previous](use-ajax-to-implement-mapping-scenarios.md)
[Next](nerddinner-wrap-up.md)</span></span>
