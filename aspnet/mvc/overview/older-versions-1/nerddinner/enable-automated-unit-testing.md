---
uid: mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
title: Включение автоматического модульного тестирования | Документация Майкрософт
author: microsoft
description: Шаг 12 показано, как разработать набор автоматических модульных тестов для проверки нашего функционала NerdDinner и которое даст нам уверенность в том, чтобы внести изменения...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: a19ff2ce-3f7e-4358-9a51-a1403da9c63e
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
msc.type: authoredcontent
ms.openlocfilehash: 09a7aa186605a6cce48ee94028425ded957c00d3
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65117355"
---
# <a name="enable-automated-unit-testing"></a>Включение автоматического модульного тестирования

по [Microsoft](https://github.com/microsoft)

[Загрузить PDF-файл](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это 12 из бесплатной [руководство по использованию приложения «NerdDinner»](introducing-the-nerddinner-tutorial.md) , пошаговое рассмотрение как создать небольшой, но завершить, веб-приложения с помощью ASP.NET MVC 1.
> 
> Шаг 12 показано, как разработать набор автоматических модульных тестов для проверки нашего функционала NerdDinner и которое даст нам уверенность, изменения и улучшения в приложение в будущем.
> 
> Если вы используете ASP.NET MVC 3, рекомендуется следовать [Приступая к работе с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.

## <a name="nerddinner-step-12-unit-testing"></a>NerdDinner Step 12: Модульное тестирование

Давайте разработаем это набор автоматических модульных тестов для проверки нашего функционала NerdDinner и которое даст нам уверенность, изменения и улучшения в приложение в будущем.

### <a name="why-unit-test"></a>Почему модульный тест?

На диске на работу утром один у вас есть внезапные вспышки вдохновения о приложении, над которым вы работаете из. Вы поймете, что изменение можно реализовать, значительно улучшить приложение. Возможно, рефакторинга, который удаляет код, добавляет новый компонент или исправляет ошибку.

На вопрос, вы confronts при приходе на компьютере — «насколько безопасным его, чтобы сделать это улучшение?» Что делать, если внесение изменений имеет побочные эффекты или что-то нарушает? Изменения могут быть простыми и занимает несколько минут для реализации, но что делать, если требуется часов, чтобы вручную протестировать все сценарии работы приложений? Что делать, если вы забудете охватить сценарий и приложение выходит в производство? Делает это улучшение действительно стоит всех?

Автоматические модульные тесты обеспечивают средство подстраховки, дающий возможность постоянно Улучшите свои приложения и не стать боится кода, над которым вы работаете. Выполнив автоматические тесты, быстро убедитесь, что позволяет с уверенностью — программируйте и позволит вам для повышения качества, вы может в противном случае не чувствовать себя комфортно. Они также помогают создавать решения, которые являются более простым в обслуживании и имеют большее время - какие приводит к гораздо выше окупаемости инвестиций.

Платформа ASP.NET MVC позволяет простым и естественным функции модульного тестирования приложения. Он также позволяет протестировать разработку, управляемую (TDD) рабочий процесс, который позволяет осуществлять разработку на основе основанная на тестировании.

### <a name="nerddinnertests-project"></a>NerdDinner.Tests Project

Если мы создали наше приложение NerdDinner в начале работы с этим руководством, мы были будет появляться диалоговое окно с запросом ли нам нужно создать проект модульного теста для перехода вместе с проектом приложения:

![](enable-automated-unit-testing/_static/image1.png)

«Да, создать проект модульного теста» переключатель выбирается что привело к «NerdDinner.Tests» проекта, добавляемый наше решение сохранена:

![](enable-automated-unit-testing/_static/image2.png)

NerdDinner.Tests проект ссылается на сборку проекта приложение NerdDinner и позволяет легко добавлять автоматические тесты, проверьте функциональные возможности приложения его.

### <a name="creating-unit-tests-for-our-dinner-model-class"></a>Создание модульных тестов для нашего класса модели Dinner

Давайте добавим некоторые тесты в свой проект NerdDinner.Tests, проверить класс обед, созданную при создании наш слой модели.

Мы начнем с создания новой папки в наш проект теста с именем «Моделей», где мы поместим наши тесты, связанные с моделью. Мы затем папку правой кнопкой мыши и выберите **Add -&gt;новый тест** команды меню. Это приведет к появлению диалогового окна «Добавление нового теста».

Мы выберем создание «Unit Test» и назовите его «DinnerTest.cs»:

![](enable-automated-unit-testing/_static/image3.png)

При нажатии кнопки «ОК» Visual Studio будет добавить (и открыть) DinnerTest.cs файл в проект:

![](enable-automated-unit-testing/_static/image4.png)

В шаблоне модульного теста по умолчанию Visual Studio имеет множество стереотипного кода внутри него, найти немного запутанным. Давайте Очистка его должен просто содержать приведенный ниже код:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample1.cs)]

Атрибут [TestClass] на приведенный выше класс DinnerTest определяет его как класс, который будет содержать тесты, а также дополнительный тест инициализации и деинициализации кода. Тесты в ней можно определить путем добавления открытых методов, на которых установлена атрибутом [TestMethod].

Ниже приведены первое из двух тестов для, мы добавим наш класс ужин. Первый тест проверяет, что нашей компании Dinner является недопустимым, если новый Dinner создается без правильно задать все свойства. Второй тест проверяет действительность нашей компании Dinner при Dinner имеет все свойства, заданные с допустимыми значениями:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample2.cs)]

Вы заметите выше, явным образом (и отчасти verbose) нашей имен тестов. Мы делаем это, так как мы может оказаться, что создание сотни или тысячи Мелкие тесты, и мы хотим упростить процесс, можно быстро определить назначение и поведение каждого из них (в особенности мы ищем по списку ошибок в средство выполнения тестов). Имена тестов должны называться после функциональные возможности, которые они предназначены для проверки. Выше мы используем «существительное\_следует\_глагол «шаблон именования.

Мы структурирование тесты с помощью pattern — предназначенную для «Размещение, Act, Assert» тестирование «AAA»:

- Упорядочите: Единица тестируемой программы установки
- ACT: Упражнение модульного теста и записать результаты
- Утверждение: Проверьте поведение

При написании тестов, мы хотим избежать отдельные тесты сделать слишком многое. Вместо этого каждый тест следует проверить только единую концепцию (что сделает его гораздо легче определить причину сбоев). Рекомендуется является попробовать и иметь только один assert инструкции для каждого теста. При наличии более одного оператора в методе теста контроля, убедитесь, что они все используются для тестирования совпадает с концепцией. Если вы сомневаетесь, сделайте еще один тест.

### <a name="running-tests"></a>Выполнение тестов

Visual Studio 2008 Professional (и более поздние версии) включает в себя встроенные тестов, которые можно использовать для выполнения модульных тестов Visual Studio проектов интегрированной среды разработки. Мы можем выбрать **Test -&gt;выполнения -&gt;все тесты в решении** меню команды (или нажмите клавиши Ctrl-R, A) для выполнения всех наших модульных тестов. Или в качестве альтернативы можно поместите курсор внутри конкретного класса или тестового метода и использовать **Test -&gt;выполнения -&gt;тесты в текущем контексте** команды меню (или нажмите клавиши Ctrl-R, T), чтобы выполнить модульных тестов.

Давайте поместите курсор внутри класса DinnerTest и введите «Ctrl R, T» выполнение двух тестов, который мы только что определили. Когда для этого мы окне «Результаты теста» будет отображаться в Visual Studio, и мы увидим результаты тестового выполнения перечисленных в нем:

![](enable-automated-unit-testing/_static/image5.png)

*Примечание. В окне результатов теста VS не содержит столбца имя класса по умолчанию. Это можно добавить, щелкнув правой кнопкой мыши в окне результатов теста с помощью команды меню Добавить или удалить столбцы.*

Наши два тесты занимали только доли секунды для выполнения – и как вы можете см. оба они передаются. Теперь можно перейти и дополнять их, создав другие тесты, которые проверить конкретное правило проверки, а также рассматриваются два вспомогательных метода - IsUserHost() и IsUserRegistered() —, мы добавили в класс Dinner. Так все эти тесты находятся в месте для класса Dinner сделает его намного легче и безопаснее добавить новые бизнес-правила и проверки к нему в будущем. Мы ужином можно добавить логику новые правила и затем в течение нескольких секунд убедиться, что он еще не нарушают любой из наших прежние функции логики.

Обратите внимание на то, как с помощью теста описательное имя позволяет быстро понять, что выполняется проверка каждого теста. Я рекомендую использовать **Сервис -&gt;параметры** команды меню, открыв тестирования Сервис -&gt;экран настройки выполнения тестов и проверки «дважды щелкните результат теста неудачных или с неопределенным результатом отображается флажок точки сбоя в тесте». Это позволит вам дважды щелкните ошибку в окне результатов теста и мгновенного перехода к Сбой утверждения.

### <a name="creating-dinnerscontroller-unit-tests"></a>Создание DinnersController модульных тестов

Теперь создадим несколько модульных тестов, которые проверяют нашего функционала DinnersController. Мы начнем, щелкнув правой кнопкой папку «Контроллеры», в тестовый проект и затем выберите **Add -&gt;новый тест** команды меню. Мы будем создайте «Unit Test» и назовите его «DinnersControllerTest.cs».

Мы создадим два метода теста, которые проверяют на метод действия Details() в DinnersController. Первый убедитесь, что представление возвращается при запросе существующие компании Dinner. Второй убедитесь, что представление «NotFound» возвращается при запросе Dinner несуществующие:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample3.cs)]

Очистка компилирует код, представленный выше. При запуске тестов, однако завершаются с ошибкой:

![](enable-automated-unit-testing/_static/image6.png)

Если взглянуть на сообщения об ошибках, мы увидим, что причина Тест завершен с ошибкой был так, как наш класс DinnersRepository не удалось соединиться с базой данных. Наше приложение NerdDinner использует строку подключения в локальный файл SQL Server Express, которая находится в разделе \App\_каталог данных NerdDinner проекта приложения. Поскольку наш проект NerdDinner.Tests компилируется и выполняется в другой каталог и затем проект приложения, неправильный относительный путь, где нашу строку подключения.

Мы *удалось* устранить эту проблему путем копирования файла базы данных SQL Express в тестовый проект, а затем добавьте проверки-строку подключения к нему, в файле App.config нашего тестового проекта. Это будет вышеуказанные тесты разблокировано и под управлением.

Модульное тестирование кода, с помощью реальной базе данных, однако предлагает ряд проблем. В частности:

- Он значительно замедляет времени выполнения модульных тестов. Чем дольше необходимое для выполнения тестов, тем меньше вероятность, вы должны выполнять их часто. Вы в идеале модульные тесты, чтобы иметь возможность запускать в секундах — и должны быть это можно сделать как естественным образом, как компиляции проекта.
- Это усложняет логику установки и очистки в тесты. Требуется, чтобы каждый модульный тест был изолированным и независимым от остальных (с помощью побочных эффектов или зависимостей). При работе с реальной базой данных необходимо учитывать состояние и сбрасывать его между тестами.

Давайте взглянем на шаблон, который называется «внедрение зависимостей», которые могут помочь нам решить эти проблемы и избежать необходимости использовать реальную базу данных с помощью наших тестов.

### <a name="dependency-injection"></a>Внедрение зависимостей

Прямо сейчас DinnersController «тесно» к классу DinnerRepository. «Соединение» относится к ситуации, где класс явно зависит от другого класса для работы:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample4.cs)]

Так как класс DinnerRepository требуется доступ к базе данных, тесно связанных зависимостей в классе DinnersController есть на концах DinnerRepository вверх необходимости мы получили базу данных в порядке для методов действий DinnersController проверяемый.

Можно обойти это, используя шаблон, который называется «внедрение зависимостей» — это подход, где больше не неявного создания зависимостей (например, репозиторий классы, предоставляющие доступ к данным) в классах, которые их используют. Вместо этого зависимости можно явно передать класс, который использует их с помощью аргументов конструктора. Если зависимости определяются с помощью интерфейсов, мы получаем гибкость доходить до реализаций «фальшивая» зависимостей для модульного тестирования сценариев. Это позволяет нам создать зависимость относится к тесту реализации, которые фактически не требуется доступ к базе данных.

Чтобы увидеть это в действии, давайте внедрения зависимостей с помощью наших DinnersController.

#### <a name="extracting-an-idinnerrepository-interface"></a>Извлечение интерфейса IDinnerRepository

Нашим первым этапом является создание новый интерфейс IDinnerRepository, инкапсулирующий наших контроллеров, необходимых для извлечения и обновления ужинов контракт репозитория.

Этот интерфейс контракта можно определить вручную, щелкнув правой кнопкой мыши на папку \Models и выбрав **Add -&gt;новый элемент** команды меню и создается с именем IDinnerRepository.cs интерфейс.

Также мы использовать автоматически рефакторинг средства встроены в Visual Studio Professional (и более поздние версии) для извлечения и создать интерфейс для нас от наших существующий класс DinnerRepository. Чтобы извлечь этот интерфейс, с помощью VS, просто поместите курсор в текстовом редакторе в классе DinnerRepository и затем щелкните правой кнопкой мыши и выберите **Refactor -&gt;извлечение интерфейса** команды меню:

![](enable-automated-unit-testing/_static/image7.png)

Это будет открыть диалоговое окно «Извлечение интерфейса» и запрашивать нами имя интерфейса для создания. Он будет по умолчанию IDinnerRepository и автоматически выбрать все открытые методы в классе DinnerRepository для добавления к интерфейсу:

![](enable-automated-unit-testing/_static/image8.png)

При нажатии кнопки «ОК», Visual Studio добавит новый интерфейс IDinnerRepository в наше приложение:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample5.cs)]

И наши существующий класс DinnerRepository обновится, чтобы он реализовал интерфейс:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample6.cs)]

#### <a name="updating-dinnerscontroller-to-support-constructor-injection"></a>Обновление DinnersController для поддержки внедрение через конструктор

Теперь мы обновим DinnersController класс для использования нового интерфейса.

В настоящее время DinnersController жестко задано таким образом, что его поля «dinnerRepository» всегда является классом DinnerRepository:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample7.cs)]

Мы изменим его, чтобы поле «dinnerRepository» имеет тип IDinnerRepository вместо DinnerRepository. Затем мы добавим два общих конструктора DinnersController. Один из конструкторов разрешает IDinnerRepository передается как аргумент. Второе — конструктор по умолчанию, использующий наших существующей реализации DinnerRepository:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample8.cs)]

Так как MVC ASP.NET по умолчанию создает классы контроллера, используя конструкторы по умолчанию, наши DinnersController во время выполнения будет продолжать класс DinnerRepository для осуществления доступа к данным.

Теперь мы можем обновить наших модульные тесты, однако для передачи в реализацию repository «фальшивая» обед, с помощью параметра конструктора. Этот репозиторий «фальшивая» компании dinner не требуется доступ к любой настоящей базе данных и вместо этого образца in-memory данные будут использоваться.

#### <a name="creating-the-fakedinnerrepository-class"></a>Создание класса FakeDinnerRepository

Давайте создадим класс FakeDinnerRepository.

Мы начнем с создания каталога «Fakes» в нашем проекте NerdDinner.Tests и затем добавьте новый класс FakeDinnerRepository к нему (папку правой кнопкой мыши и выберите **Add -&gt;новый класс**):

![](enable-automated-unit-testing/_static/image9.png)

Мы обновим код, чтобы класс FakeDinnerRepository реализует интерфейс IDinnerRepository. Затем можно его правой кнопкой мыши и выберите из контекстного меню команду «Реализовать интерфейс IDinnerRepository»:

![](enable-automated-unit-testing/_static/image10.png)

Это приведет к Visual Studio для автоматического добавления всех членов интерфейса IDinnerRepository к нашему классу FakeDinnerRepository с реализациями «заглушки» по умолчанию:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample9.cs)]

Затем можно обновлять реализации работу над список в памяти, что FakeDinnerRepository&lt;Dinner&gt; коллекции, переданного в качестве аргумента конструктора:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample10.cs)]

Теперь у нас есть это фиктивный IDinnerRepository реализация, которая необходима база данных, а вместо этого можно работы за пределами список в памяти объектов, компания Dinner.

#### <a name="using-the-fakedinnerrepository-with-unit-tests"></a>С помощью FakeDinnerRepository с модульными тестами

Давайте вернемся к DinnersController модульные тесты, которые ранее сбой базы данных был недоступен. Позволяет обновлять используемые методы теста FakeDinnerRepository, заполненную данными компании Dinner пример выполняющейся в памяти DinnersController, с помощью следующего кода:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample11.cs)]

И теперь при запуске этих тестов они оба передайте:

![](enable-automated-unit-testing/_static/image11.png)

Лучше всего они принимают только небольшую часть второй — для запуска и не требуют логику сложной настройки или очистки. Мы можем теперь, модульный тест все наши код DinnersController действие метода (включая перечисления, разбиение по страницам, сведения, создание, обновление и удаление) без подведена для подключения к любой настоящей базе данных.

| **Тема стороне: Платформы внедрения зависимостей** |
| --- |
| Выполнение внедрения вручную зависимостей (например, превышающие) работает отлично, но становится еще сложнее обслуживать как число зависимостей, и увеличивает компонентов в приложении. Для .NET, которая обеспечивает большую гибкость управления зависимостей существует несколько платформы внедрения зависимостей. Эти платформы, иногда называют «контейнеры Inversion of Control» (IoC), предоставляют механизмы, позволяющие дополнительный уровень поддержки конфигурации для указания и передачи объектов во время выполнения (чаще всего с помощью внедрения через конструктор зависимостей ). Некоторые из наиболее популярных внедрения зависимостей OSS / include инфраструктур IOC в .NET: AutoFac, Ninject, Spring.NET, StructureMap и Windsor. ASP.NET MVC предоставляет интерфейсы API, позволяющие разработчикам для участия в решение и создание контроллеров и который обеспечивает внедрение зависимостей расширения / инфраструктур IoC полностью интегрированы в рамках данного процесса. С помощью внедрения Зависимостей и IOC платформы также позволит нам для удаления из наших DinnersController — что бы полностью удалить связь между ним и DinnerRepository конструктор по умолчанию. Мы не будем использовать внедрение зависимостей и инфраструктуры IOC с наше приложение NerdDinner. Но то, что мы можем рассмотреть в будущем, если NerdDinner базы кода и возможности роста. |

### <a name="creating-edit-action-unit-tests"></a>Создание модульных тестов изменить действие

Теперь создадим несколько модульных тестов, которые проверяют DinnersController функциональные возможности редактирования. Мы начнем с проверки HTTP-GET версии наших действие изменения:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample12.cs)]

Мы создадим тест, который проверяет, что визуализации представления, поддерживаемый объект DinnerFormViewModel обратно в том случае, когда запрашивается допустимым dinner:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample13.cs)]

При запуске теста, но очень скоро найдется что происходит сбой, поскольку при метода Edit обращается к свойству User.Identity.Name выполнить проверку Dinner.IsHostedBy() исключение пустой ссылки.

Объект User на базовый класс контроллера инкапсулирует сведения о вошедшего в систему пользователя и заполняется платформой ASP.NET MVC, при создании контроллера во время выполнения. Так как мы тестируем DinnersController за пределами среды веб сервера, объект пользователя не задано (поэтому пустая ссылка на исключение).

### <a name="mocking-the-useridentityname-property"></a>Макетирование свойство User.Identity.Name

Инфраструктур макетирования упростить тестирование, благодаря чему мы можем динамически создавать фиктивные версии зависимых объектов, которые поддерживают наших тестов. Например можно использовать инфраструктуру макетирования в наш тест действие редактирования для динамического создания объекта пользователя, наши DinnersController можно использовать для уточняющего запроса имитации имя пользователя. Это позволит избежать ссылкой на null исключение при запуске нашего теста.

Существует множество .NET платформы, которые могут использоваться с ASP.NET MVC имитации (список из них здесь вы найдете: [ http://www.mockframeworks.com/ ](http://www.mockframeworks.com/)). Для тестирования наше приложение NerdDinner, мы будем использовать макетирование структуру, называемую «Moq» открытый код, который можно загрузить бесплатно из [ http://www.mockframeworks.com/moq ](http://www.mockframeworks.com/moq).

После загрузки, мы добавим ссылку в нашем проекте NerdDinner.Tests Moq.dll сборки:

![](enable-automated-unit-testing/_static/image12.png)

Затем мы добавим «CreateDinnersControllerAs(username)» вспомогательный метод для наших тестового класса, который принимает в качестве параметра и что имя пользователя, а затем свойство User.Identity.Name на экземпляре DinnersController «mocks»:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample14.cs)]

Выше мы используем Moq для создания объекта макет, который имитирует объект параметром ControllerContext (который передает в классы контроллера для представления объектов среды выполнения, например пользователя, запроса, ответа и сеанса ASP.NET MVC). Мы вызов метода «SetupGet» на макете, чтобы указать, что свойство HttpContext.User.Identity.Name параметром ControllerContext должна возвращать строку имени пользователя, которую мы передали вспомогательный метод.

Мы можете создать макет любое количество параметром ControllerContext свойства и методы. В качестве примера я также добавил вызов SetupGet() для свойства Request.IsAuthenticated (которой не нужен для тестов ниже — но что позволяет продемонстрировать, как вы можете создать макет свойства запроса). Когда Готово мы присвоить экземпляр параметром ControllerContext фиктивного объекта DinnersController, возвращает наших вспомогательный метод.

Теперь можно написать модульные тесты, использующие этот вспомогательный метод для проверки сценариев редактирования с использованием разных пользователей:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample15.cs)]

И теперь при запуске тестов они передайте:

![](enable-automated-unit-testing/_static/image13.png)

### <a name="testing-updatemodel-scenarios"></a>UpdateModel() сценариев тестирования

Мы создали тесты, использующие версию HTTP-GET действие изменения. Давайте теперь создадим некоторые тесты, проверяющие версию HTTP-POST действие изменения.

[!code-csharp[Main](enable-automated-unit-testing/samples/sample16.cs)]

Интересный новый сценарий тестирования поддержки с данным методом действия является использование UpdateModel() вспомогательный метод в базовом классе контроллера. Мы используем этот вспомогательный метод для привязки значений формы post на наш экземпляр объекта Dinner.

Ниже приведены два теста, которые демонстрирует, как мы можем передать форму, передаваемую значения для вспомогательного метода UpdateModel() для использования. Мы это сделать, создании и заполнении объекта FormCollection и затем присвоить его свойству «Значение ValueProvider» на контроллере.

Первый тест проверяет, что на сохранение успешным браузер перенаправляется на действие details. Второй тест проверяет, что при отправке недопустимые входные данные действия повторно отображает представление изменения еще раз с сообщением об ошибке.

[!code-csharp[Main](enable-automated-unit-testing/samples/sample17.cs)]

### <a name="testing-wrap-up"></a>Тестирование заключение

Мы рассмотрели основные понятия, связанные с модульного тестирования классы контроллера. Эти методы можно использовать без труда создавать сотни простые тесты, проверяющие работу нашего приложения.

Поскольку наш контроллера и модели тесты не требуют реальную базу данных, они очень быстро и легко запускать. Мы сможем выполнять сотни автоматических тестов в секундах и немедленно получить обратную связь относительно ли мы внесли Изменение привело к нарушению что-то. Это поможет предоставить нам достоверности для непрерывного повышения рефакторинга и уточнить нашего приложения.

Мы узнали, что тестирование как последний раздел, в этой главе — но не потому, что тестирование — что-то делать в конце процесса разработки! Напротив следует писать автоматические тесты как можно раньше в процессе разработки. Таким образом, это позволяет получать немедленные отзывы в процессе разработки, помогает продуманным подумать о сценариев вариантов использования приложения и описывает, как разрабатывать приложение с чистой, наложение и увязку в виду.

Одной из следующих глав в книге будут рассмотрены разработки на основе тестирования (TDD) и способы его использования с ASP.NET MVC. TDD проектируется итеративный правильна сначала тесты, которые удовлетворяют полученный код. В случае TDD каждой функции начните с создания теста, который проверяет функциональные возможности, которые вы собираетесь реализовать. Написания модульных тестов помогает сначала необходимо четко понимать, эта функция и как он должен работать. Только после записи теста (и вы проверили, что не удается) вы, а затем реализовать проверяет функциональность теста. Так как вы уже провели времени на размышления о том, как эта функция должна работать в случае использования, будет иметь хорошее представление о требованиях и предоставит оптимальный способ их реализации. Когда вы закончите с реализацией, можно повторно запустить тест — и получить немедленный отзыв как для ли эта функция работает правильно. Мы обсудим TDD более в главе 10.

### <a name="next-step"></a>Следующий шаг

Некоторые окончательного переноса по словам комментариев.

> [!div class="step-by-step"]
> [Назад](use-ajax-to-implement-mapping-scenarios.md)
> [Вперед](nerddinner-wrap-up.md)
