---
uid: mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
title: Включить автоматизированное модульное тестирование (ru) Документы Майкрософт
author: rick-anderson
description: Шаг 12 показывает, как разработать набор автоматизированных модульных тестов, которые проверяют нашу функциональность NerdDinner, и которая даст нам уверенность, чтобы внести изменения ...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: a19ff2ce-3f7e-4358-9a51-a1403da9c63e
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
msc.type: authoredcontent
ms.openlocfilehash: 7fe84efd9e4cc359c19d5ab9e22c579b80207e9c
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81541472"
---
# <a name="enable-automated-unit-testing"></a>Включение автоматического модульного тестирования

[корпорацией Майкрософт](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 12 бесплатно ["NerdDinner" приложение учебник,](introducing-the-nerddinner-tutorial.md) который ходит через как построить небольшой, но полный, веб-приложение с использованием ASP.NET MVC 1.
> 
> Шаг 12 показывает, как разработать набор автоматизированных модульных тестов, которые проверяют нашу функциональность NerdDinner, и которые дадут нам уверенность, чтобы внести изменения и улучшения в приложение в будущем.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем вам следовать [начиная с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.

## <a name="nerddinner-step-12-unit-testing"></a>NerdDinner Шаг 12: Модульное тестирование

Давайте разработаем набор автоматизированных модульных тестов, которые проверяют нашу функциональность NerdDinner, и которые дадут нам уверенность в том, что в будущем мы внедрим изменения и усовершенствования приложения.

### <a name="why-unit-test"></a>Почему модульный тест?

На диске на работу однажды утром у вас есть внезапная вспышка вдохновения о приложении вы работаете. Вы понимаете, что есть изменения, которые можно реализовать, которые сделают приложение значительно лучше. Это может быть рефакторинг, который очищает код, добавляет новую функцию или исправляет ошибку.

Вопрос, который стоит перед вами, когда вы приедете на ваш компьютер - "как безопасно это сделать это улучшение?" Что делать, если внесение изменений имеет побочные эффекты или что-то ломает? Изменение может быть простым и займет всего несколько минут, но что делать, если это займет несколько часов, чтобы вручную проверить все сценарии приложения? Что делать, если вы забыли охватить сценарий и сломанное приложение переходит в производство? Является ли это улучшение действительно стоит всех усилий?

Автоматизированные модульные тесты могут обеспечить защитную сетку, которая позволяет постоянно улучшать приложения и не бояться кода, над которым вы работаете. Автоматизированные тесты, которые быстро проверяют функциональность, позволяют с уверенностью кодировать и позволяют вам вносить улучшения, которые в противном случае могли бы не чувствовать себя комфортно. Они также помогают создавать решения, которые являются более обслуживаемыми и имеют более длительный срок службы, что приводит к гораздо более высокой отдаче от инвестиций.

ASP.NET MVC Framework упрощает и естественна функциональность модульных тестов. Он также позволяет работать на основе разработки test Driven Development (TDD), который позволяет проводить разработку на основе тестов.

### <a name="nerddinnertests-project"></a>Проект NerdDinner.Tests

Когда мы создали наше приложение NerdDinner в начале этого учебника, нам было предложено с диалогом с просьбой, хотим ли мы создать модульный проект тестирования, чтобы идти вместе с проектом приложения:

![](enable-automated-unit-testing/_static/image1.png)

Мы сохранили радио-кнопку "Да, создайте модульный тест", которая привела к добавлению в наше решение проекта "NerdDinner.Tests":

![](enable-automated-unit-testing/_static/image2.png)

Проект NerdDinner.Tests ссылается на сборку проекта приложения NerdDinner и позволяет нам легко добавлять в него автоматизированные тесты, проверяющие функциональность приложения.

### <a name="creating-unit-tests-for-our-dinner-model-class"></a>Создание модульных тестов для нашего класса модели ужина

Давайте добавим некоторые тесты в наш проект NerdDinner.Tests, которые проверяют класс Ужина, который мы создали, когда строили наш модельный слой.

Начнем с создания новой папки в рамках нашего тестового проекта под названием "Модели", где мы разместим наши тесты, связанные с моделью. Затем мы нажмем правой кнопкой мыши на папку и выберем команду **меню Add-&gt;New Test.** Это позволит поднять диалог "Добавить новый тест".

Мы выберем для создания "Единый тест" и назвать его "DinnerTest.cs":

![](enable-automated-unit-testing/_static/image3.png)

При нажатии кнопки "ОК" Visual Studio добавит (и откроет) DinnerTest.cs файл в проект:

![](enable-automated-unit-testing/_static/image4.png)

По умолчанию Visual Studio модуль ный тест шаблон имеет кучу котла пластины код в нем, что я нахожу немного грязный. Давайте очистим его, чтобы просто содержать код ниже:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample1.cs)]

Атрибут «TestClass» на классе DinnerTest выше определяет его как класс, который будет содержать тесты, а также дополнительный тест инициализации и слезоточивый код. Мы можем определить тесты в нем, добавив общедоступные методы, которые имеют атрибут «TestMethod».

Ниже приведены первые из двух тестов, которые мы добавим, что осуществлять наш ужин класса. Первый тест проверяет, что наш ужин является недействительным, если новый ужин создан без правильного набора всех свойств. Второй тест проверяет, что наш ужин действителен, когда ужин имеет все свойства, установленные с действительными значениями:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample2.cs)]

Вы заметите выше, что наши имена испытаний очень явные (и несколько многословный). Мы делаем это потому, что мы могли бы в конечном итоге создать сотни или тысячи небольших тестов, и мы хотим, чтобы сделать его легко быстро определить намерения и поведение каждого из них (особенно, когда мы смотрим через список неудач в тест бегун). Имена тестов должны быть названы в честь функциональности, которые они тестируют. Выше мы используем шаблон\_именования "Существительный должен\_глагол".

Мы структурируем тесты с использованием шаблона тестирования "AAA" - который означает "Устройте, действуйте, утверждайте":

- Упорядочить: Настройка проверяемого устройства
- Закон: Упражнение единицы под тест и захват результатов
- Утверждение: Проверить поведение

Когда мы пишем тесты, мы хотим избежать того, чтобы отдельные тесты делали слишком много. Вместо этого каждый тест должен проверить только одну концепцию (которая значительно упростит выявление причин сбоев). Хорошим ориентиром является попытка и только одно утверждение заявление для каждого теста. Если в тестовом методе у вас есть несколько утверждений, убедитесь, что все они используются для тестирования одной и той же концепции. Если вы сомневаетесь, сделайте еще один тест.

### <a name="running-tests"></a>Выполнение тестов

Visual Studio 2008 Professional (и высшие издания) включает в себя встроенный тест-раннер, который может быть использован для запуска проектов Visual Studio Unit Test в рамках IDE. Мы можем выбрать **команду меню Test-&gt;Run-&gt;All Tests в** меню решения (или тип Ctrl R, A), чтобы выполнить все наши модульные тесты. Или же мы можем позиционировать наш курсор в определенном тестовом классе или тестовом методе и использовать **тест-выполнить-&gt;&gt;тесты в текущей** команде меню контекста (или типа Ctrl R, T) для запуска подмножества модульных тестов.

Давайте позиционировать наш курсор в классе DinnerTest и типа "Ctrl R, T", чтобы запустить два теста мы только что определили. Когда мы сделаем это, в Visual Studio появится окно "Результаты тестирования", и мы увидим результаты нашего тестового запуска, перечисленные в нем:

![](enable-automated-unit-testing/_static/image5.png)

*Примечание: Окно результатов тестирования VS не показывает столбец «Название класса» по умолчанию. Вы можете добавить это путем нажатия правого нажатия в окне результатов тестирования и с помощью команды меню Добавления/Удалить столбцы.*

Наши два теста заняли лишь долю секунды, чтобы запустить - и, как вы можете видеть, они оба прошли. Теперь мы можем продолжать и дополнять их, создавая дополнительные тесты, которые проверяют конкретные проверки правил, а также охватывают два метода помощника - IsUserHost() и IsUserRegistered () - которые мы добавили в класс Ужина. Наличие всех этих тестов для класса Dinner значительно упростит и безопаснее добавить к нему новые бизнес-правила и проверки в будущем. Мы можем добавить нашу новую логику правила в Dinner, а затем в течение нескольких секунд убедиться, что она не нарушила ни одной из наших предыдущих функций логики.

Обратите внимание, что использование описательного тестового имени позволяет быстро понять, что проверяет каждый тест. Я рекомендую использовать команду меню **&gt;«Инструменты- параметры»,** открывая экран конфигурации test Tools-&gt;Test Execution и проверяя «Двойной нажав неудачный или неубедительный результат теста единицы отображает точку сбоя в контрольном флажке теста». Это позволит вам дважды нажать на сбой в окне результатов тестирования и немедленно перейти к утверждению отказа.

### <a name="creating-dinnerscontroller-unit-tests"></a>Создание обедсконтроллерных модульных тестов

Давайте создадим несколько модульных тестов, которые проверяют нашу функциональность DinnersController. Начнем с правильного нажатия на папку "Контролеры" в нашем тестовом проекте, а затем выберем команду **меню Add-&gt;New Test.** Мы создадим "Единый тест" и назовем его "DinnersControllerTest.cs".

Мы создадим два метода тестирования, которые проверяют метод действия Детали () на DinnersController. Первый проверит, возвращается ли представление при запросе существующего ужина. Второй удостоверится, что представление "NotFound" возвращается при запросе несуществующего ужина:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample3.cs)]

Вышеуказанный код компилируется чистым. Однако при запуске тестов они оба проваливаются:

![](enable-automated-unit-testing/_static/image6.png)

Если мы посмотрим на сообщения об ошибках, мы увидим, что причина неудачных тестов была в том, что наш класс DinnersRepository не смог подключиться к базе данных. Наше приложение NerdDinner использует строку подключения к локальному файлу S'L Server Express, который живет в каталоге\_данных приложения NerdDinner. Поскольку наш проект NerdDinner.Tests компилирует и выполняетв в другом каталоге, чем проект приложения, относительное расположение пути нашей строки соединения неверно.

Мы *могли бы* исправить это, скопируя файл базы данных S'L Express в наш тестовый проект, а затем добавить соответствующую тестовую строку подключения к нему в App.config нашего тестового проекта. Это позволит получить выше тесты разблокированы и работает.

Однако код модульного тестирования с использованием реальной базы данных сопряжен с рядом проблем. В частности:

- Это значительно замедляет время выполнения модульных тестов. Чем больше времени требуется для выполнения тестов, тем меньше вероятность их частого выполнения. В идеале вы хотите, чтобы ваши модульные тесты могли быть запущены в считанные секунды – и это будет что-то, что вы делаете так же естественно, как компиляция проекта.
- Это усложняет логику настройки и очистки в тестах. Вы хотите, чтобы каждый модульный тест был изолирован и независим от других (без побочных эффектов или зависимостей). При работе с реальной базой данных вы должны помнить о состоянии и сбросить его между тестами.

Давайте рассмотрим шаблон проектирования, называемый «инъекцией зависимости», который может помочь нам обойти эти проблемы и избежать необходимости использования реальной базы данных с нашими тестами.

### <a name="dependency-injection"></a>Внедрение зависимостей

Сейчас DinnersController плотно "связан" с классом DinnerRepository. "Соединение" относится к ситуации, когда класс явно полагается на другой класс для работы:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample4.cs)]

Поскольку класс DinnerRepository требует доступа к базе данных, тесно связанная зависимость класса DinnersController от DinnerRepository заканчивается тем, что мы должны иметь базу данных для тестирования методов действий DinnersController.

Мы можем обойти это, используя шаблон проектирования, называемый "инъекцией зависимости" - это подход, при котором зависимости (например, классы репозитория, обеспечивающие доступ к данным) больше не являются неявно созданными в классах, которые их используют. Вместо этого зависимости могут быть явно переданы классу, который использует их с помощью аргументов конструктора. Если зависимости определяются с помощью интерфейсов, мы должны иметь гибкость, чтобы передать в "поддельных" реализаций зависимостей для сценариев модульных тестов. Это позволяет нам создавать реализации зависимостей, специфичным для тестирования, которые на самом деле не требуют доступа к базе данных.

Чтобы увидеть это в действии, давайте внедрим инъекцию зависимости с нашим DinnersController.

#### <a name="extracting-an-idinnerrepository-interface"></a>Извлечение интерфейса IDinnerRepository

Наш первый шаг будет заключаться в создании нового интерфейса IDinnerRepository, который инкапсулирует репозиторий контракт наши контроллеры требуют для извлечения и обновления Dinners.

Мы можем определить этот контракт интерфейса вручную, нажав правой кнопкой на папку «Модели», а затем выбрав команду меню **Add-&gt;New Item** и создав новый интерфейс под названием IDinnerRepository.cs.

Кроме того, мы можем использовать инструменты рефакторинга, встроенные visual Studio Professional (и более высокие издания), чтобы автоматически извлечь и создать интерфейс для нас из нашего существующего класса DinnerRepository. Чтобы извлечь этот интерфейс с помощью VS, просто расположите курсор в текстовом редакторе на классе DinnerRepository, а затем нажмите правой кнопкой мыши и выберите команду меню **Refactor-&gt;Extract Interface:**

![](enable-automated-unit-testing/_static/image7.png)

Это запустит диалог "Extract Interface" и подскажет нам название интерфейса для создания. Он будет по умолчанию IDinnerRepository и автоматически выбрать все общедоступные методы на существующем классе DinnerRepository, чтобы добавить в интерфейс:

![](enable-automated-unit-testing/_static/image8.png)

Когда мы нажмем кнопку "ОК", Visual Studio добавит в наше приложение новый интерфейс IDinnerRepository:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample5.cs)]

И наш существующий класс DinnerRepository будет обновлен так, что он реализует интерфейс:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample6.cs)]

#### <a name="updating-dinnerscontroller-to-support-constructor-injection"></a>Обновление DinnersController для поддержки впрыска конструктора

Теперь мы обновим класс DinnersController, чтобы использовать новый интерфейс.

В настоящее время DinnersController жестко закодирован так, что его "dinnerRepository" поле всегда DinnerRepository класса:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample7.cs)]

Мы изменим его так, чтобы поле "dinnerRepository" было типа IDinnerRepository вместо DinnerRepository. Затем мы добавим два публичных конструктора DinnersController. Один из конструкторов позволяет IDinnerRepository быть переданы в качестве аргумента. Другой конструктор по умолчанию, который использует нашу существующую реализацию DinnerRepository:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample8.cs)]

Поскольку ASP.NET MVC по умолчанию создает классы контроллеров с использованием конструкторов по умолчанию, наш DinnersController во время выполнения будет продолжать использовать класс DinnerRepository для выполнения доступа к данным.

Теперь мы можем обновить наши модульные тесты, однако, чтобы пройти в "поддельных" реализации репозитория ужина с помощью конструктора параметров. Этот "поддельный" обеденный репозиторий не потребует доступа к реальной базе данных, а вместо этого будет использовать данные образца памяти.

#### <a name="creating-the-fakedinnerrepository-class"></a>Создание класса FakeDinnerRepository

Давайте создадим класс FakeDinnerRepository.

Мы начнем с создания каталога "Fakes" в рамках нашего проекта NerdDinner.Tests, а затем добавим к нему новый класс FakeDinnerRepository (справа нажмите на папку и выберите **Add-&gt;New Class):**

![](enable-automated-unit-testing/_static/image9.png)

Мы обновим код таким образом, чтобы класс FakeDinnerRepository реализовал интерфейс IDinnerRepository. Затем мы можем нажать на него правой кнопкой мыши и выбрать команду контекстного меню "Implement interface IDinnerpository":

![](enable-automated-unit-testing/_static/image10.png)

Это приведет к тому, что Visual Studio автоматически добавит все члены интерфейса IDinnerRepository в наш класс FakeDinnerRepository с реализациями по умолчанию:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample9.cs)]

Затем мы можем обновить реализацию FakeDinnerRepository для работы&lt;&gt; с коллекцией в списке памяти, переданной ему в качестве аргумента конструктора:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample10.cs)]

Теперь у нас есть поддельные IDinnerRepository реализации, которая не требует базы данных, и вместо этого может отработать в памяти список объектов ужин.

#### <a name="using-the-fakedinnerrepository-with-unit-tests"></a>Использование FakeDinnerRepository с модульными тестами

Вернемся к модульным тестам DinnersController, которые не удались ранее из-за того, что база данных была недоступна. Мы можем обновить методы тестирования, чтобы использовать FakeDinnerRepository, населенный с образцами данных в памяти, на DinnersController, используя приведенный ниже код:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample11.cs)]

И теперь, когда мы проводим эти тесты они оба проходят:

![](enable-automated-unit-testing/_static/image11.png)

Лучше всего, они принимают только часть секунды для запуска, и не требуют каких-либо сложных настройки / очистки логики. Теперь мы можем уединить тест ировать весь наш код метода действия DinnersController (включая перечисление, paging, детали, создание, обновление и удаление) без необходимости подключения к реальной базе данных.

| **Боковая тема: Рамки впрыски в зависимости** |
| --- |
| Выполнение инъекций ручной зависимости (как мы выше) работает нормально, но становится все труднее поддерживать, как количество зависимостей и компонентов в приложении увеличивается. Для .NET существует несколько инфраструктур впрыска зависимостей, которые могут обеспечить еще большую гибкость управления зависимостью. Эти фреймворки, также иногда называемые контейнерами «Инверсия управления» (IoC), обеспечивают механизмы, позволяющие поддерживать дополнительный уровень конфигурации для определения и передачи зависимостей объектам во время выполнения (чаще всего с помощью впрыска конструктора). Некоторые из наиболее популярных инфраструктур зависимостей OSS / МОК в .NET включают в себя: AutoFac, Ninject, Spring.NET, StructureMap и Windsor. ASP.NET MVC предоставляет расширяемую aIs, которая позволяет разработчикам участвовать в разрешении и мгновенности контроллеров, и которая позволяет системы инъекций зависимости / IoC быть чисто интегрированы в этот процесс. Использование системы DI/IOC также позволит нам удалить конструктор по умолчанию из нашего DinnersController, что полностью удалит связь между ним и DinnerRepository. Мы не будем использовать инъекцию зависимости / МОК рамки с нашим приложением NerdDinner. Но это то, что мы могли бы рассмотреть на будущее, если NerdDinner код-базы и возможности выросли. |

### <a name="creating-edit-action-unit-tests"></a>Создание тестов группы действий по отдействию

Давайте создадим некоторые модульные тесты, которые проверяют функциональность edit Of the DinnersController. Начнем с тестирования версии HTTP-GET нашего действия по edit:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample12.cs)]

Мы создадим тест, который проверяет, что просмотр, поддерживаемый объектом DinnerFormViewModel, отображается назад при запросе действительного ужина:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample13.cs)]

Однако при запуске теста мы обнаружим, что он не выполняется, поскольку при доступе к User.Identity.Name-прежнему используется метод Edit, который получает доступ к свойству User.Identity.Name для выполнения проверки Dinner.IsHostedBy.)

Объект пользователя в базовом классе Контроллера инкапсулирует сведения о зарегистрированном пользователе и заполняется ASP.NET MVC, когда он создает контроллер во время выполнения. Поскольку мы тестируем DinnersController за пределами среды веб-сервера, объект пользователя не установлен (отсюда и исключение нулевой ссылки).

### <a name="mocking-the-useridentityname-property"></a>Мокинг User.Identity.Name собственности

Платформы Mocking упрощают тестирование, позволяя нам динамически создавать поддельные версии зависимых объектов, поддерживающих наши тесты. Например, мы можем использовать в нашем тесте действий edit action платформу для динамического создания объекта пользователя, который наш DinnersController может использовать для поиска смоделированного имени пользователя. Это позволит избежать нулевой ссылки от бросали, когда мы запускаем наш тест.

Есть много .NET насмешливые рамки, которые могут быть использованы с [http://www.mockframeworks.com/](http://www.mockframeworks.com/)ASP.NET MVC (вы можете увидеть список из них здесь: ). Для тестирования нашего приложения NerdDinner мы будем использовать платформу с открытым исходным кодом [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq)под названием "Moq", которая может быть загружена бесплатно с .

После загрузки мы добавим ссылку в наш проект NerdDinner.Tests в сборку Moq.dll:

![](enable-automated-unit-testing/_static/image12.png)

Затем мы добавим метод-помощник "CreateDinnersControllerAs (username)" в наш тестовый класс, который принимает имя пользователя в качестве параметра, а затем "подсмешит" User.Identity.Name свойством на экземпляре DinnersController:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample14.cs)]

Выше мы используем Moq для создания объекта Mock, который подделывает объект ControllerContext (который является то, что ASP.NET MVC передает в классы контроллера, чтобы разоблачить объекты выполнения, такие как пользователь, запрос, ответ и сессия). Мы вызываем метод "SetupGet" на Mock, чтобы указать, что HttpContext.User.Identity.Name свойство на ControllerContext должны вернуть строку имени пользователя, которую мы передали методу помощника.

Мы можем издеваться над любым количеством свойств и методов ControllerContext. Чтобы проиллюстрировать это, я также добавил SetupGet () вызов для свойства Request.IsAuthenticated (который на самом деле не требуется для тестов ниже, - но который помогает проиллюстрировать, как вы можете макет Свойства запроса). Когда мы закончим, мы назначаем экземпляр макета Controller Наблюду, который возвращает наш метод помощника.

Теперь мы можем писать модульные тесты, которые используют этот метод помощника для тестирования сценариев edit с участием разных пользователей:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample15.cs)]

И теперь, когда мы запускаем тесты, они проходят:

![](enable-automated-unit-testing/_static/image13.png)

### <a name="testing-updatemodel-scenarios"></a>Тестирование сценариев UpdateModel ()

Мы создали тесты, которые охватывают версию http-GET действия Edit. Давайте создадим некоторые тесты, которые проверят версию действия ACTION-POST:

[!code-csharp[Main](enable-automated-unit-testing/samples/sample16.cs)]

Интересный новый сценарий тестирования для нас, чтобы поддержать с помощью этого метода действий является его использование UpdateModel () вспомогательный метод на базовом классе контроллера. Мы используем этот метод помощника для привязки значений форм-поста к нашему экземпляру объекта Ужина.

Ниже приведены два теста, которые демонстрируют, как мы можем поставлять форму размещены значения для UpdateModel () помощник метод для использования. Мы сделаем это путем создания и заполнения объекта FormCollection, а затем назначить его свойству "ValueProvider" на контроллере.

Первый тест проверяет, что при успешном сохранении браузер перенаправляется на действие деталей. Второй тест проверяет, что при размещении недействительных входных сигналов действие снова отображает представление отсылки с сообщением об ошибке.

[!code-csharp[Main](enable-automated-unit-testing/samples/sample17.cs)]

### <a name="testing-wrap-up"></a>Тестирование Wrap-Up

Мы рассмотрели основные концепции, участвующие в классах контроллеров модульного тестирования. Мы можем использовать эти методы, чтобы легко создать сотни простых тестов, которые проверяют поведение нашего приложения.

Поскольку наши тесты контроллера и модели не требуют реальной базы данных, они очень быстры и просты в запуске. Мы сможем выполнить сотни автоматизированных тестов в считанные секунды, и сразу же получить обратную связь о том, изменения, которые мы сделали сломал что-то. Это поможет нам в большей уверенности в постоянном совершенствовании, рефакторинге и совершенствовании нашего приложения.

Мы рассмотрели тестирование в качестве последней темы в этой главе, - но не потому, что тестирование является то, что вы должны сделать в конце процесса разработки! Напротив, вы должны написать автоматизированные тесты как можно раньше в процессе разработки. Это позволяет вам получать немедленную обратную связь по мере разработки, помогает вам вдумчиво рассматривать сценарии использования приложения и направляет вас к разработке приложения с чистым наслоением и совмещение в виду.

Более поздняя глава в книге будет обсуждать разработку test Driven (TDD), и как использовать его с ASP.NET MVC. TDD — это итеративная практика кодирования, в которой вы сначала пишете тесты, которые удовлетворит полученный код. С TDD вы начинаете каждую функцию, создавая тест, который проверяет функциональность, которую вы собираетесь реализовать. Написание модульного теста сначала помогает вам четко понимать эту функцию и то, как она должна работать. Только после того, как тест написан (и вы подтвердили, что он не справляется) вы затем реализовать фактическую функциональность тест проверяет. Поскольку вы уже потратили время на размышления об использовании, как функция должна работать, вы будете иметь лучшее понимание требований и как лучше их реализовать. Когда вы закончите с реализацией, вы можете повторно запустить тест – и получить немедленную обратную связь о том, работает ли функция правильно. Мы рассмотрим TDD больше в главе 10.

### <a name="next-step"></a>Следующий шаг

Некоторые окончательные обернуть комментарии.

> [!div class="step-by-step"]
> [Назад](use-ajax-to-implement-mapping-scenarios.md)
> [Вперед](nerddinner-wrap-up.md)
