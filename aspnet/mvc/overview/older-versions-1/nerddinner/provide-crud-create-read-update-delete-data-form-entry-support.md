---
uid: mvc/overview/older-versions-1/nerddinner/provide-crud-create-read-update-delete-data-form-entry-support
title: Укажите CRUD (Создание, чтение, обновление и удаление) запись поддержки форм данных | Документация Майкрософт
author: microsoft
description: Шаг 5 показано, как использовать наш класс DinnersController, включите поддержку для изменения, создание и удаление ужинов с ним, а также.
ms.author: riande
ms.date: 07/27/2010
ms.assetid: bbb976e5-6150-4283-a374-c22fbafe29f5
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/provide-crud-create-read-update-delete-data-form-entry-support
msc.type: authoredcontent
ms.openlocfilehash: 242665b3ba2e2ad2157abbe2c44ae207f15e72ce
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59410868"
---
# <a name="provide-crud-create-read-update-delete-data-form-entry-support"></a>Обеспечение поддержки операций CRUD (создание, чтение, обновление и удаление) для записей форм данных

по [Microsoft](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это 5 из бесплатной [руководство по использованию приложения «NerdDinner»](introducing-the-nerddinner-tutorial.md) , пошаговое рассмотрение как создать небольшой, но завершить, веб-приложения с помощью ASP.NET MVC 1.
> 
> Шаг 5 показано, как использовать наш класс DinnersController, включите поддержку для изменения, создание и удаление ужинов с ним, а также.
> 
> Если вы используете ASP.NET MVC 3, рекомендуется следовать [Приступая к работе с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.


## <a name="nerddinner-step-5-create-update-delete-form-scenarios"></a>NerdDinner Step 5: Создание, обновление и удаление формы сценариев

Мы появились контроллеры и представления и описаны способы их использования для реализации более возможности списка и сведений для ужинов на сайте. Следующим этапом будет предпринимать никаких дополнительных наш класс DinnersController и включите поддержку редактирования, создание и удаление ужинов с ним, а также.

### <a name="urls-handled-by-dinnerscontroller"></a>URL-адресов, обрабатываемых DinnersController

Методы действий ранее добавленного DinnersController, реализована поддержка два URL-адреса: */Dinners* и */Dinners/сведения / [id]*.

| **URL-адрес** | **КОМАНДА** | **Цель** |
| --- | --- | --- |
| */Dinners/* | GET | Отобразить список предстоящих ужинов HTML. |
| */Dinners/сведения / [id]* | GET | Отображение сведений о конкретных ужин. |

Теперь мы добавим методы действий для реализации три дополнительные URL-адреса: */Dinners/Edit / [id]*, */ужинов/Create*, и */Dinners/Delete / [id]*. Эти URL-адреса будет включить поддержку редактирования существующих ужинов, создание новых ужинов и удаление ужинов.

Будет добавлена поддержка взаимодействия глагол HTTP GET и HTTP POST с эти новые URL-адреса. HTTP-запросы GET на эти URL-адреса отображается исходное представление HTML данные (форма, заполняется данными ужин в случае «edit», пустую форму в случае «создать» и окно подтверждения удаления в случае «удалить»). HTTP-запросы POST к этим URL-будет сохранение, обновление и удаление данных компании Dinner в наших DinnerRepository (и из него — в базе данных).

| **URL-адрес** | **КОМАНДА** | **Цель** |
| --- | --- | --- |
| */Dinners/edit / [id]* | GET | Отобразить заполняются данными компании Dinner редактируемую форму HTML. |
| ПОМЕСТИТЬ | Сохраните изменения формы для конкретной компании Dinner к базе данных. |
| */ Ужинов/создать* | GET | Отображение пустой HTML-форму, позволяющий пользователям определять новые ужинов. |
| ПОМЕСТИТЬ | Создайте новый Dinner и сохраните его в базе данных. |
| */Dinners/delete / [id]* | GET | Отображение удалить экран подтверждения. |
| ПОМЕСТИТЬ | Удаляет указанный dinner из базы данных. |

### <a name="edit-support"></a>Изменить поддержки

Начнем с реализации сценария «изменить».

#### <a name="the-http-get-edit-action-method"></a>Метод HTTP-GET редактирования действия

Мы начнем с реализации поведения «GET» HTTP наши изменения метода действия. Этот метод будет вызываться при */Dinners/Edit / [id]* запрашивается URL-адрес. Наша реализация выглядят следующим образом:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample1.cs)]

Приведенный выше код использует DinnerRepository для извлечения объекта ужин. Затем она визуализирует шаблон представления, с помощью объекта ужин. Поскольку мы еще не передается явно имя шаблона сертификата для *View()* вспомогательный метод, чтобы устранить этот шаблон будет использоваться путь по умолчанию на основе соглашения об: /Views/Dinners/Edit.aspx.

Теперь создадим этот шаблон представления. Мы сделаем это, щелкните правой кнопкой мыши внутри метода Edit и выбрав из контекстного меню команду «Добавление представления»:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image1.png)

В диалоговом окне «Добавление представления» здесь мы указываем мы передаваемый объект Dinner наш шаблон представления, как его модель и выберите шаблон «Изменить», для формирования шаблонов автоматически:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image2.png)

При нажатии кнопки «Добавить», Visual Studio добавит новый файл шаблона представления «Edit.aspx» для нас в каталоге «\Views\Dinners». Он также открывает новый шаблон представления «Edit.aspx» внутри редактора кода — заполняется начальной «Изменить» каркаса реализации как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image3.png)

Давайте внести некоторые изменения в созданные каркаса Edit (изменить) по умолчанию и обновите представление шаблона редактирования приведенное ниже содержимое, (что устраняет некоторые из свойств, которые мы не хотим предоставлять):

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample2.aspx)]

При запуске приложения и запрос *«/ ужинов/Edit/1»* URL-адрес, мы увидим следующую страницу:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image4.png)

HTML-разметка, создаваемые нашего представления выглядит как ниже. Это стандартный HTML – с &lt;формы&gt; элемент, который выполняет запрос HTTP POST к */Dinners/Edit/1* URL-адрес при «Сохранить» &lt;тип входного = «submit» /&gt; нажатия кнопки. HTML &lt;тип входного = «text» /&gt; элемент был выходные данные для каждого изменяемому свойству:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image5.png)

#### <a name="htmlbeginform-and-htmltextbox-html-helper-methods"></a>Html.BeginForm() и Html.TextBox() Html вспомогательные методы

Наш шаблон представления «Edit.aspx» используется несколько методов «Вспомогательный метод Html»: Html.ValidationSummary(), Html.BeginForm(), Html.TextBox() и Html.ValidationMessage(). Помимо создания HTML-разметка для нас, эти вспомогательные методы предоставляют обработка встроенных ошибок и проверки поддержки.

##### <a name="htmlbeginform-helper-method"></a>Вспомогательный метод Html.BeginForm()

— Это вспомогательный метод Html.BeginForm() какие выходные данные HTML &lt;формы&gt; элемент в разметку. В нашем шаблоне представления Edit.aspx вы заметите, к которому применяется оператор «using» при использовании этого метода C#. Открывающей фигурной скобки обозначает начало &lt;формы&gt; содержимого и закрывающую фигурную скобку является то, что указывает на конец &lt;/form&gt; элемент:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample3.cs)]

Кроме того Если оператор «using» подход понятном и естественном для такого сценария, можно использовать сочетание Html.BeginForm() и Html.EndForm() (что делает то же самое):

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample4.aspx)]

Вызов Html.BeginForm() без параметров приведет к его в выходной элемент формы, который выполняет запрос HTTP POST на URL-адрес текущего запроса. То есть почему нашего представления редактирования приводит к возникновению ошибки *&lt;действия формы = «/ ужинов/Edit/1» метод = «post»&gt;* элемент. Мы может также передается явных параметров Html.BeginForm() если нам нужно опубликовать другой URL-адрес.

##### <a name="htmltextbox-helper-method"></a>Вспомогательный метод Html.TextBox()

Нашего представления Edit.aspx использует вспомогательный метод Html.TextBox() для вывода &lt;тип входного = «text» /&gt; элементов:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample5.aspx)]

Описанный выше метод Html.TextBox() принимает один параметр —, который используется для указания атрибутов имя/идентификатор из &lt;тип входного = «text» /&gt; элемента выходных данных, а также свойства модели для заполнения значения из текстового поля. Для этого мы передали в представление редактирования объект Dinner имеет значение «Title» свойства «Futures.NET», и назовем выходные данные нашего метода Html.TextBox("Title"): *&lt;входа с идентификатором = «Title» имя = «Title» type = «text» value = «.NET Futures» /&gt;*.

Кроме того можно использовать первый параметр Html.TextBox() укажите идентификатор и имя элемента, и явным образом передать в значение, используемое в качестве второго параметра:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample6.aspx)]

Часто нам понадобятся для выполнения, пользовательское форматирование на значение, которое будет выходных данных. В таких случаях полезно статический метод String.Format() встроены в .NET. Наш шаблон представления Edit.aspx использует это для форматирования значения EventDate (которые имеют тип даты и времени), чтобы оно не показывает секунд, время:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample7.aspx)]

Третий параметр Html.TextBox() можно использовать при необходимости для вывода дополнительных атрибутов HTML. Фрагменте кода показано, как дополнительный размер отрисовки = «30» атрибут и класс = атрибут «mycssclass» на &lt;тип входного = «text» /&gt; элемент. Обратите внимание на то, как мы экранирование имя класса атрибута с помощью "@" character because "класс» является зарезервированным словом в C#:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample8.aspx)]

#### <a name="implementing-the-http-post-edit-action-method"></a>Реализация метода действия изменить HTTP-POST

Теперь у нас есть версия HTTP-GET наш метод действия Edit реализован. Когда пользователи запрашивают */Dinners/Edit/1* URL-адрес, они получают страницу HTML, как показано ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image6.png)

При нажатии кнопки «Сохранить» вызывает отправку формы */Dinners/Edit/1* URL-адрес, и отправляет HTML &lt;входной&gt; форме значения, с помощью команды HTTP POST. Теперь реализуем поведение HTTP POST метода действия наших редактирования — которой будут обрабатываться сохранение компании Dinner.

Начнем с добавления перегруженный метод действие «Изменить» для наших DinnersController, имеющего атрибут «AcceptVerbs» на него, указывающее, что он обрабатывает сценарии HTTP POST:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample9.cs)]

При применении атрибута [AcceptVerbs] к методам действий перегруженных ASP.NET MVC автоматически обрабатывает диспетчеризации запросы в метод соответствующие действия в зависимости от входящего HTTP-команды. Запрос HTTP POST для */Dinners/Edit / [id]* URL-адреса будет отправлена приведенный выше метод редактирования при всех других запросов глагол HTTP для */Dinners/Edit / [id]* URL-адреса переходит к первому методу редактирования (которые были мы реализовали Нет `[AcceptVerbs]` атрибут).

| **Тема стороне: Почему различать через HTTP-команды?** |
| --- |
| Вы можете задать вопрос – Почему используем один URL-адресу и запоминающихся его поведение с помощью HTTP-команду? Почему бы не иметь два отдельных URL-адреса для обработки загрузки и сохранения изменений редактирования? Например: /Dinners/Edit / [id] для отображения исходной формы и /Dinners/Save / [id] для обработки формы post, чтобы сохранить его? Недостатком с публикации два отдельных URL-адреса является то, что в случаях, где мы отправкой /Dinners/Save/2, а затем нужно отобразить HTML-формы из-за ошибок на входе, конечный пользователь будет образоваться ужинов/Save/2 URL-адрес в адресной строке браузера (так как это было URL-адреса отправки формы). Если конечный пользователь закладки эту redisplayed страницу, чтобы их список "Избранное" браузера, или копирования или вставляет URL-адрес и отправляет по электронной почте его друзей, они окажутся сохранение URL-адрес, который не будет работать в будущем (так как этот URL-адрес зависит от значения отправки). Предоставляя единый URL-адрес (например: /Dinners/Edit/[id]) и запоминающихся от обработки по HTTP-команды, можно безопасно для конечных пользователей к закладки страницы "edit" и/или отправить URL-адрес для других пользователей. |

#### <a name="retrieving-form-post-values"></a>Получение значения отправки формы

Существует множество способов можно обратиться к публикации параметров формы внутри нашего метода HTTP POST «Изменить». Один из простых подходов является просто использовать свойство запроса на базовый класс контроллера для доступа к коллекции форм и напрямую извлечь переданные значения:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample10.cs)]

Описанный подход применим многословны, однако, особенно в том случае, когда мы добавляем логику обработки ошибок.

Более удачное решение состоит этот сценарий рекомендуется использовать встроенные *UpdateModel()* вспомогательный метод в базовом классе контроллера. Она поддерживает обновление свойств объекта, который мы передаем его с помощью входящих параметров формы. Он использует отражение для определения имен свойств в объекте и автоматически преобразует и присваивает им основано на входных значениях, предоставленный клиентом значения.

Метод UpdateModel() можно использовать для упрощения наших HTTP-POST изменение действия с помощью следующего кода:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample11.cs)]

Мы теперь можно посетить */Dinners/Edit/1* URL-адрес и измените название нашей компании Dinner:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image7.png)

При нажатии кнопки «Сохранить», выполним формы post для наших действие изменения, а обновленные значения будут сохранены в базе данных. Мы затем будут перенаправляться на URL-адрес сведений на обед, (который будет отображаться только что сохраненные значения):

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image8.png)

#### <a name="handling-edit-errors"></a>Обработка ошибок редактирования

Тонкую нашей текущей реализации works HTTP-POST — за исключением случаев, когда имеются ошибки.

Когда пользователь делает ошибку редактирование формы, нам нужно убедиться, что формы отображается повторно с сообщением об подробное сообщение об ошибке, который проведет их к ее устранению. Сюда входят случаи, когда конечный пользователь публикует неверные входные данные (например: строка имеет неправильный формат даты), а также ситуации, когда формат входных данных является допустимым, но есть нарушение бизнес-правил. При возникновении ошибок, что форме необходимо сохранять входные данные пользователя, изначально ввели таким образом, чтобы им не пришлось пополнить свои изменения вручную. Этот процесс повторяется столько раз до успешного завершения формы.

ASP.NET MVC включает в себя некоторые встроенные удобных функций, которые упрощают обработку ошибок и повторного отображения формы. Чтобы увидеть эти функции в действии, давайте обновить наш метод действия Edit следующим кодом:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample12.cs)]

Приведенный выше код аналогичен нашей предыдущей реализации — за исключением того, что мы теперь создается программа-оболочка блок обработки ошибок try/catch вокруг нашей работе. Если возникает исключение при вызове UpdateModel() или попробуйте элемент и сохранить DinnerRepository, (который будет выдано исключение, если компании Dinner объект, который мы пытаемся сохранить является недопустимым из-за нарушение правил в нашей модели), наш блок catch Ошибка обработки будет выполнение. В ней мы цикла нарушения правил, которые существуют в объекте Dinner и добавить их объект ModelState (который мы обсудим чуть позже). Затем мы снова отобразить представление.

Чтобы увидеть это работает, давайте снова запустим приложение, отредактируйте обед и измените его пустым заголовком, EventDate «BOGUS», и использовать номер телефона часть соединенного Королевства со значением страны из США. При нажатии кнопки «Сохранить» нашего метода HTTP POST изменить нельзя будет сохранить ужин (из-за ошибок) и будет повторного вывода формы:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image9.png)

Наше приложение имеет возможность неплохую ошибки. Текстовые элементы с недопустимые входные данные, выделены красным цветом, а сообщения об ошибках проверки отображаются для конечного пользователя о них. Формы также сохраняет входные данные пользователя была введена изначально — таким образом, чтобы у них нет ничего пополнение.

Как это сделать вы можете спросить, это происходило? Как текстовые поля заголовка, EventDate и ContactPhone сами выделить красным цветом и знать для вывода значений изначально вводится пользователем? И как сообщения об ошибках отображаются в списке в верхней? Хорошо то, что это случается не по волшебству — вместо этого было так, как мы использовали некоторые встроенные функции ASP.NET MVC, которые упрощают проверку входных данных и ошибка сценария обработки.

#### <a name="understanding-modelstate-and-the-validation-html-helper-methods"></a>Основные сведения о ModelState и вспомогательный метод HTML методов проверки

Классы контроллера имеют набор свойств «ModelState», который предоставляет возможность указать, что имеются ошибки с помощью объекта модели, передаваемые в представление. Ошибка записи в коллекции ModelState идентифицировать имя свойства модели с проблемой (например: «Title», «EventDate» или «ContactPhone») и разрешить сообщение об ошибке понятном указать (например: «Требуется заголовок»).

*UpdateModel()* вспомогательный метод автоматически заполняет коллекцию ModelState при обнаружении ошибок при попытке присвоения значений формы свойства в объекте модели. Например свойство EventDate нашей компании Dinner объекта имеет тип DateTime. Когда метод UpdateModel() не удалось присвоить строковое значение «BOGUS» в сценарии выше, метод UpdateModel() добавленных возникла запись в коллекцию ModelState, указывающее, ошибка назначения с этим свойством.

Разработчики также могут создавать код, чтобы явно добавить Ошибка записи в коллекцию ModelState, как это делается ниже в нашей «catch» Ошибка обработки блок, который заполнение коллекции ModelState операциями на основе active нарушений правил в Объект Dinner:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample13.cs)]

#### <a name="html-helper-integration-with-modelstate"></a>Интеграция вспомогательный метод HTML с ModelState

Вспомогательные методы HTML - как Html.TextBox() - Проверьте коллекцию ModelState при отрисовке выходных данных. При наличии ошибки для элемента, они отображались, введенное пользователем значение и ошибка класс CSS.

Например в нашего представления Edit (изменить) используется вспомогательный метод Html.TextBox() для подготовки к просмотру EventDate нашей компании Dinner объекта:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample14.aspx)]

Когда было отображено в сценарии с ошибками, метод Html.TextBox() проверка ModelState коллекции см. в разделе, если бы все ошибки, связанные со свойством «EventDate» из нашего объекта Dinner. Если обнаружено, что произошла ошибка при его подготовке к просмотру ввода отправленного пользователя («BOGUS»), как значение и добавлен класс css, ошибка &lt;тип входного = «текстовое поле» /&gt; его созданной разметки:

[!code-html[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample15.html)]

Можно настроить внешний вид ошибки класс css для поиска, тем не менее необходимо. Класс ошибки CSS по умолчанию — «входные данные —-ошибка проверки» — определяется в *\content\site.css* таблицы стилей и выглядит, такие как ниже:

[!code-css[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample16.css)]

Это правило CSS является, что вызвало наших недопустимые входные элементы, как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image10.png)

##### <a name="htmlvalidationmessage-helper-method"></a>Вспомогательный метод Html.ValidationMessage()

Вспомогательный метод Html.ValidationMessage() можно использовать для вывода ModelState сообщение, связанное со свойством конкретной модели:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample17.aspx)]

Приведенный выше код выводит:  *&lt;span класса = «ошибка поле проверки»&gt; указано недопустимое значение «BOGUS» &lt; /span&gt;*

Вспомогательный метод Html.ValidationMessage() также поддерживает второй параметр, который позволяет разработчикам переопределять текстовое сообщение об ошибке, отображаемый:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample18.aspx)]

Приведенный выше код выводит: *&lt;span класс = «ошибка поле проверки»&gt;\*&lt;/span&gt;* вместо текст ошибки по умолчанию при наличии для ошибки Свойство EventDate.

##### <a name="htmlvalidationsummary-helper-method"></a>Вспомогательный метод Html.ValidationSummary()

Вспомогательный метод Html.ValidationSummary() можно использовать для подготовки к просмотру сводное сообщение об ошибке, сопровождается &lt;ul&gt;&lt;li /&gt;&lt;/ul&gt; список все подробные сведения об ошибке сообщений в ModelState коллекции:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image11.png)

Вспомогательный метод Html.ValidationSummary() принимает параметр необязательная строка — определяющий сводное сообщение об ошибке для отображения над списком подробных описаний ошибок:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample19.aspx)]

При необходимости можно использовать CSS для переопределения, как выглядит списка ошибок.

#### <a name="using-a-addruleviolations-helper-method"></a>С помощью AddRuleViolations вспомогательный метод

Начальная реализация изменить HTTP-POST используется оператор foreach в качестве блока catch для циклического прохода объекта Dinner нарушения правил и добавить их в коллекции ModelState контроллера:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample20.cs)]

Мы можем сделать этот код немного более понятную путем добавления «ControllerHelpers» класса в проект NerdDinner и реализуйте метод расширения «AddRuleViolations» внутри него, который добавляет вспомогательный метод в класс ASP.NET MVC ModelStateDictionary. Этот метод расширения может инкапсулировать логику, необходимую для заполнения ModelStateDictionary со списком ошибок RuleViolation:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample21.cs)]

Затем можно обновить наш изменить HTTP-POST метода действия для использования этого метода расширения для заполнения коллекции ModelState нарушения правил нашей компании Dinner.

#### <a name="complete-edit-action-method-implementations"></a>Завершить реализации метода действия редактирования

Приведенный ниже код реализует все контроллера логику, необходимую для нашего сценария редактирования:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample22.cs)]

О нашей реализации редактирования приятно, что наш класс контроллера, ни шаблон представления должно ничего знать об специальные проверочные или бизнес-правила, установленному нашей модели компании Dinner. Мы можно добавить дополнительные правила для нашей модели в будущем, не внося изменения в код к нашей контроллер или представление, чтобы их для поддержки. Это предоставляет возможность легко развивать наших требований приложения в будущем с как минимум изменений кода.

### <a name="create-support"></a>Создание поддержки

После завершения реализации поведения наш класс DinnersController «Изменить». Теперь перейдем к реализации поддержки «Создать» на нем, — которую будет предоставить пользователям возможность добавлять новый ужинов.

#### <a name="the-http-get-create-action-method"></a>Действие метода создания HTTP-GET

Начнем с реализации HTTP «GET» поведения наших Создание метода действия. Этот метод будет вызываться при посещении */ужинов/Create* URL-адрес. Наше решение выглядит так:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample23.cs)]

Приведенный выше код создает новый объект Dinner и присваивает его свойства EventDate одну неделю в будущем. Затем она Визуализирует представление, основанный на новый объект ужин. Так как мы еще не передается явно имя *View()* вспомогательный метод, чтобы устранить этот шаблон будет использоваться путь по умолчанию на основе соглашения об: /Views/Dinners/Create.aspx.

Теперь создадим этот шаблон представления. Это можно сделать, щелкнув правой кнопкой мыши в методе действия Create и выбрав команда контекстного меню «Добавление представления». В диалоговом окне «Добавление представления» здесь мы указываем мы передаваемый объект Dinner этот шаблон что решили автоматически каркаса шаблон «Создать»:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image12.png)

При нажатии кнопки «Добавить», Visual Studio будет сохранение нового представления на основе шаблона «Create.aspx» каталог «\Views\Dinners» и открыть его в интегрированной среде разработки:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image13.png)

Давайте внести некоторые изменения к файлу по умолчанию «создать» каркаса, созданный для нас и измените его вверх, чтобы выглядеть следующим образом:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample24.aspx)]

И теперь при запуске приложения из наших доступа *«/ ужинов/Create»* URL-адрес в браузере, будет заполняться из нашей реализации создать действие пользовательского интерфейса, например ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image14.png)

#### <a name="implementing-the-http-post-create-action-method"></a>Реализация HTTP-POST метода действия "Создать"

У нас есть версия наш метод действия Create реализации HTTP-GET. Когда пользователь нажимает кнопку «Сохранить», он выполняет отправку формы */ужинов/Create* URL-адрес, и отправляет HTML &lt;входной&gt; форме значения, с помощью команды HTTP POST.

Теперь реализуем поведение HTTP POST наших Создание метода действия. Начнем с добавления перегруженного метода действия «Создать» для наших DinnersController, имеющего атрибут «AcceptVerbs» на него, указывающее, что он обрабатывает сценарии HTTP POST:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample25.cs)]

Существует ряд способов, мы может обращаться к параметрам отправленной формы внутри нашего метода «Создать» включить HTTP-POST.

Можно создать объект обед, а затем использовать *UpdateModel()* вспомогательный метод (как это делалось с действие изменения) требуется заполнить отправленные значения формы. Мы затем можно добавить его к нашей DinnerRepository, сохранить их в базе данных и перенаправить пользователя к нашей действие сведения, чтобы отобразить только что созданный обед, с помощью следующего кода:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample26.cs)]

Кроме того можно использовать подход которых наш метод действия Create() занять объект ужин в качестве параметра метода. ASP.NET MVC будет затем автоматически создать экземпляр объекта ужин для нас, заполнить его свойства с помощью формы ввода данных и передать его методу наши действия:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample27.cs)]

Наш метод действия выше проверяет, что объект Dinner был успешно заполнен значения отправки формы, обращаясь к свойству ModelState.IsValid. Эта команда возвращает значение false, если входные данные проблемы преобразования (например: строка «BOGUS» для свойства EventDate), и повторно отображает форму, если возникли проблемы при нашего метода действия.

Если входные значения являются допустимыми, метод действия предпринимает добавьте и сохраните новый Dinner DinnerRepository. Он создает оболочку для этой работы внутри блока try/catch и повторно отображает форму, в случае нарушения правил бизнеса (что приведет к dinnerRepository.Save() метод для вызова исключения).

Чтобы просмотреть это поведение в действии обработки ошибок, можно запросить */ужинов/Create* URL-адрес и заполните сведения о новых ужин. Неверные входные данные или значения, вызовет создание формы, чтобы повторно из-за ошибок выделены как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image15.png)

Обратите внимание на то, как наши Создание формы соблюдает точное же проверки и бизнес-правилам, что наши формы редактирования. Это потому, что наши проверки и бизнес-правила были определены в модели, а не внедрены в пределах пользовательского интерфейса или контроллера приложения. Это означает, что мы можно позже изменить/развиваться наших проверки или бизнес-правила в одном размещения и их применения на протяжении нашего приложения. Нам не нужно изменить любой код, либо в нашей измените или создайте автоматически учитывает любые новые правила или изменения в существующие методы действия.

При мы исправьте входные значения и нажмите кнопку «Сохранить» опять же, наших дополнением к DinnerRepository будет выполнена успешно, и новый Dinner будут добавлены в базу данных. Мы затем будут перенаправляться в */Dinners/сведения / [id]* URL-адрес — где мы предоставят сведения о только что созданный Dinner:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image16.png)

### <a name="delete-support"></a>Поддержка удаления

Давайте теперь добавить поддержку «Удалить», чтобы наши DinnersController.

#### <a name="the-http-get-delete-action-method"></a>Метод действия Delete HTTP-GET

Начнем с реализации поведения HTTP GET наш метод действия delete. Этот метод будет вызываться при посещении */Dinners/Delete / [id]* URL-адрес. Ниже приведена реализация:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample28.cs)]

Метод действия пытается получить ужин для удаления. Если компании Dinner существует, он отображает представление на основе Dinner объекта. Если объект не существует (или уже была удалена) он возвращает представление, которое отображает «NotFound» просмотреть шаблон, созданный ранее для нашего метода действия «Подробности».

Можно создать этот шаблон «Удалить», щелкнув правой кнопкой мыши, в метод действия Delete и выбрав из контекстного меню команду «Добавление представления». В диалоговом окне «Добавление представления» мы будет означать, что мы передаваемый объект Dinner наш шаблон представления, как его модель и решили создать пустой шаблон:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image17.png)

При нажатии кнопки «Добавить», Visual Studio добавит новый файл шаблона представления «Delete.aspx» для нас в каталог «\Views\Dinners». Мы добавим некоторые HTML и код шаблона для реализации экран подтверждения удаления следующее:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample29.aspx)]

В приведенном выше коде отображается заголовок ужин для удаления и выходные данные &lt;формы&gt; элемент, который выполняет запрос POST на /Dinners/Delete / [id] URL-адрес, если конечный пользователь нажимает кнопку «Удалить» внутри него.

Когда мы запускаем наши приложения и доступа *«/ ужинов/Delete / [id]»* URL-адрес допустимым пообедать объекта, он выполняет визуализацию пользовательского интерфейса, такие как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image18.png)

| **Тема стороне: Почему мы делаем POST?** |
| --- |
| Вы можете задать вопрос — Почему мы пошли через усилия на создании &lt;формы&gt; в наш экран подтверждения удаления? Почему бы не использовать стандартные гиперссылки для связывания метода действия, который выполняет фактическая операция удаления? Это связано, поскольку нам нужно соблюдать осторожность, чтобы защититься от программ-обходчиков и поисковых систем обнаружения наши URL-адреса и случайно приводит к данные должны удаляться при перейдите по ссылкам. На основе HTTP-GET файлы «безопасны» для них доступ/сканирования URL-адреса, и они должны не выполните HTTP-POST из них. Хорошее правило – убедитесь, что вы всегда помещать разрушением или операции изменения данных за запросы HTTP POST. |

#### <a name="implementing-the-http-post-delete-action-method"></a>Реализация метод действия Delete HTTP-POST

Теперь у нас есть версии HTTP-GET наш метод действия Delete реализации которого отображается экран подтверждения удаления. Когда конечный пользователь нажимает кнопку «Удалить», он будет выполнять отправку формы */Dinners/Dinner / [id]* URL-адрес.

Теперь рассмотрим процедуру внедрения HTTP «POST» поведение метод действия delete, с помощью следующего кода:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample30.cs)]

HTTP-POST версию наш метод действия Delete пытается извлечь объект ужин для удаления. Если не удается найти (так как она уже была удалена) он отображает шаблон «NotFound». При обнаружении компании Dinner из DinnerRepository удаляет ее. Затем она визуализирует шаблон «Удалено».

Для реализации шаблона «Удалено» мы щелкните правой кнопкой мыши в методе действия и выберите в контекстном меню «Добавление представления». Мы будем имя нашего представления «Удалено», который будет пустой шаблон (и не принимать объект модели со строгой типизацией). Затем мы добавим некоторые HTML-содержимое в него:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample31.aspx)]

И теперь при запуске приложения из наших доступа *«/ ужинов/Delete / [id]»* URL-адрес допустимым пообедать, подтверждение удаления объекта, он будет обрабатывать нашей компании Dinner экрана как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image19.png)

При нажатии кнопки «Удалить», он будет выполнять запрос HTTP POST к */Dinners/Delete / [id]* URL-адрес, который удалит ужин из базы данных и отобразить наш шаблон представления «Удалено»:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image20.png)

### <a name="model-binding-security"></a>Безопасность привязки модели

Мы уже обсудили, два разных способа использования встроенных возможностей привязки модели ASP.NET MVC. Сначала с помощью метода UpdateModel() для обновления свойств на основе существующего объекта модели и второй с помощью поддержки ASP.NET MVC для передачи объектов модели в качестве параметров метода действия. Оба этих метода являются очень мощным и полезным.

Эти возможности также предлагает очень ответственности. Очень важно всегда быть страдающие паранойей специалисты о безопасности при приеме вводимые пользователем, и это также справедливо при привязке объектов для входных данных для формы. Следует соблюдать осторожность, чтобы всегда кодировать в HTML значения вводимых пользователем, чтобы избежать атак путем внедрения кода HTML и JavaScript и будьте внимательны, атак путем внедрения кода SQL (Примечание: для нашего приложения, который автоматически кодирует параметры, чтобы предотвратить их мы используем LINQ to SQL типы атак). Никогда не следует полагаться на клиентскую проверку только и всегда использовать проверки на стороне сервера для защиты от хакеров попытки отправить вам фиктивный значения.

Один элемент дополнительную защиту, чтобы убедиться в том, что вы думаете о при использовании средства связывания с ASP.NET MVC — это область объектов, к которому выполняется привязка. В частности необходимо убедиться, что вы понимаете последствия свойства, которые позволяет привязать, и убедитесь, что допускается только те свойства, которые действительно должен иметь возможность обновлять конечным пользователем обновления для системы безопасности.

По умолчанию метод UpdateModel() будет пытаться обновить все свойства в объекте модели, которые соответствуют значения входящих параметров формы. Аналогично объекты также передаются как параметры метода действия по умолчанию необходимо для их свойства, заданные с помощью параметров формы.

#### <a name="locking-down-binding-on-a-per-usage-basis"></a>Блокирование привязки на основе за использование

Можно заблокировать политику привязки на основе за использование, предоставляя явные «перечислить» свойств, которые могут быть обновлены. Это можно сделать, передача параметров массива дополнительной строки в метод UpdateModel() как ниже:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample32.cs)]

Объекты передаются как параметры метода действия, также поддерживает атрибут [привязки], который позволяет «перечислить» из допускается указывать как ниже свойства:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample33.cs)]

#### <a name="locking-down-binding-on-a-type-basis"></a>Блокирование привязки на основе типа

Вы также можете заблокировать работу правил привязки на уровне отдельных типов. Это позволяет указать правила привязки один раз, а затем их применять во всех сценариях (включая сценарии для параметра методов UpdateModel и действие) на все контроллеры и методы действий.

Правила для типа привязки можно настроить путем добавления атрибута [привязки] на тип или зарегистрировать его в файле Global.asax приложения (полезно для сценариев, где вы не владеете тип). Затем можно использовать привязки атрибута Include и Exclude свойства, определяющие свойства, которые можно привязать для определенного класса или интерфейса.

Будет использовать этот метод для класса Dinner в наше приложение NerdDinner и добавить атрибут [привязки] к нему, который ограничивает список привязываемые свойства следующее:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample34.cs)]

Обратите внимание, что мы не позволяем Кроме коллекции для обработки через привязку, а также мы позволяем DinnerID или HostedBy свойства и быть через привязку. По соображениям безопасности мы будем вместо этого работает только с этих определенных свойств, с помощью явного кода в методах наши действия.

### <a name="crud-wrap-up"></a>Заключение CRUD

ASP.NET MVC включает ряд встроенных функций, которые помогут в реализации формы, учет сценариев. Мы использовали ряд этих средств для обеспечения поддержки CRUD пользовательского интерфейса на основе нашей DinnerRepository.

Мы используем подход, ориентированный на модели для реализации нашего приложения. Это означает, что все наши проверки и бизнес-правила, что логика определяется внутри наш слой модели — а не внутри нашей контроллеров и представлений. Наш класс контроллера, ни наши шаблоны представлений подозревающий о конкретных бизнес-правила, установленному наш класс модели компании Dinner.

Это будет поддерживать чистую архитектуру приложения и упрощения процесса для тестирования. Можно добавить дополнительные бизнес-правила в наш слой модели в будущем и *не вносить любые изменения кода* наших контроллер или представление, чтобы они будут поддерживаться. Это будет предоставления нам большую гибкость для будут добавляться и изменяться в будущем для нашего приложения.

Наши DinnersController теперь позволяет компании Dinner списки и сведения, а также создание, изменение и удаление поддержки. Полный код для класса можно найти ниже:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample35.cs)]

### <a name="next-step"></a>Следующий шаг

Теперь у нас есть базовая поддержка CRUD (Create, Read, Update и Delete) реализовать в наш класс DinnersController.

Давайте теперь взглянем на как можно использовать классы ViewData и ViewModel для включения более широкие возможности пользовательского интерфейса на нашей формы.

> [!div class="step-by-step"]
> [Назад](use-controllers-and-views-to-implement-a-listingdetails-ui.md)
> [Вперед](use-viewdata-and-implement-viewmodel-classes.md)
