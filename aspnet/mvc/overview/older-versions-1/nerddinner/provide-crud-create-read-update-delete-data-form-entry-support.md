---
uid: mvc/overview/older-versions-1/nerddinner/provide-crud-create-read-update-delete-data-form-entry-support
title: Обеспечить CRUD (Создать, читать, обновлять, удалять) поддержка формы данных Документы Майкрософт
author: rick-anderson
description: Шаг 5 показывает, как принять наш класс DinnersController дальше, включив поддержку для редактирования, создания и удалять Dinners с ним, а также.
ms.author: riande
ms.date: 07/27/2010
ms.assetid: bbb976e5-6150-4283-a374-c22fbafe29f5
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/provide-crud-create-read-update-delete-data-form-entry-support
msc.type: authoredcontent
ms.openlocfilehash: 2b75a7eda8bce4baa25d92626639f4d904eb363a
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542629"
---
# <a name="provide-crud-create-read-update-delete-data-form-entry-support"></a>Обеспечение поддержки операций CRUD (создание, чтение, обновление и удаление) для записей форм данных

[корпорацией Майкрософт](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 5 бесплатно ["NerdDinner" приложение учебник,](introducing-the-nerddinner-tutorial.md) который ходит через как построить небольшой, но полный, веб-приложение с помощью ASP.NET MVC 1.
> 
> Шаг 5 показывает, как принять наш класс DinnersController дальше, включив поддержку для редактирования, создания и удалять Dinners с ним, а также.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем вам следовать [начиная с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.

## <a name="nerddinner-step-5-create-update-delete-form-scenarios"></a>NerdDinner Шаг 5: Создание, обновление, удаление формы Сценарии

Мы представили контроллеры и представления, а также рассмотрели, как использовать их для реализации списка / детали опыт для Dinners на сайте. Наш следующий шаг будет принимать наши DinnersController класса дальше и включить поддержку для редактирования, создания и удаляя Dinners с ним, а также.

### <a name="urls-handled-by-dinnerscontroller"></a>URL-адреса, обрабатываемые DinnersController

Ранее мы добавляли методы действий в DinnersController, которые реализовали поддержку для двух *URL-адресов: /Dinners* и */Dinners/Подробности / .)*.

| **URL-адрес** | **Глагол** | **Цель** |
| --- | --- | --- |
| */Ужины/* | GET | Отобразите список предстоящих ужинов HTML. |
| */Ужины/Подробности/Зид»* | GET | Отображение деталей о конкретном ужине. |

Теперь мы добавим методы действий для реализации трех дополнительных URL-адресов: */Dinners/Edit/'id),* */Dinners/Create*, и */Dinners/Delete/'id .* Эти URL-адреса позволят поддерживать редактирование существующих обедов, создание новых обедов и удаляние dinners.

Мы будем поддерживать как http GET, так и http POST, взаимодействие глагола с этими новыми URL-адресами. Запросы HTTP GET на эти URL-адреса будут отображать исходное представление HTML данных (форма, заполненная данными Ужина в случае "отсечения", пустой формы в случае "создать" и экрана подтверждения удаления в случае "удалить"). ЗАПРОСы HTTP POST на эти URL-адреса сохранят/обновляют/удаляют данные ужина в нашем DinnerRepository (а оттуда в базу данных).

| **URL-адрес** | **Глагол** | **Цель** |
| --- | --- | --- |
| */Ужины/изменяй/зид»* | GET | Отображение регитируемой формы HTML, населенной данными Dinner. |
| POST | Сохраните изменения формы для конкретного ужина в базе данных. |
| */Ужины/Создание* | GET | Отобразите пустую форму HTML, которая позволяет пользователям определять новые Dinners. |
| POST | Создайте новый ужин и сохраните его в базе данных. |
| */Ужины/Удаление/Зид»* | GET | Отображение экрана подтверждения удаления. |
| POST | Удаляет указанный ужин из базы данных. |

### <a name="edit-support"></a>Поддержка отсылки

Начнем с реализации сценария "отсваить".

#### <a name="the-http-get-edit-action-method"></a>Метод действий по отдействию HTTP-GET

Начнем с реализации http "GET" поведение нашего метода действий по отдействию. Этот метод будет вызываться при запросе *URL/Dinners/Edit/id.* Наша реализация будет выглядеть следующим:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample1.cs)]

Приведенный выше код использует DinnerRepository для извлечения объекта Ужина. Затем он отображает шаблон View с помощью объекта Ужин. Поскольку мы явно не передали имя шаблона методу помощника *View()* он будет использовать путь по умолчанию, основанный на конвенции, для разрешения шаблона представления: /Views/Dinners/Edit.aspx.

Теперь давайте создадим этот шаблон представления. Мы сделаем это путем нажатия правого нажатия в методе edit и выбора команды контекстного меню "Добавить вид":

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image1.png)

В диалоге "Add View" мы укажем, что передавая объект Ужина шаблону представления в качестве модели и выбираем авто-эшафот шаблона "Edit":

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image2.png)

При нажатии кнопки "Добавить" Visual Studio добавит для нас в каталоге шаблон "Edit.aspx" новый файл шаблона представления "Edit.aspx". Он также откроет новый шаблон представления "Edit.aspx" в код-редакторе - населенный начальной реализации эшафота "Edit", как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image3.png)

Давайте внести несколько изменений в по умолчанию "отменить" эшафот генерируется, и обновить шаблон представления для удаления содержимого ниже (который удаляет некоторые из свойств, которые мы не хотим подвергать действию):

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample2.aspx)]

Когда мы займем приложение и запросим *URL-адрес "/Dinners/Edit/1",* мы увидим следующую страницу:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image4.png)

Разметка HTML, генерируемая нашим представлением, выглядит ниже. Это стандартный HTML &lt;-&gt; с элементом формы, который выполняет HTTP POST на */Dinners/Edit/1* URL, когда "Сохранить" &lt;входной тип "представить"/кнопка&gt; нажата. &lt;Для каждого отсвативаемого свойства был выводимый тип HTML ввода »текст»:»&gt;

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image5.png)

#### <a name="htmlbeginform-and-htmltextbox-html-helper-methods"></a>Html.BeginForm () и Html.TextBox() Html Помощник Методы

Наш шаблон представления "Edit.aspx" использует несколько методов Html.ValidationSummary(), Html.BeginForm(), Html.TextBox() и Html.ValidationMessage(). Помимо создания HTML-разметки для нас, эти вспомогательные методы обеспечивают встроенную поддержку обработки ошибок и проверки.

##### <a name="htmlbeginform-helper-method"></a>Метод помощи Html.BeginForm ()

Метод помощи Html.BeginForm () — &lt;это&gt; то, что выводит элемент формы HTML в нашей разметке. В нашем шаблоне представления Edit.aspx вы заметите, что при использовании этого метода мы применяем заявление «использование» с помощью C'. Открытая фигурная скобка указывает &lt;&gt; на начало содержания формы, а закрывающийся фигурный скобка указывает на конец &lt;элемента /формы:&gt;

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample3.cs)]

Кроме того, если вы считаете подход "использование" оператора неестественным для такого сценария, вы можете использовать комбинацию Html.BeginForm () и Html.EndForm() (которая делает то же самое):

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample4.aspx)]

Вызов Html.BeginForm () без каких-либо параметров приведет к выводу элемента формы, который делает HTTP-POST к URL текущего запроса. Вот почему наше представление Edit генерирует * &lt;форму действия»/Dinners/Edit/1 "метод" "пост"&gt; * элемент. Мы могли бы в качестве альтернативы передать явные параметры html.BeginForm (), если бы мы хотели разместить на другой URL.

##### <a name="htmltextbox-helper-method"></a>Метод помощи Html.TextBox()

Наш вид Edit.aspx использует метод помощи Html.TextBox() для вывода &lt;&gt; типа ввода/текста/элементов:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample5.aspx)]

Приведенный выше метод Html.TextBox() использует один параметр, который используется для указания &lt;как атрибутов идентификатора/имен типа ввода,«текста»/элемента&gt; для вывода, а также свойства модели для заполнения значения текстового ящика. Например, объект Ужин мы перешли к Редактированию зрения был "Название" стоимость имущества ".NET фьючерсы", и поэтому наш Html.TextBox ("Название") метод вызова выход: * &lt;вхотворный id'"Title" название "Название" тип ""текст" значение ".NET Фьючерсы" /&gt;*.

Кроме того, мы можем использовать первый параметр Html.TextBox() для указания идентификатора/названия элемента, а затем явно передать значение для использования в качестве второго параметра:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample6.aspx)]

Часто мы хотим выполнить пользовательский форматирование на значение, которое является выходным. Встроенный в .NET статичный метод String.Format () полезен для этих сценариев. Наш шаблон представления Edit.aspx использует это для формата значения EventDate (которое имеет тип DateTime), чтобы он не отображал секунды на время:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample7.aspx)]

Третий параметр Html.TextBox() можно дополнительно использовать для вывода дополнительных html атрибутов. Ниже показан фрагмент кода, как визуализировать дополнительный атрибут размера «30» и атрибут класса &lt;«mycssclass»&gt; на входной тип»»text»/элемент. Обратите внимание, как мы избегаем имени атрибута класса с помощью "класса"@" character because "является зарезервированным ключевым словом в C':

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample8.aspx)]

#### <a name="implementing-the-http-post-edit-action-method"></a>Внедрение метода действий по отдействию HTTP-POST

Теперь у нас есть версия HTTP-GET нашего метода действий edit реализована. Когда пользователь запрашивает *URL/Dinners/Edit/1,* он получает страницу HTML, например следующее:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image6.png)

Нажатие кнопки "Сохранить" вызывает публикацию формы на *URL/Dinners/Edit/1* &gt; и отправляет значения формы ввода HTML &lt;с помощью глагола HTTP POST. Теперь давайте реализуем поведение HTTP POST нашего метода действий по праву, который будет обрабатывать сохранение ужина.

Начнем с добавления перегруженного метода действий "Edit" в наш DinnersController с атрибутом "AcceptVerbs", указывающим на то, что он обрабатывает сценарии HTTP POST:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample9.cs)]

Когда атрибут «AcceptVerbs» применяется к перегруженным методам действия, ASP.NET MVC автоматически обрабатывает отправку запросов на соответствующий метод действий в зависимости от входящего глагола HTTP. ЗАПРОСы HTTP POST *на URL-адреса /Dinners/Edit/'id)* будут переходить к приведенным выше методу edit, в то время как все другие запросы глагола HTTP на */Dinners/Edit/'id)* URL-адреса будут переходить к первому методу edit, который мы реализовали (который не имел `[AcceptVerbs]` атрибута).

| **Боковая тема: Почему дифференцировать через глаголы HTTP?** |
| --- |
| Вы можете спросить – почему мы используем один URL и дифференимацию его поведения с помощью глагола HTTP? Почему бы просто не иметь два отдельных URL-адреса для обработки изменений загрузки и сохранения изменения изменения? Например: /Dinners/Edit/'id) для отображения исходной формы и /Dinners/Save/'id) для обработки поста формы, чтобы сохранить ее? Недостатком публикации двух отдельных URL-адресов является то, что в тех случаях, когда мы публикуем в /Dinners/Save/2, а затем необходимо повторно отобразить форму HTML из-за ошибки ввода, конечный пользователь будет в конечном итоге иметь /Dinners/Save/2 URL в адресной панели своего браузера (так как это был URL-адрес, размещенный в). Если конечный пользователь закладки этой переотображатьие страницы в список избранных браузеров, или копировать / вставить URL и по электронной почте его другу, они будут в конечном итоге сохранение URL, который не будет работать в будущем (так как этот URL зависит от значения поста). Подвергая один URL (например: /Dinners/Edit/'id) и дифференивируя его глаголом HTTP, конечным пользователям безопасно закладку страницы отодевания и/или отправлять URL другим. |

#### <a name="retrieving-form-post-values"></a>Получение значений формы

Есть множество способов, которыми мы можем получить доступ к размещенным параметрам формы в нашем методе HTTP POST "Edit". Один простой подход заключается в том, чтобы просто использовать свойство Запрос на базовом классе контроллера для доступа к сбору форм и получения размещенных значений напрямую:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample10.cs)]

Вышеупомянутый подход немного многословен, однако, особенно после того, как мы добавляем логику обработки ошибок.

Лучшим подходом для этого сценария является использование встроенного метода *поддержки UpdateModel ()* в базовом классе контроллера. Он поддерживает обновление свойств объекта, который мы передаем, используя параметры входящих форм. Он использует отражение для определения имен свойств на объекте, а затем автоматически преобразует и присваивает значения им на основе значений ввода, представленных клиентом.

Мы могли бы использовать метод UpdateModel () для упрощения нашего действия по администрированию HTTP-POST с помощью этого кода:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample11.cs)]

Теперь мы можем посетить */Dinners/Edit/1* URL, и изменить название нашего ужина:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image7.png)

При нажатии кнопки "Сохранить" мы выполним публикацию формы для нашего действия по edit, и обновленные значения будут сохраняться в базе данных. Затем мы будем перенаправлены на URL-адрес детали для ужина (который будет отображать недавно сохраненные значения):

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image8.png)

#### <a name="handling-edit-errors"></a>Обработка ошибок edit

Наша текущая реализация HTTP-POST работает отлично - за исключением случаев, когда есть ошибки.

Когда пользователь делает ошибку, редактируя форму, мы должны убедиться, что форма будет отображаться с информативным сообщением об ошибке, которое направляет его для ее исправления. Это включает случаи, когда конечный пользователь публикует неправильный вход (например, порок строки даты), а также случаи, когда формат ввода действителен, но есть нарушение бизнес-правила. При возникновении ошибок форма должна сохранять данные ввода, которые пользователь первоначально ввел, чтобы им не пришлось пополнять свои изменения вручную. Этот процесс должен повторяться столько раз, сколько необходимо, пока форма успешно не завершится.

ASP.NET MVC включает в себя некоторые интересные встроенные функции, которые делают обработку ошибок и форму повторного отображения легко. Чтобы увидеть эти функции в действии, давайте обновим наш метод действий по отдействию со следующим кодом:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample12.cs)]

Вышеуказанный код похож на нашу предыдущую реализацию, за исключением того, что мы сейчас заворачиваем блок обработки ошибок try/catch вокруг нашей работы. Если исключение происходит либо при вызове UpdateModel(), либо при попытке сохранить DinnerRepository (что приведет к исключению, если объект Dinner, который мы пытаемся сохранить, недействителен из-за нарушения правил в нашей модели), наш блок обработки ошибок ловли выполнит. В нем мы цикл над любыми нарушениями правил, которые существуют в объекте ужин и добавить их в объект ModelState (который мы обсудим в ближайшее время). Затем мы повторно отображаем вид.

Чтобы увидеть эту работу, давайте повторно запустим приложение, отодвинем ужин и изменим его, чтобы иметь пустое название, EventDate "BOGUS", и используем номер телефона Великобритании со значением США. При нажатии кнопки "Сохранить" наш метод http POST Edit не сможет сохранить ужин (потому что есть ошибки) и будет повторно отображать форму:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image9.png)

Наше приложение имеет достойный опыт ошибки. Текстовые элементы с недействительным ввозавыделением выделены красным цветом, а сообщения об ошибках проверки отображаются конечному пользователю о них. Форма также сохраняет входные данные, которые пользователь первоначально ввел, так что им не нужно ничего пополнять.

Как, спросите вы, это произошло? Как текстовые ящики Title, EventDate и ContactPhone выделили себя красным цветом и знали, что выводят первоначально введенные значения пользователя? И как сообщения об ошибках отображаются в списке в верхней части? Хорошей новостью является то, что это не произошло по волшебству - скорее это было потому, что мы использовали некоторые из встроенных ASP.NET MVC функции, которые делают входним проверки и обработки ошибок сценарии легко.

#### <a name="understanding-modelstate-and-the-validation-html-helper-methods"></a>Понимание ModelState и методы поддержки HTML-подтверждения валидации

Классы контроллеров имеют коллекцию свойств "ModelState", которая позволяет указать, что ошибки существуют при передаваемом объекте модели в View. Ошибки в коллекции ModelState идентифицируют название свойства модели с проблемой (например: "Title", EventDate или "ContactPhone"), и позволяют указать сообщение об ошибке, удобное для человека (например: "Требуется название").

Метод помощника *UpdateModel ()* автоматически заполняет коллекцию ModelState при обнаружении ошибок при попытке присвоить значения формы свойствам объекта модели. Например, свойство EventDate объекта нашего ужина имеет тип DateTime. Когда метод UpdateModel() не смог присвоить значение строки "BOGUS" к нему в вышеуказанном сценарии, метод UpdateModel() добавил запись в коллекцию ModelState, указывающую на ошибку назначения, произошедшая с этим свойством.

Разработчики также могут написать код, чтобы явно добавить записи ошибок в коллекцию ModelState, как мы делаем ниже в нашем "поймать" блок обработки ошибок, который заполняет коллекцию ModelState с записями на основе активных нарушений правил в объекте ужин:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample13.cs)]

#### <a name="html-helper-integration-with-modelstate"></a>Интеграция Html Helper с ModelState

Методы HTML-помощника - например Html.TextBox() - проверяют коллекцию ModelState при рендеринге. Если ошибка для элемента существует, они отображают значение пользователя и класс ошибки CSS.

Например, в нашем представлении "Edit" мы используем метод помощника Html.TextBox() для визуализации EventDate нашего объекта ужина:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample14.aspx)]

Когда представление было отображено в сценарии ошибки, метод Html.TextBox() проверил коллекцию ModelState, чтобы увидеть, были ли ошибки, связанные с свойством "EventDate" нашего объекта ужина. Когда было установлено, что произошла ошибка, он визовал представленный пользовательский ввод ("BOGUS") в качестве значения, и добавил класс ошибки css &lt;в тип ввода/textbox"/&gt; разметку, которую он генерировал:

[!code-html[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample15.html)]

Вы можете настроить внешний вид класса ошибок css, чтобы выглядеть как хотите. Класс ошибок CSS по умолчанию - "вход-проверка-ошибка" - определяется в таблице стилей *«content»site.css* и выглядит ниже:

[!code-css[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample16.css)]

Это правило CSS является причиной того, что наши недействительные входные элементы должны быть выделены, как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image10.png)

##### <a name="htmlvalidationmessage-helper-method"></a>Html.ValidationMessage() Метод помощи

Метод помощи Html.ValidationMessage() может быть использован для вывода сообщения об ошибке ModelState, связанного с определенным свойством модели:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample17.aspx)]

Вышеприведенный код выходы: * &lt;пролет класса "поле-проверка-ошибка"&gt; Значение "BOGUS" является недействительным&lt;/ span&gt;*

Метод помощи Html.ValidationMessage() также поддерживает второй параметр, который позволяет разработчикам переопределить отображаемый текстсообщения об ошибке:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample18.aspx)]

Вышеприведенный код выводит: * &lt;пролет класса&gt;\*&lt;"поле-проверка-ошибка" / пространство&gt; * вместо текста ошибки по умолчанию, когда ошибка присутствует для свойства EventDate.

##### <a name="htmlvalidationsummary-helper-method"></a>Html.ВалидацияРезюмов () Метод помощника

Метод помощника Html.ValidationSummary() может быть использован для визуализации сводная&gt;&lt;ошибка&gt; сообщение, сопровождаемый &lt;ul&gt;&lt;li/ /ul список всех подробных сообщений об ошибках в коллекции ModelState:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image11.png)

Метод помощи Html.ValidationSummary() использует дополнительный параметр строки, который определяет сообщение об ошибке совмещением, чтобы отобразить над списком подробных ошибок:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample19.aspx)]

Можно по желанию использовать CSS, чтобы переопределить, как выглядит список ошибок.

#### <a name="using-a-addruleviolations-helper-method"></a>Использование метода помощи AddRuleViolations

Наша первоначальная реализация ПРОГРАММЫ HTTP-POST Edit использовала заявление foreach в блоке catch, чтобы зациклиться на нарушениях правил объекта Ужина и добавить их в коллекцию ModelState контроллера:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample20.cs)]

Мы можем сделать этот код немного чище, добавив класс «ControllerHelpers» в проект NerdDinner и внедрив в него метод расширения «AddRuleViolations», который добавляет метод помощника к ASP.NET классу MVC ModelStateDictionary. Этот метод расширения может инкапсулировать логику, необходимую для заполнения ModelStateDictionary со списком ошибок нарушения правил:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample21.cs)]

Затем мы можем обновить наш метод действий http-POST Edit, чтобы использовать этот метод расширения для заполнения коллекции ModelState с нашими нарушениями правил ужина.

#### <a name="complete-edit-action-method-implementations"></a>Полная реализация метода действий

Приведенный ниже код реализует всю логику контроллера, необходимую для нашего сценария edit:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample22.cs)]

Хорошая вещь о нашей реализации Edit является то, что ни наш класс контроллера, ни наш шаблон View не должен знать ничего о конкретной проверки или бизнес-правила, которые применяются нашей моделью ужина. Мы можем добавить дополнительные правила к нашей модели в будущем и не должны вносить какие-либо изменения кода в наш контроллер или представление для того, чтобы они были поддержаны. Это дает нам гибкость для легкого развития наших требований к приложениям в будущем с минимальными изменениями кода.

### <a name="create-support"></a>Создание поддержки

Мы закончили реализацию поведения "Edit" нашего класса DinnersController. Теперь давайте перейдем к реализации поддержки "Создать" на нем - что позволит пользователям добавлять новые Dinners.

#### <a name="the-http-get-create-action-method"></a>Метод действия HTTP-GET создает

Начнем с реализации http "GET" поведение нашего метода создания действий. Этот метод будет вызываться, когда кто-то посещает */Dinners/Create* URL. Наша реализация выглядит следующим:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample23.cs)]

Приведенный выше код создает новый объект Ужина и назначает его свойство EventDate на одну неделю в будущем. Затем отображается представление, основанное на новом объекте Ужина. Поскольку мы явно не передали имя методу помощника *View()* он будет использовать путь по умолчанию, основанный на конвенции, для разрешения шаблона представления: /Views/Dinners/Create.aspx.

Теперь давайте создадим этот шаблон представления. Мы можем сделать это путем нажатия правого нажатия в методе действий Create и выбора команды контекстного меню "Add View". В диалоге "Add View" мы укажем, что передадим объект ужина шаблону представления, и выберем для автоматического создания шаблона "Создать":

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image12.png)

При нажатии кнопки "Добавить" Visual Studio сохранит новый эшафот на основе "Create.aspx" вид на "Виды и ужины" каталог, и открыть его в IDE:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image13.png)

Давайте внедрем несколько изменений в файл эшафот по умолчанию, который был создан для нас, и изменяем его, чтобы выглядеть ниже:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample24.aspx)]

И теперь, когда мы запускаем наше приложение и получаем доступ к *URL-адресу "/Dinners/Create"* в браузере, это сделает uI, как ниже, из нашей реализации действий Create:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image14.png)

#### <a name="implementing-the-http-post-create-action-method"></a>Реализация метода создания http-POST

У нас реализована версия HTTP-GET нашего метода действий Create. Когда пользователь нажимает кнопку "Сохранить", он выполняет публикацию формы на */Dinners/Create* URL и отправляет значения формы ввода &lt;&gt; HTML с помощью глагола HTTP POST.

Теперь давайте реализуем поведение HTTP POST нашего метода создания действий. Начнем с добавления перегруженного метода действий «Создать» в наш DinnersController с атрибутом «AcceptVerbs», указывающим на то, что он обрабатывает сценарии HTTP POST:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample25.cs)]

Существует множество способов доступа к параметрам размещенной формы в нашем методе HTTP-POST с поддержкой "Создание".

Один из подходов заключается в создании нового объекта Ужин, а затем использовать *UpdateModel ()* метод помощника (как мы сделали с действием edit) заполнить его с размещены значения формы. Затем мы можем добавить его в наш DinnerRepository, упорствовать в базе данных и перенаправить пользователя на наше действие «Подробности», чтобы показать недавно созданный Ужин с помощью приведенного ниже кода:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample26.cs)]

Кроме того, мы можем использовать подход, в котором у нас есть наш метод действий Create() принять объект Ужин в качестве параметра метода. ASP.NET MVC автоматически мгновенно создайте для нас новый объект Dinner, заселит его свойства с помощью входных данных формы и передадут его нашему методу действия:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample27.cs)]

Наш метод действия выше проверяет, что объект Ужин был успешно заселен значениями формы поста, проверяя свойство ModelState.IsValid. Это возвращает сярприза, если есть проблемы с конверсией ввода (например: строка "BOGUS" для свойства EventDate), и если есть какие-либо проблемы, наш метод действия переотображает форму.

Если значения ввода действительны, то метод действия пытается добавить и сохранить новый ужин в DinnerRepository. Он обертывает эту работу в блоке try/catch и переотображает форму, если есть какие-либо нарушения бизнес-правил (что приведет к тому, что метод dinnerRepository.Save() вызовет исключение).

Чтобы увидеть это поведение обработки ошибок в действии, мы можем запросить */Dinners/Create* URL и заполнить подробную информацию о новом ужине. Неправильный ввод или значения приведет к повторному отображению формы создания с ошибками, выделенными ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image15.png)

Обратите внимание, что наша форма Create чтит точно такую же проверку и бизнес-правила, что и наша форма edit. Это связано с тем, что наши правила проверки и бизнес-правила были определены в модели и не были встроены в uI или контроллер приложения. Это означает, что мы можем позже изменить/развить наши правила проверки или ведения бизнеса в одном месте и заставить их применяться на протяжении всего нашего приложения. Нам не придется менять какой-либо код в рамках наших методов edit или Create action, чтобы автоматически соблюдать любые новые правила или изменения существующих.

Когда мы исправим значения ввода и снова нажмем на кнопку "Сохранить", наше добавление к DinnerRepository будет успешным, и новый ужин будет добавлен в базу данных. Затем мы будем перенаправлены на */Dinners/Подробности / URL-адрес* - где мы будем представлены с подробной информацией о недавно созданном ужине:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image16.png)

### <a name="delete-support"></a>Поддержка удаления

Теперь давайте добавим поддержку "Удалить" в наш DinnersController.

#### <a name="the-http-get-delete-action-method"></a>Метод действий по удалению HTTP-GET

Начнем с реализации поведения HTTP GET нашего метода действий удаления. Этот метод будет вызываться, когда кто-то посещает */Dinners/Delete/'id)* URL. Ниже приведена реализация:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample28.cs)]

Метод действия пытается получить ужин для удаления. Если ужин существует, он отображает Представление на основе объекта Ужина. Если объект не существует (или уже удален), он возвращает Представление, которое отображает шаблон представления "NotFound", созданный ранее для нашего метода действий "Подробности".

Мы можем создать шаблон представления «Удалить» путем нажатия правого нажатия в методе действия Delete и выбора команды меню контекста «Добавить вид». В диалоге "Add View" мы укаем, что передавая объект Ужина шаблону представления в качестве модели и выбираем создание пустого шаблона:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image17.png)

При нажатии кнопки "Добавить" Visual Studio добавит для нас в нашем каталоге шаблон "Delete.aspx" новый файл шаблона "Delete.aspx". Мы добавим некоторый HTML и код к шаблону для реализации экрана подтверждения удаления, как ниже:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample29.aspx)]

Приведенный выше код отображает название ужина, который будет удален, и выводит элемент &lt;формы,&gt; который делает POST на /Dinners/Delete/'id» URL, если конечный пользователь нажимает кнопку "Удалить" в нем.

Когда мы запускаем наше приложение и получаем доступ к *URL-адресу "/Dinners/Delete/'id)* для действительного объекта Ужин, он отображает uI как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image18.png)

| **Боковая тема: Почему мы делаем POST?** |
| --- |
| Вы можете спросить – почему мы прошли &lt;&gt; через усилия по созданию формы в нашем экране подтверждения Удаления? Почему бы просто не использовать стандартную гиперссылку для ссылки на метод действия, который делает фактическую операцию удаления? Причина в том, что мы хотим быть осторожными, чтобы защититься от веб-сканеров и поисковых систем обнаружения наших URL-адресов и непреднамеренно вызывая данные, которые будут удалены, когда они следуют ссылкам. URL-адреса на основе HTTP-GET считаются «безопасными» для доступа к ним, и они должны не следовать требованиям HTTP-POST. Хорошее правило заключается в том, чтобы убедиться, что вы всегда ставите разрушительные или данные, изменяющие операции за запросами HTTP-POST. |

#### <a name="implementing-the-http-post-delete-action-method"></a>Реализация метода действий по удалению HTTP-POST

Теперь у нас есть версия HTTP-GET нашего метода действий Delete, который отображает экран подтверждения удаления. Когда конечный пользователь нажимает кнопку "Удалить", он выполнит публикацию формы на *URL/Dinners/Dinner/id.*

Теперь давайте реализуем поведение http "POST" метода действий удаления с помощью приведенного ниже кода:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample30.cs)]

Версия http-POST нашего метода действий Delete пытается удалить объект ужина. Если он не может найти его (потому что он уже удален), он отображает наш шаблон "NotFound". Если он находит Ужин, он удаляет его из DinnerRepository. Затем отображается шаблон "Удаленный".

Для реализации шаблона "Удаленный" мы нажмем правой кнопкой мыши в методе действия и выберем контекстное меню "Добавить вид". Мы назовем наше представление "Удаленный" и иметь его пустой шаблон (а не принимать сильно типир модель объекта). Затем мы добавим в него некоторый HTML-контент:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample31.aspx)]

И теперь, когда мы запускаем наше приложение и доступ к *"/Dinners/Delete/'id)* URL для действительного объекта Ужин он будет оказывать наш ужин удалить подтверждение экрана, как ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image19.png)

При нажатии кнопки "Удалить" он будет выполнять HTTP-POST *на /Dinners / Удалить / ID "* URL, который будет удалить ужин из нашей базы данных, и отображать наш "Удаленный" шаблон представления:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image20.png)

### <a name="model-binding-security"></a>Модель связывающей безопасности

Мы обсудили два различных способа использования встроенных модельных связывающих функций ASP.NET MVC. Первый использует метод UpdateModel () для обновления свойств на существующем объекте модели, а второй — поддержку ASP.NET поддержки MVC для прохождения объектов модели в качестве параметров метода действия. Оба эти метода очень мощные и чрезвычайно полезны.

Эта власть также несет с собой ответственность. Важно всегда быть параноиком о безопасности при принятии любого пользовательского ввода, и это также верно при связывании объектов для формирования ввода. Вы должны быть осторожны, чтобы всегда HTML кодировать любые пользовательские значения, чтобы избежать HTML и JavaScript инъекций атак, и будьте осторожны с атак инъекций S'L (обратите внимание: мы используем LIN' для S'L для нашего приложения, который автоматически кодирует параметры для предотвращения этих типов атак). Вы никогда не должны полагаться только на проверку на стороне клиента и всегда использовать проверку на стороне сервера для защиты от хакеров, пытающихся отправить вам фиктивные значения.

Еще один элемент безопасности, чтобы убедиться, что вы думаете о при использовании связывающих функций ASP.NET MVC является область объектов, которые вы связывали. В частности, необходимо убедиться, что вы понимаете последствия свойств, которые вы позволяете быть связанными, и убедитесь, что вы разрешаете обновлять только те свойства, которые действительно должны быть обновлены конечным пользователем.

По умолчанию метод UpdateModel () будет пытаться обновить все свойства на объекте модели, которые соответствуют значениям параметров входящих форм. Аналогичным образом, объекты, передаваемые по параметрам метода действия, также по умолчанию могут иметь все свои свойства, установленные по параметрам формы.

#### <a name="locking-down-binding-on-a-per-usage-basis"></a>Блокировка привязки на основе использования

Можно заблокировать обязательную политику на основе использования, предоставив явный "список" свойств, которые могут быть обновлены. Это можно сделать, передавая дополнительный параметр массива строки методу UpdateModel() как ниже:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample32.cs)]

Объекты, передаваемые в качестве параметров метода действия, также поддерживают атрибут «Bind», который позволяет указывать «список» разрешенных свойств, как ниже:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample33.cs)]

#### <a name="locking-down-binding-on-a-type-basis"></a>Блокировка привязки на основе типа

Можно также заблокировать правила связывания на основе типа. Это позволяет один раз указать обязательные правила, а затем применить их во всех сценариях (включая сценарии параметров UpdateModel и метода действия) во всех контроллерах и методах действий.

Можно настроить правила привязки к типу, добавив атрибут «Bind» в тип или зарегистрировав его в файле Global.asax приложения (полезно для сценариев, где вы не владеете типом). Затем можно использовать свойства атрибута Bind Include and Exclude, чтобы контролировать, какие свойства могут быть связуемыдляы для конкретного класса или интерфейса.

Мы будем использовать этот метод для класса Ужин в нашем приложении NerdDinner, и добавим атрибут «Bind», который ограничивает список связываемых свойств следующими:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample34.cs)]

Обратите внимание, что мы не позволяем манипулировать коллекцией RSVPs с помощью связывания, и мы не позволяем свойствам DinnerID или HostedBy устанавливаться с помощью связывания. По соображениям безопасности мы будем манипулировать этими конкретными свойствами только с помощью явного кода в наших методах действий.

### <a name="crud-wrap-up"></a>CRUD Wrap-Up

ASP.NET MVC включает в себя ряд встроенных функций, которые помогают в реализации сценариев размещения форм. Мы использовали различные из этих функций, чтобы обеспечить поддержку uI CRUD поверх нашего DinnerRepository.

Мы используем ориентированный на модель подход к реализации нашего приложения. Это означает, что вся логика проверки и бизнес-правил определяется в нашем уровне модели, а не в наших контроллерах или представлениях. Ни наш класс контроллера, ни наши шаблоны View ничего не знают о конкретных бизнес-правилах, которые соблюдаются нашим классом модели Dinner.

Это позволит сохранить нашу архитектуру приложений в чистоте и упростит тестирование. В будущем мы можем добавить дополнительные бизнес-правила в наш модельный слой, и *не нужно вносить какие-либо изменения в код* в наш контроллер или представление, чтобы они могли быть поддержаны. Это даст нам большую гибкость для развития и изменения нашего приложения в будущем.

Наш DinnersController теперь позволяет списки/ детали ужина, а также создавать, отсвапроизводить и удалять поддержку. Полный код для класса можно найти ниже:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample35.cs)]

### <a name="next-step"></a>Следующий шаг

Теперь у нас есть базовая поддержка CRUD (Создание, чтение, обновление и удаление) в нашем классе DinnersController.

Давайте теперь рассмотрим, как мы можем использовать классы ViewData и ViewModel, чтобы включить еще более богатый доступ к доступу к веб-уму в наших формах.

> [!div class="step-by-step"]
> [Назад](use-controllers-and-views-to-implement-a-listingdetails-ui.md)
> [Вперед](use-viewdata-and-implement-viewmodel-classes.md)
