---
uid: mvc/overview/older-versions-1/nerddinner/provide-crud-create-read-update-delete-data-form-entry-support
title: Обеспечение поддержки записи формы данных CRUD (создание, чтение, обновление, удаление) | Документация Майкрософт
author: microsoft
description: На шаге 5 показано, как дальше использовать наш класс Диннерсконтроллер, включив поддержку редактирования, создания и удаления диннерс вместе с ним.
ms.author: riande
ms.date: 07/27/2010
ms.assetid: bbb976e5-6150-4283-a374-c22fbafe29f5
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/provide-crud-create-read-update-delete-data-form-entry-support
msc.type: authoredcontent
ms.openlocfilehash: b3123af9a1477bc496a0d229d628510fc202b6d2
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78468918"
---
# <a name="provide-crud-create-read-update-delete-data-form-entry-support"></a>Обеспечение поддержки операций CRUD (создание, чтение, обновление и удаление) для записей форм данных

по [Майкрософт](https://github.com/microsoft)

[Скачать в формате PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 5 бесплатного [учебника по приложению "NerdDinner"](introducing-the-nerddinner-tutorial.md) , в котором рассматривается создание небольшого, но полного веб-приложения с использованием ASP.NET MVC 1.
> 
> На шаге 5 показано, как дальше использовать наш класс Диннерсконтроллер, включив поддержку редактирования, создания и удаления диннерс вместе с ним.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем следовать руководствам по [Начало работы в MVC 3 или в приложении для](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) [музыкального магазина MVC](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) .

## <a name="nerddinner-step-5-create-update-delete-form-scenarios"></a>NerdDinner шаг 5. Создание, обновление и удаление сценариев форм

Мы предоставили контроллеры и представления и рассмотрели, как их использовать для реализации интерфейса получения списка и подробностей для диннерс на сайте. Следующим шагом будет дальнейшее использование нашего класса Диннерсконтроллер и включение поддержки редактирования, создания и удаления диннерс с ним.

### <a name="urls-handled-by-dinnerscontroller"></a>URL-адреса, обрабатываемые Диннерсконтроллер

Ранее мы добавили методы действий в Диннерсконтроллер, которые реализовали поддержку двух URL-адресов: */диннерс* и */диннерс/детаилс/[ID]* .

| **URL-адрес** | **ПЕРЕКЛЮЧАТЕЛ** | **Назначение** |
| --- | --- | --- |
| */диннерс/* | GET | Отобразить список HTML-страниц предстоящего диннерс. |
| */Диннерс/детаилс/[идентификатор]* | GET | Отображение сведений об определенном обеде. |

Теперь мы добавим методы действий для реализации трех дополнительных URL-адресов: */диннерс/едит/[ID]* , */диннерс/креате*и */диннерс/делете/[ID]* . Эти URL-адреса обеспечивают поддержку редактирования существующих диннерс, создания новых диннерс и удаления диннерс.

Мы будем поддерживать взаимодействия HTTP GET и HTTP POST с этими новыми URL-адресами. HTTP-запросы GET к этим URL-адресам будут отображать начальное представление HTML данных (форма, заполненная данными о компании в случае "Правка", пустая форма в случае "создать", и экран подтверждения удаления в случае "Удалить"). Запросы HTTP POST к этим URL-адресам сохраняют, обновляют или удаляют данные о обедах в нашей Диннеррепоситори (а также в базе данных).

| **URL-адрес** | **ПЕРЕКЛЮЧАТЕЛ** | **Назначение** |
| --- | --- | --- |
| */Диннерс/едит/[идентификатор]* | GET | Отображение редактируемой HTML-формы, заполненной данными о ужинах. |
| POST | Сохранение изменений формы для конкретного обеда в базе данных. |
| */диннерс/креате* | GET | Отобразить пустую HTML-форму, которая позволяет пользователям определять новые диннерс. |
| POST | Создайте новый обед и сохраните его в базе данных. |
| */Диннерс/делете/[идентификатор]* | GET | Отображение экрана подтверждения удаления. |
| POST | Удаляет указанный обед из базы данных. |

### <a name="edit-support"></a>Поддержка изменения

Начнем с реализации сценария "Изменить".

#### <a name="the-http-get-edit-action-method"></a>Метод действия HTTP-GET Edit

Начнем с реализации поведения HTTP "GET" для нашего метода действия Edit. Этот метод будет вызываться при запросе URL-адреса */диннерс/едит/[ID]* . Наша реализация будет выглядеть следующим образом:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample1.cs)]

Приведенный выше код использует Диннеррепоситори для получения объекта Dinner. Затем он визуализирует шаблон представления с помощью объекта Dinner. Поскольку имя шаблона не было явно передано в вспомогательный метод *View ()* , оно будет использовать путь по умолчанию на основе соглашения для разрешения шаблона представления:/виевс/диннерс/едит.аспкс.

Теперь создадим этот шаблон представления. Для этого нужно щелкнуть правой кнопкой мыши в методе Edit и выбрать команду контекстного меню "добавить представление":

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image1.png)

В диалоговом окне "Добавление представления" мы покажем, что мы передаем объект Dinnered в шаблон представления в качестве своей модели и выбираем автоматическое формирование шаблона "Edit".

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image2.png)

При нажатии кнопки "Добавить" Visual Studio добавит новый файл шаблона представления Edit. aspx для нас в каталог "\Виевс\диннерс". Кроме того, откроется новый шаблон представления Edit. aspx в редакторе кода, заполненный первой реализацией шаблона "Edit", как показано ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image3.png)

Внесите несколько изменений в создаваемый шаблон "Edit" по умолчанию и обновите его, добавим в него следующее содержимое (которое удаляет несколько свойств, которые мы не хотим предоставлять):

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample2.aspx)]

При запуске приложения и запросе URL-адреса *"/Dinners/Edit/1"* будет отображаться следующая страница:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image4.png)

Разметка HTML, созданная нашим представлением, выглядит следующим образом. Это стандартный HTML-код с &lt;формой&gt;, который выполняет HTTP-запрос POST к */Dinners/Edit/1* URL при нажатии кнопки "Save" &lt;input type = "Submit"/&gt;. Элемент HTML &lt;input type = "Text"/&gt; был выведен для каждого редактируемого свойства:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image5.png)

#### <a name="htmlbeginform-and-htmltextbox-html-helper-methods"></a>Вспомогательные методы HTML HTML. Бегинформ () и HTML. TextBox ()

В шаблоне представления "Edit. aspx" используется несколько методов "HTML helper": HTML. ValidationSummary (), HTML. Бегинформ (), HTML. TextBox () и HTML. Валидатионмессаже (). Помимо создания разметки HTML эти вспомогательные методы предоставляют встроенную поддержку обработки ошибок и проверки.

##### <a name="htmlbeginform-helper-method"></a>Вспомогательный метод HTML. Бегинформ ()

Вспомогательный метод HTML. Бегинформ () выводит элемент&gt; HTML &lt;Form в нашей разметке. В нашем шаблоне представления Edit. aspx Вы заметите, что при C# использовании этого метода мы применяем оператор "using". Открывающая фигурная скобка обозначает начало &lt;формы&gt; содержимому, а закрывающая фигурная скобка — это элемент, указывающий на конец элемента&gt; &lt;а форм:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample3.cs)]

Кроме того, при обнаружении неестественного подхода "using" для сценария, такого как, можно использовать сочетание HTML. Бегинформ () и HTML. Ендформ () (что делает то же самое):

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample4.aspx)]

Вызов HTML. Бегинформ () без параметров приведет к выходу элемента Form, который выполняет HTTP-POST в URL текущего запроса. Именно поэтому в нашем представлении редактирования создается *&lt;форма Action = «/Dinners/Edit/1» Method = «POST»&gt;* element. Можно было бы передать явные параметры в формат HTML. Бегинформ (), если нам хотелось бы публиковать данные по другому URL-адресу.

##### <a name="htmltextbox-helper-method"></a>Вспомогательный метод HTML. TextBox ()

Представление Edit. aspx использует вспомогательный метод HTML. TextBox () для вывода &lt;input type = "Text"/&gt; Elements:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample5.aspx)]

Приведенный выше метод HTML. TextBox () принимает один параметр, который используется для указания атрибутов ID/Name элемента &lt;input type = "Text"/&gt; для вывода, а также свойства модели для заполнения значения TextBox. Например, объект Dinner, переданный в представление редактирования, имел свойство "Title" со значением ".NET Futures", поэтому наш вызов метода HTML. TextBox ("Title"): *&lt;вход ID = "Title" Name = "Title" Type = "Text" value = ". NET Futures"/&gt;* .

Кроме того, можно использовать первый параметр HTML. TextBox (), чтобы указать идентификатор или имя элемента, а затем явно передать значение для использования в качестве второго параметра:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample6.aspx)]

Часто требуется выполнить пользовательское форматирование для выходных значений. В этих сценариях используется статический метод String. Format (), встроенный в .NET. Наш шаблон представления Edit. aspx использует этот параметр для форматирования значения Евентдате (который относится к типу DateTime), чтобы не показывать секунды в течение времени:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample7.aspx)]

Третий параметр для HTML. TextBox () при необходимости можно использовать для вывода дополнительных атрибутов HTML. В приведенном ниже фрагменте кода показано, как отобразить дополнительный атрибут size = "30" и атрибут class = "миксскласс" в элементе &lt;input type = "Text"/&gt;. Обратите внимание, что при экранировании имени атрибута класса с помощью «@" character because "класса» зарезервированное ключевое слово C#в:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample8.aspx)]

#### <a name="implementing-the-http-post-edit-action-method"></a>Реализация метода действия HTTP-POST

Теперь у нас есть реализованная версия метода действия Edit для HTTP-GET. Когда пользователь запрашивает URL-адрес */Dinners/Edit/1* , он получает HTML-страницу, подобную следующей:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image6.png)

Нажатие кнопки "Сохранить" приводит к тому, что форма отправляется на URL-адрес */Dinners/Edit/1* , а также передает HTML-&lt;входные&gt; значения формы с помощью команды HTTP POST. Давайте теперь реализуем поведение HTTP POST в нашем методе действия Edit, который будет работать с сохранением компании Dinner.

Начнем с добавления перегруженного метода действия Edit в наш Диннерсконтроллер с атрибутом Акцептвербс, который указывает, что он обрабатывает сценарии HTTP POST:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample9.cs)]

Если атрибут [Акцептвербс] применяется к перегруженным методам действия, ASP.NET MVC автоматически обрабатывает запросы к соответствующему методу действия в зависимости от входящей HTTP-команды. HTTP-запросы POST к URL-адресам */диннерс/едит/[ID]* будут переноситься в приведенный выше метод Edit, а все остальные HTTP-запросы к */диннерс/едит/[ID]* будут переходить к первому методу Edit, который мы реализовали (не имеющего атрибута `[AcceptVerbs]`).

| **Побочный раздел: Почему следует отличать через HTTP-команды?** |
| --- |
| Вы можете спросить, зачем использовать один URL-адрес и отличать его поведение с помощью глагола HTTP? Почему бы не просто иметь два отдельных URL-адреса для управления загрузкой и сохранением изменения? Например:/диннерс/едит/[ID] для вывода начальной формы и/диннерс/Саве/[ID] для сохранения формы? Недостаток публикации двух отдельных URL-адресов заключается в том, что в случаях, когда мы публикуемся в/Dinners/Save/2, а затем требуется повторно отобразить форму HTML из-за ошибки ввода, конечный пользователь будет иметь URL-адрес/Dinners/Save/2 в адресной строке браузера (так как это URL-адрес, который был опубликован в форме). Если пользователь запишет эту измененную страницу в список избранного браузера или скопирует и вставит URL-адрес и отправит его другу, то в итоге будет сохранен URL-адрес, который не будет работать в будущем (так как этот URL-адрес зависит от значений POST). Благодаря предоставлению одного URL-адреса (например,/диннерс/едит/[ID]) и различения его обработки командой HTTP, конечным пользователям может быть обеспечено создание закладки на странице редактирования и/или отправка URL-адреса другим. |

#### <a name="retrieving-form-post-values"></a>Получение значений записи формы

Существует множество способов доступа к опубликованным параметрам формы в методе HTTP POST "Edit". Простой подход заключается в простом использовании свойства Request в базовом классе контроллера для доступа к коллекции форм и получения размещенных значений напрямую:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample10.cs)]

Однако описанный выше подход является довольно подробным, особенно после добавления логики обработки ошибок.

Лучшим подходом для этого сценария является использование встроенного вспомогательного метода *упдатемодел ()* в базовом классе контроллера. Он поддерживает обновление свойств объекта, который мы передаем с помощью входящих параметров формы. Он использует отражение для определения имен свойств объекта, а затем автоматически преобразует и присваивает им значения на основе входных значений, отправленных клиентом.

Мы можем использовать метод Упдатемодел (), чтобы упростить наше действие по изменению HTTP, используя следующий код:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample11.cs)]

Теперь мы можем посетить URL-адрес */Dinners/Edit/1* и изменить название нашего обеда:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image7.png)

При нажатии кнопки "Сохранить" мы выполним запись формы в наше действие редактирования, и обновленные значения будут сохранены в базе данных. Затем мы будем перенаправлены на URL-адрес сведений о обеде (который будет отображать только что сохраненные значения):

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image8.png)

#### <a name="handling-edit-errors"></a>Обработка ошибок редактирования

Наша текущая реализация HTTP-POST работает нормально — за исключением случаев возникновения ошибок.

Когда пользователь создает ошибку при редактировании формы, необходимо убедиться в том, что форма отображается с информативным сообщением об ошибке, помогающим устранить ее. Сюда входят случаи, когда конечный пользователь отправляет неверные входные данные (например, неверно сформированная строка даты), а также случаи, когда входной формат допустим, но существует нарушение бизнес-правила. При возникновении ошибок форма должна сохранить введенные пользователем входные данные, чтобы они не заполняли изменения вручную. Этот процесс должен повторяться столько раз, сколько необходимо, пока форма не будет успешно завершена.

ASP.NET MVC содержит некоторые удобные встроенные функции, которые упрощают обработку ошибок и отображение формы. Чтобы просмотреть эти функции в действии, обновите наш метод действия Edit следующим кодом:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample12.cs)]

Приведенный выше код похож на нашу предыдущую реализацию, за исключением того, что теперь мы обтеканием блока обработки ошибок try/catch вокруг нашей работы. Если исключение возникает либо при вызове Упдатемодел (), либо при попытке сохранить Диннеррепоситори (что вызовет исключение, если объект ужин, который мы пытаемся сохранить, является недопустимым из-за нарушения правила в нашей модели), наш блок обработки ошибок catch будет работать. В нем мы циклим все нарушения правил, которые существуют в объекте ужин, и добавили их в объект ModelState (который мы будем обсуждать чуть позже). Затем отобразится представление.

Чтобы увидеть, как это работает, перезапустите приложение, измените обед и измените его, указав пустой заголовок, Евентдате "ФИКТИВного" и используя номер телефона в Великобритании со значением "страна США". При нажатии кнопки "Сохранить" наш метод HTTP POST не сможет сохранить обед (из-за ошибок) и снова отобразит форму:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image9.png)

Наше приложение имеет приличное взаимодействие с ошибками. Текстовые элементы с недопустимыми входными данными выделены красным цветом, а сообщения об ошибках проверки выводятся конечным пользователем. Форма также сохраняет входные данные, которые были изначально введены пользователем — так что им не придется заполнять ничего.

Как вы можете спросить, что это произошло? Как текстовые поля Title, Евентдате и Контактфоне выделяются красным цветом и знали, что они выводят первоначально введенные значения пользователя? И как сообщения об ошибках появляются в списке вверху? Хорошая новость заключается в том, что это не было вызвано волшебной функциональностью, так как мы использовали некоторые встроенные функции ASP.NET MVC, упрощающие проверку входных данных и сценарии обработки ошибок.

#### <a name="understanding-modelstate-and-the-validation-html-helper-methods"></a>Основные сведения о ModelState и вспомогательных методах HTML проверки

Классы контроллеров имеют коллекцию свойств «ModelState», которая позволяет указать, что ошибки существуют в объекте модели, переданном в представление. Записи об ошибках в коллекции ModelState определяют имя свойства модели с проблемой (например, "Title", "Евентдате" или "Контактфоне") и позволяют указать удобное сообщение об ошибке (например, "заголовок является обязательным").

Вспомогательный метод *упдатемодел ()* автоматически заполняет коллекцию ModelState при возникновении ошибок при попытке присвоить значения формы свойствам объекта модели. Например, свойство Евентдате нашего объекта Dinner имеет тип DateTime. Если методу Упдатемодел () не удалось назначить строковое значение "подфиктиво" в приведенном выше сценарии, метод Упдатемодел () добавил запись в коллекцию ModelState, указывающую на ошибку назначения для этого свойства.

Разработчики также могут написать код для явного добавления записей ошибок в коллекцию ModelState, как показано ниже в блоке обработки ошибок "Catch", который заполняет коллекцию ModelState записями на основе нарушений активного правила в Объект ужина:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample13.cs)]

#### <a name="html-helper-integration-with-modelstate"></a>Интеграция вспомогательного метода HTML с ModelState

Вспомогательные методы HTML, например HTML. TextBox (). Проверьте коллекцию ModelState при отрисовке выходных данных. Если для элемента существует ошибка, он отображает пользовательское значение и класс ошибок CSS.

Например, в нашем представлении "Правка" мы используем вспомогательный метод HTML. TextBox () для визуализации Евентдате нашего объекта Dinner.

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample14.aspx)]

Когда представление было подготовлено в случае ошибки, метод HTML. TextBox () проверил коллекцию ModelState, чтобы узнать, не возникали ли ошибки, связанные со свойством "Евентдате" нашего объекта Dinner. Если было определено, что произошла ошибка при отправке введенных пользователем данных ("ФИКТИВных") в качестве значения, а также добавлен класс Error CSS в &lt;input type = "TextBox"/&gt; разметки, созданной им:

[!code-html[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample15.html)]

Вы можете настроить внешний вид класса ошибок CSS. Класс ошибок CSS по умолчанию — "Ввод-проверка-ошибка" — определяется в таблице стилей *\контент\сите.КСС* и выглядит следующим образом:

[!code-css[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample16.css)]

Это правило CSS привело к тому, что наши недопустимые элементы ввода будут выделены следующим образом:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image10.png)

##### <a name="htmlvalidationmessage-helper-method"></a>Вспомогательный метод HTML. Валидатионмессаже ()

Вспомогательный метод HTML. Валидатионмессаже () можно использовать для вывода сообщения об ошибке ModelState, связанного с определенным свойством модели:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample17.aspx)]

Приведенный выше код выводит: *&lt;span class = "поле-Проверка-ошибка"&gt; значение "ПОДдельное" недопустимо&lt;/span&gt;*

Вспомогательный метод HTML. Валидатионмессаже () также поддерживает второй параметр, позволяющий разработчикам переопределять отображаемое текстовое сообщение об ошибке:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample18.aspx)]

Приведенный выше код выводит: *&lt;span class = "поле-Проверка-ошибка"&gt;\*&lt;/span&gt;* вместо текста ошибки по умолчанию, если для свойства евентдате задана ошибка.

##### <a name="htmlvalidationsummary-helper-method"></a>Вспомогательный метод HTML. ValidationSummary ()

Вспомогательный метод HTML. ValidationSummary () можно использовать для отображения сводного сообщения об ошибке, сопровождаемого &lt;UL&gt;&lt;Li/&gt;&lt;/UL&gt; список всех подробных сообщений об ошибках в коллекции ModelState:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image11.png)

Вспомогательный метод HTML. ValidationSummary () принимает необязательный строковый параметр, который определяет сводное сообщение об ошибке, отображаемое над списком подробных ошибок:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample19.aspx)]

При необходимости можно использовать CSS для переопределения того, как выглядит список ошибок.

#### <a name="using-a-addruleviolations-helper-method"></a>Использование вспомогательного метода Аддрулевиолатионс

Наша первоначальная реализация HTTP-после редактирования использовала инструкцию foreach в блоке catch для циклического перебора нарушений правил объекта Dinner The и добавления их в коллекцию ModelState контроллера:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample20.cs)]

Мы можем сделать этот код небольшим, добавив класс "Контроллерхелперс" в проект NerdDinner и реализующий в нем метод расширения "Аддрулевиолатионс", который добавляет вспомогательный метод в класс ASP.NET MVC ModelStateDictionary. Этот метод расширения может инкапсулировать логику, необходимую для заполнения ModelStateDictionary списком ошибок Рулевиолатион:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample21.cs)]

Затем мы можем обновить наш метод действия HTTP-POST, чтобы использовать этот метод расширения для заполнения коллекции ModelState с помощью наших нарушений правила компании.

#### <a name="complete-edit-action-method-implementations"></a>Завершение реализации методов редактирования действий

В приведенном ниже коде реализована вся логика контроллера, необходимая для нашего сценария редактирования.

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample22.cs)]

Хорошая вещь в нашей реализации редактирования заключается в том, что ни наш класс контроллера, ни наш шаблон представления не должны знать никаких сведений о конкретной проверке или бизнес-правилах, реализованных нашей моделью компании. Мы можем добавить дополнительные правила в нашу модель в будущем и не нужно вносить какие – либо изменения в код для этого контроллера или представления, чтобы они поддерживались. Это дает нам возможность легко развивать требования к приложениям в будущем с минимальными изменениями кода.

### <a name="create-support"></a>Создание поддержки

Мы завершили реализацию режима редактирования нашего класса Диннерсконтроллер. Теперь давайте перейдем к реализации поддержки "создания" для ИТ-службы, которая позволит пользователям добавлять новые диннерс.

#### <a name="the-http-get-create-action-method"></a>Метод действия HTTP-GET Create

Начнем с реализации поведения HTTP «GET» для нашего метода создания действия. Этот метод вызывается, когда пользователь посещает URL-адрес */диннерс/креате* . Наша реализация выглядит следующим образом:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample23.cs)]

Приведенный выше код создает новый объект ужин и присваивает его свойству Евентдате одну неделю в будущем. Затем он отображает представление, основанное на новом объекте Dinner. Так как мы не передавали имя в вспомогательный метод *View ()* , он будет использовать путь по умолчанию на основе соглашения для разрешения шаблона представления:/виевс/диннерс/креате.аспкс.

Теперь создадим этот шаблон представления. Это можно сделать, щелкнув правой кнопкой мыши в методе создания действия и выбрав команду контекстного меню "добавить представление". В диалоговом окне "Добавление представления" мы покажем, что мы передаем объект ужина в шаблон представления, и выбираете Автоформирование шаблона "создать":

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image12.png)

При нажатии кнопки "Добавить" Visual Studio сохранит новое представление на основе шаблона "Create. aspx" в каталоге "\Виевс\диннерс" и откроет его в интегрированной среде разработки:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image13.png)

Внесите несколько изменений в файл шаблона "Create" по умолчанию, который был создан для нас, и измените его так, чтобы он выглядел следующим образом:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample24.aspx)]

Теперь, когда мы запустим приложение и доступ к URL-адресу *"/диннерс/креате"* в браузере, он будет отображать пользовательский интерфейс, подобный приведенному ниже, из реализации создания действия.

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image14.png)

#### <a name="implementing-the-http-post-create-action-method"></a>Реализация метода действия HTTP-POST

Мы реализуем реализованный нами метод создания действия HTTP-GET. Когда пользователь нажимает кнопку "Сохранить", он выполняет запись POST в URL-адрес */диннерс/креате* и отправляет входные данные HTML &lt;&gt; значения формы с помощью команды HTTP POST.

Давайте теперь реализуем поведение HTTP POST для нашего метода создания действия. Начнем с добавления перегруженного метода действия Create в наш Диннерсконтроллер с атрибутом Акцептвербс, который указывает, что он обрабатывает сценарии HTTP POST:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample25.cs)]

Существует множество способов доступа к опубликованным параметрам формы в методе "Create", поддерживающем HTTP-POST.

Один из подходов состоит в создании нового объекта Dinner и последующем использовании вспомогательного метода *упдатемодел ()* (как мы сделали с действием Edit), чтобы заполнить его переданными значениями формы. Затем мы можем добавить его в наш Диннеррепоситори, сохранить в базе данных и перенаправить пользователя в подробное действие, чтобы отобразить только что созданный обед, используя приведенный ниже код.

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample26.cs)]

Кроме того, мы можем использовать подход, в котором мы создаем метод действия Create (), принимающий объект Dinner в качестве параметра метода. ASP.NET MVC автоматически создает экземпляр нового объекта Dinner for US, заполняет его свойства с помощью входных данных формы и передает его в метод действия:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample27.cs)]

Наш метод действия проверяет успешное заполнение объекта Dinner значениями формы POST путем проверки свойства ModelState. IsValid. Будет возвращено значение false, если возникли проблемы с входным преобразованием (например, строка "подложный" для свойства Евентдате), и если возникли какие-либо проблемы, метод действия переводит форму.

Если входные значения допустимы, метод действия пытается добавить и сохранить новый ужин в Диннеррепоситори. Он заключает эту работу в блок try/catch и повторно отображает форму при наличии нарушений бизнес-правил (что вызовет метод Диннеррепоситори. Save () для вызова исключения).

Чтобы увидеть это поведение обработки ошибок в действии, мы можем запросить URL-адрес */диннерс/креате* и заполнить сведения о новом обеде. Неверные входные данные или значения приведут к повторному отображению формы создания с выделенными ошибками, приведенными ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image15.png)

Обратите внимание, что наша форма создания имеет те же проверки и бизнес-правила, что и наша форма редактирования. Это обусловлено тем, что наши проверки и бизнес-правила были определены в модели и не были внедрены в пользовательский интерфейс или контроллер приложения. Это означает, что мы можем позже изменить или развивать проверку или бизнес-правила в одном месте и применить их ко всему приложению. Нам не придется изменять код в методах действия Edit или CREATE, чтобы автоматически учитывать любые новые правила или изменения существующих.

При исправлении входных значений и повторном нажатии кнопки "Сохранить" Добавление в Диннеррепоситори будет продолжено, а новый обед будет добавлен в базу данных. Затем мы будем перенаправлены на URL-адрес */диннерс/детаилс/[ID]* , где будут представлены сведения о вновь созданном обеде:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image16.png)

### <a name="delete-support"></a>Поддержка удаления

Теперь добавим поддержку "Delete" в наш Диннерсконтроллер.

#### <a name="the-http-get-delete-action-method"></a>Метод действия HTTP-GET Delete

Начнем с реализации поведения HTTP GET для нашего метода действия Delete. Этот метод вызывается, когда пользователь посещает URL-адрес */диннерс/делете/[ID]* . Ниже приведена реализация:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample28.cs)]

Метод действия пытается извлечь обед для удаления. Если компания Dinner Now, она отображает представление на основе объекта Dinner. Если объект не существует (или уже был удален), он возвращает представление, которое визуализирует шаблон представления "NotFound", созданный ранее для нашего метода действия "Details".

Шаблон представления "удаление" можно создать, щелкнув правой кнопкой мыши в методе действия Delete и выбрав команду контекстного меню Добавить представление. В диалоговом окне "Добавление представления" мы будем указывать, что в качестве модели мы передаем объект ужина в шаблон представления, а затем создаем пустой шаблон:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image17.png)

При нажатии кнопки "Добавить" Visual Studio добавит новый файл шаблона представления "Delete. aspx" для нас в нашем каталоге "\Виевс\диннерс". Мы добавим в шаблон HTML и код, чтобы реализовать экран подтверждения удаления, как показано ниже:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample29.aspx)]

Приведенный выше код отображает название компании, которую нужно удалить, и выводит &lt;форму&gt;, которая выполняет запись в URL-адрес/диннерс/делете/[ID], если пользователь нажимает кнопку "Удалить" в ней.

При запуске нашего приложения и доступе к URL-адресу *"/диннерс/делете/[ID]"* для действительного объекта ужин он визуализируется следующим образом:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image18.png)

| **Побочный раздел: почему мы делаем запись?** |
| --- |
| Вы можете спросить, зачем создавать &lt;формы&gt; на экране подтверждения удаления? Почему бы не просто использовать стандартную гиперссылку для связи с методом действия, который выполняет фактическую операцию удаления? Причина заключается в том, что необходимо соблюдать осторожность при защите от веб-обходчиков и поисковых модулей, чтобы обнаружить наши URL-адреса и случайно вызвать удаление данных, когда они следуют по ссылкам. URL-адреса, основанные на HTTP, считаются "безопасными", чтобы они были доступны для доступа и сканирования, и они должны не следовать за HTTP-POST. Хорошее правило заключается в том, чтобы всегда помещать разрушение или операции изменения данных за запросы HTTP-POST. |

#### <a name="implementing-the-http-post-delete-action-method"></a>Реализация метода действия HTTP-POST Delete

Теперь у нас есть версия HTTP-GET метода действия Delete, реализованная с отображением экрана подтверждения удаления. Когда пользователь нажимает кнопку "Удалить", он выполнит форму POST на URL-адрес */диннерс/Диннер/[ID]* .

Давайте теперь реализуем поведение HTTP "POST" метода Delete, используя приведенный ниже код.

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample30.cs)]

Версия HTTP-POST метода действия Delete пытается извлечь объект обеда для удаления. Если он не удается найти (потому что он уже удален), он визуализирует наш шаблон "NotFound". Если он находит обед, он удаляется из Диннеррепоситори. Затем он отображает удаленный шаблон.

Чтобы реализовать шаблон "Deleted", щелкните правой кнопкой мыши в методе действия и выберите контекстное меню "добавить представление". Мы назовем представление "удалено" и добавим его в пустой шаблон (и не возьмем объект модели со строгой типизацией). Затем мы добавим в него некоторое содержимое HTML:

[!code-aspx[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample31.aspx)]

Теперь, когда мы выполним приложение и доступ к URL-адресу *"/диннерс/делете/[ID]"* для действительного объекта ужин, он отобразит экран подтверждения удаления компании, как показано ниже:

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image19.png)

Когда мы нажимайте кнопку "Удалить", он выполняет HTTP-POST в URL */диннерс/делете/[ID]* , который удаляет обед из нашей базы данных и отображает наш шаблон представления "удалено":

![](provide-crud-create-read-update-delete-data-form-entry-support/_static/image20.png)

### <a name="model-binding-security"></a>Безопасность привязки модели

Мы обсуждали два разных способа использования встроенных функций привязки моделей ASP.NET MVC. Первый способ заключается в использовании метода Упдатемодел () для обновления свойств существующего объекта Model, а второй использует поддержку ASP.NET MVC для передачи объектов модели в качестве параметров метода действия. Оба эти метода являются очень мощными и чрезвычайно полезными.

Эта мощность также приносит ответственность за ИТ. Важно всегда параноиков о безопасности при принятии любых вводимых пользователем данных, и это также справедливо при привязке объектов к входным данным. Следует осторожно всегда кодировать все введенные пользователем значения в формате HTML, чтобы избежать атак типа HTML и JavaScript, и будьте внимательны при атаках путем внедрения кода SQL (Примечание. Мы используем LINQ to SQL для нашего приложения, которое автоматически кодирует параметры, чтобы предотвратить их типы атак). Не следует использовать только проверку на стороне клиента и всегда применять проверку на стороне сервера для защиты от хакеров, пытающихся отправить вам фиктивные значения.

Еще один дополнительный элемент безопасности, который необходимо учесть при использовании функций привязки ASP.NET MVC, — это область объектов, которые вы привязываете. В частности, необходимо убедиться в том, что вы понимаете влияние на безопасность свойств, которые вы разрешаете привязать, и убедитесь, что разрешено обновление только тех свойств, которые должны обновляться конечным пользователем.

По умолчанию метод Упдатемодел () попытается обновить все свойства объекта модели, которые соответствуют входящим значениям параметров формы. Аналогично, объекты, передаваемые как параметры метода действия, также по умолчанию могут иметь все свои свойства, заданные через параметры формы.

#### <a name="locking-down-binding-on-a-per-usage-basis"></a>Блокировка привязки для каждого использования

Политику привязки можно заблокировать на уровне использования, предоставив явный "include List" для обновляемых свойств. Это можно сделать, передав дополнительный параметр массива строк методу Упдатемодел (), как показано ниже:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample32.cs)]

Объекты, передаваемые в качестве параметров метода действия, также поддерживают атрибут [BIND], который позволяет указать "include List" разрешенных свойств, как показано ниже:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample33.cs)]

#### <a name="locking-down-binding-on-a-type-basis"></a>Блокировка привязки на основе типа

Можно также заблокировать правила привязки для каждого типа. Это позволяет указать правила привязки один раз, а затем применять их во всех сценариях (включая сценарии Упдатемодел и параметров метода действия) на всех контроллерах и методах действий.

Правила привязки для каждого типа можно настроить, добавив атрибут [BIND] в тип или зарегистрировав его в файле Global. asax приложения (полезно для сценариев, в которых вы не являетесь владельцем типа). Затем можно использовать свойства include и Exclude атрибута BIND для управления тем, какие свойства могут быть привязаны к конкретному классу или интерфейсу.

Мы будем использовать этот метод для класса ужин в нашем приложении NerdDinner и добавим к нему атрибут [BIND], который будет ограничивать список связываемых свойств следующим образом:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample34.cs)]

Обратите внимание, что мы не можем управлять коллекцией RSVP с помощью привязки, а также не допускайте установки свойств Диннерид или Хостедби посредством привязки. По соображениям безопасности мы будем манипулировать только этими конкретными свойствами, используя явный код в методах действий.

### <a name="crud-wrap-up"></a>Создание оболочки для CRUD

ASP.NET MVC включает ряд встроенных функций, помогающих реализовать сценарии размещения форм. Мы использовали различные функции, чтобы обеспечить поддержку пользовательского интерфейса CRUD поверх наших Диннеррепоситори.

Мы используем подход, ориентированный на модели, для реализации нашего приложения. Это означает, что вся наша логика проверки и бизнес-правил определяется на уровне модели, а не в контроллерах и представлениях. Ни класс контроллера, ни наш шаблон представления не знает никаких сведений о конкретных бизнес-правилах, применяемых нашим классом модели Dinner.

Это обеспечит очистку архитектуры приложения и упростит ее тестирование. Мы можем добавить дополнительные бизнес-правила в наш слой модели в будущем и *не должны вносить изменения в код* контроллера или представления, чтобы они поддерживались. Это позволит нам получить большую гибкость в развитии и изменении нашего приложения в будущем.

Наша Диннерсконтроллер теперь включает в себя списки и сведения о обеде, а также поддержку создания, редактирования и удаления. Полный код для класса можно найти ниже:

[!code-csharp[Main](provide-crud-create-read-update-delete-data-form-entry-support/samples/sample35.cs)]

### <a name="next-step"></a>Следующий шаг

Теперь в нашем классе Диннерсконтроллер реализована поддержка базового класса CRUD (создание, чтение, обновление и удаление).

Теперь рассмотрим, как можно использовать классы ViewData и ViewModel, чтобы включить в наши формы даже более широкий пользовательский интерфейс.

> [!div class="step-by-step"]
> [Назад](use-controllers-and-views-to-implement-a-listingdetails-ui.md)
> [Вперед](use-viewdata-and-implement-viewmodel-classes.md)
