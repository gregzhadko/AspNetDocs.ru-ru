---
uid: mvc/overview/older-versions-1/nerddinner/build-a-model-with-business-rule-validations
title: Создайте модель с валидацией бизнес-правил (ru) Документы Майкрософт
author: rick-anderson
description: Шаг 3 показывает, как создать модель, которую мы можем использовать как для запроса, так и для обновления базы данных для нашего приложения NerdDinner.
ms.author: riande
ms.date: 07/27/2010
ms.assetid: 0bc191b2-4311-479a-a83a-7f1b1c32e6fe
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/build-a-model-with-business-rule-validations
msc.type: authoredcontent
ms.openlocfilehash: 1a316e9051cf56cd4f1546336b334ace991c05b3
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81541641"
---
# <a name="build-a-model-with-business-rule-validations"></a>Создание модели с проверками бизнес-правил

[корпорацией Майкрософт](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 3 бесплатно ["NerdDinner" приложение учебник,](introducing-the-nerddinner-tutorial.md) который ходит через как построить небольшой, но полный, веб-приложение с помощью ASP.NET MVC 1.
> 
> Шаг 3 показывает, как создать модель, которую мы можем использовать как для запроса, так и для обновления базы данных для нашего приложения NerdDinner.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем вам следовать [начиная с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.

## <a name="nerddinner-step-3-building-the-model"></a>NerdУжин Шаг 3: Строительство модели

В рамочной системе представления-контроллера модели термин "модель" относится к объектам, представляющим данные приложения, а также к соответствующей логике домена, которая интегрирует с ним проверку и бизнес-правила. Модель во многом является «сердцем» приложения на основе MVC, и, как мы увидим позже, принципиально управляет его поведением.

Платформа ASP.NET MVC поддерживает использование любой технологии доступа к данным, и разработчики могут выбирать из различных богатых вариантов данных .NET для реализации своих моделей, включая: LIN' to Entities, LIN- to S'L, NHibernate, LLBLGen Pro, SubSonic, WilsonORM или просто необработанные ADO.NET DataReaders или DataSets.

Для нашего приложения NerdDinner мы собираемся использовать LIN's для S'L для создания простой модели, которая довольно тесно соответствует нашей конструкции базы данных, и добавляет некоторые пользовательские логики проверки и бизнес-правил. Затем мы реализуем класс репозитория, который помогает абстрагировать реализацию сохранения данных от остальной части приложения и позволяет нам легко унифицировать его.

### <a name="linq-to-sql"></a>LINQ to SQL

ЛИНЗ к СЗЛ — это ORM (объектрелую реляционную картограф), которая поставляется как часть .NET 3.5.

ДЛЯ индекса LIN' в S'L предоставляется простой способ отображения таблиц баз данных в классах .NET, которые мы можем кодировать против. Для нашего приложения NerdDinner мы будем использовать его для отображения таблиц Dinners и RSVP в нашей базе данных к классам Dinner и RSVP. Столбцы столов Dinners и RSVP будут соответствовать свойствам в классах Dinner и RSVP. Каждый объект Dinner и RSVP будет представлять отдельную строку в таблицах Dinners или RSVP в базе данных.

ДЛЯ получения и обновления объектов Dinner и RSVP с данными базы данных нам позволяет избежать ручной работы инструкций по созданию и обновлению объектов Dinner и RSVP. Вместо этого мы определим классы Ужин и RSVP, как они сополога к / из базы данных, и отношения между ними. После этого компания LIN's to S'L позаботится о создании соответствующей логики выполнения S'L для использования во время выполнения, когда мы взаимодействуем и используем их.

Мы можем использовать языковую поддержку LIN'а в VB и C, чтобы писать выразительные запросы, которые извлекают объекты Dinner и RSVP из базы данных. Это сводит к минимуму объем кода данных, который нам нужно написать, и позволяет нам создавать действительно чистые приложения.

### <a name="adding-linq-to-sql-classes-to-our-project"></a>Добавление ЛИНЗ к классам S'L к нашему проекту

Начнем с нажатия правого нажатия на папку "Модели" в нашем проекте и выберем команду меню **Add-&gt;New Item:**

![](build-a-model-with-business-rule-validations/_static/image1.png)

Это позволит поднять диалог "Добавить новый пункт". Мы отфильтруем в категории "Данные" и выберем в нем шаблон "LIN- to S'L Classes":

![](build-a-model-with-business-rule-validations/_static/image2.png)

Мы назовем элемент "NerdDinner" и нажмите кнопку "Добавить". Visual Studio добавит файл NerdDinner.dbml в нашем каталоге «Модели», а затем откроет LIN' для реляционного дизайнера объектов S'L:

![](build-a-model-with-business-rule-validations/_static/image3.png)

### <a name="creating-data-model-classes-with-linq-to-sql"></a>Создание классов модели данных с помощью LIN- в S'L

Система LIN's to S'L позволяет нам быстро создавать классы моделей данных из существующей схемы базы данных. Для этого мы откроем базу данных NerdDinner в Server Explorer и выберем таблицы, которые мы хотим смоделировать в ней:

![](build-a-model-with-business-rule-validations/_static/image4.png)

Затем мы можем перетащить столы на поверхность конструктора LIN'l на поверхность конструктора. При этом lin-in S'L автоматически создадут классы Ужин и RSVP, используя схему таблиц (с свойствами класса, которые отображены в столбцах таблиц баз данных):

![](build-a-model-with-business-rule-validations/_static/image5.png)

По умолчанию конструктор у творцовой связи для конструктора S'L автоматически «плюрализмирует» названия таблиц и столбцов при создаете классы на основе схемы базы данных. Например: таблица "Ужины" в нашем примере выше привела к классу "Ужин". Это название класса помогает сделать наши модели совместимыми с соглашениями именования .NET, и я обычно считаю, что наличие дизайнера исправить это удобно (особенно при добавлении большого количества таблиц). Если вам не нравится название класса или имущества, которое генерирует дизайнер, вы всегда можете переопределить его и изменить его на любое имя, которое вы хотите. Вы можете сделать это либо путем редактирования объекта / имени в строке в рамках дизайнера или путем изменения его через сетку свойств.

По умолчанию конструктор LIN's to S'L также проверяет основные ключевые отношения ключей/иностранных ключей таблиц и на их основе автоматически создает «ассоциации взаимоотношений» по умолчанию между различными типами моделей, которые он создает. Например, когда мы тащили столы Dinners и RSVP на столы LIN' дизайнеру S'L, была выведена связь между ними между нами, основанная на том факте, что таблица RSVP имела иностранный ключ к столу Dinners (это указывается стрелкой в дизайнере):

![](build-a-model-with-business-rule-validations/_static/image6.png)

Вышеупомянутая ассоциация приведет к тому, что LIN-L добавит в класс RSVP сильно набранное свойство «Ужин», которое разработчики могут использовать для доступа к ужину, связанного с данным RSVP. Это также приведет к тому, что класс Dinner будет иметь свойство коллекции «RSVP», которое позволяет разработчикам извлекать и обновлять объекты RSVP, связанные с определенным ужином.

Ниже вы можете увидеть пример интеллекта в Visual Studio, когда мы создаем новый объект RSVP и добавляем его в коллекцию RSVPs ужина. Обратите внимание на то, как LIN-s к S'L автоматически добавлял коллекцию «RSVP» на объекте Ужина:

![](build-a-model-with-business-rule-validations/_static/image7.png)

Добавляя объект RSVP в коллекцию RSVPs ужина, мы говорим LIN's s S'L, чтобы связать отношения между ужином и строкой RSVP в нашей базе данных:

![](build-a-model-with-business-rule-validations/_static/image8.png)

Если вам не нравится, как дизайнер смоделировал или назвал ассоциацию таблиц, вы можете переопределить ее. Просто нажмите на ассоциативную стрелку внутри конструктора и получите доступ к ее свойствам через сетку свойств, чтобы переименовать, удалить или изменить ее. Однако для нашего приложения NerdDinner правила ассоциации по умолчанию хорошо работают для классов моделей данных, которые мы строим, и мы можем просто использовать поведение по умолчанию.

### <a name="nerddinnerdatacontext-class"></a>Класс NerdDinnerDataКонтекст

Visual Studio будет автоматически создавать классы .NET, представляющие модели и отношения баз данных, определенные с помощью LIN- для конструктора S'L. Кроме того, для каждого дизайнерского файла, добавленного в решение, формируется также класс LIN' к S'L DataContext. Поскольку мы назвали наш пункт lin's в класс «NerdDinner», созданный класс DataContext будет называться «NerdDinnerDataContext». Этот класс NerdDinnerDataContext является основным способом взаимодействия с базой данных.

Наш класс NerdDinnerDataContext предоставляет два свойства - "Ужины" и "RSVPs", которые представляют две таблицы, которые мы смоделировали в базе данных. Мы можем использовать C'для записи запросов LIN'а с этими свойствами для запроса и извлечения объектов Dinner и RSVP из базы данных.

Следующий код демонстрирует, как мгновенно издать объект NerdDinnerDataContext и выполнить запрос LIN' против него, чтобы получить последовательность ужинов, которые происходят в будущем. Visual Studio обеспечивает полное представление при написании запроса LIN', и объекты, возвращенные из него, сильно набраны, а также поддерживают интеллект:

![](build-a-model-with-business-rule-validations/_static/image9.png)

В дополнение к разрешению запроса на объекты Dinner и RSVP, NerdDinnerDataContext также автоматически отслеживает любые изменения, которые мы впоследствии вносим в объекты Dinner и RSVP, которые мы извлекаем через него. Мы можем использовать эту функциональность, чтобы легко сохранить изменения обратно в базу данных - без необходимости писать какой-либо явный код обновления S'L.

Например, приведенный ниже код демонстрирует, как использовать запрос LIN'а для извлечения одного объекта Ужина из базы данных, обновления двух свойств Ужина, а затем сохранения изменений обратно в базу данных:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample1.cs)]

Объект NerdDinnerDataContext в приведенном выше коде автоматически отслеживал изменения свойств, внесенные в объект Ужина, который мы извлекли из него. Когда мы вызвали метод «SubmitChanges()», он выполнит соответствующее заявление «UPDATE» в базе данных, чтобы сохранить обновленные значения обратно.

### <a name="creating-a-dinnerrepository-class"></a>Создание класса DinnerRepository

Для небольших приложений иногда хорошо, чтобы контроллеры работали непосредственно против класса LIN's to DataContext и встраивались в запросы LIN'а в состав контроллеров. Однако по мере того, как приложения становятся больше, этот подход становится громоздким для обслуживания и тестирования. Это также может привести к дублированию одних и тех же запросов В нескольких местах.

Один из подходов, который может упростить обслуживание и тестирование приложений, заключается в использовании шаблона «репозитория». Класс репозитория помогает инкапсулировать логику запроса и сохранения данных, а также абстрагирует детали реализации сохранения данных из приложения. Помимо более чистого кода приложения, использование шаблона репозитория может облегчить изменение реализации хранения данных в будущем, а также может облегчить модульное тестирование приложения, не требуя реальной базы данных.

Для нашего приложения NerdDinner мы определим класс DinnerRepository с подписью ниже:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample2.cs)]

*Примечание: Позже в этой главе мы извлекем интерфейс IDinnerRepository из этого класса и включим инъекцию зависимости с ним на наших контроллерах. Начнем с того, однако, мы собираемся начать простой и просто работать непосредственно с DinnerRepository класса.*

Для реализации этого класса мы нажмем правой кнопкой мыши на нашей папке "Модели" и выберем команду меню **Add-&gt;New Item.** В диалоге «Добавить новый элемент» мы выберем шаблон «Класс» и назовем файл «DinnerRepository.cs»:

![](build-a-model-with-business-rule-validations/_static/image10.png)

Затем мы можем реализовать наш класс DinnerRepository, используя приведенный ниже код:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample3.cs)]

### <a name="retrieving-updating-inserting-and-deleting-using-the-dinnerrepository-class"></a>Получение, обновление, вставка и удаление с помощью класса DinnerRepository

Теперь, когда мы создали наш класс DinnerRepository, давайте рассмотрим несколько примеров кода, которые демонстрируют общие задачи, которые мы можем сделать с ним:

#### <a name="querying-examples"></a>Примеры запросов

Приведенный ниже код получает один ужин с использованием значения DinnerID:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample4.cs)]

Код ниже получает все предстоящие обеды и петли над ними:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample5.cs)]

#### <a name="insert-and-update-examples"></a>Вставить и обновить примеры

Приведенный ниже код демонстрирует добавление двух новых ужинов. Дополнения/изменения в репозитории не засваучиваемые в базе данных до тех пор, пока не будет вызван метод «Сохранить()». ЛИНЗ в S'L автоматически обертывает все изменения в транзакции базы данных — так что либо все изменения происходят, либо ни одно из них не происходит, когда наш репозиторий экономит:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample6.cs)]

Приведенный ниже код извлекает существующий объект Dinner и изменяет два свойства на нем. Изменения завердаются обратно в базу данных при вызове метода "Сохранить()" в нашем репозитории:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample7.cs)]

Приведенный ниже код получает ужин, а затем добавляет к нему RSVP. Он делает это с помощью коллекции RSVPs на объекте Ужин, что LIN' к S'L создан для нас (потому что есть основной ключ / иностранных ключов отношения между двумя в базе данных). Это изменение сохраняется обратно в базу данных в качестве новой строки таблицы RSVP при вызове метода "Сохранить()" в репозитории:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample8.cs)]

#### <a name="delete-example"></a>Удалить Пример

Приведенный ниже код извлекает существующий объект Ужин, а затем отмечает его для удаления. При вызове метода "Сохранить()" в репозитории он выведет удаление обратно в базу данных:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample9.cs)]

### <a name="integrating-validation-and-business-rule-logic-with-model-classes"></a>Интеграция валидации и логики бизнес-правил с типовыми классами

Интеграция проверки и логики бизнес-правил является ключевой частью любого приложения, работающего с данными.

#### <a name="schema-validation"></a>Проверка схемы

При определении типов моделей с помощью lin's конструктору S'L типы данных свойств в классах моделей данных соответствуют типам данных таблицы баз данных. Например: если столбец "EventDate" в таблице Dinners является "временем даты", класс модели данных, созданный LIN' to S'L, будет типа "DateTime" (который является встроенным типом данных .NET). Это означает, что вы получите ошибки компиляции, если вы попытаетесь назначить целый ряд или boolean к нему из кода, и это приведет к ошибке автоматически, если вы попытаетесь неявно преобразовать недействительный тип строки к нему во время выполнения.

Кроме того, при использовании строк, которые будут защищать вас от атак на инъекционные удары, при использовании этого значения, можно автоматически обрабатывать ускользающие значения S'L для вас, что поможет защитить вас от атак на впрыски.

#### <a name="validation-and-business-rule-logic"></a>Логика валидации и бизнес-правил

Проверка схемы полезна в качестве первого шага, но редко достаточна. Большинство реальных сценариев требуют возможности указывать более богатую логику проверки, которая может охватывать несколько свойств, выполнять код и часто осознавать состояние модели (например: создается ли она /обновлена/удалена, или в пределах конкретного состояния домена, например "архивированного"). Существует множество различных шаблонов и фреймворков, которые могут быть использованы для определения и применения правил проверки для моделей классов, и существует несколько инфраструктур на основе .NET, которые могут быть использованы для оказания помощи в этом. Вы можете использовать почти любой из них в ASP.NET mVC приложений.

Для целей нашего приложения NerdDinner мы будем использовать относительно простой и прямой шаблон, где мы подвергаем свойство IsValid и метод GetRuleViolations() на нашем объекте модели ужина. Свойство IsValid будет возвращаться истинно или ложно в зависимости от того, являются ли все правила проверки и бизнес-правила действительными. Метод GetRuleViolations() вернет список ошибок правил.

Мы реализуем IsValid и GetRuleViolations() для нашей модели ужина, добавив в наш проект «частичный класс». Частичные классы могут использоваться для добавления методов/свойств/событий в классы, поддерживаемые конструктором VS (например, класс Ужин, генерируемый конструктором LIN' для S'L) и помогают избежать того, чтобы инструмент не вмешивался в наш код. Мы можем добавить новый частичный класс в наш проект, нажав правой кнопкой мыши на папке «Модели», а затем выберите команду меню «Добавить новый элемент». Затем мы можем выбрать шаблон "Класс" в диалоге "Добавить новый элемент" и назвать его Dinner.cs.

![](build-a-model-with-business-rule-validations/_static/image11.png)

Нажав на кнопку "Добавить", мы добавим Dinner.cs файл в наш проект и откроет его в рамках IDE. Затем мы можем реализовать основную структуру обеспечения соблюдения правил/проверки, используя приведенный ниже код:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample10.cs)]

Несколько заметок о приведенном выше коде:

- Класс «Ужин» предваряется «частичным» ключевым словом, что означает, что код, содержащийся в нем, будет сочетаться с классом, генерируемым/поддерживаемым конструктором LIN' и составленным в единый класс.
- Класс RuleViolation — это класс помощников, который мы добавим к проекту, который позволяет нам предоставить более подробную информацию о нарушении правил.
- Метод Dinner.GetRuleViolations() вызывает оценку наших правил проверки и бизнес-правил (мы внедрим их в ближайшее время). Затем он возвращает последовательность объектов нарушения правил, которые предоставляют более подробную информацию о любых ошибках правил.
- Свойство Dinner.IsValid предоставляет удобное свойство помощника, которое указывает, имеет ли объект Ужин какие-либо активные Нарушения правил. Он может быть упреждающе проверен разработчиком, использующим объект Ужин в любое время (и не вызывает исключения).
- Частичный метод Dinner.OnValidate () — это крючок, который обеспечивает LIN's к S'L, который позволяет нам получать уведомления в любое время, когда объект «Ужин» вот-вот будет упорствовать в базе данных. Наша реализация OnValidate () выше гарантирует, что ужин не имеет правил Нарушения, прежде чем он будет сохранен. Если он находится в недействительном состоянии, он вызывает исключение, что приведет к тому, что LIN-L может прервать транзакцию.

Этот подход обеспечивает простую основу, в которую мы можем интегрировать правила проверки и бизнес-правила. А теперь давайте добавим ниже правила к нашему методу GetRuleViolations():

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample11.cs)]

Мы используем функцию «возврата доходности» C, чтобы вернуть последовательность любых нарушений правил. Первые шесть проверок правил выше, просто принудить, что свойства строки на нашем ужине не могут быть нулевыми или пустыми. Последнее правило немного интереснее, и называет Метод помощника PhoneValidator.IsValidNumber(), который мы можем добавить в наш проект, чтобы убедиться, что формат номера ContactPhone соответствует стране ужина.

Мы можем использовать . Регулярная поддержка выражения NET для реализации этой поддержки проверки телефона. Ниже приводится простая реализация PhoneValidator, которую мы можем добавить в наш проект, которая позволяет нам добавлять проверки шаблонов Regex в конкретных странах:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample12.cs)]

#### <a name="handling-validation-and-business-logic-violations"></a>Обработка валидации и нарушения бизнес-логики

Теперь, когда мы добавили приведенный выше код валидации и бизнес-правил, каждый раз, когда мы пытаемся создать или обновить Ужин, наши правила логики проверки будут оценены и приведены в исполнение.

Разработчики могут написать код, как ниже, чтобы упреждающе определить, является ли объект Ужин действительным, и получить список всех нарушений в нем без каких-либо исключений:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample13.cs)]

Если мы попытаемся сохранить ужин в недействительном состоянии, будет увеличено исключение, когда мы вызываем метод «Сохранить() в DinnerRepository. Это происходит потому, что LIN's to S'L автоматически вызывает наш метод Dinner.OnValidate() частичный метод, прежде чем он сохранит изменения ужина, и мы добавили код в Dinner.OnValidate(), чтобы вызвать исключение, если в ужине есть какие-либо нарушения правил. Мы можем поймать это исключение и извлечь список нарушений для устранения:

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample14.cs)]

Поскольку наши правила проверки и ведения бизнеса реализуются в нашем типовом слое, а не в уровне UI, они будут применяться и использоваться во всех сценариях нашего приложения. Позже мы можем изменить или добавить бизнес-правила и иметь весь код, который работает с нашими объектами Dinner, чтобы соблюдать их.

Наличие гибкости для изменения бизнес-правил в одном месте, без того, чтобы эти изменения рябь всей приложения и логики uI, является признаком хорошо написанного приложения, и преимущество, что платформа MVC помогает поощрять.

### <a name="next-step"></a>Следующий шаг

Теперь у нас есть модель, которую мы можем использовать как для запроса, так и для обновления нашей базы данных.

Теперь давайте добавим некоторые контроллеры и представления к проекту, которые мы можем использовать для создания html интерфейса вокруг него.

> [!div class="step-by-step"]
> [Назад](create-a-database.md)
> [Вперед](use-controllers-and-views-to-implement-a-listingdetails-ui.md)
