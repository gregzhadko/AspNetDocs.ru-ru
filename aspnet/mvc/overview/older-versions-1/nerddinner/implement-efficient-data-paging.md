---
uid: mvc/overview/older-versions-1/nerddinner/implement-efficient-data-paging
title: Реализация эффективного разбиения данных на страницы | Документация Майкрософт
author: microsoft
description: На шаге 8 показано, как добавить в наш URL-адрес/диннерс поддержку разбиения по страницам, чтобы вместо 1000 тысяч диннерс отображалось 10 предстоящих диннерс в...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: adea836d-dbc2-4005-94ea-53aef09e9e34
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/implement-efficient-data-paging
msc.type: authoredcontent
ms.openlocfilehash: 2d9a0dba381b71755ac626f76d52bc5bcb434447
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78486486"
---
# <a name="implement-efficient-data-paging"></a>Реализация эффективного разбиения данных по страницам

по [Майкрософт](https://github.com/microsoft)

[Скачать в формате PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 8 из бесплатного [учебника по NerdDinner приложению](introducing-the-nerddinner-tutorial.md) , в котором рассматривается создание небольшого, но полного веб-приложения с использованием ASP.NET MVC 1.
> 
> На шаге 8 показано, как добавить поддержку разбиения по страницам в наш URL-адрес/диннерс, чтобы вместо отображения тысяч диннерс одновременно отображалось 10 предстоящих диннерсов, и позволить конечным пользователям пролистывать и пересылать весь список в удобном для SEO виде.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем следовать руководствам по [Начало работы в MVC 3 или в приложении для](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) [музыкального магазина MVC](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) .

## <a name="nerddinner-step-8-paging-support"></a>NerdDinner шаг 8. Поддержка разбиения по страницам

Если наш сайт будет успешным, у него будут тысячи ближайших диннерс. Нам нужно убедиться, что наш интерфейс масштабируется для выполнения всех этих диннерс и позволяет пользователям просматривать их. Чтобы включить эту функцию, мы добавим поддержку разбиения по страницам к URL-адресу */диннерс* , чтобы вместо отображения тысяч диннерс одновременно отображалось 10 предстоящих диннерс, и позволить конечным пользователям пролистывать и пересылать по всему списку понятный способ для SEO.

### <a name="index-action-method-recap"></a>Метод действия Index ()

В настоящее время метод действия Index () в нашем классе Диннерсконтроллер выглядит следующим образом:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample1.cs)]

При выполнении запроса к URL-адресу */диннерс* извлекается список всех предстоящих диннерс, а затем отображается список всех их элементов:

![](implement-efficient-data-paging/_static/image1.png)

### <a name="understanding-iqueryablelttgt"></a>Основные сведения о IQueryable&lt;T&gt;

*Iqueryable&lt;t&gt;* — это интерфейс, который появился с LINQ в составе .NET 3,5. Он обеспечивает мощные сценарии отложенного выполнения, которые можно использовать для реализации поддержки разбиения по страницам.

В нашем Диннеррепоситори мы возвращаем в метод Финдупкомингдиннерс ()&gt;ную последовательность с IQueryable&lt;.

[!code-csharp[Main](implement-efficient-data-paging/samples/sample2.cs)]

Объект IQueryable&lt;ужин&gt;, возвращенный методом Финдупкомингдиннерс (), инкапсулирует запрос для получения объектов Dinner из нашей базы данных с помощью LINQ to SQL. Важно то, что он не будет выполнять запрос к базе данных, пока не предпримет попытку получить доступ к данным в запросе или выполнить итерацию, или пока мы не вызываем метод ToList (). Код, вызывающий наш метод Финдупкомингдиннерс (), при необходимости может добавить дополнительные "сцепленные" операции или фильтры к IQueryable&lt;объект&gt; ужин перед выполнением запроса. Затем LINQ to SQL достаточно интеллектуальной, чтобы выполнить Объединенный запрос к базе данных при запросе данных.

Чтобы реализовать логику разбиения по страницам, мы можем обновить метод действия Index () Диннерсконтроллер, чтобы он применял дополнительные операторы "Skip" и "Take" к возвращенной последовательностью IQueryable&lt;ужин&gt; перед вызовом метода ToList ().

[!code-csharp[Main](implement-efficient-data-paging/samples/sample3.cs)]

Приведенный выше код пропускает первые 10 предстоящих диннерс в базе данных, а затем возвращает 20 диннерс. LINQ to SQL достаточно разумна для создания оптимизированного SQL-запроса, который выполняет эту пропускную логику в базе данных SQL, а не в Web Server. Это означает, что даже если у нас есть миллионы предстоящих диннерс в базе данных, в рамках этого запроса будет извлекаться только 10.

### <a name="adding-a-page-value-to-the-url"></a>Добавление значения "Page" к URL-адресу

Вместо того чтобы жестко программировать конкретный диапазон страниц, мы хотим, чтобы наши URL-адреса включали параметр «Page», указывающий, какой Обедный диапазон запрашивает пользователь.

#### <a name="using-a-querystring-value"></a>Использование значения строки запроса

В приведенном ниже коде показано, как можно обновить наш метод действия Index () для поддержки параметра QueryString и включения URL-адресов, таких как */диннерс? Page = 2*:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample4.cs)]

Метод действия Index () выше имеет параметр с именем "Page". Параметр объявляется как целое число, допускающее значение null (то есть что int? указывает). Это означает, что URL-адрес */диннерс? Page = 2* приведет к передаче значения "2" в качестве значения параметра. URL-адрес */диннерс* (без значения QueryString) приведет к передаче значения NULL.

Мы умножаем значение страницы на размер страницы (в данном случае 10 строк), чтобы определить, сколько диннерс пропускается. Мы используем [ C# оператор "объединения" (??) со значением NULL](https://weblogs.asp.net/scottgu/archive/2007/09/20/the-new-c-null-coalescing-operator-and-using-it-with-linq.aspx) , который полезен при работе с типами, допускающими значение null. Приведенный выше код присваивает странице значение 0, если параметр страницы имеет значение null.

#### <a name="using-embedded-url-values"></a>Использование внедренных URL-значений

Альтернативой использованию значения строки запроса является встраивание параметра страницы в фактический URL-адрес. Например: */Dinners/Page/2* или */Dinners/2*. ASP.NET MVC включает мощный механизм маршрутизации URL-адресов, который упрощает поддержку таких сценариев.

Мы можем зарегистрировать пользовательские правила маршрутизации, которые сопоставляют любой входящий URL-адрес или формат URL-адреса с любым классом контроллера или методом действия, который нам нужен. Нам нужно только открыть файл Global. asax в нашем проекте:

![](implement-efficient-data-paging/_static/image2.png)

Затем зарегистрируйте новое правило сопоставления с помощью вспомогательного метода файл MapRoute (), подобно первому вызову маршрутов. Файл MapRoute () ниже:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample5.cs)]

Выше мы регистрируем новое правило маршрутизации с именем "Упкомингдиннерс". Мы обозначаем, что он имеет формат URL-адреса "диннерс/Page/{Page}", где {Page} — это значение параметра, внедренное в URL-адрес. Третий параметр метода файл MapRoute () указывает, что необходимо сопоставить URL-адреса, соответствующие этому формату, с методом действия Index () в классе Диннерсконтроллер.

Мы можем использовать тот же код индекса (), который мы имели до нашего сценария QueryString, за исключением того, что теперь наш параметр "страница" будет получен из URL-адреса, а не из строки запроса:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample6.cs)]

Теперь при запуске приложения и вводе в */диннерс* мы увидим первые 10 предстоящих диннерс:

![](implement-efficient-data-paging/_static/image3.png)

И при вводе в */Dinners/Page/1* мы увидим следующую страницу диннерс:

![](implement-efficient-data-paging/_static/image4.png)

### <a name="adding-page-navigation-ui"></a>Добавление пользовательского интерфейса навигации по страницам

Последним шагом для завершения нашего сценария разбиения на страницы будет реализация пользовательского интерфейса навигации "Next" и "Previous" в нашем шаблоне представления, чтобы пользователи могли легко пропускать данные о обедах.

Чтобы правильно реализовать эту возможность, необходимо знать общее количество диннерс в базе данных, а также количество страниц данных, на которые она преобразуется. Затем необходимо определить, находится ли текущее запрошенное значение "Page" в начале или в конце данных, а также показать или скрыть соответствующий пользовательский интерфейс "назад" и "Далее". Мы можем реализовать эту логику в методе действия Index (). Кроме того, мы можем добавить вспомогательный класс в наш проект, который инкапсулирует эту логику более повторного использования.

Ниже приведен простой вспомогательный класс "Пагинатедлист", производный от класса списка&lt;T&gt; коллекции, встроенного в .NET Framework. Он реализует повторно используемый класс коллекции, который можно использовать для разбиения любой последовательности данных IQueryable на страницы. В нашем приложении NerdDinner он будет работать с IQueryable&lt;&gt;ных результатов, но его можно было бы легко использовать для IQueryable&lt;&gt; продуктов или IQueryable&lt;клиентской&gt; результаты в других сценариях приложения:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample7.cs)]

Обратите внимание на то, как оно вычисляется, а затем предоставляет такие свойства, как "PageIndex", "PageSize", "TotalCount" и "TotalPages". Он также предоставляет два вспомогательных свойства "Хаспревиауспаже" и "Хаснекстпаже", которые указывают, находится ли страница данных в коллекции в начале или в конце исходной последовательности. Приведенный выше код приведет к запуску двух SQL-запросов — первый способ получить количество от общего числа объектов Dinner (это не возвращает объекты), а затем выполняет инструкцию SELECT COUNT, возвращающую целое число, а вторая — для получения только строк данные, необходимые в нашей базе данных для текущей страницы данных.

Затем можно обновить вспомогательный метод Диннерсконтроллер. index (), чтобы создать Пагинатедлист&lt;ужин&gt; из результата Диннеррепоситори. Финдупкомингдиннерс () и передать его в наш шаблон представления:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample8.cs)]

Затем можно обновить шаблон представления \Виевс\диннерс\индекс.аспкс, чтобы он наследовался от СтраницаПредставления&lt;NerdDinner. Helps. Пагинатедлист&lt;ужин&gt;&gt; вместо СтраницаПредставления&lt;IEnumerable&lt;ужин&gt;&gt;, а затем добавьте следующий код в нижнюю часть нашего шаблона представления, чтобы показать или скрыть следующий и предыдущий пользовательский интерфейс навигации:

[!code-aspx[Main](implement-efficient-data-paging/samples/sample9.aspx)]

Обратите внимание, что мы используем вспомогательный метод HTML. Раутелинк () для создания гиперссылок. Этот метод аналогичен вспомогательному методу HTML. ActionLink (), который мы использовали ранее. Разница заключается в том, что мы создаем URL-адрес с помощью правила маршрутизации "Упкомингдиннерс", которое мы настроили в файле Global. asax. Это гарантирует, что мы создадим URL-адреса для нашего метода действия Index (), который имеет следующий формат: */диннерс/Паже/{Паже}* — где значение {Page} — это переменная, которую мы предоставляем выше на основе текущего индекса PageIndex.

Теперь при повторном запуске нашего приложения в браузере будет показано 10 диннерс:

![](implement-efficient-data-paging/_static/image5.png)

Кроме того, в нижней части страницы есть &lt;&lt;&lt; и &gt;&gt;&gt;, что позволяет пропускать пересылку и обратную передачу по данным, используя доступные URL-адреса поисковой системы:

![](implement-efficient-data-paging/_static/image6.png)

| **Боковая Тема: основные сведения о влиянии IQueryable&lt;T&gt;** |
| --- |
| IQueryable&lt;T&gt; — это очень мощная функция, которая обеспечивает разнообразные интересные сценарии отложенного выполнения (например, запросы на основе разбиения на страницы и композиции). Как и в случае с любыми мощными функциями, необходимо соблюдать осторожность при использовании этой функции и убедиться в том, что она не нарушена. Важно понимать, что возврат IQueryable&lt;T&gt; результат из репозитория позволяет вызывать код для добавления в цепочку методов операторов и поэтому участвует в окончательном выполнении запроса. Если вы не хотите предоставлять вызывающему коду эту возможность, следует вернуть IList&lt;T&gt; или IEnumerable&lt;T&gt; results, которые содержат результаты уже выполненного запроса. Для сценариев разбивки на страницы необходимо передать логику разбиения данных на страницы в вызываемом методе репозитория. В этом сценарии мы можем обновить наш метод Финдупкомингдиннерс () Finder, чтобы получить сигнатуру, которая либо возвращает Пагинатедлист: Пагинатедлист&lt; ужин&gt; Финдупкомингдиннерс (int pageIndex, int pageSize) {} или вернуть IList&lt;ужин&gt;и использовать параметр "totalCount" для получения общего числа диннерс: IList&lt;ужин&gt; Финдупкомингдиннерс (int pageIndex, int pageSize, out int totalCount) {} |

### <a name="next-step"></a>Следующий шаг

Теперь рассмотрим, как можно добавить поддержку проверки подлинности и авторизации в наше приложение.

> [!div class="step-by-step"]
> [Назад](re-use-ui-using-master-pages-and-partials.md)
> [Вперед](secure-applications-using-authentication-and-authorization.md)
