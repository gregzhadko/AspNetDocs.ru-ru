---
uid: mvc/overview/older-versions-1/nerddinner/implement-efficient-data-paging
title: Реализовать эффективный данных разбиение по страницам | Документация Майкрософт
author: microsoft
description: Шаг 8 показано, как добавить поддержки разбиения по страницам наших /Dinners URL-адрес, чтобы вместо отображения тысячи ужинов за один раз, мы будем только отображать 10 предстоящих ужинов в...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: adea836d-dbc2-4005-94ea-53aef09e9e34
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/implement-efficient-data-paging
msc.type: authoredcontent
ms.openlocfilehash: 2bef690355cd1f89a15a67f0c49775296d551136
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57060161"
---
<a name="implement-efficient-data-paging"></a>Реализация эффективного разбиения данных по страницам
====================
по [Microsoft](https://github.com/microsoft)

[Загрузить PDF-файл](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это бесплатная этап 8 [руководство по использованию приложения «NerdDinner»](introducing-the-nerddinner-tutorial.md) , пошаговое рассмотрение как создать небольшой, но завершить, веб-приложения с помощью ASP.NET MVC 1.
> 
> Шаг 8 показано, как добавить поддержку разбиения по страницам наших /Dinners URL-адрес, чтобы вместо отображения тысячи ужинов за один раз, мы только раз - 10 предстоящих ужинов отображаются и предоставление конечным пользователям возможности странице назад и вперед по по всему списку, понятным образом SEO.
> 
> Если вы используете ASP.NET MVC 3, рекомендуется следовать [Приступая к работе с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.


## <a name="nerddinner-step-8-paging-support"></a>NerdDinner Step 8: Поддержка разбиения на страницы

При успешном выполнении наш сайт будет тысячи предстоящих ужинов. Нам необходимо убедиться, что масштабируется для удовлетворения всех этих ужинов пользовательскому Интерфейсу и позволяет пользователям просматривать их. Для этого мы добавим поддержку разбиения по страницам наших */Dinners* URL-адрес так, чтобы вместо отображения тысячи ужинов на один раз, мы будет только одновременно - отобразить 10 ужинов предстоящих и предоставление конечным пользователям возможности странице назад и вперед по весь список в SEO понятным способом.

### <a name="index-action-method-recap"></a>Обзор метод INDEX() действие

Метод действия Index() внутри наш класс DinnersController в данный момент выглядит как ниже:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample1.cs)]

При запросе к */Dinners* URL-адрес, он получает список всех будущих ужинов и выводит список всех из них:

![](implement-efficient-data-paging/_static/image1.png)

### <a name="understanding-iquerablelttgt"></a>Основные сведения о IQuerable&lt;T&gt;

*IQueryable&lt;T&gt;*  является интерфейсом, которая была представлена как часть .NET 3.5 с помощью LINQ. Он поддерживает мощные «отложенное выполнение» сценарии, которые мы можно воспользоваться преимуществами для реализации поддержки разбиения по страницам.

В нашем DinnerRepository возвращаете IQueryable&lt;ужин&gt; последовательности из нашего метода FindUpcomingDinners():

[!code-csharp[Main](implement-efficient-data-paging/samples/sample2.cs)]

IQueryable&lt;ужин&gt; объект, возвращенный наш метод FindUpcomingDinners() инкапсулирует запрос для получения Dinner объекты из базы данных с помощью LINQ to SQL. Что важно не будет выполняться запрос к базе данных, пока предпринимается попытка доступа/итерацию по данным в запросе или пока мы вызываем метод ToList() на нем. Код вызова нашего метода FindUpcomingDinners() при необходимости могут добавить дополнительные «связанный» operations/фильтры к IQueryable&lt;ужин&gt; объекта перед выполнением запроса. LINQ to SQL, то она затем выполнение объединенный запрос к базе данных, при запросе данных.

Для реализации логики разбиения на страницы, то есть применяется к возвращаемый IQueryable дополнительных операторов «Skip» и «Take» позволяет обновлять метод действия Index() наших DinnersController&lt;Dinner&gt; последовательности перед вызовом ToList() на нем:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample3.cs)]

Приведенный выше код пропускает первые 10 предстоящих ужины в базе данных и затем возвращает 20 ужинов. LINQ to SQL способен создавать оптимизированных запросов SQL, который выполняет эту проверку пропуск логики в базе данных SQL — а не в веб сервера. Это означает, что даже если у нас есть миллионы предстоящих ужинов в базе данных, только 10, которые требуется будут извлекаться как часть этого запроса (сделав его, эффективные и масштабируемые).

### <a name="adding-a-page-value-to-the-url"></a>Добавление значения «страница» в URL-адрес

Вместо жестко запрограммированного определенный диапазон страниц, нам понадобятся наши URL-адреса для включают параметр «страница», который обозначает диапазон какие обед, запрашивает пользователя.

#### <a name="using-a-querystring-value"></a>Использование значения строки запроса

В приведенном ниже коде показано, как можно обновить метод действия наших Index() поддерживает параметр строки запроса и включение URL-адреса, например */Dinners? страницы = 2*:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample4.cs)]

Описанный выше метод Index() действие имеет параметр с именем «страница». Параметр объявлен как значение типа обнуляемого целого (это какие int? указывает). Это означает, что */Dinners? страницы = 2* URL-адрес будет привести значение «2» нельзя передать как значение параметра. */Dinners* URL-адрес (без значения строки запроса) приведет к передать значение null.

Мы умножения значения страницы на размер страницы (в данном случае 10 строк), чтобы определить, сколько ужинов для пропуска. Мы используем [C# null «оператор объединения со значением» (?) ](https://weblogs.asp.net/scottgu/archive/2007/09/20/the-new-c-null-coalescing-operator-and-using-it-with-linq.aspx) что удобно при работе с обнуляемые типы. Приведенный выше код назначает страницы значение 0, если параметр страницы имеет значение null.

#### <a name="using-embedded-url-values"></a>С помощью значения Embedded URL-адрес

Альтернативой использованию значение строки запроса будет внедрить параметра страницы в фактический URL-адрес, сам. Например: */Dinners/Page/2* или */ужинов/2*. ASP.NET MVC включает в себя мощные механизм маршрутизации URL-адрес, который упрощает процесс для поддержки таких сценариев, как это.

Зарегистрировать настраиваемые правила маршрутизации, сопоставленные с любого входящего URL-адрес или URL-адрес формат для любого контроллера классу или методу действия, нам нужно. Все мы должны задача — открыть файл Global.asax в наш проект:

![](implement-efficient-data-paging/_static/image2.png)

А затем зарегистрировать новое правило сопоставления, используя вспомогательный метод MapRoute() как первый вызов маршруты. MapRoute() ниже:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample5.cs)]

Выше мы регистрируем новое правило маршрутизации с именем «UpcomingDinners». Мы, указывающее, он имеет следующий формат URL-адрес «ужинов/страницы / {странице}» — где {page} представляет собой значение параметра, внедрен в URL-адрес. Третий параметр метода MapRoute() указывает, мы должны были сопоставлены URL-адреса, соответствует этому формату, метод действия Index() DinnersController класса.

Можно использовать точно Index() код, который мы выполняли раньше в нашем строки запроса — за исключением того, теперь наши параметр «страница» будет получен из URL-адрес, а не строку запроса:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample6.cs)]

А теперь когда мы запустите приложение и введите в */Dinners* мы увидим, первые 10 предстоящих ужины:

![](implement-efficient-data-paging/_static/image3.png)

И если тип в */Dinners/Page/1* будет показано на следующей странице ужинов:

![](implement-efficient-data-paging/_static/image4.png)

### <a name="adding-page-navigation-ui"></a>Добавление навигации по страницам пользовательского интерфейса

Последний шаг в завершение нашего случая разбиения по страницам будет реализовать «Далее» и «раньше» Навигационный пользовательский Интерфейс в наш шаблон представления, чтобы пользователи могли легко пропустить данные компании Dinner.

Чтобы реализовать это правильно, необходимо знать общее число ужинов в базе данных, также как много страниц данных, это преобразуется в. Затем необходимо вычислить, является ли значение текущей запрошенной «page» в начале или конце данных также скрытие и отображение пользовательского интерфейса «раньше» и «далее» соответствующим образом. Мы может реализовывать эту логику внутри нашего метода действия Index(). Кроме того можно добавить вспомогательный класс для нашего проекта, который инкапсулирует эту логику повторно удобным образом.

Ниже приведен простой «PaginatedList» вспомогательный класс, который является производным от списка&lt;T&gt; класс коллекции встроены в .NET Framework. Она реализует класс коллекции доступны для повторного использования, можно использовать для разбиения по страницам, любая последовательность данных IQueryable. В нашем приложении NerdDinner мы будем заставить его работать над IQueryable&lt;ужин&gt; результаты, но он может легко использоваться против IQueryable&lt;продукта&gt; или IQueryable&lt;клиента&gt;приводит других сценариев приложений:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample7.cs)]

Обратите внимание, каким образом вычисляется, и затем предоставляет свойства, такие как «PageIndex», «PageSize», «TotalCount» и «TotalPages». Он также предоставляет две вспомогательные свойства «HasPreviousPage» и «HasNextPage», которые указывают, является ли страница данных в коллекции в начале или конце исходной последовательности. Приведенный выше код вызовет два SQL-запроса для запуска — первый для получения количества общее число объектов Dinner (это не возвращает объекты — вместо этого он выполняет инструкцию «SELECT COUNT», которая возвращает целое число), а вторая — для получения строк из данные, мы должны из базы данных для текущей страницы данных.

Затем можно обновлять наши DinnersController.Index() вспомогательный метод для создания PaginatedList&lt;Dinner&gt; из наших DinnerRepository.FindUpcomingDinners() привести и передайте его в наш шаблон представления:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample8.cs)]

Мы можем затем обновить шаблон представления \Views\Dinners\Index.aspx наследование ViewPage&lt;NerdDinner.Helpers.PaginatedList&lt;ужин&gt; &gt; вместо ViewPage&lt;IEnumerable&lt;Ужин&gt;&gt;, а затем добавьте следующий код в нижнюю часть нашей шаблона представления для отображения или скрытия следующей и предыдущей Навигационный пользовательский Интерфейс:

[!code-aspx[Main](implement-efficient-data-paging/samples/sample9.aspx)]

Обратите внимание, как мы используем Html.RouteLink() вспомогательный метод для создания нашей гиперссылок. Этот метод аналогичен Html.ActionLink() вспомогательный метод, который мы использовали ранее. Разница в том что создания URL-адрес, используя правило маршрутизации, мы настраиваем в наш файл Global.asax «UpcomingDinners». Это гарантирует, что нам достаточно создать URL-адреса к нашему методу действия Index(), имеют формат: */Dinners/страницы / {page}* , по которому значение {страницы} является переменной, мы предоставляем выше зависимости от текущего PageIndex.

И теперь при выполнении приложения еще раз мы увидим 10 ужинов одновременно в нашем средстве просмотра:

![](implement-efficient-data-paging/_static/image5.png)

У нас также есть &lt; &lt; &lt; и &gt; &gt; &gt; Навигационный пользовательский Интерфейс в нижней части страницы, позволяющий пропустить вперед и назад через наши данные с помощью поиска доступны ядра URL-адреса:

![](implement-efficient-data-paging/_static/image6.png)

| **Тема стороне: Основные сведения о последствиях IQueryable&lt;T&gt;** |
| --- |
| IQueryable&lt;T&gt; — очень мощная функция, которая включает разнообразные интересные сценарии отложенного выполнения (например разбиение по страницам и композиции запросы на основе). Все эффективные возможности, вы должны быть осторожным с их использования и убедитесь, что ее использовать. Очень важно для распознавания, возвращая IQueryable&lt;T&gt; вызывающий код для добавления на оператор цепочки методов и поэтому участвовать в выполнении запроса ultimate позволяет результатов из репозитория. Если вы хотите обеспечить эту возможность для вызывающего кода, то необходимо вернуть обратно IList&lt;T&gt; или IEnumerable&lt;T&gt; результаты - содержащие результаты запроса, который уже выполнен. Для сценариев разбиения на страницы это потребует Принудительная отправка логики разбиения на страницы фактические данные в репозиторий вызываемого метода. В этом сценарии мы может обновлять наших FindUpcomingDinners() метод поиска, чтобы иметь сигнатуру, что либо возвращены PaginatedList: PaginatedList&lt; Dinner&gt; FindUpcomingDinners (int pageIndex, int pageSize) {} или возвратом размещаемой IList&lt;ужин&gt;и использовать для получения общего числа ужинов «totalCount» out param: IList&lt;ужин&gt; FindUpcomingDinners (int pageIndex, int pageSize, out int totalCount) {} |

### <a name="next-step"></a>Следующий шаг

Давайте теперь взглянем на как можно добавить поддержку проверки подлинности и авторизации к нашему приложению.

> [!div class="step-by-step"]
> [Назад](re-use-ui-using-master-pages-and-partials.md)
> [Вперед](secure-applications-using-authentication-and-authorization.md)
