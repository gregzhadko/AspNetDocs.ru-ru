---
uid: mvc/overview/older-versions-1/nerddinner/implement-efficient-data-paging
title: Реализация эффективного анализа данных (ru) Документы Майкрософт
author: rick-anderson
description: Шаг 8 показывает, как добавить paging поддержку нашего / Dinners URL так, что вместо отображения 1000s обедов сразу, мы будем отображать только 10 предстоящих обедов в ...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: adea836d-dbc2-4005-94ea-53aef09e9e34
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/implement-efficient-data-paging
msc.type: authoredcontent
ms.openlocfilehash: a833553fe44b62b136f7eb55c7e00eca0b0462c6
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81541329"
---
# <a name="implement-efficient-data-paging"></a>Реализация эффективного разбиения данных по страницам

[корпорацией Майкрософт](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 8 бесплатно ["NerdDinner" приложение учебник,](introducing-the-nerddinner-tutorial.md) который ходит через как построить небольшой, но полный, веб-приложение с помощью ASP.NET MVC 1.
> 
> Шаг 8 показывает, как добавить paging поддержку нашего / Dinners URL так, что вместо отображения 1000s обедов сразу, мы будем отображать только 10 предстоящих обедов в то время, - и позволяют конечным пользователям страницу назад и вперед через весь список в SEO дружественным образом.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем вам следовать [начиная с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.

## <a name="nerddinner-step-8-paging-support"></a>NerdDinner Шаг 8: Поддержка paging

Если наш сайт будет успешным, он будет иметь тысячи предстоящих обедов. Мы должны убедиться, что наш uI масштабируется для обработки всех этих обедов, и позволяет пользователям просматривать их. Для этого мы добавим paging поддержку нашего */ Dinners* URL так, что вместо отображения 1000s обедов сразу, мы будем отображать только 10 предстоящих обедов в то время, - и позволяют конечным пользователям страницу назад и вперед через весь список в SEO дружественным образом.

### <a name="index-action-method-recap"></a>Индекс () Метод действий Резюме

Метод действия Index() в нашем классе DinnersController в настоящее время выглядит следующим:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample1.cs)]

Когда запрос сделан на */Dinners* URL, он получает список всех предстоящих обедов, а затем оказывает список всех из них:

![](implement-efficient-data-paging/_static/image1.png)

### <a name="understanding-iqueryablelttgt"></a>Понимание Икериable&lt;T&gt;

*I'I'i'iryable&lt;T&gt; * — это интерфейс, который был представлен с помощью LIN' как часть .NET 3.5. Это позволяет создавать мощные сценарии "отложенного выполнения", которыми мы можем воспользоваться для реализации поддержки paging.

В нашем DinnerRepository мы возвращаем&lt;&gt; последовательность ужина i'e'reable из нашего метода FindUpcomingDinners()

[!code-csharp[Main](implement-efficient-data-paging/samples/sample2.cs)]

Объект «Имитируемый&lt;ужин»,&gt; возвращенный нашим методом FindUpcomingDinners() инкапсулирует запрос для извлечения объектов ужина из нашей базы данных с помощью LIN'а в S'L. Важно отметить, что он не будет выполнять запрос против базы данных, пока мы не попытаемся получить доступ / итерировать данные в запросе, или пока мы не вызовем ToList () метод на нем. Код, вызывающий наш метод FindUpcomingDinners() может по желанию добавить дополнительные «цепные» операции/фильтры к объекту I'Eeryable&lt;Dinner&gt; перед выполнением запроса. После этого, когда запрашиваются данные, lin's to S'L достаточно умен для выполнения комбинированного запроса в отношении базы данных.

Для реализации логики paging мы можем обновить наш метод действий Индекса /) DinnersController, чтобы он применял дополнительные операторы "Skip" и "Take" к возвращенной последовательности&lt;ужина,&gt; прежде чем позвонить в ToList() по нему:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample3.cs)]

Вышеуказанный код пропускает первые 10 предстоящих ужинов в базе данных, а затем возвращает сядки в 20 ужинов. ДЛЯ создания оптимизированного запроса s-L, выполняющего эту логику пропуска в базе данных S'L, а не веб-сервера, достаточно умна система LIN's для S'L. Это означает, что даже если у нас есть миллионы предстоящих Ужины в базе данных, только 10 мы хотим будут получены в рамках этого запроса (что делает его эффективным и масштабируемым).

### <a name="adding-a-page-value-to-the-url"></a>Добавление значения "страницы" в URL

Вместо жесткого кодирования определенного диапазона страниц мы хотим, чтобы наши URL-адреса включали параметр «страницы», указывающий, какой диапазон ужина запрашивает пользователь.

#### <a name="using-a-querystring-value"></a>Использование значения querystring

Приведенный ниже код демонстрирует, как мы можем обновить наш метод действий Index() для поддержки параметра запроса и включения *URL-адресов, таких как /Dinners?page 2*:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample4.cs)]

Метод действия Индекса () выше имеет параметр под названием "страница". Параметр объявляется недействительным целым (это то, что int? указывает). Это означает, что *URL-адрес /Dinners?page-2* приведет к тому, что значение "2" будет передано в качестве значения параметра. *URL/Dinners* (без значения запроса) приведет к пройдену нулевую стоимость.

Мы умножаем значение страницы на размер страницы (в данном случае 10 строк), чтобы определить, сколько обедов пропустить. Мы используем [оператора "коалессинга" (??),](https://weblogs.asp.net/scottgu/archive/2007/09/20/the-new-c-null-coalescing-operator-and-using-it-with-linq.aspx) который полезен при работе с необыдающимися типами. Приведенный выше код присваивает странице значение 0, если параметр страницы является нулевым.

#### <a name="using-embedded-url-values"></a>Использование встроенных значений URL

Альтернативой использованию значения запроса может быть встраивание параметра страницы в сам URL-адрес. Например: */Ужины/Страница/2* или */Ужины/2*. ASP.NET MVC включает в себя мощный движок url-адресной реукторов, который упрощает поддержку подобных сценариев.

Мы можем зарегистрировать пользовательские правила разгрома, которые отображают любой входящий формат URL или URL в любом замедляемом классе или методе действия. Все, что нам нужно сделать, это открыть файл Global.asax в рамках нашего проекта:

![](implement-efficient-data-paging/_static/image2.png)

А затем зарегистрируйте новое правило отображения, используя метод помощника MapRoute () как первый вызов к маршрутам. MapRoute () ниже:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample5.cs)]

Выше мы регистрируем новое правило разгрома под названием "UpcomingDinners". Мы указываем, что он имеет формат URL", где «страница» является значением параметра, встроенным в URL. Третий параметр метода MapRoute () указывает на то, что мы должны составить URL-адреса, которые соответствуют этому формату методу действия Index() в классе DinnersController.

Мы можем использовать точно такой же код Index() мы имели раньше с нашим сценарием querystring - за исключением теперь наш параметр «страницы» придет от URL и не querystring:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample6.cs)]

И теперь, когда мы запускаем приложение и введите *в / Dinners* мы увидим первые 10 предстоящих обедов:

![](implement-efficient-data-paging/_static/image3.png)

И когда мы введем в */Ужины / Страница / 1* мы увидим следующую страницу ужинов:

![](implement-efficient-data-paging/_static/image4.png)

### <a name="adding-page-navigation-ui"></a>Добавление uI навигации страницы

Последним шагом для завершения нашего сценария paging будет реализация пользовательного времени навигации «следующий» и «предыдущий», чтобы пользователи могли легко пропускать данные ужина.

Чтобы реализовать это правильно, нам нужно знать общее количество ужинов в базе данных, а также количество страниц данных, на которые это переводится. Затем нам нужно будет вычислить, находится ли запрашиваемый в настоящее время значение "страницы" в начале или конце данных, и показать или скрыть "предыдущий" и "следующий" UI соответственно. Мы могли бы реализовать эту логику в нашем методе действий Index() Кроме того, мы можем добавить в наш проект класс помощников, который инкапсулирует эту логику более многоразовым способом.

Ниже приводится простой "PaginatedList" помощник класса,&lt;&gt; который вытекает из класса коллекции список T встроенный в .NET Framework. Он реализует многоразовый класс сбора, который может быть использован для paginate любой последовательности данных, используемых i's. В нашем приложении NerdDinner мы будем иметь&lt;его&gt; работу над i''queryable Результаты&lt;ужина, но он может так же легко быть использованы в отношении I'Siryable продукта&gt; или i''siable&lt;Результаты клиента&gt; в других сценариях применения:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample7.cs)]

Обратите внимание выше, как он вычисляет, а затем подвергает свойства, такие как "PageIndex", "PageSize", "TotalCount" и "TotalPages". Затем он предоставляет два свойства помощника "HasPreviousPage" и "HasNextPage", которые указывают, находится ли страница данных в коллекции в начале или конце исходной последовательности. Вышеупомянутый код вызовет запуск двух запросов S'L - первый для получения количества общего числа объектов Ужина (это не возвращает объекты - скорее он выполняет "SELECT COUNT" заявление, которое возвращает целый ряд), а второй для получения только строки данных, которые нам нужны из нашей базы данных для текущей страницы данных.

Затем мы можем обновить наш метод помощи DinnersController.Index()&lt;для&gt; создания ужина PaginatedList из нашего результата DinnerRepository.FindUpcomingDinners() и передать его в наш шаблон представления:

[!code-csharp[Main](implement-efficient-data-paging/samples/sample8.cs)]

Затем мы можем обновить шаблон представления «Views»Dinners.aspx,&lt;чтобы унаследовать&lt;от ViewPage NerdDinner.Helpers.PaginatedList&gt;&gt;&gt; &gt; Dinner вместо ViewPage&lt;IEnumerable Dinner, а затем добавить следующий код в нижней части нашего шаблона просмотра, чтобы показать или скрыть следующий и предыдущий навигационный&lt;ими:

[!code-aspx[Main](implement-efficient-data-paging/samples/sample9.aspx)]

Обратите внимание выше, как мы используем метод помощи Html.RouteLink() для создания наших гиперссылок. Этот метод аналогичен методу помощи Html.ActionLink(), который мы использовали ранее. Разница в том, что мы генерируем URL-адрес с помощью правила разгрома "UpcomingDinners", которое мы настраиваем в нашем файле Global.asax. Это гарантирует, что мы будем создавать URL-адреса для нашего метода действий Index() в формате: */Dinners/Page/'page»* - где значение «страница» является переменной, которую мы предоставляем выше на основе текущего PageIndex.

И теперь, когда мы запускаем наше приложение снова мы увидим 10 обедов в то время, в нашем браузере:

![](implement-efficient-data-paging/_static/image5.png)

У нас &lt; &lt; &lt; &gt; &gt; &gt; также есть и навигация uI в нижней части страницы, что позволяет нам пропускать вперед и назад по нашим данным с помощью поисковой системы доступны URL-адреса:

![](implement-efficient-data-paging/_static/image6.png)

| **Побочная тема: Понимание последствий&lt;I-Кериable T&gt;** |
| --- |
| I'E'Eryable&lt;T&gt; является очень мощной функцией, которая позволяет использовать различные интересные сценарии отложенного выполнения (например, запросы на основе paging и композиции). Как и все мощные функции, вы хотите быть осторожным с тем, как вы используете его и убедитесь, что он не злоупотребляют. Важно признать, что возврат имитируемого&lt;T-результата&gt; из репозитория позволяет вызывать код для придатка на прикованных к нему методах оператора и таким образом участвовать в окончательном выполнении запроса. Если вы не хотите предоставлять вызывающий код этой способности,&gt; то вы должны&lt;&gt; вернуть обратно IList&lt;T или IEnumerable T результаты - которые содержат результаты запроса, который уже выполнен. Для сценариев pagination это потребует от вас нажать фактическую логику pagination данных в метод репозитория вызывается. В этом сценарии мы могли бы обновить наш findUpcomingDinners () поиск метода, чтобы иметь&lt; подпись, которая либо вернулся PaginatedList: PaginatedList Ужин&gt; &lt;FindUpcomingDinners (int pageIndex, int pageSize) - или вернуть сяритоге IList Dinner&gt;, и используйте "totalCount" из парама, чтобы вернуть общее количество Ужинов: IList&lt;Dinner&gt; FindUpcomingDinners (int pageIndex, int pageSize, out totalCount) |

### <a name="next-step"></a>Следующий шаг

Давайте рассмотрим, как мы можем добавить поддержку аутентификации и авторизации в наше приложение.

> [!div class="step-by-step"]
> [Назад](re-use-ui-using-master-pages-and-partials.md)
> [Вперед](secure-applications-using-authentication-and-authorization.md)
