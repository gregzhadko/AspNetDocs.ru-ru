---
uid: mvc/overview/older-versions-1/nerddinner/use-controllers-and-views-to-implement-a-listingdetails-ui
title: Используйте контроллеры и представления для реализации списка / Подробная информация UI (ru) Документы Майкрософт
author: rick-anderson
description: Шаг 4 показывает, как добавить контроллер в приложение, которое использует нашу модель, чтобы предоставить пользователям список данных / детали навигации опыт ...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: 64116e56-1c9a-4f07-8097-bb36cbb6e57f
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/use-controllers-and-views-to-implement-a-listingdetails-ui
msc.type: authoredcontent
ms.openlocfilehash: 49c7dc977477a4edbfcfc68b166ae7ea3fa22f2a
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81541316"
---
# <a name="use-controllers-and-views-to-implement-a-listingdetails-ui"></a>Использование контроллеров и представлений для реализации пользовательского интерфейса списка и сведений

[корпорацией Майкрософт](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 4 [бесплатного "NerdDinner" приложение учебник,](introducing-the-nerddinner-tutorial.md) который ходит через как построить небольшой, но полный, веб-приложение с помощью ASP.NET MVC 1.
> 
> Шаг 4 показывает, как добавить контроллер в приложение, которое использует нашу модель, чтобы предоставить пользователям список данных / детали навигации опыт для ужинов на нашем сайте NerdDinner.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем вам следовать [начиная с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.

## <a name="nerddinner-step-4-controllers-and-views"></a>NerdDinner Шаг 4: Контроллеры и мнения

С традиционными веб-инфраструктурами (классические ASP, PHP, ASP.NET web Forms и т.д.) входящие URL-адреса обычно отображаются в файлы на диске. Например: запрос на URL-адрес типа "/Products.aspx" или "/Products.php" может быть обработан файлом "Products.aspx" или "Products.php".

Веб-платформы MVC отображали URL-адреса серверного кода несколько иным образом. Вместо того, чтобы отображение входящих URL-адресов в файлах, они вместо этого отображают URL-адреса с методами в классах. Эти классы называются "Контролеры", и они отвечают за обработку входящих запросов HTTP, обработку пользовательских ввода, получение и сохранение данных, а также определение ответа для отправки обратно клиенту (отображение HTML, загрузка файла, перенаправление на другой URL и т.д.).

Теперь, когда мы создали базовую модель для нашего приложения NerdDinner, нашим следующим шагом будет добавление контроллера в приложение, которое использует его, чтобы предоставить пользователям список данных / детали навигации опыт для Dinners на нашем сайте.

### <a name="adding-a-dinnerscontroller-controller"></a>Добавление контроллера DinnersController

Мы начнем с правильного нажатия на папку "Контролеры" в нашем веб-проекте, а затем выберем команду меню **Add-&gt;Controller** (вы также можете выполнить эту команду, введя Ctrl-M, Ctrl-C):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image1.png)

Это позволит поднять диалог "Добавить контроллер":

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image2.png)

Мы назовем новый контроллер "DinnersController" и нажмите кнопку "Добавить". Visual Studio добавит DinnersController.cs файл в нашем каталоге «Контролеров»:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image3.png)

Он также откроет новый класс DinnersController в код-редакторе.

### <a name="adding-index-and-details-action-methods-to-the-dinnerscontroller-class"></a>Добавление индекса () и подробная информация () Методы действий к классу DinnersController

Мы хотим, чтобы посетители, использующие наше приложение, чтобы просмотреть список предстоящих ужинов, и позволить им нажать на любой ужин в списке, чтобы увидеть конкретные подробности о нем. Мы сделаем это, опубликовав следующие URL-адреса из нашего приложения:

| **URL-адрес** | **Цель** |
| --- | --- |
| */Ужины/* | Отображение HTML-списка предстоящих ужинов |
| */Ужины/Подробности/Зид»* | Отображение сведений о конкретном ужине, указанном параметром "id", встроенным в URL- - который будет соответствовать DinnerID ужина в базе данных. Например: /Ужины/Подробности/2 будут отображать сядр на страницу HTML с подробной информацией о Ужине, значение которого DinnerID составляет 2. |

Мы опубликуем первоначальные реализации этих URL-адресов, добавив два общедоступных «метода действий» в наш класс DinnersController, как ниже:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample1.cs)]

Затем мы займем приложение NerdDinner и используем наш браузер для их использования. Ввод в *URL-адрес "/Dinners/"* приведет к запуску нашего метода *Index()* и отправит обратный ответ:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image4.png)

Ввод в *URL-адрес "/Dinners/Подробности/2"* приведет к запуску нашего метода *"Подробности()* и отправке следующего ответа:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image5.png)

Вы можете быть удивлены - как ASP.NET MVC знаю, чтобы создать наш класс DinnersController и ссылаться на эти методы? Чтобы понять, что давайте взглянем на то, как работает routing.

### <a name="understanding-aspnet-mvc-routing"></a>Понимание ASP.NET MVC Routing

ASP.NET MVC включает в себя мощный url-движок, который обеспечивает большую гибкость в управлении тем, как URL-адреса отображаются на классах контроллеров. Это позволяет нам полностью настроить, как ASP.NET MVC выбирает, какой класс контроллера создать, какой метод, чтобы вызвать на него, а также настроить различные способы, что переменные могут быть автоматически разобрана из URL / Querystring и переданы методу в качестве аргументов параметров. Он обеспечивает гибкость, чтобы полностью оптимизировать сайт для SEO (оптимизация поисковой системы), а также публиковать любые структуры URL мы хотим от приложения.

По умолчанию новые ASP.NET проектов MVC поставляются с уже зарегистрированным предустановленным набором правил url-адресов. Это позволяет нам легко начать работу над приложением без необходимости явно настраивать что-либо. Регистрация правил по умолчанию может быть найдена в классе «Приложение» наших проектов, который мы можем открыть, дважды нажав на файл «Global.asax» в корне нашего проекта:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image6.png)

Правила маршрутизации по умолчанию ASP.NET MVC зарегистрированы в методе "RegisterRoutes" этого класса:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample2.cs)]

"Маршруты. MapRoute()" метод вызова выше регистрирует правило маршрутизации по умолчанию, что карты входящих URL-адресов для классов контроллера с помощью формата URL: "/"контроллер/ /'действия) / "id" - где "контроллер" является имя класса контроллера мгновенно, "действие" является имя общедоступного метода для вызова на него, и "id" является дополнительным параметром, встроенным в URL, который может быть передан как метод. Третий параметр, передаваемый на вызов метода MapRoute()" — это набор значений по умолчанию, используемых для значений контроллера/действия/идол в случае их отсутствия в URL(Controller »Home»,, Action »«Индекс», Id»»).

Ниже приведена таблица, которая демонстрирует, как различные URL-адреса отображаются с помощью правила маршрута по умолчанию "<em>/"контроллеры"/"действия/id"/"id":</em>

| **URL-адрес** | **Класс контроллера** | **Метод действия** | **Параметры пройдены** |
| --- | --- | --- | --- |
| */Ужины/Подробности/2* | DinnersКонтроллер | Подробности (id) | id No2 |
| */Ужины/отожесть/5* | DinnersКонтроллер | Edit (id) | id No5 |
| */Ужины/Создание* | DinnersКонтроллер | Create() | Недоступно |
| */Ужины* | DinnersКонтроллер | Индекс() | Недоступно |
| */home* | Домашний контроллер | Индекс() | Недоступно |
| */* | Домашний контроллер | Индекс() | Недоступно |

Последние три строки показывают используемые значения по умолчанию (Контролер - Главная, Действие - Индекс, Ид ид. Поскольку метод "Индекс" зарегистрирован как имя действия по умолчанию, если он не указан, URL-адреса "/Dinners" и "/Home" вызывают вызов метода действия Index() в их классах контроллера. Поскольку контроллер "Home" зарегистрирован в качестве контроллера по умолчанию, если он не указан, URL-адрес "/" приводит к созданию HomeController и вызываемому методу действий Index() на нем.

Если вам не нравятся эти правила маршрутизации URL-адреса по умолчанию, хорошей новостью является то, что их легко изменить - просто отспособите их в методе RegisterRoutes выше. Для нашего приложения NerdDinner, однако, мы не собираемся менять любой из правил по умолчанию URL-адреса - вместо этого мы будем просто использовать их как есть.

### <a name="using-the-dinnerrepository-from-our-dinnerscontroller"></a>Использование DinnerRepository от нашего DinnersController

Теперь давайте заменим нашу текущую реализацию методов действия DinnersController () и детали () с реализациями, которые используют нашу модель.

Мы будем использовать класс DinnerRepository, который мы построили ранее, для реализации этого поведения. Начнем с добавления "использования" заявление, которое ссылается на "NerdDinner.Models" название пространства, а затем объявить экземпляр нашего DinnerRepository в качестве поля на нашем типе DinnerController.

Позже в этой главе мы представим понятие "Инъекция зависимости" и покажем другой способ для наших контроллеров, чтобы получить ссылку на DinnerRepository, что позволяет лучше модульного тестирования - но сейчас мы просто создадим экземпляр нашего DinnerRepository вне как ниже.

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample3.cs)]

Теперь мы готовы создать ответ HTML обратно с помощью наших извлеченных объектов модели данных.

### <a name="using-views-with-our-controller"></a>Использование представлений с нашим контроллером

Хотя можно написать код в наших методах действий для сборки HTML, а затем использовать метод помощника *Response.Write()* для отправки его обратно клиенту, этот подход быстро становится довольно громоздким. Гораздо лучший подход заключается только в том, чтобы выполнять логику приложений и данных в наших методах действий DinnersController, а затем передавать данные, необходимые для предоставления HTML-ответа, в отдельный шаблон «взгляда», который отвечает за выход html-представления. Как мы увидим в данный момент, шаблон "вид" представляет собой текстовый файл, который обычно содержит комбинацию HTML разметки и встроенного кода рендеринга.

Отделение нашей логики контроллера от рендеринга при внедрении приносит несколько больших преимуществ. В частности, это помогает обеспечить четкое «разделение проблем» между кодом приложения и кодом форматирования/рендеринга uI. Это значительно упрощает логику модульного тестирования приложений в отрыве от логики визуализации uI. Это упрощает последующее изменение шаблонов визуализации uI без внесения изменений в код приложения. И это может облегчить для разработчиков и дизайнеров совместную совместную работу над проектами.

Мы можем обновить наш класс DinnersController, чтобы указать, что мы хотим использовать шаблон представления для отправки обратно ответа на html UI, изменив сигнатуры нашего двух методов действия с момента возврата типа "пустоты" на обратный тип "ActionResult". Затем мы можем вызвать метод помощника *View()* на базовом классе контроллера, чтобы вернуть обратно объект "ViewResult", как показано ниже:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample4.cs)]

Подпись метода помощника *View()* мы используем выше выглядит ниже:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image7.png)

Первым параметром метода помощи *View()* является название файла шаблона представления, который мы хотим использовать для визуализации HTML-ответа. Второй параметр — это объект модели, содержащий данные, необходимые шаблону представления для визуализации HTML-ответа.

В нашем методе действий Index() мы вызываем метод помощника *View()* и указываем, что мы хотим сделать HTML-список обедов с помощью шаблона представления "Индекс". Мы передавая шаблон представления последовательности объектов Ужин для создания списка из:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample5.cs)]

В нашем методе действия Детали () мы пытаемся получить объект Ужин с помощью идентификатора, предоставленного в URL-. Если будет найден действительный ужин, мы вызываем метод помощника *View()* с указанием использования шаблона представления "Подробности" для визуализации извлеченного объекта Ужина. Если запрашивается недействительный ужин, мы визучим полезное сообщение об ошибке, которое указывает на то, что Ужин не существует с помощью шаблона представления "NotFound" (и перегруженной версии метода помощи *View()* помощника, который просто принимает имя шаблона):

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample6.cs)]

Теперь давайте реализуем шаблоны представления "NotFound", "Подробности" и "Индекс".

### <a name="implementing-the-notfound-view-template"></a>Реализация шаблона просмотра "NotFound"

Начнем с реализации шаблона представления "NotFound", в котором отображается дружественное сообщение об ошибке, указывающее на то, что запрошенный ужин не может быть найден.

Мы создадим новый шаблон представления, позиционируя наш текстовый курсор в методе действия контроллера, а затем нажмите правой кнопкой мыши и выберем команду меню "Add View" (мы также можем выполнить эту команду, набрав Ctrl-M, Ctrl-V):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image8.png)

Это позволит поднять "Добавить вид" диалог, как ниже. По умолчанию диалог предварительно заселит имя представления для создания в соответствии с названием метода действия, в которое находился курсор при запуске диалога (в данном случае «Подробности»). Поскольку мы хотим сначала реализовать шаблон "NotFound", мы переопроизуем это имя представления и установить его вместо этого "NotFound":

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image9.png)

При нажатии кнопки "Добавить" Visual Studio создадим для нас новый шаблон представления "NotFound.aspx" в каталоге "Просмотры и ужины" (который он также создаст, если каталог еще не существует):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image10.png)

Он также откроет наш новый шаблон представления "NotFound.aspx" в код-редакторе:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image11.png)

Шаблоны просмотра по умолчанию имеют два "региона содержания", где мы можем добавить содержимое и код. Первый позволяет настроить "название" страницы HTML отправлены обратно. Второй позволяет настроить "основной контент" страницы HTML отправлены обратно.

Для реализации нашего шаблона представления "NotFound" мы добавим некоторые основные материалы:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample7.aspx)]

Затем мы можем попробовать его в браузере. Для этого давайте запросим *URL-адрес "/Dinners/Details/9999".* Это относится к обеду, который в настоящее время не существует в базе данных, и вызовет наш Метод действия DinnersController.Details() для визуализации нашего шаблона представления "NotFound":

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image12.png)

Одна вещь, вы заметите, в скриншоте выше, что наш основной шаблон представления унаследовал кучу HTML, который окружает основное содержание на экране. Это связано с тем, что наш шаблон просмотра использует шаблон "master page", который позволяет нам применять согласованный макет во всех представлениях на сайте. Мы обсудим, как мастер-страницы работают больше в более поздней части этого учебника.

### <a name="implementing-the-details-view-template"></a>Реализация шаблона просмотра "Подробности"

Теперь давайте реализуем шаблон представления "Подробности", который будет генерировать HTML для одной модели Ужина.

Мы сделаем это, позиционируя наш текстовый курсор в методе действия Детали, а затем нажмите правой кнопкой мыши и выберите команду меню "Добавить вид" (или нажмите Ctrl-M, Ctrl-V):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image13.png)

Это позволит поднять диалог "Добавить вид". Мы сохраним имя представления по умолчанию ("Подробности"). Мы также выберем флажок "Создание сильно набранного представления" в диалоге и выберем (с помощью выпадения комбобокса) название типа модели, который мы переходим от контроллера к Представлени. Для этого представления мы проходим объект ужин (полностью квалифицированное название для этого типа: "NerdDinner.Models.Dinner"):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image14.png)

В отличие от предыдущего шаблона, где мы решили создать "Пустой вид", на этот раз мы выберем автоматически "подмостки" представление с помощью шаблона "Подробности". Мы можем указать на это, изменив "Вид содержимого" выпадение вниз в диалоге выше.

"Scaffolding" будет генерировать начальную реализацию нашего шаблона представления деталей на основе объекта Ужина, который мы передавая ему. Это обеспечивает простой способ для нас, чтобы быстро начать работу над реализацией шаблона представления.

При нажатии кнопки "Добавить" Visual Studio создадим для нас в нашем каталоге "Просмотры и ужины":

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image15.png)

Он также откроет наш новый шаблон представления "Details.aspx" в код-редакторе. Он будет содержать начальную эшафот реализации представления деталей на основе модели ужина. Строительный двигатель использует отражение .NET, чтобы посмотреть на общественные свойства, выставленные на пройденных им класса, и добавит соответствующее содержимое на основе каждого типа, который он находит:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample8.aspx)]

Мы можем запросить *URL-адрес "/Dinners/Details/1",* чтобы узнать, как выглядит эта реализация эшафота "подробности". С помощью этого URL будет отображаться один из обедов, которые мы вручную добавили в нашу базу данных, когда мы впервые создали его:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image16.png)

Это позволяет нам быстро работать и обеспечивает первоначальную реализацию нашего представления Details.aspx. Затем мы можем пойти и настроить его, чтобы настроить uI к нашему удовлетворению.

При более внимательном пристальном взгляде на шаблон Details.aspx мы обнаружим, что он содержит статический HTML, а также встроенный код визуализации. &lt;%&gt; насамоотворки кода исполнять код &lt;при визуализации шаблона представления, а насамодожи кода % % % и %&gt; выполняют код, содержащийся в них, а затем отображайте результат в выходной поток шаблона.

Мы можем написать код в нашем Представлени, который получает доступ к объекту модели "Ужин", который был передан от нашего контроллера, используя сильно набранное свойство "Модель". Visual Studio предоставляет нам полный код-интеллект при доступе к этому свойству "Модель" в редакторе:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image17.png)

Давайте сделаем некоторые настройки, чтобы источник для нашего окончательного шаблона представления деталей выглядит ниже:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample9.aspx)]

Когда мы получим доступ к *"/Dinners/Подробности/1"* URL снова он будет теперь визуализации, как ниже:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image18.png)

### <a name="implementing-the-index-view-template"></a>Реализация шаблона представления "Индекс"

Теперь давайте реализуем шаблон представления "Индекс", который будет генерировать список предстоящих ужинов. Для этого мы размещаем наш текстовый курсор в методе действия Индекса, а затем нажмите правой кнопкой мыши и выберите команду меню "Добавить вид" (или нажмите Ctrl-M, Ctrl-V).

В диалоге "Add View" мы сохраним шаблон представления под названием "Индекс" и выберем флажок "Создайте сильно набранный вид". На этот раз мы выберем для автоматического создания шаблона представления "Список", и выбрать "NerdDinner.Models.Dinner" как тип модели передается в представление (который, поскольку мы указали, что мы создаем "Список" эшафот вызовет Добавить Вид диалог предположить, что мы проходим последовательность Ужин объектов от нашего контроллера к просмотру):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image19.png)

Когда мы нажмем кнопку "Добавить", Visual Studio создадит новый файл шаблона представления "Index.aspx" для нас в нашем каталоге "Просмотры и ужины". Он будет "подмостки" первоначальная реализация в нем, который обеспечивает HTML таблице список Ужины мы передаем в представлении.

Когда мы запускаем приложение и доступ к *"/Dinners/"* URL он будет оказывать наш список обедов, как так:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image20.png)

Таблица решение выше дает нам сетки, как макет наших данных ужин - который не совсем то, что мы хотим для нашего потребителя перед Ужин листинг. Мы можем обновить шаблон представления Index.aspx и изменить его, чтобы &lt;перечислить меньше столбцов данных, и использовать элемент ul,&gt; чтобы сделать их вместо таблицы, используя приведенный ниже код:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample10.aspx)]

Мы используем "вар" ключевое слово в вышеупомянутом заявлении foreach, как мы цикл над каждым обедом в нашей модели. Те, кто не знаком с C'3.0, могут подумать, что использование "var" означает, что объект ужина в конце. Вместо этого это означает, что компилятор использует тип-вывод против сильно набранных "Модель"&lt;собственности (которая имеет тип "IEnumerable Dinner&gt;") и компиляции местных "ужин" переменной, как тип ужина - что означает, что мы получаем полный intellisense и компиляции времени проверки для него в рамках кодовых блоков:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image21.png)

Когда мы нажмем обновление на */Dinners* URL в нашем браузере наш обновленный вид теперь выглядит ниже:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image22.png)

Это выглядит лучше, - но не совсем там еще. Наш последний шаг заключается в том, чтобы позволить конечным пользователям нажать отдельные Dinners в списке и увидеть подробную информацию о них. Мы реализуем это путем визуализации элементов гиперссылки HTML, которые ссылаются на метод действия Детали на нашем DinnersController.

Мы можем создать эти гиперссылки в нашем представлении Индекса одним из двух способов. Во-первых, вручную &lt;создать&gt; HTML элемент, как &lt;ниже,&gt; где &lt;мы&gt; встраиваем % блоков в html элемент:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image23.png)

Альтернативный подход, который мы можем использовать, заключается в том, чтобы воспользоваться встроенным методом помощи "Html.ActionLink()" в рамках ASP.NET MVC, который поддерживает программное создание HTML &lt;&gt; элемента, который связывает с другим методом действия на контроллере:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample11.aspx)]

Первым параметром метода помощи Html.ActionLink() является ссылка-текст для отображения (в данном случае название ужина), второй параметр — это имя действия Контроллера, к которое мы хотим создать (в данном случае метод Детали), а третий параметр — набор параметров для отправки в действие (реализованный как анонимный тип с именем/ценностями свойства). В этом случае мы указываем параметр "id" ужина, на который мы хотим ссылаться, и потому, что правило по умолчанию URL-адреса в ASP.NET MVC является ""Контролер/ /"Действия" метод-помощник Html.ActionLink() будет генерировать следующий выход:

[!code-html[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample12.html)]

Для нашего представления Index.aspx мы будем использовать подход метода помощи Html.ActionLink() и каждый ужин в списке ссылку на соответствующие детали URL:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample13.aspx)]

И теперь, когда мы попали *в / УжинЫ* URL наш список ужин выглядит ниже:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image24.png)

Когда мы нажимаем любой из Ужинов в списке, мы будем перемещаться, чтобы увидеть подробности о нем:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image25.png)

### <a name="convention-based-naming-and-the-views-directory-structure"></a>Именование на основе конвенции и структура каталога «Виды»

ASP.NET приложения MVC по умолчанию используют структуру именования каталогов, основанную на конвенции, при разрешении шаблонов представления. Это позволяет разработчикам избежать необходимости полностью квалифицировать путь определения местоположения при ссылках на представления из класса контроллера. По умолчанию ASP.NET MVC будет искать файл шаблона представления в каталоге «Views\[ControllerName»\* под приложением.

Например, мы работаем над классом DinnersController, который прямо ссылается на три шаблона представления: "Индекс", "Подробности" и "NotFound". ASP.NET MVC по умолчанию будет искать эти представления в каталоге *«Виды»* под корневым каталогом приложений:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image26.png)

Обратите внимание выше, как в настоящее время в проекте есть три класса контроллеров (DinnersController, HomeController и AccountController - последние два были добавлены по умолчанию, когда мы создали проект), и есть три подкаталога (по одному для каждого контроллера) в каталоге «Просмотры».

Представления, на которые ссылаются контроллеры "Домашние" и "Учетные записи", автоматически разрешают шаблоны представления из соответствующих каталогов *"Просмотры"* и *"Просмотры".* Подкаталог *«Виды» (Общие представления)* предоставляет способ хранения шаблонов представления, которые повторно используются в нескольких контроллерах в приложении. При ASP.NET mVC пытается решить шаблон представления, он сначала проверит в конкретном каталоге *\[«Views Controller»,* и если он не сможет найти шаблон представления, то будет выглядеть в каталоге *«Views»Shared.*

Когда дело доходит до именования отдельных шаблонов представления, рекомендуемое руководство состоит в том, чтобы шаблон представления имел то же имя, что и метод действия, который заставил его визуализировать. Например, над нашим методом действий "Индекс" используется представление "Индекс" для визуализации результата представления, а метод действия "Подробности" использует представление "Подробности" для визуализации его результатов. Это позволяет быстро увидеть, какой шаблон связан с каждым действием.

Разработчикам не нужно явно указывать имя шаблона представления, когда шаблон представления имеет то же имя, что и метод действия, на который ссылается контроллер. Вместо этого мы можем просто передать объект модели методу помощника "View()" (без указания имени представления), и ASP.NET MVC автоматически сделает вывод, что мы хотим использовать шаблон представления *\[\[ActionName* на диске, чтобы сделать его.

Это позволяет нам немного очистить наш код контроллера и избежать дублирования имени дважды в нашем коде:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample14.cs)]

Вышеуказанный код все, что необходимо для реализации хороший ужин листинг / детали опыт для сайта.

#### <a name="next-step"></a>Следующий шаг

Теперь у нас есть хороший опыт просмотра ужин построен.

Теперь давайте включить cruD (Создание, чтение, обновление, удаление) поддержки редактирования формы данных.

> [!div class="step-by-step"]
> [Назад](build-a-model-with-business-rule-validations.md)
> [Вперед](provide-crud-create-read-update-delete-data-form-entry-support.md)
