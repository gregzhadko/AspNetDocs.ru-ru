---
uid: mvc/overview/older-versions-1/nerddinner/use-controllers-and-views-to-implement-a-listingdetails-ui
title: Использование контроллеров и представлений для реализации пользовательского интерфейса листинга и подробностей | Документация Майкрософт
author: microsoft
description: На шаге 4 показано, как добавить в приложение контроллер, который использует преимущества нашей модели для предоставления пользователям возможности навигации со списком данных и сведениями...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: 64116e56-1c9a-4f07-8097-bb36cbb6e57f
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/use-controllers-and-views-to-implement-a-listingdetails-ui
msc.type: authoredcontent
ms.openlocfilehash: 74319fe5ea4c79b50140834349e2fdf86420cfbb
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78486222"
---
# <a name="use-controllers-and-views-to-implement-a-listingdetails-ui"></a>Использование контроллеров и представлений для реализации пользовательского интерфейса списка и сведений

по [Майкрософт](https://github.com/microsoft)

[Скачать в формате PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 4 бесплатного [учебника по NerdDinner приложению](introducing-the-nerddinner-tutorial.md) , в котором рассматривается создание небольшого, но полного веб-приложения с использованием ASP.NET MVC 1.
> 
> На шаге 4 показано, как добавить в приложение контроллер, который использует преимущества нашей модели для предоставления пользователям возможности навигации со списком или подробными данными для диннерс на нашем сайте NerdDinner.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем следовать руководствам по [Начало работы в MVC 3 или в приложении для](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) [музыкального магазина MVC](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) .

## <a name="nerddinner-step-4-controllers-and-views"></a>NerdDinner. шаг 4. контроллеры и представления

В традиционных веб-платформах (классической версии ASP, PHP, ASP.NET Web Forms и т. д.) входящие URL-адреса обычно сопоставляются с файлами на диске. Например: запрос URL-адреса, например "/Продуктс.аспкс" или "/Продуктс.ФП", может обрабатываться файлом Products. aspx или Products. php.

Веб-платформы MVC сопоставляют URL-адреса с кодом сервера немного иным образом. Вместо сопоставления входящих URL-адресов с файлами они вместо этого сопоставляют URL-адреса с методами в классах. Эти классы называются "контроллерами", они отвечают за обработку входящих HTTP-запросов, обработку входных данных пользователя, получение и сохранение данных, а также определение ответа на отправку клиенту (отображение HTML-кода, скачивание файла, перенаправление в другой URL-адрес и т. д.).

Теперь, когда мы создали базовую модель для нашего приложения NerdDinner, наш следующий шаг заключается в добавлении контроллера в приложение, которое использует его преимущества для предоставления пользователям возможности навигации со списком и подробными данными для диннерс на нашем сайте.

### <a name="adding-a-dinnerscontroller-controller"></a>Добавление контроллера Диннерсконтроллер

Начнем с того, что щелкните правой кнопкой мыши папку Controllers в нашем веб-проекте, а затем выберите команду меню **Add-&gt;контроллер** (эту команду также можно выполнить, нажав клавиши CTRL + M, CTRL + C):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image1.png)

Откроется диалоговое окно "Добавление контроллера":

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image2.png)

Мы назовем новый контроллер "Диннерсконтроллер" и нажмите кнопку "Добавить". Visual Studio добавит файл DinnersController.cs в наш каталог \Controllers:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image3.png)

В редакторе кода также откроется новый класс Диннерсконтроллер.

### <a name="adding-index-and-details-action-methods-to-the-dinnerscontroller-class"></a>Добавление методов действия Index () и Details () в класс Диннерсконтроллер

Мы хотим, чтобы посетители, использующие наше приложение, могли просматривать список предстоящих диннерс и позволят им щелкнуть любой обед в списке, чтобы просмотреть подробные сведения о нем. Для этого нужно опубликовать следующие URL-адреса из нашего приложения:

| **URL-адрес** | **Назначение** |
| --- | --- |
| */диннерс/* | Отобразить список HTML-страниц предстоящего диннерс |
| */Диннерс/детаилс/[идентификатор]* | Отображение подробных сведений о конкретном обеде, указанном в URL-адресе, который будет соответствовать Диннериду компании Dinner в базе данных. Например:/Dinners/Details/2 будет отображать HTML-страницу со сведениями о обеде, значение Диннерид которого равно 2. |

Мы будем публиковать первоначальные реализации этих URL-адресов, добавляя два открытых метода действия в наш класс Диннерсконтроллер, как показано ниже:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample1.cs)]

Затем мы запустим приложение NerdDinner и используем его для вызова в нашем браузере. Ввод в URL-адресе *"/диннерс/"* вызовет выполнение метода *index ()* и отправит следующий ответ:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image4.png)

Ввод в URL-адресе *"/Dinners/Details/2"* вызовет выполнение метода *Details ()* и отправит следующий ответ:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image5.png)

Возможно, вас интересует, как ASP.NET MVC знает, как создать наш класс Диннерсконтроллер и вызывать эти методы? Чтобы понять, как работает маршрутизация, выполните краткий обзор.

### <a name="understanding-aspnet-mvc-routing"></a>Основные сведения о маршрутизации ASP.NET MVC

ASP.NET MVC включает мощный механизм маршрутизации URL-адресов, обеспечивающий большую гибкость в управлении сопоставлением URL-адресов с классами контроллеров. Это позволяет полностью настроить, как ASP.NET MVC выбирает класс контроллера для создания, какой метод вызывать для него, а также настраивать различные способы автоматического анализа переменных по URL-адресу или строке запроса и передаются в метод в качестве аргументов параметров. Она обеспечивает гибкость для полной оптимизации сайта для SEO (оптимизация поисковой системы), а также для публикации любой требуемой структуры URL-адресов из приложения.

По умолчанию новые проекты ASP.NET MVC поставляются с предварительно настроенным набором правил маршрутизации URL-адресов, которые уже зарегистрированы. Это позволяет нам легко приступить к работе над приложением, не настраивая никаких действий явным образом. Регистрации правил маршрутизации по умолчанию можно найти в классе "Application" наших проектов, которые можно открыть, дважды щелкнув файл Global. asax в корневом каталоге нашего проекта:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image6.png)

Правила маршрутизации ASP.NET MVC по умолчанию регистрируются в методе "Регистерраутес" этого класса:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample2.cs)]

"Маршруты. Файл MapRoute () "вызов метода выше регистрирует правило маршрутизации по умолчанию, которое сопоставляет входящие URL-адреса с классами контроллеров, используя формат URL-адреса:"/{контроллер}/{Актион}/{ИД} "– где" Controller "— имя класса контроллера для создания экземпляра," Action "— это имя открытого метода для вызова, а" ID "— необязательный параметр, внедренный в URL-адрес, который можно передать в качестве аргумента в метод. Третьим параметром, передаваемым вызову метода "файл MapRoute ()", является набор значений по умолчанию, используемых для значений параметров Controller и Action/ID в случае, если они отсутствуют в URL-адресе (Controller = "домашний", Action = "index", ID = "").

Ниже приведена таблица, демонстрирующая способ сопоставления различных URL-адресов с помощью правила маршрута "<em>/{контроллерс}/{Актион}/{ИД}"</em>по умолчанию:

| **URL-адрес** | **Класс контроллера** | **Метод действия** | **Переданные параметры** |
| --- | --- | --- | --- |
| */Dinners/Details/2* | диннерсконтроллер | Сведения (идентификатор) | ИД = 2 |
| */Dinners/Edit/5* | диннерсконтроллер | Изменить (идентификатор) | ИД = 5 |
| */диннерс/креате* | диннерсконтроллер | Create() | Недоступно |
| */диннерс* | диннерсконтроллер | Index () | Недоступно |
| */Home* | HomeController | Index () | Недоступно |
| */* | HomeController | Index () | Недоступно |

В последних трех строках показаны значения по умолчанию (контроллер = Home, Action = индекс, ID = ""), который используется. Так как метод "index" регистрируется в качестве имени действия по умолчанию, если он не указан, URL-адреса "/диннерс" и "/Home" вызывают вызов метода действия Index () в своих классах контроллера. Так как "корневой контроллер" зарегистрирован как контроллер по умолчанию, если он не указан, URL-адрес "/" вызывает создание HomeController и вызов метода действия Index () для него.

Если вам не нравятся правила маршрутизации URL-адресов по умолчанию, хорошая новость заключается в том, что их легко изменить — просто измените их в описанном выше методе Регистерраутес. Однако для нашего приложения NerdDinner мы не будем менять правила маршрутизации URL-адресов по умолчанию — вместо этого мы будем использовать их как есть.

### <a name="using-the-dinnerrepository-from-our-dinnerscontroller"></a>Использование Диннеррепоситори из нашего Диннерсконтроллер

Теперь выполним замену текущей реализации методов действий index () и Details () Диннерсконтроллер с реализациями, которые используют нашу модель.

Мы будем использовать класс Диннеррепоситори, созданный ранее для реализации поведения. Начнем с добавления оператора "using", который ссылается на пространство имен "NerdDinner. Models", а затем объявите экземпляр нашего Диннеррепоситори в качестве поля в нашем Диннерконтроллер классе.

Далее в этой главе мы рассмотрим концепцию «внедрения зависимостей» и покажем другой способ получить ссылку на Диннеррепоситори, который обеспечивает лучшее модульное тестирование, но сейчас мы просто создадим экземпляр нашего Диннеррепоситори встроено, как показано ниже.

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample3.cs)]

Теперь все готово для создания ответа HTML с помощью полученных объектов модели данных.

### <a name="using-views-with-our-controller"></a>Использование представлений с нашим контроллером

Хотя можно написать код в методах действий для сборки HTML, а затем использовать вспомогательный метод *Response. Write ()* , чтобы отправить его обратно клиенту, этот подход становится довольно громоздким. Гораздо лучшим подходом является выполнение только логики приложения и данных в методах действия Диннерсконтроллер, а затем передача данных, необходимых для визуализации ответа HTML в отдельный шаблон "View", который отвечает за вывод представления HTML . Как мы увидим, шаблон «View» — это текстовый файл, который обычно содержит сочетание разметки HTML и внедренного кода отрисовки.

Отделение нашей логики контроллера от визуализации представления дает ряд больших преимуществ. В частности, он позволяет четко отделить области ответственности между кодом приложения и форматированием пользовательского интерфейса и кодом подготовки к просмотру. Это значительно упрощает логику приложения модульного тестирования в изоляции от логики отрисовки пользовательского интерфейса. Это упрощает изменение шаблонов отрисовки пользовательского интерфейса без внесения изменений в код приложения. А разработчики и дизайнеры могут упростить совместную работу над проектами.

Мы можем обновить наш класс Диннерсконтроллер, чтобы указать, что мы хотим использовать шаблон представления для отправки обратной реакции на пользовательский интерфейс HTML, изменив сигнатуры методов наших двух методов действия, чтобы они имели возвращаемый тип "void", а не возвращают тип "ActionResult". Затем можно вызвать вспомогательный метод *View ()* в базовом классе контроллера, чтобы вернуть объект "виевресулт", как показано ниже:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample4.cs)]

Сигнатура вспомогательного метода *View ()* , который мы используем выше, выглядит следующим образом:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image7.png)

Первым параметром вспомогательного метода *View ()* является имя файла шаблона представления, который мы хотим использовать для отображения ответа HTML. Второй параметр — это объект модели, который содержит данные, необходимые шаблону представления для отображения ответа HTML.

В нашем методе действия Index () мы вызываем вспомогательный метод *View ()* и обозначаем, что нам нужно отобразить HTML-список диннерс с помощью шаблона представления index. Мы передаем шаблон представления последовательность объектов Dinner для создания списка из:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample5.cs)]

В нашем методе действия Details () мы попытались получить объект ужин, используя идентификатор, указанный в URL-адресе. Если найден допустимый обед, мы вызываем вспомогательный метод *View ()* , указывая, что нам нужно использовать шаблон представления Details для визуализации полученного объекта Dinner. Если запрошен недопустимый обед, выводится полезное сообщение об ошибке, указывающее на то, что обед не существует с помощью шаблона представления "NotFound" (и перегруженной версией вспомогательного метода *View ()* , которая просто принимает имя шаблона):

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample6.cs)]

Давайте теперь реализуем шаблоны представлений "NotFound", "Details" и "index".

### <a name="implementing-the-notfound-view-template"></a>Реализация шаблона представления "NotFound"

Начнем с реализации шаблона представления "NotFound", который отображает понятное сообщение об ошибке, указывающее, что запрошенный обед не найден.

Мы создадим новый шаблон представления путем размещения текстового курсора в методе действия контроллера, а затем щелкните правой кнопкой мыши и выберите команду меню "добавить представление" (эту команду можно также выполнить, нажав клавиши CTRL + M, Ctrl + V):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image8.png)

Откроется диалоговое окно "Добавление представления", как показано ниже. По умолчанию диалоговое окно будет заполнять имя создаваемого представления, чтобы оно совпадало с именем метода действия, в котором находился курсор при запуске диалогового окна (в данном случае "сведения"). Так как мы хотим сначала реализовать шаблон "NotFound", мы переопределяем имя этого представления и зададим ему значение "NotFound":

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image9.png)

При нажатии кнопки "Добавить" Visual Studio создаст новый шаблон представления "NotFound. aspx" для нас в каталоге "\Виевс\диннерс" (который также будет создан, если каталог еще не создан):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image10.png)

В редакторе кода также откроется новый шаблон представления "NotFound. aspx":

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image11.png)

По умолчанию в шаблонах отображаются две области содержимого, где можно добавить содержимое и код. Первый позволяет настроить заголовок HTML-страницы, для которой была отправлена обратная передача. Второй позволяет настроить "основное содержимое" HTML-страницы, отправленной обратно.

Для реализации нашего шаблона представления "NotFound" мы добавим некоторое базовое содержимое:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample7.aspx)]

Затем можно испытать его в браузере. Для этого запросите URL-адрес *"/Dinners/Details/9999"* . Он будет ссылаться на обед, который в настоящее время не существует в базе данных, и вызовет метод действия Диннерсконтроллер. Details () для подготовки к просмотру шаблона представления "NotFound":

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image12.png)

На снимке экрана, о котором вы заметите, вы увидите, что наш шаблон базового представления наследовал множество HTML-кода, который окружает основное содержимое экрана. Это связано с тем, что наш шаблон представления использует шаблон "Главная страница", позволяющий применять единообразный макет ко всем представлениям на сайте. Мы обсудим, как главные страницы работают в дальнейшем в рамках этого руководства.

### <a name="implementing-the-details-view-template"></a>Реализация шаблона представления "подробности"

Теперь реализуем шаблон представления Details, который создаст HTML для одной модели Dinner.

Для этого нужно поместить текстовый курсор в метод действия Details, а затем щелкнуть правой кнопкой мыши и выбрать команду меню "добавить представление" (или нажать клавиши CTRL + M, Ctrl + V):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image13.png)

Откроется диалоговое окно "Добавление представления". Мы будем использовать имя представления по умолчанию ("Details"). Также будет установлен флажок "создать строго типизированное представление" в диалоговом окне и выбрать (в раскрывающемся списке ComboBox) имя типа модели, который мы передаем из контроллера в представление. Для этого представления мы передаем объект Dinner (полное имя для этого типа: "NerdDinner. Models. ужин"):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image14.png)

В отличие от предыдущего шаблона, где мы решили создать "пустое представление", на этот раз мы будем выбирать автоматически "формирование шаблонов" для представления с помощью шаблона "сведения". Это можно указать, изменив раскрывающийся список "Просмотр содержимого" в диалоговом окне выше.

"Формирование шаблонов" создаст исходную реализацию нашего шаблона представления сведений на основе объекта ужина, который мы передаем. Это позволяет быстро начать работу над реализацией шаблона представления.

При нажатии кнопки "Добавить" Visual Studio создаст новый файл шаблона представления Details. aspx для нас в нашем каталоге "\Виевс\диннерс":

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image15.png)

Кроме того, в редакторе кода откроется новый шаблон представления "Details. aspx". Он будет содержать начальную реализацию формирования шаблонов представления сведений на основе модели компании Dinner. Механизм формирования шаблонов использует отражение .NET для просмотра открытых свойств, предоставленных в классе, который его передал, и будет добавлять соответствующее содержимое на основе каждого найденного типа:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample8.aspx)]

Мы можем запросить URL-адрес *"/Dinners/Details/1"* , чтобы увидеть, как выглядит эта реализация формирования шаблонов "Details" в браузере. При использовании этого URL-адреса будет отображаться один из диннерс, добавленный в базу данных вручную при ее создании:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image16.png)

Это позволяет быстро и эффективно работать и предоставляет нам начальную реализацию представления Details. aspx. Затем можно настроить пользовательский интерфейс для нашего удовлетворения.

При более близком рассмотрении шаблона Details. aspx мы увидим, что он содержит статический HTML, а также встроенный код отрисовки. &lt;%%&gt; код кусочки выполнить код при отрисовке шаблона представления, а &lt;% =%&gt; Code кусочки выполнить код, содержащийся в них, а затем отобразить результат в поток вывода шаблона.

Мы можем написать код в представлении, который обращается к объекту модели "ужин", который был передан из нашего контроллера, используя строго типизированное свойство "Model". Visual Studio предоставляет нам полный код — IntelliSense при доступе к этому свойству "Model" в редакторе:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image17.png)

Давайте сделаем некоторые корректировки, чтобы источник для нашего итогового шаблона представления сведений был представлен ниже:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample9.aspx)]

При обращении к URL-адресу *"/Dinners/Details/1"* он теперь будет выглядеть следующим образом:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image18.png)

### <a name="implementing-the-index-view-template"></a>Реализация шаблона представления "индекс"

Теперь создадим шаблон представления index, который создаст список предстоящих диннерс. Для этого мы разместите текстовый курсор в методе действия индекса, а затем щелкните правой кнопкой мыши и выберите команду меню "добавить представление" (или нажмите клавиши CTRL + M, Ctrl + V).

В диалоговом окне "Добавление представления" будет сохранятся шаблон представления с именем "index" и установлен флажок "создать строго типизированное представление". На этот раз мы выберем автоматическое создание шаблона представления "список" и выбираете "NerdDinner. Models. ужин" в качестве типа модели, переданного в представление (так как мы указали, что мы создаем шаблон "List", в диалоговом окне добавления представления будет предложено передача последовательности объектов Dinner из контроллера в представление):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image19.png)

При нажатии кнопки "Добавить" Visual Studio создаст новый файл шаблона представления "index. aspx" для нас в нашем каталоге "\Виевс\диннерс". Она будет «сформировать» исходную реализацию в ней, которая предоставляет таблицу HTML со списком диннерс, передаваемых в представление.

Когда мы запустим приложение и доступ к URL-адресу *"/диннерс/"* , он выводит наш список диннерс следующим образом:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image20.png)

Приведенное выше решение для работы с таблицами дает нам макет данных о обедах, который не так уж нужен для наших потребителей. Мы можем обновить шаблон представления index. aspx и изменить его, чтобы вывести список меньшего количества столбцов данных, а затем использовать элемент &lt;UL&gt;, чтобы отобразить их вместо таблицы с помощью приведенного ниже кода.

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample10.aspx)]

Мы используем ключевое слово "var" в приведенной выше инструкции foreach, так как мы выполним цикл по каждому обеду в нашей модели. Те, кто не C# знаком с 3,0, могут подумать, что использование "var" означает, что объект ужин имеет позднюю привязку. Это означает, что компилятор использует вывод типа со строго типизированным свойством "Model" (который относится к типу "IEnumerable&lt;ужин&gt;") и компилирует локальную переменную "ужин" в качестве типа "ужин". Это означает, что мы получаем полную IntelliSense и проверку во время компиляции для него в блоках кода:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image21.png)

При нажатии клавиши "Обновить" на URL-адресе */диннерс* в нашем браузере обновленное представление теперь выглядит следующим образом:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image22.png)

Это лучше, но еще не совсем. Последний шаг — позволить конечным пользователям щелкнуть отдельные диннерс в списке и просмотреть сведения о них. Мы реализуем это путем визуализации элементов HTML-гиперссылки, которые связываются с методом действия Details в нашем Диннерсконтроллер.

Эти гиперссылки можно создать в представлении индекса одним из двух способов. Первый способ — вручную создать HTML &lt;&gt; элементов, как показано ниже, где мы внедряем &lt;%%&gt; в &lt;элемент HTML&gt;:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image23.png)

Альтернативный подход, который мы можем использовать, заключается в использовании встроенного вспомогательного метода "HTML. ActionLink ()" в ASP.NET MVC, который поддерживает программное создание HTML-&lt;элемента&gt;, ссылающегося на другой метод действия на контроллере:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample11.aspx)]

Первый параметр в HTML. вспомогательный метод ActionLink () — это отображаемый текст (в данном случае название компании Dinner), второй параметр — имя действия контроллера, к которому нужно создать ссылку (в данном случае это метод Details), а третий параметр — набор параметров для отправки в действие (реализовано как анонимный тип с именем свойства или значениями). В этом случае мы указываем параметр ID для компании, к которой нам нужно привязаться, а так как правило маршрутизации URL-адресов по умолчанию в ASP.NET MVC — это "{Controller}/{Актион}/{ИД}". вспомогательный метод HTML. ActionLink () создаст следующий результат:

[!code-html[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample12.html)]

Для нашего представления index. aspx мы будем использовать метод вспомогательного метода HTML. ActionLink (), и каждый ужин в списке свяжется с соответствующим URL-адресом сведений:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample13.aspx)]

И теперь, когда мы достигли URL-адреса */диннерс* , наш список будет выглядеть следующим образом:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image24.png)

Щелкнув любую из диннерс в списке, вы перейдете к нему, чтобы просмотреть сведения о нем:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image25.png)

### <a name="convention-based-naming-and-the-views-directory-structure"></a>Именование на основе соглашения и структура каталогов \Виевс

ASP.NET приложения MVC по умолчанию используют структуру именования каталогов на основе соглашений при разрешении шаблонов представлений. Это позволяет разработчикам избежать полного определения пути расположения при ссылке на представления из класса контроллера. По умолчанию ASP.NET MVC будет искать файл шаблона представления в каталоге * \Виевс\[ControllerName\*], который находится под приложением.

Например, мы работаем над классом Диннерсконтроллер, который явно ссылается на три шаблона представления: "index", "Details" и "NotFound". ASP.NET MVC по умолчанию будет искать эти представления в каталоге *\виевс\диннерс* , расположенном под корневым каталогом приложения:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image26.png)

Обратите внимание на то, как в проекте присутствуют три класса контроллера (Диннерсконтроллер, HomeController и AccountController — последние два были добавлены по умолчанию при создании проекта), и существует три вложенных каталога (по одному для каждого контроллер) в каталоге \Виевс.

Представления, указанные на контроллерах Home и Accounts, автоматически разрешают шаблоны представлений из соответствующих каталогов *\виевс\хоме* и *\виевс\аккаунт* . Вложенный каталог *\Views\Shared* предоставляет способ хранения шаблонов представлений, которые повторно используются на нескольких контроллерах в приложении. Когда ASP.NET MVC пытается разрешить шаблон представления, он сначала проверяется в каталоге *\виевс\[Controller]* , и если не удается найти шаблон представления, он будет выглядеть в каталоге *\Views\Shared* .

Когда речь идет о именовании отдельных представлений, рекомендуется, чтобы шаблон представления имел то же имя, что и метод действия, вызвавший его визуализацию. Например, выше наш метод действия Index использует представление Index для визуализации результата представления, а метод действия Details использует представление Details для отображения результатов. Это упрощает быстрый просмотр того, какой шаблон связан с каждым действием.

Разработчикам не нужно явно указывать имя шаблона представления, если имя шаблона представления совпадает с именем метода действия, вызываемого на контроллере. Вместо этого можно просто передать объект модели в вспомогательный метод "View ()" (без указания имени представления), а ASP.NET MVC будет автоматически определять, что мы хотим использовать шаблон представления *\виевс\[ControllerName]\[ActionName]* на диске для подготовки к просмотру.

Это позволяет нам очистить код контроллера немного и избежать дублирования имени дважды в нашем коде:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample14.cs)]

Приведенный выше код необходим для реализации удобного списка и сведений о компании на сайте.

#### <a name="next-step"></a>Следующий шаг

Теперь у нас есть хороший опыт работы с обзором обедов.

Теперь добавим поддержку изменения формы данных CRUD (создание, чтение, обновление, удаление).

> [!div class="step-by-step"]
> [Назад](build-a-model-with-business-rule-validations.md)
> [Вперед](provide-crud-create-read-update-delete-data-form-entry-support.md)
