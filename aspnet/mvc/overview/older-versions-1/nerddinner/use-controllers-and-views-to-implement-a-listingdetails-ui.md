---
uid: mvc/overview/older-versions-1/nerddinner/use-controllers-and-views-to-implement-a-listingdetails-ui
title: Использование контроллеров и представлений для реализации пользовательского интерфейса списка и сведений | Документация Майкрософт
author: microsoft
description: Шаг 4 показано, как добавить контроллер в приложение, которое использует преимущества нашей модели, чтобы предоставить пользователям возможности навигации данные списка и сведений...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: 64116e56-1c9a-4f07-8097-bb36cbb6e57f
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/use-controllers-and-views-to-implement-a-listingdetails-ui
msc.type: authoredcontent
ms.openlocfilehash: 203a12473f79f38f7162d360d2179ca7c4a30303
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57063671"
---
<a name="use-controllers-and-views-to-implement-a-listingdetails-ui"></a>Использование контроллеров и представлений для реализации пользовательского интерфейса списка и сведений
====================
по [Microsoft](https://github.com/microsoft)

[Загрузить PDF-файл](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это четвертый этап бесплатной [руководство по использованию приложения «NerdDinner»](introducing-the-nerddinner-tutorial.md) , пошаговое рассмотрение как создать небольшой, но завершить, веб-приложения с помощью ASP.NET MVC 1.
> 
> Шаг 4 показано, как добавить контроллер в приложение, которое использует преимущества нашей модели, чтобы предоставить пользователям возможность данные списка и сведений навигации для ужинов на нашем сайте NerdDinner.
> 
> Если вы используете ASP.NET MVC 3, рекомендуется следовать [Приступая к работе с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.


## <a name="nerddinner-step-4-controllers-and-views"></a>NerdDinner Step 4: Контроллеры и представления

С помощью традиционных веб-платформ, (классической технологии ASP, PHP, веб-форм ASP.NET, и т.д.) URL-адреса обычно сопоставляются файлы на диске. Например: запрос на URL-адрес, например «/ Products.aspx» или «/ Products.php» может быть обработан «Products.aspx» или «Products.php» файла.

Веб-платформы MVC сопоставления URL-адресов серверный код в немного иначе. Вместо сопоставления URL-адреса к файлам, они вместо сопоставления URL-адресов методы в классах. Эти классы называются «Контроллеры» и они отвечают за обработку входящих HTTP-запросов, обработка введенных пользователем данных, получения и сохранения данных и определения ответа для отправки обратно клиенту (отображения HTML-кода, загрузите файл, перенаправления на другой URL-адрес, и т.д.).

Теперь, когда мы создали модель, базовый для нашего приложения NerdDinner, следующим этапом будет добавление контроллера в приложение, которое использует преимущества его, чтобы предоставить пользователям возможность данные списка и сведений навигации для ужинов на нашем сайте.

### <a name="adding-a-dinnerscontroller-controller"></a>Добавление контроллера DinnersController

Мы будем begin, щелкнув правой кнопкой папку «Контроллеры» в нашем веб-проект, а затем выберите **Add -&gt;контроллера** команды меню (вы также можно выполнить эту команду, введя сочетание клавиш Ctrl-M, Ctrl + C):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image1.png)

Откроется диалоговое окно «Добавление контроллера»:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image2.png)

Мы назовите новый контроллер «DinnersController» и нажмите кнопку «Добавить». Visual Studio добавит файл DinnersController.cs наших \Controllers в каталоге:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image3.png)

Он также будет открыт новый класс DinnersController в редакторе кода.

### <a name="adding-index-and-details-action-methods-to-the-dinnerscontroller-class"></a>Добавление в класс DinnersController Index() и методах действий Details()

Необходимо, чтобы посетители, используя наше приложение позволяет просматривать список предстоящих ужинов и дают возможность щелкнуть любой компании Dinner в списке, чтобы просмотреть подробные сведения о нем. Мы сделаем это путем публикации следующие URL-адреса из нашего приложения:

| **URL** | **Назначение** |
| --- | --- |
| */Dinners/* | Отобразить список предстоящих ужинов HTML |
| */Dinners/сведения / [id]* | Отображение сведений о конкретных обед, указанному параметром «id», внедрен в URL-адрес — который будет соответствовать DinnerID ужин в базе данных. Например: /Dinners/Details/2 отобразит HTML-страницу с подробными сведениями о компании Dinner DinnerID, значение которого равно 2. |

Мы опубликуем начальной реализации эти URL-адреса, добавив двумя общедоступными «методы действий» к нашему классу DinnersController как ниже:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample1.cs)]

Мы затем запустите приложение NerdDinner и использовать наш обозреватель для их вызова. Заполните *«/ ужинов /»* URL-адреса приведет к нашей *Index()* метод для запуска, а он отправит обратно следующий ответ:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image4.png)

Заполните *«/ ужинов/сведения/2»* URL-адреса приведет к нашей *Details()* метод для запуска и следующий ответ:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image5.png)

Может возникнуть вопрос - как ASP.NET MVC знаете создать наш класс DinnersController и вызвать эти методы? Чтобы понять, давайте рассмотрим краткий принципы работы маршрутизации.

### <a name="understanding-aspnet-mvc-routing"></a>Основные сведения о ASP.NET MVC маршрутизация

ASP.NET MVC включает в себя мощный механизм маршрутизации URL, который предоставляет большую гибкость в управлении, как URL-адреса сопоставляются с классами контроллера. Он позволяет полностью настроить как ASP.NET MVC выбирает, какой класс контроллера, чтобы создать, какой метод следует вызвать его, а также настроить различными способами, что автоматически извлечены из URL-адрес или строку запроса и переменных, передаваемый методу в качестве параметра аргументы. Она обеспечивает возможность полностью оптимизация узла для SEO (оптимизация для поисковых систем), а также опубликовать любой структуре URL-адрес, материалов из приложения.

По умолчанию новые проекты ASP.NET MVC в состав набор предварительно настроенных правил маршрутизации URL-адрес уже зарегистрирован. Это позволяет нам легко приступить к работе в приложении без необходимости явно ничего настраивать. Регистрации правило маршрутизации по умолчанию можно найти в классе «Приложение» из наших проектов — которые можно открыть двойным щелчком файла «Global.asax» в корне нашего проекта:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image6.png)

Правила маршрутизации ASP.NET MVC по умолчанию регистрируются в методе «RegisterRoutes» этого класса:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample2.cs)]

«Маршруты. MapRoute()» вызов метода выше регистрирует правило маршрутизации по умолчанию, которое сопоставляет URL-адреса с классами контроллера в формате URL-адрес: «/ {controller} / {action} / {id}», по которому «controller» — это имя класса контроллера для создания экземпляра, «action» — имя открытый метод для вызова в нем, а также «id» является необязательным параметром внедрен в URL-адрес, который может быть передан как аргумент методу. Третий параметр, переданный в вызов метода «MapRoute()» — это набор значений по умолчанию для использования значений идентификатором/контроллера и действия в случае, если они не существуют в URL-адрес (контроллер = «Home» Action = «Index», идентификатор =»»).

Ниже приведен таблицу, которая демонстрирует различные URL-адреса сопоставляются с помощью по умолчанию "<em>/ {контроллеры} / {action} / {id}»</em>правило маршрутизации:

| **URL** | **Класс контроллера** | **Метод действия** | **Параметры, передаваемые** |
| --- | --- | --- | --- |
| */ Ужинов/сведения/2* | DinnersController | Details(ID) | id=2 |
| */ Ужинов/Edit/5* | DinnersController | Edit(ID) | id=5 |
| */ Ужинов/создать* | DinnersController | Create() | Н/Д |
| */ Ужинов* | DinnersController | Index() | Н/Д |
| */ Home* | HomeController | Index() | Н/Д |
| */* | HomeController | Index() | Н/Д |

Последние три строки отображения значения по умолчанию (контроллер = Home, действие = индекс, идентификатор = «») используется. Так как метод «Index» зарегистрирован как имя действия по умолчанию, если не задан, «/ ужинов» и «/ Home» причина URL-адреса Index() метод действия должен быть вызван на их классы контроллера. Поскольку контроллер «Home» зарегистрирован как контроллер по умолчанию, если не задан, URL-адреса «/» вызывает HomeController должен быть создан и метод действия Index() на нем должен быть вызван.

Если вам не нравятся эти правила маршрутизации URL-адрес по умолчанию, хорошей новостью является их легко изменить: нужно просто изменить их в описанный выше метод RegisterRoutes. Для нашего приложения NerdDinner, мы не собираемся изменить какие-либо правил маршрутизации URL-адрес по умолчанию — вместо этого мы будем просто использовать их в виде — является.

### <a name="using-the-dinnerrepository-from-our-dinnerscontroller"></a>С помощью DinnerRepository из наших DinnersController

Давайте теперь замените текущей реализацией класса DinnersController Index() и Details() методы действий с реализациями, использующих нашей модели.

Мы будем использовать класс DinnerRepository, созданному ранее для реализации поведения. Мы начнем с добавления инструкцию «using», которая ссылается на пространство имен «NerdDinner.Models» и затем объявите экземпляр нашей DinnerRepository как поле в класс DinnerController.

Далее в этой главе мы впервые реализована концепция «Внедрение зависимостей» и показать другим способом контроллеры для получения ссылки на DinnerRepository, позволяющий лучше модульного тестирования – но для справа теперь мы просто создадим экземпляр нашей DinnerRepository встроенный как ниже.

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample3.cs)]

Теперь мы готовы для создания HTML-ответа, с помощью модели объектов извлеченных данных.

### <a name="using-views-with-our-controller"></a>Использование представлений с нашего контроллера

Хотя можно написать код в наши методы действий для компоновки HTML и затем использовать *Response.Write()* вспомогательный метод, чтобы отправить его обратно клиенту, что подход становится довольно громоздкими быстро. Гораздо лучшим подходом является для нас выполнять только приложения и логику данных внутри нашей DinnersController методы действий и затем передать данные, необходимые для отображения ответа HTML отдельное «представление» шаблон, который отвечает за вывод представление HTML его. Как мы увидим позже, шаблон «Просмотр» — текстовый файл, который обычно содержит сочетание HTML-разметка и код отрисовки embedded.

Отделение логику контроллера от наших отображение привносит несколько больших преимуществ. В частности она помогает обеспечивать снимите флажок «Разделение областей ответственности» между кодом приложения и код форматирования или отрисовки пользовательского интерфейса. Это значительно упрощает логику приложения модульного теста в изоляции от логики отрисовки пользовательского интерфейса. Он упрощает позже изменить шаблоны отрисовки пользовательского интерфейса без внесения изменений в коде приложения. И он может облегчить процесс для разработчиков и проектировщиков, чтобы совместно работать с проектами.

Корпорация Майкрософт может обновлять наш класс DinnersController, чтобы указать, что мы хотим использования шаблона представления для обратной отправки ответа на пользовательского интерфейса HTML путем изменения сигнатуры метода наши методы два действия не типом возвращаемого значения «void», чтобы был типом возвращаемого значения «ActionResult». Затем можно вызвать *View()* вспомогательный метод в базовом классе контроллера, чтобы вернуться назад, например объект «ViewResult» ниже:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample4.cs)]

Подпись *View()* вспомогательный метод, мы используем выше выглядит так:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image7.png)

Первый параметр для *View()* вспомогательный метод — имя файла шаблона представления, который будет использоваться для отрисовки HTML-ответа. Второй параметр является объектом модели, который содержит данные, которые требуются шаблону представления для отображения HTML-ответа.

Внутри нашего метода действия Index() мы называем *View()* вспомогательный метод и указывая, что для подготовки к просмотру HTML список ужинов, с помощью шаблона представления «Индекс». Мы передаем шаблона представление последовательности объектов Dinner, чтобы создать список из:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample5.cs)]

Внутри нашего метода действия Details() предпринимается попытка получить объект обед, используя указанный идентификатор в URL-адрес. Если найден допустимый Dinner мы называем *View()* вспомогательный метод, указывающий, мы хотим использовать шаблон представления «Сведения» для подготовки к просмотру полученный объект Dinner. Если запрашивается недопустимый обед, мы визуализируем возникающих ошибках сообщение о том, что компании Dinner не существует, с помощью шаблона представления «NotFound» (и перегруженную версию *View()* вспомогательный метод, который просто принимает имя шаблона ):

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample6.cs)]

Теперь рассмотрим процедуру внедрения шаблоны представлений «NotFound», «Подробности» и «Индекс».

### <a name="implementing-the-notfound-view-template"></a>Реализация шаблона представления «NotFound»

Начнем с реализации шаблона представления «NotFound» — которая отображает сообщение сообщением об ошибке, указывающее, что не удается найти запрошенный компании dinner.

Мы будем создать новый шаблон представления посредством позиционирования наших текстовый курсор внутри метода действия контроллера, щелкните правой кнопкой мыши и выберите команду меню «Добавление представления» (мы также можно выполнить эту команду, введя сочетание клавиш Ctrl-M, Ctrl + V):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image8.png)

Это приведет к появлению «Добавление представления» диалог, подобный ниже. По умолчанию диалоговое окно будет предварительно указано имя представления для создания должно соответствовать имени метода действия курсор находился в момент запуска диалогового окна (в данном случае «Подробности»). Поскольку нам нужно реализовать шаблон «NotFound», мы переопределить имя этого представления и установке его вместо «NotFound»:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image9.png)

При нажатии кнопки «Добавить», Visual Studio создаст новый шаблон «NotFound.aspx» представление для нас в каталоге «\Views\Dinners» (который также будет создан, если каталог уже не существует):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image10.png)

Он также открывает наш новый шаблон представления «NotFound.aspx» в редакторе кода:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image11.png)

Просмотр шаблонов по умолчанию имеют два «содержимого региона «где можно добавить содержимого и кода. Первый позволяет настраивать «title» HTML-страницы отправке его обратно. Второй позволяет настроить «основное содержимое» HTML-страницы отправке его обратно.

Чтобы реализовать шаблон представления «NotFound» мы добавим некоторые простое содержимое:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample7.aspx)]

Мы затем попробовать эту в браузере. Для этого давайте запроса *«/ ужинов/сведения/9999»* URL-адрес. Это будет ссылаться на обед, в настоящее время нет в базе данных, который вызовет метод действия наших DinnersController.Details() для подготовки к просмотру наш шаблон представления «NotFound»:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image12.png)

Единственное, что можно заметить на снимке экрана выше является то, что наш шаблон общее представление унаследовал ряд HTML, которая окружает основное содержимое на экране. Это обусловлено наш шаблон представления используется шаблон «главную страницу», который позволяет нам применять согласованного макета ко всем представлениям на сайте. Мы обсудим, как функционируют на более поздних этапах работы с этим руководством дополнительные главные страницы.

### <a name="implementing-the-details-view-template"></a>Реализация шаблона представления «Сведения»

Теперь реализуем этот шаблон «Подробности» – что обеспечит создание HTML для одной компании Dinner.

Мы будем это сделать, поместив наших текстовый курсор в методе действия, сведения и затем щелкните правой кнопкой мыши и выберите команду меню «Добавление представления» (или нажмите клавиши Ctrl-M, Ctrl + V):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image13.png)

Откроется диалоговое окно «Добавление представления». Пока мы храним имя представления по умолчанию («подробности»). Мы также установите флажок «Создать строго типизированное представление» в диалоговом окне и выберите (с помощью поля с раскрывающимся списком) имя типа модели, которые передаются из контроллера в представление. Для этого представления мы передаем объект Dinner (полное имя для этого типа: «NerdDinner.Models.Dinner»):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image14.png)

В отличие от предыдущего шаблона, где мы решили создать «Пустой View», этот раз мы выберем, автоматически» позволяет формировать» представление, с помощью шаблона «Сведения». Мы об этом, изменив «Просмотр содержимого» раскрывающееся меню в указанном выше диалоговом окне.

«Формирование шаблонов» создаст для первой реализации наших сведения представление шаблона, основанного на ужин объект, который мы передаем к нему. Это обеспечивает простой способ для нас, чтобы быстро приступить к работе в нашей реализации шаблона представления.

При нажатии кнопки «Добавить», Visual Studio создаст новый файл шаблона представления «Details.aspx» для нас в каталог «\Views\Dinners»:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image15.png)

Он также открывает наш новый шаблон представления «Details.aspx» в редакторе кода. Он будет содержать реализацию начальной каркаса представление сведений на основе модели Dinner. Подсистема формирования шаблонов использует отражение .NET для поиска на общедоступных свойствах, предоставляемых в классе, он передается и добавит соответствующие содержимому по типам, которые она находит:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample8.aspx)]

Мы можете запросить *«/ ужинов/сведения/1»* URL-адрес, чтобы увидеть, как выглядит эта реализация шаблона «сведения» в браузере. Этот URL-адрес будет отображаться одно из ужинов, которые мы вручную добавили в нашей базе данных, когда мы впервые создали:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image16.png)

Это приближает нас запущен и работает быстро и обеспечивает реализацию начальное представление Details.aspx. Затем мы можно вернуться и настройка служб для настройки пользовательского интерфейса для наших удовлетворенности.

Если взглянуть на шаблоне Details.aspx более точно, очень скоро найдется что он содержит статические HTML, а также встроенный код отрисовки. &lt;%%&gt; фрагментами кода выполнения кода при подготовке к просмотру шаблону представления, и &lt;% = %&gt; фрагментами кода выполнения кода, содержащихся в них и визуализировать результат в поток выходных данных шаблона.

Мы можем написать код в рамках нашего представления, который обращается к объекту модели «Обед», который был передан из нашего контроллера, с помощью свойства «Модели» со строгой типизацией. Visual Studio предоставляет нам с полной поддержкой intellisense кода при доступе к это свойство «Модели» в редакторе:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image17.png)

Давайте внесем некоторые изменения, чтобы источник для наших окончательная версия шаблона представления сведений выглядит так:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample9.aspx)]

Когда мы доступ к *«/ ужинов/сведения/1»* URL-адрес еще раз будет происходить на этом этапе отрисовки ниже:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image18.png)

### <a name="implementing-the-index-view-template"></a>Реализация шаблона представления «Индекс»

Теперь рассмотрим процедуру внедрения шаблона представления «Индекс» — который создаст список предстоящих ужинов. Задача, это мы поместите текстовый курсор в методе действия индекса и затем правой кнопкой мыши щелкните и выберите команду меню «Добавление представления» (или нажмите клавиши Ctrl-M, Ctrl + V).

В диалоговом окне «Добавление представления» будет поддерживать этот шаблон с именем «Index» и установите флажок «Создать строго типизированное представление». Сейчас мы будем использовать для автоматического создания шаблона представления «List» и выберите «NerdDinner.Models.Dinner» как тип модели передается в представление (которой так, как мы указали, мы создаем каркаса вызовет диалоговое окно Add View предположить, мы «список» Передача последовательности объектов компании Dinner из нашего контроллера в представление):

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image19.png)

При нажатии кнопки «Добавить», Visual Studio создаст новый файл шаблона представления «Index.aspx» для нас в каталог «\Views\Dinners». Он будет «сформировать шаблон» начальной реализации в нем, обеспечивающий перечисление таблицы HTML ужинов, мы передаем в представление.

Когда мы запускаем доступа к приложениям и *«/ ужинов /»* URL-адрес, он будет обрабатывать наш список ужинов следующим образом:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image20.png)

Решение таблицы выше позволяет нам сеткоподобной компоновки данных нашей компании Dinner — что довольно нам не нужна для наших клиентов, создающих список компании Dinner. Можно обновить шаблон представление Index.aspx и добавьте в него списка меньшее число столбцов данных, а &lt;ul&gt; элемента для визуализации их вместо таблицы с помощью следующего кода:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample10.aspx)]

Как мы цикла каждого ужин в нашей модели мы используем ключевое слово «var» в операторе foreach выше. Те, которые не знакомы с C# 3.0 может показаться, что использование «var» означает, что компании dinner объекта с поздним связыванием. Вместо этого означает, что компилятор использует определение типа для строго типизированного свойства «Model» (типа «IEnumerable&lt;компании Dinner&gt;«) и компиляции переменной локальный «обед» как тип Dinner — это означает, мы получаем полный IntelliSense и проверка его внутри блоков кода во время компиляции:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image21.png)

Когда обновим страницу */Dinners* URL-адрес, в нашем средстве просмотра, выглядит нашей обновленной представление теперь ниже:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image22.png)

Это выглядит лучше — но полностью существует еще не. Наши последним шагом является включение конечным пользователям щелкните отдельные ужинов в списке и просмотреть сведения о них. Это реализуется путем представления элементов гиперссылки HTML, дающие ссылки на метод действия сведения в нашем DinnersController.

Мы сможем создать эти гиперссылки в рамках нашего представления индекса в одном из двух способов. Первый — вручную создать HTML &lt;&gt; элементы, такие как ниже, где мы внедрить &lt;%%&gt; выполняет блокировку в &lt;&gt; HTML-элемент:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image23.png)

Мы можем использовать альтернативный подход – воспользоваться встроенной вспомогательного метода «Html.ActionLink()» в ASP.NET MVC, которая поддерживает программное создание HTML &lt;&gt; элемент, который связывает к другому методу действия на Контроллер:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample11.aspx)]

Первый параметр Html.ActionLink() вспомогательного метода является текст ссылки для отображения (в данном случае заголовок из компании dinner), второй параметр — имя действия контроллера, необходимо создать ссылку, чтобы (в данном случае метод сведения), а третий параметр — набор параметров для отправки к действию (реализованную как анонимного типа со свойством имени/значения). В этом случае мы указываем параметр «id» dinner мы нужно связать и потому что маршрутизацию URL-адрес по умолчанию правило в ASP.NET MVC — «{Controller} / {Action} / {id}» вспомогательный метод Html.ActionLink() создаст следующие выходные данные:

[!code-html[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample12.html)]

Для нашего представления Index.aspx мы следует использовать Html.ActionLink() вспомогательный метод и у каждой компании dinner на список, чтобы URL-адрес, соответствующие сведения:

[!code-aspx[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample13.aspx)]

И теперь мы по достижении */Dinners* URL-адрес, наш список компании dinner выглядит так:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image24.png)

При нажатии любой из ужины в списке, перейдем к просмотреть сведения о нем:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image25.png)

### <a name="convention-based-naming-and-the-views-directory-structure"></a>Именование и структуру папок \Views

Приложения ASP.NET MVC по умолчанию использовать структуры именования при разрешении шаблоны представлений каталогов на основе соглашения. Это позволяет разработчикам не пришлось полные пути при ссылке на представления в классе контроллера. По умолчанию ASP.NET MVC будет искать файл шаблона представления в * \Views\[Имя_контроллера]\* каталог под этим приложением.

Например мы работали в классе DinnersController —, который явно ссылается на три шаблона представления: «Индекс», «Подробности» и «NotFound». ASP.NET MVC по умолчанию ищет эти представления в *\Views\Dinners* каталог под наших корневой каталог приложения:

![](use-controllers-and-views-to-implement-a-listingdetails-ui/_static/image26.png)

Обратите внимание, что выше как здесь находятся три класса контроллера в проекте (DinnersController, HomeController и AccountController — последние два было добавлено по умолчанию при создании проекта), и существует три вложенных каталогов (по одному для каждого контроллер) в каталоге \Views.

Ссылка из дома и учетные записи контроллеров представлений автоматически обрабатывает их шаблоны представлений из соответствующих *\Views\Home* и *\Views\Account* каталоги. *\Views\Shared* вложенный каталог предоставляет способ хранения шаблоны представлений, которые повторно используются на нескольких контроллерах внутри приложения. Когда ASP.NET MVC пытается разрешить шаблон представления, он сперва проверит в *\Views\[контроллер]* конкретного каталога, и если не удается найти этот шаблон будет выглядеть в *\Views\ Общие* каталога.

Когда дело доходит до именования шаблонов отдельных представлений, рекомендациям является шаблон представления, в то же имя, что и метод действия, вызвавшей ее для подготовки к просмотру. Например выше наших «Index» метод действия использует представлении «Указатель» для подготовки к просмотру результат представления, и метод действия «Подробности» использует представлении «Подробности» для отображения его результаты. Это позволяет быстро просмотреть шаблон, который связан с каждого действия.

Разработчикам не требуется явно указать имя шаблона представления, когда шаблон представления имеет то же имя, что и метод действия, вызываемого на контроллере. Можно вместо этого просто передать объект модели вспомогательный метод «View()» (без указания имени представления) и ASP.NET MVC автоматически определяет, что мы хотим использовать *\Views\[Имя_контроллера]\[ActionName]* шаблон представления на диске для воспроизведения.

Это позволяет немного очистить наш код контроллера и предотвратить дублирование имени дважды в нашем коде:

[!code-csharp[Main](use-controllers-and-views-to-implement-a-listingdetails-ui/samples/sample14.cs)]

Приведенный выше код — возможности, необходимые для реализации хорошо Dinner списка и сведений для сайта.

#### <a name="next-step"></a>Следующий шаг

Теперь у нас есть удобная обед, встроенные возможности обзора.

Давайте теперь включить поддержку редактирования формы данных CRUD (Create, Read, Update, Delete).

> [!div class="step-by-step"]
> [Назад](build-a-model-with-business-rule-validations.md)
> [Вперед](provide-crud-create-read-update-delete-data-form-entry-support.md)
