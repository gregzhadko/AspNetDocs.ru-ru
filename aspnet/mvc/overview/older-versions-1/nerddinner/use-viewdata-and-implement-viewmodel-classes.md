---
uid: mvc/overview/older-versions-1/nerddinner/use-viewdata-and-implement-viewmodel-classes
title: Используйте ViewData и реализуйте классы ViewModel (ru) Документы Майкрософт
author: rick-anderson
description: Шаг 6 показывает, как включить поддержку для более богатых сценариев редактирования формы, а также обсуждает два подхода, которые могут быть использованы для передачи данных от контроллеров к представлениям:...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: 5755ec4c-60f1-4057-9ec0-3a5de3a20e23
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/use-viewdata-and-implement-viewmodel-classes
msc.type: authoredcontent
ms.openlocfilehash: 7fa2af2a55d12bbe11b29dff594823a1e5ea0152
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81541108"
---
# <a name="use-viewdata-and-implement-viewmodel-classes"></a>Использование ViewData и реализация классов ViewModel

[корпорацией Майкрософт](https://github.com/microsoft)

[Скачать PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 6 бесплатно ["NerdDinner" приложение учебник,](introducing-the-nerddinner-tutorial.md) который ходит через как построить небольшой, но полный, веб-приложение с использованием ASP.NET MVC 1.
> 
> Шаг 6 показывает, как включить поддержку более богатых сценариев редактирования форм, а также обсуждает два подхода, которые могут быть использованы для передачи данных от контроллеров к представлениям: ViewData и ViewModel.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем вам следовать [начиная с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.

## <a name="nerddinner-step-6-viewdata-and-viewmodel"></a>NerdDinner Шаг 6: ViewData и ViewModel

Мы рассмотрели ряд сценариев публикации форм и обсудили, как реализовать поддержку создания, обновления и удаления (CRUD). Теперь мы проведем реализацию DinnersController и сможем поддержать более насыщенные сценарии редактирования форм. При этом мы обсудим два подхода, которые могут быть использованы для передачи данных от контроллеров к представлениям: ViewData и ViewModel.

### <a name="passing-data-from-controllers-to-view-templates"></a>Передача данных от контроллеров к view-Templates

Одной из определяющих характеристик шаблона MVC является строгое «разделение проблем», которое помогает обеспечить соблюдение между различными компонентами приложения. Модели, контроллеры и представления имеют четко определенные роли и обязанности, и они общаются друг с другом в четко определенных способов. Это помогает повысить возможность тестирования и повторного использования кода.

Когда класс Контроллера решает передать ответ HTML клиенту, он несет ответственность за явное прохождение в шаблон представления всех данных, необходимых для визуализации ответа. Шаблоны представления никогда не должны выполнять какую-либо логику поиска данных или приложения, а вместо этого должны ограничиваться только отренгой кода, который отогнан от модели/данных, передаваемых ему контроллером.

Сейчас данные модели, передаваемые нашим классом DinnersController в шаблоны представления, просты и прямолинейны — список объектов Ужина в случае Индекса () и одного объекта ужина в случае детали (), Edit(), «Создание») и удаление(). По мере того, как мы добавляем в наше приложение больше возможностей uI, нам часто нужно будет передавать больше, чем просто эти данные, чтобы внедрить HTML-ответы в шаблонах представления. Например, мы можем изменить поле "Страна" в нашем редактировании и создать представления из HTML текстового ящика на список выпадающих. Вместо того, чтобы жестко кодировать список названий стран в шаблоне представления, мы можем захотеть создать его из списка поддерживаемых стран, которые мы населяем динамически. Нам понадобится способ передать как объект *Ужин,* так и список поддерживаемых стран от нашего контроллера к нашим шаблонам представления.

Давайте посмотрим на два способа, которыми мы можем достичь этого.

### <a name="using-the-viewdata-dictionary"></a>Использование словаря ViewData

Базовый класс контроллера предоставляет свойство словаря «ViewData», которое может быть использовано для передачи дополнительных элементов данных от контроллеров к представлениям.

Например, для поддержки сценария, в котором мы хотим изменить текстовый ящик "Страна" в нашем представлении Edit от HTML текстового ящика к списку сбросов, мы можем обновить наш метод действий Edit() для передачи (в дополнение к объекту ужина) объекта SelectList, который может быть использован в качестве модели списка выпадающих данных стран.

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample1.cs)]

Конструктор SelectList выше принимает список графств для того чтобы заселить drop-downlist с, также, как в настоящее время выбранное значение.

Затем мы можем обновить наш шаблон представления Edit.aspx, чтобы использовать метод помощника Html.DropDownList() вместо метода помощи Html.TextBox(), который мы использовали ранее:

[!code-aspx[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample2.aspx)]

Метод помощи Html.DropDownList () выше занимает два параметра. Во-первых, это название элемента формы HTML для вывода. Во-вторых, это модель "SelectList", который мы прошли через словарь ViewData. Мы используем ключевое слово «как» для отливки типа в словаре в качестве SelectList.

И теперь, когда мы запускаем наше приложение и доступ к */Dinners / Edit/1* URL в нашем браузере мы увидим, что наш интерфейс редактирования был обновлен для отображения списка стран, а не текстовый ящик:

![](use-viewdata-and-implement-viewmodel-classes/_static/image1.png)

Поскольку мы также делаем шаблон представления «Отверженные» из метода «HTTP-POST Edit» (в сценариях, когда происходят ошибки), мы хотим убедиться, что мы также обновляем этот метод, чтобы добавить SelectList в ViewData, когда шаблон представления отображается в сценариях ошибок:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample3.cs)]

И теперь наш сценарий действенной верести DinnersController поддерживает DropDownList.

### <a name="using-a-viewmodel-pattern"></a>Использование шаблона ViewModel

Словарный подход ViewData имеет преимущество довольно быстрого и легкого в реализации. Некоторые разработчики не любят использовать строки на основе словарей, хотя, так как опечатки могут привести к ошибкам, которые не будут пойманы на время компиляции. Нетипированный словарь ViewData также требует использования оператора «как» или литья при использовании сильно набранного языка, такого как C-е в шаблоне представления.

Альтернативный подход, который мы могли бы использовать, часто называют шаблоном "ViewModel". При использовании этого шаблона мы создаем классы с сильно типичными, которые оптимизированы для наших конкретных сценариев представления и которые разоблачают свойства для динамических значений/содержимого, необходимых нашим шаблонам представления. Наши классы контроллеров могут затем заполнять и передавать эти классы, оптимизированные для представления, в шаблон представления. Это позволяет обеспечить безопасность типов, проверку времени компиляции и интеллект редактора в шаблонах представления.

Например, для того, чтобы включить сценарии редактирования формы ужина, мы можем создать класс «DinnerFormViewModel», как ниже, который предоставляет два сильно набранных свойства: объект ужина и модель SelectList, необходимые для заполнения списка стран:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample4.cs)]

Затем мы можем обновить наш метод действий Edit() для создания DinnerFormViewModel с помощью объекта Dinner, который мы извлекаем из нашего репозитория, а затем передать его в наш шаблон представления:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample5.cs)]

Затем мы обновим наш шаблон представления так, чтобы он ожидает "DinnerFormViewModel" вместо объекта "Dinner", изменив атрибут "наследует" в верхней части страницы edit.aspx, как это:

[!code-cshtml[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample6.cshtml)]

Как только мы сделаем это, intellisense свойства "Модель" в нашем шаблоне представления будет обновляться, чтобы отразить объектную модель типа DinnerFormViewModel, который мы передавая:

![](use-viewdata-and-implement-viewmodel-classes/_static/image2.png)

![](use-viewdata-and-implement-viewmodel-classes/_static/image3.png)

Затем мы можем обновить наш код представления, чтобы отработать его. Обратите внимание ниже, как мы не меняем имена элементов ввода, которые мы создаем (элементы формы будут по-прежнему называться "Title", "Страна"), - но мы обновляем html Helper методы для получения значений с помощью класса DinnerFormViewModel:

[!code-aspx[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample7.aspx)]

Мы также обновим наш метод публикации edit для использования класса DinnerFormViewModel при визуализации ошибок:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample8.cs)]

Мы также можем обновить наши методы создания () действий, чтобы повторно использовать тот же тип *DinnerFormViewModel,* чтобы страны DropDownList в них также. Ниже приводится реализация HTTP-GET:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample9.cs)]

Ниже приводится реализация метода создания HTTP-POST:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample10.cs)]

И теперь и наши Edit и Создать экраны поддержки падение-даунлистов для выбора страны.

### <a name="custom-shaped-viewmodel-classes"></a>Индивидуальные классы ViewModel

В приведенном выше сценарии наш класс DinnerFormViewModel непосредственно предоставляет объект модели Dinner как свойство, а также вспомогательное свойство модели SelectList. Этот подход прекрасно подходит для сценариев, где HTML-образный универс, который мы хотим создать в шаблоне представления, относительно близко соответствует нашим объектам модели домена.

Для сценариев, в которых это не так, одним из вариантов, который можно использовать, является создание класса ViewModel, объектная модель которого более оптимизирована для потребления представлением и которая может выглядеть совершенно иначе, чем базовый объект модели домена. Например, он потенциально может подвергать различные имена свойств и/или агрегированные свойства, собранные с нескольких объектов модели.

Классы ViewModel в форме пользовательской формы могут использоваться как для передачи данных от контроллеров к представлениям для визуализации, так и для обработки данных формы, размещенных обратно в метод действия контроллера. Для этого более позднего сценария метод действия может обновить объект ViewModel с размещенными в форме данными, а затем использовать экземпляр ViewModel для картирования или извлечения фактического объекта модели домена.

Классы ViewModel, сформированные на индивидуальной основе, могут обеспечить большую гибкость и исследовать их в любое время, когда вы находите код рендеринга в шаблонах представления или код размещения формы внутри ваших методов действий, начинают усложняться. Это часто является признаком того, что ваши модели доменов не соответствуют пользовательскому пользовательскому элементу, который вы создаете, и что промежуточный класс ViewModel в форме пользовательской формы может помочь.

### <a name="next-step"></a>Следующий шаг

Давайте рассмотрим, как мы можем использовать частичные и мастер-страницы для повторного использования и обмена uI через наше приложение.

> [!div class="step-by-step"]
> [Назад](provide-crud-create-read-update-delete-data-form-entry-support.md)
> [Вперед](re-use-ui-using-master-pages-and-partials.md)
