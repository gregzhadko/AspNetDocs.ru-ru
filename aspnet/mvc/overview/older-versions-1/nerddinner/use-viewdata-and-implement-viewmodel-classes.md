---
uid: mvc/overview/older-versions-1/nerddinner/use-viewdata-and-implement-viewmodel-classes
title: Использование ViewData и реализация классов ViewModel | Документация Майкрософт
author: microsoft
description: На шаге 6 показано, как включить поддержку расширенных сценариев редактирования форм, а также обсуждаются два подхода, которые можно использовать для передачи данных из контроллеров в представления:...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: 5755ec4c-60f1-4057-9ec0-3a5de3a20e23
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/use-viewdata-and-implement-viewmodel-classes
msc.type: authoredcontent
ms.openlocfilehash: ca9775417c2e25952511a73096fb76d5d4edaea2
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78435534"
---
# <a name="use-viewdata-and-implement-viewmodel-classes"></a>Использование ViewData и реализация классов ViewModel

по [Майкрософт](https://github.com/microsoft)

[Скачать в формате PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это шаг 6 из бесплатного [учебника по NerdDinner приложению](introducing-the-nerddinner-tutorial.md) , в котором рассматривается создание небольшого, но полного веб-приложения с использованием ASP.NET MVC 1.
> 
> На шаге 6 показано, как включить поддержку расширенных сценариев редактирования форм, а также обсуждаются два подхода, которые можно использовать для передачи данных из контроллеров в представления: ViewData и ViewModel.
> 
> Если вы используете ASP.NET MVC 3, мы рекомендуем следовать руководствам по [Начало работы в MVC 3 или в приложении для](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) [музыкального магазина MVC](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) .

## <a name="nerddinner-step-6-viewdata-and-viewmodel"></a>NerdDinner шаг 6. ViewData и ViewModel

Мы рассмотрели ряд сценариев отправки форм и рассмотрели, как реализовать поддержку создания, обновления и удаления (CRUD). Теперь мы рассмотрим нашу реализацию Диннерсконтроллер и добавим поддержку расширенных сценариев редактирования форм. При этом мы обсудим два подхода, которые можно использовать для передачи данных из контроллеров в представления: ViewData и ViewModel.

### <a name="passing-data-from-controllers-to-view-templates"></a>Передача данных из контроллеров в представление — шаблоны

Одной из определяющих характеристик шаблона MVC является строгая «разграничение задач», которая помогает обеспечить соответствие между различными компонентами приложения. Каждый из моделей, контроллеров и представлений имеет четко определенные роли и обязанности, и они взаимодействуют друг с другом с точно определенными способами. Это способствует повышению пригодности к тестированию и повторному использованию кода.

Когда класс контроллера принимает решение преобразовать HTML-ответ обратно в клиент, он отвечает за явное пересылкой шаблона представления всех данных, необходимых для отображения ответа. Шаблоны представлений никогда не должны выполнять какие-либо операции получения данных или логики приложения, а вместо этого должны ограничиваться только кодом отрисовки, который не входит в модель или данные, передаваемые контроллером.

Сейчас данные модели, передаваемые нашим классом Диннерсконтроллер в наш шаблон представления, просты и переводятся прямо вперед — список объектов Dinner в случае индекса () и один объект Dinner в случае с подробностями (), Edit (), Create () и Delete (). По мере добавления возможностей пользовательского интерфейса в наше приложение нам часто приходится передавать не только эти данные для отображения ответов HTML в шаблонах представления. Например, может потребоваться изменить поле Country в представлениях «изменить» и «создать» в виде текстового поля HTML на DropDownList. Вместо жесткого кодирования раскрывающегося списка названий стран в шаблоне представления может потребоваться создать его из списка поддерживаемых стран, которые мы заполнять динамически. Нам потребуется способ передачи объекта Dinner *и* списка поддерживаемых стран из нашего контроллера в наши шаблоны представления.

Рассмотрим два способа, которые мы можем сделать.

### <a name="using-the-viewdata-dictionary"></a>Использование словаря ViewData

Базовый класс контроллера предоставляет свойство словаря "ViewData", которое можно использовать для передачи дополнительных элементов данных из контроллеров в представления.

Например, для поддержки сценария, в котором текстовое поле "Country" в нашем представлении редактирования должно быть изменено с HTML на DropDownList, мы можем обновить наш метод действия Edit () для передачи (в дополнение к объекту ужина) объекта SelectList, который можно использовать как m одель из DropDownList для стран.

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample1.cs)]

Конструктор SelectList выше принимает список подсчетов для заполнения Drop-довнлист с, а также текущее выбранное значение.

Затем мы можем обновить наш шаблон представления Edit. aspx, чтобы использовать вспомогательный метод HTML. DropDownList () вместо вспомогательного метода HTML. TextBox (), который мы использовали ранее:

[!code-aspx[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample2.aspx)]

Представленный выше вспомогательный метод HTML. DropDownList () принимает два параметра. Первый — имя элемента формы HTML для вывода. Второй — модель "SelectList", которую мы передали через Словарь ViewData. Мы используем ключевое C# слово "AS" для приведения типа в словаре в качестве SelectList.

Теперь, когда мы выполним приложение и доступ к URL-адресу */Dinners/Edit/1* в браузере, мы видим, что наш пользовательский интерфейс редактирования был обновлен для показа DropDownList для стран вместо текстового поля:

![](use-viewdata-and-implement-viewmodel-classes/_static/image1.png)

Так как мы также выберем шаблон представления редактирования из метода HTTP-POST (в сценариях при возникновении ошибок), мы хотим убедиться, что мы также обновляем этот метод, чтобы добавить SelectList в ViewData при подготовке шаблона представления к просмотру в сценариях ошибок:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample3.cs)]

А теперь наш сценарий редактирования Диннерсконтроллер поддерживает DropDownList.

### <a name="using-a-viewmodel-pattern"></a>Использование шаблона ViewModel

Преимущество словаря ViewData заключается в том, что он довольно быстрый и простой в реализации. Однако некоторые разработчики не используют словари на основе строк, поскольку опечатки могут привести к ошибкам, которые не будут перехвачены во время компиляции. Нетипизированный Словарь ViewData также требует использования оператора "AS" или приведения при использовании строго типизированного языка, например C# , в шаблоне представления.

Альтернативный подход, который можно использовать, часто называют шаблоном "ViewModel". При использовании этого шаблона создаются строго типизированные классы, оптимизированные для наших сценариев представления, которые предоставляют свойства для динамических значений и содержимого, необходимых для наших шаблонов представления. Наши классы контроллеров могут затем заполнять и передавать эти оптимизированные для просмотра классы в наш шаблон представления для использования. Это обеспечивает безопасность типов, проверку во время компиляции и IntelliSense в редакторе в шаблонах представления.

Например, чтобы включить сценарии редактирования форм-фактора компании, мы можем создать класс "Диннерформвиевмодел", как показано ниже, который предоставляет два строго типизированных свойства: объект Dinner и модель SelectList, необходимые для заполнения DropDownList для стран:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample4.cs)]

Затем мы можем обновить наш метод действия Edit (), чтобы создать Диннерформвиевмодел с помощью объекта ужин, полученного из нашего репозитория, а затем передать его в наш шаблон представления:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample5.cs)]

Затем мы изменим наш шаблон представления так, чтобы он предполагал "Диннерформвиевмодел" вместо объекта "ужин", изменив атрибут "Inherits" в верхней части страницы Edit. aspx следующим образом:

[!code-cshtml[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample6.cshtml)]

После этого IntelliSense свойства "Model" в нашем шаблоне представления будет обновлено для отражения объектной модели типа Диннерформвиевмодел, который мы передаем:

![](use-viewdata-and-implement-viewmodel-classes/_static/image2.png)

![](use-viewdata-and-implement-viewmodel-classes/_static/image3.png)

Затем мы можем обновить наш код представления для работы с ним. Обратите внимание на то, как мы не изменяем имена создаваемых элементов ввода (элементы формы по-прежнему будут называться «Title», «Country»), но мы обновляем вспомогательные методы HTML для получения значений с помощью класса Диннерформвиевмодел:

[!code-aspx[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample7.aspx)]

Мы также изменим метод Edit POST для использования класса Диннерформвиевмодел при подготовке ошибок к просмотру:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample8.cs)]

Мы также можем обновить методы действия Create (), чтобы повторно использовать тот же класс *диннерформвиевмодел* для включения DropDownList в этих странах. Ниже приведена реализация HTTP-GET:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample9.cs)]

Ниже приведена реализация метода HTTP-POST Create.

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample10.cs)]

И теперь оба экрана редактирования и создания поддерживают Drop-довнлистс для выбора страны.

### <a name="custom-shaped-viewmodel-classes"></a>Пользовательские классы ViewModel

В приведенном выше сценарии наш класс Диннерформвиевмодел непосредственно предоставляет объект модели компании как свойство, а также свойство вспомогательной модели SelectList. Этот подход прекрасно подходит для сценариев, в которых пользовательский интерфейс HTML, который нужно создать в нашем шаблоне представления, сравнительно близко к нашим объектам модели предметной области.

В сценариях, где это не так, можно воспользоваться одним из вариантов — создать пользовательский класс ViewModel, объектная модель которого более оптимизирована для использования в представлении, а это может выглядеть совершенно иначе от базового объекта модели предметной области. Например, он может предоставлять различные имена свойств и (или) статистические свойства, собранные из нескольких объектов модели.

Пользовательские классы ViewModel можно использовать для передачи данных из контроллеров в представления для подготовки к просмотру, а также для обработки данных формы, отправляемых обратно в метод действия контроллера. В этом случае метод действия может обновить объект ViewModel с данными, переданными в форме, а затем использовать экземпляр ViewModel для отображения или получения фактического объекта модели предметной области.

Пользовательские классы ViewModel могут предоставлять большую гибкость, и их можно исследовать всякий раз, когда вы найдете код отрисовки в шаблонах представления или код для размещения формы внутри методов действий, начиная со слишком сложных. Часто это подписано тем, что модели предметной области не должны точно соответствовать создаваемому пользовательскому интерфейсу, и что может помочь в создании промежуточного класса ViewModel.

### <a name="next-step"></a>Следующий шаг

Теперь рассмотрим, как можно использовать частичные и главные страницы для повторного использования и предоставления общего доступа к пользовательскому интерфейсу в нашем приложении.

> [!div class="step-by-step"]
> [Назад](provide-crud-create-read-update-delete-data-form-entry-support.md)
> [Вперед](re-use-ui-using-master-pages-and-partials.md)
