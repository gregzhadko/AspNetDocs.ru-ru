---
uid: mvc/overview/older-versions-1/nerddinner/use-viewdata-and-implement-viewmodel-classes
title: Использование ViewData и реализация классов ViewModel | Документация Майкрософт
author: microsoft
description: Шаг 6 показано как включить поддержку редактирования сценариев, более широкие форм также рассматриваются два подхода, которые могут использоваться для передачи данных из контроллеров представлений:...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: 5755ec4c-60f1-4057-9ec0-3a5de3a20e23
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/use-viewdata-and-implement-viewmodel-classes
msc.type: authoredcontent
ms.openlocfilehash: ca9775417c2e25952511a73096fb76d5d4edaea2
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65125450"
---
# <a name="use-viewdata-and-implement-viewmodel-classes"></a>Использование ViewData и реализация классов ViewModel

по [Microsoft](https://github.com/microsoft)

[Загрузить PDF-файл](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> Это бесплатная Этап 6 [руководство по использованию приложения «NerdDinner»](introducing-the-nerddinner-tutorial.md) , пошаговое рассмотрение как создать небольшой, но завершить, веб-приложения с помощью ASP.NET MVC 1.
> 
> Шаг 6 показано как включить поддержку более широкие формы, изменение сценариев, а также рассматриваются два подхода, которые могут использоваться для передачи данных из контроллеров представлений: ViewData и ViewModel.
> 
> Если вы используете ASP.NET MVC 3, рекомендуется следовать [Приступая к работе с MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) или [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) учебники.

## <a name="nerddinner-step-6-viewdata-and-viewmodel"></a>NerdDinner Step 6: ViewData и ViewModel

Мы рассказал в ряде сценариев post формы и рассматриваются способы реализации создания, обновления и удаления (CRUD). Теперь мы пойти дальше нашей реализации DinnersController и включить поддержку редактирования сценариев более широкие форм. При этом будут рассмотрены два подхода, которые могут использоваться для передачи данных из контроллеров представлений: ViewData и ViewModel.

### <a name="passing-data-from-controllers-to-view-templates"></a>Передача данных из контроллеров шаблоны представлений

Одним из определяющие характеристики этого шаблона MVC является strict «Разделение областей ответственности» он помогает обеспечивать между различными компонентами приложения. Модели, контроллеры и представления каждый четко определены роли и обязанности, и они взаимодействуют между собой хорошо определенными способами. Это помогает повысить уровень пригодности для тестирования и повторное использование кода.

Когда класс контроллера решает для отрисовки HTML-ответа обратно клиенту, он несет ответственность за явно передачи шаблону представления, все данные, необходимые для подготовки к просмотру в ответ. Просмотр шаблонов не должны выполнять данных с получением или приложения логики — и вместо этого следует ограничить могут иметь только код подготовки отчетов, который выполняется на основе переданного ему контроллером данных или модели.

Сейчас модели данных, передаваемого по нашей DinnersController класс для наших шаблонов представления является простой и прост — список компании Dinner объектов в случае Index() и единый Dinner объекта в случае Details(), Edit(), Create() и Delete(). Мы будем добавлять дополнительные возможности пользовательского интерфейса для нашего приложения, часто будет необходимо передать эти данные не только для подготовки к просмотру HTML ответов в наших шаблонов представлений. Например мы может потребоваться изменить поле «Страна» в нашей редактирования и создания представлений не текстовое поле HTML для элемента управления dropdownlist. Вместо того чтобы жестко раскрывающемся списке названия стран в шаблоне представления необходимо создать его из списка поддерживаемых стран, мы динамического заполнения. Нам понадобится для передачи объекта Dinner *и* список поддерживаемых стран, из нашего контроллера для наших шаблонов представлений.

Давайте взглянем на этого можно достичь двумя способами.

### <a name="using-the-viewdata-dictionary"></a>Используя словарь ViewData

Базовый класс контроллера предоставляет свойство словаря «ViewData», который может использоваться для передачи дополнительных данных элементов из контроллеров представлений.

Например для поддержки сценария, где мы хотим изменить текстовое поле «Страна» в рамках нашего представления редактирования не текстовое поле HTML для элемента управления dropdownlist, можно обновить метод действия наших Edit() для передачи (в дополнение к объект Dinner) объект SelectList, который можно использовать в качестве m одель dropdownlist странах.

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample1.cs)]

Конструктор SelectList выше принимает список округов, для заполнения раскрывающегося downlist с, а также текущее выбранное значение.

Затем мы можем обновить шаблон представления Edit.aspx использовать вспомогательный метод Html.DropDownList() вместо Html.TextBox() вспомогательный метод, который мы использовали ранее:

[!code-aspx[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample2.aspx)]

Вспомогательный метод Html.DropDownList() выше принимает два параметра. Первый является имя HTML-элемента формы для вывода. Второй — «SelectList» модель, которую мы передали через словарь ViewData. Мы используем C# ключевое слово «как» для приведения типа в словарь в виде SelectList.

И теперь при запуске приложения из наших доступа */Dinners/Edit/1* URL-адрес в наш обозреватель мы увидим, что наши изменения пользовательского интерфейса был обновлен для отображения элемента управления dropdownlist стран, а не текстового поля:

![](use-viewdata-and-implement-viewmodel-classes/_static/image1.png)

Поскольку мы также отображают шаблон представления редактирования из метода изменить HTTP-POST (в сценарии, при возникновении ошибок), нам понадобятся убедитесь в том, что мы обновляем этот метод для добавления SelectList ViewData при рендеринге шаблона представления в сценариях ошибка:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample3.cs)]

И теперь в нашем сценарии редактирования DinnersController поддерживает элемента управления DropDownList.

### <a name="using-a-viewmodel-pattern"></a>С помощью шаблона модель представления

Словарь ViewData такой подход имеет преимущество в виде довольно быстро и легко реализовать. Некоторые разработчики не нравится использовать строковые словари, однако поскольку опечаток может привести к ошибкам, которые не перехватываются во время компиляции. Нетипизированный словарь ViewData также требуется, с помощью оператора «как» или приведение при использовании со строгой типизацией языке вроде C# в шаблоне представления.

Альтернативный подход, мы могли бы использовать — один часто обозначается как шаблон «ViewModel». При использовании этого шаблона, мы создаем классы со строгой типизацией, оптимизированных для наших вариантов использования конкретного представления и предоставляют свойства для динамического значения или содержимого необходимые наших шаблонов представлений. Наши классы контроллера можно заполнить и передать шаблон представления для использования этих классов, оптимизированный для представления. Благодаря этому безопасность типов, проверки во время компиляции и intellisense редактора в шаблоны представлений.

Например, чтобы включить компании dinner форму редактирования сценариев, мы можем создать «DinnerFormViewModel» класса как ниже, который предоставляет два свойства со строгой типизацией: объект Dinner и SelectList модели, необходимые для заполнения элемента управления dropdownlist странах:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample4.cs)]

Мы затем обновите метод действия наших Edit() для создания DinnerFormViewModel, используя объект Dinner, полученного из нашего репозитория и затем передать ее к шаблону представления:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample5.cs)]

Мы будем, то обновления, наш шаблон представления, так что он ожидает, что «DinnerFormViewModel» вместо «Обед» объекта путем изменения атрибута «наследует» в верхней части страницы edit.aspx следующим образом:

[!code-cshtml[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample6.cshtml)]

После этого, intellisense свойства «Модель» в нашем шаблоне представления будут обновлены в соответствии с моделью объекта типа DinnerFormViewModel, мы передаем его:

![](use-viewdata-and-implement-viewmodel-classes/_static/image2.png)

![](use-viewdata-and-implement-viewmodel-classes/_static/image3.png)

Затем можно обновить наш код представления, чтобы работать с его. Обратите внимание, что ниже как мы не изменяем имена элементов ввода мы создаем (элементы формы будет по-прежнему называться «Title», «Страна») — но мы обновляем HTML вспомогательные методы для получения значений, с помощью класса DinnerFormViewModel:

[!code-aspx[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample7.aspx)]

Мы также обновим наш метод post редактирования должен использоваться класс DinnerFormViewModel, при отрисовке ошибок:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample8.cs)]

Мы также можно обновить наши методы действия Create() для повторного использования точного же *DinnerFormViewModel* класса для включения в странах DropDownList в них также. Ниже описана реализация HTTP-GET.

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample9.cs)]

Ниже приведена реализация метода создания HTTP-POST:

[!code-csharp[Main](use-viewdata-and-implement-viewmodel-classes/samples/sample10.cs)]

И теперь экраны Edit и Create поддерживают раскрывающиеся списки для выбора страны или региона.

### <a name="custom-shaped-viewmodel-classes"></a>Custom образный классов модели представления

В сценарии выше наш класс DinnerFormViewModel напрямую предоставляет объект модели компании Dinner как свойство, а также вспомогательные SelectList свойства модели. Этот подход хорошо работает для сценариев, где пользовательского интерфейса HTML, мы хотим создать в нашем шаблоне представления соответствует относительно близко объектов модели домена.

Для сценариев, где это не так, можно использовать только один параметр заключается в создании класса ViewModel-образный custom которого объектной модели более оптимизирован для использования этого представления — и может выглядеть полностью отличаются от базовой модели объекта домена. Например потенциально подвергает разные имена свойств и свойства статистических выражений, собранных из нескольких объектов модели.

Может быть в форме пользовательских классов модели представления используется и для передачи данных из контроллеров представлений для визуализации, а также для обработки данных формы обратной передачи метод действия контроллера. Далее в этом сценарии может потребоваться метод действия обновляет объект модели представления с данными форма передается и использует экземпляр модели представления для сопоставления или извлечения объекта модели домена.

Форме пользовательских классов модели представления может предоставить большую гибкость и немного для изучения каждый раз, когда поиска кода отображения в шаблоны представления или формы учета код внутри своих методов действий, начинает привлекать слишком сложным. Часто это знак, что модели предметной не соответствуют полностью при создании пользовательского интерфейса, и что промежуточный форме пользовательский класс ViewModel может помочь.

### <a name="next-step"></a>Следующий шаг

Давайте теперь взглянем на как можно использовать частичные реплики и главных страниц для повторного использования и совместное использование пользовательского интерфейса для нашего приложения.

> [!div class="step-by-step"]
> [Назад](provide-crud-create-read-update-delete-data-form-entry-support.md)
> [Вперед](re-use-ui-using-master-pages-and-partials.md)
