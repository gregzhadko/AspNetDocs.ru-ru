---
uid: mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
title: '#5 итерации — создание модульныхC#тестов () | Документация Майкрософт'
author: microsoft
description: В пятой итерации мы сделаем наше приложение проще в обслуживании и изменении, добавляя модульные тесты. Мы размакетирования наши классы модели данных и создаем модульные тесты для o...
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 28ad8f80-b8a5-444e-b478-8b15a846060c
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
msc.type: authoredcontent
ms.openlocfilehash: 32e81cce34a0e0b1f6b01934334e1b66dce89651
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78437844"
---
# <a name="iteration-5--create-unit-tests-c"></a>#5 итерации — создание модульныхC#тестов ()

по [Майкрософт](https://github.com/microsoft)

[Скачать код](iteration-5-create-unit-tests-cs/_static/contactmanager_5_cs1.zip)

> В пятой итерации мы сделаем наше приложение проще в обслуживании и изменении, добавляя модульные тесты. Мы размакетирования наши классы модели данных и создаем модульные тесты для наших контроллеров и логики проверки.

## <a name="building-a-contact-management-aspnet-mvc-application-c"></a>Создание приложения для управления контактами ASP.NET MVCC#()

В этой серии учебников мы создадим все приложение управления контактами от начала до конца. Приложение диспетчера контактов позволяет хранить контактные данные, имена телефонов и адреса электронной почты. список людей.

Мы создаем приложение для нескольких итераций. При каждой итерации мы постепенно улучшаем приложение. Цель этого нескольких итераций — позволить вам понять причину каждого изменения.

- Итерация #1 — Создайте приложение. В первой итерации мы создаем Диспетчер контактов проще всего. Добавлена поддержка основных операций с базой данных: создание, чтение, обновление и удаление (CRUD).

- Итерация #2 — сделайте приложение привлекательным. В этой итерации мы улучшаем внешний вид приложения путем изменения главной страницы ASP.NET представления MVC по умолчанию и каскадной таблицы стилей.

- Итерация #3 — Добавление проверки формы. В третьей итерации мы добавим проверку базовой формы. Мы запрещаем пользователям отправлять форму, не заполняя обязательные поля формы. Мы также проверяем адреса электронной почты и номера телефонов.

- Итерация #4 — сделайте приложение слабо связанным. В этой четвертой итерации мы используем преимущества нескольких шаблонов проектирования программного обеспечения, чтобы упростить обслуживание и изменение приложения Contact Manager. Например, мы выполним рефакторинг нашего приложения для использования шаблона репозитория и шаблона внедрения зависимостей.

- Итерация #5 — Создание модульных тестов. В пятой итерации мы сделаем наше приложение проще в обслуживании и изменении, добавляя модульные тесты. Мы размакетирования наши классы модели данных и создаем модульные тесты для наших контроллеров и логики проверки.

- Итерация #6 — Используйте разработку на основе тестирования. В этой шестой итерации мы добавим новые функции в наше приложение, создав модульные тесты в первую очередь и записав код в модульные тесты. В этой итерации мы добавляем группы контактов.

- Итерация #7 — Добавление функциональности AJAX. В седьмой итерации мы улучшаем скорость реагирования и производительность нашего приложения, добавив поддержку AJAX.

## <a name="this-iteration"></a>Эта итерация

В предыдущей итерации приложения диспетчера контактов мы переделили приложение так, чтобы оно было более слабо связанным. Мы разделили приложение на отдельные уровни контроллера, службы и репозитория. Каждый уровень взаимодействует с уровнем под ним через интерфейсы.

Мы выполнили рефакторинг приложения, чтобы упростить обслуживание и изменение приложения. Например, если необходимо использовать новую технологию доступа к данным, можно просто изменить слой репозитория, не затрагивая контроллер или слой служб. Благодаря нетесной связи диспетчера контактов мы сделали приложение более устойчивым для изменения.

Но что произойдет, когда нам нужно добавить новую функцию в приложение Contact Manager? Или что происходит при исправлении ошибки? Грустный, но хорошо проверенный, честно написание кода заключается в том, что при каждом касании кода создается риск введения новых ошибок.

Например, один отличный день руководитель может попросить вас добавить новую функцию в Диспетчер контактов. Она хочет добавить поддержку для групп контактов. Она хочет предоставить пользователям возможность организовывать контакты в группы, такие как друзья, Бизнес и т. д.

Чтобы реализовать эту новую функцию, необходимо изменить все три уровня приложения диспетчера контактов. Вам потребуется добавить новые функции к контроллерам, уровню служб и репозиторию. Как только вы начнете изменять код, вы рискуете разорывать функциональность, которая работала раньше.

Оптимизация приложения на отдельные слои, как мы делали в предыдущей итерации, было хорошим делом. Это было неплохо, поскольку оно позволяет вносить изменения во все слои, не затрагивая остальную часть приложения. Однако если необходимо упростить обслуживание и изменение кода в слое, необходимо создать модульные тесты для кода.

Модульный тест используется для тестирования отдельной единицы кода. Эти единицы кода меньше, чем все уровни приложения. Как правило, модульный тест используется для проверки того, что конкретный метод в коде ведет себя так, как вы ждете. Например, можно создать модульный тест для метода Креатеконтакт (), предоставляемого классом Контактманажерсервице.

Модульные тесты для приложения работают так же, как и безопасность сети. При изменении кода в приложении можно выполнить набор модульных тестов, чтобы проверить, не нарушает ли изменение существующие функциональные возможности. Модульные тесты делают код защищенным для изменения. Модульные тесты делают весь код в приложении более устойчивым к изменению.

В этой итерации мы добавим модульные тесты к нашему приложению диспетчера контактов. Таким образом, в следующей итерации мы можем добавить группы контактов в наше приложение, не беспокоясь о нарушении существующих функциональных возможностей.

> [!NOTE] 
> 
> Существует множество платформ модульного тестирования, включая NUnit, xUnit.net и MbUnit. В этом руководстве мы используем платформу модульного тестирования, входящую в состав Visual Studio. Тем не менее можно было бы использовать одну из этих альтернативных платформ.

## <a name="what-gets-tested"></a>Что проверяется

В идеальном мире весь код будет охватывать модульные тесты. В идеальном мире у вас будет идеальная безопасность сети. Вы сможете изменять любую строку кода в приложении и сразу же узнавать, выполняя модульные тесты, независимо от того, нарушили ли изменения существующие функциональные возможности.

Тем не менее мы не будем жить в идеальном мире. На практике при написании модульных тестов вы сосредоточены на написании тестов для бизнес-логики (например, логики проверки). В частности, вы *не* пишете модульные тесты для логики доступа к данным или логики представления.

Чтобы быть полезным, модульные тесты должны выполняться очень быстро. Вы можете легко накапливать сотни (или даже тысячи) модульных тестов для приложения. Если выполнение модульных тестов занимает много времени, вы не сможете их выполнять. Иными словами, длительные модульные тесты бесполезны для написания кода в повседневной работе.

По этой причине вы обычно не пишете модульные тесты для кода, взаимодействующего с базой данных. Выполнение сотен модульных тестов для активной базы данных будет выполняться слишком долго. Вместо этого вы размещаете базу данных и пишете код, который взаимодействует с макетом базы данных (обсуждается макет базы данных ниже).

По той же причине вы обычно не пишете модульные тесты для представлений. Чтобы протестировать представление, необходимо запустить веб-сервер. Поскольку веб-сервер вращается относительно медленным процессом, не рекомендуется создавать модульные тесты для представлений.

Если представление содержит сложную логику, следует рассмотреть возможность перемещения логики в вспомогательные методы. Можно написать модульные тесты для вспомогательных методов, которые выполняются без запуска веб-сервера.

> [!NOTE] 
> 
> Хотя написание тестов для логики доступа к данным или логики представлений не является хорошей идеей при написании модульных тестов, эти тесты могут оказаться очень полезными при создании функциональных или интеграционных тестов.

> [!NOTE] 
> 
> ASP.NET MVC — это обработчик представлений веб-форм. Хотя обработчик представлений веб-форм зависит от веб-сервера, другие обработчики представлений могут не быть.

## <a name="using-a-mock-object-framework"></a>Использование объектной платформы макетов

При создании модульных тестов почти всегда нужно использовать преимущества макетной платформы объектов. Макетная платформа объектов позволяет создавать макеты и заглушки для классов в приложении.

Например, можно использовать структуру объектной платформы для создания макетной версии класса репозитория. Таким образом, можно использовать класс макета репозитория вместо действительного класса репозитория в модульных тестах. Использование макета репозитория позволяет избежать исполнения кода базы данных при выполнении модульного теста.

Visual Studio не включает в себя макетную платформу объектов. Однако для .NET Framework доступно несколько инфраструктурных макетов объектов с открытым исходным кодом:

1. MOQ — эта платформа доступна по лицензии BSD с открытым исходным кодом. MOQ можно скачать из [https://code.google.com/p/moq/](https://code.google.com/p/moq/).
2. Макеты Rhino. Эта платформа доступна по лицензии BSD с открытым исходным кодом. Макеты Rhino можно скачать с [http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx).
3. Typemock Isolator — это коммерческая платформа. Пробную версию можно скачать с [http://www.typemock.com/](http://www.typemock.com/).

В этом учебнике я решил использовать MOQ. Тем не менее можно легко использовать макеты Rhino или Typemock Isolator для создания макетов объектов для приложения диспетчера контактов.

Перед использованием MOQ необходимо выполнить следующие действия.

1. .
2. Перед распаковкой загружаемого файла щелкните правой кнопкой мыши файл и нажмите кнопку **разблокировать** (см. рис. 1).
3. Распакуйте загружаемый файл.
4. Добавьте ссылку на сборку MOQ, щелкнув правой кнопкой мыши папку References в проекте ContactManager. Tests и выбрав пункт **Добавить ссылку**. На вкладке Обзор перейдите к папке, в которой вы расMoqе расzip-файл, и выберите сборку MOQ. dll. Нажмите кнопку **ОК** .
5. После выполнения этих действий папка References должна выглядеть, как показано на рис. 2.

[![разблокировки MOQ](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)

**Рис. 01**. Разблокирование MOQ ([щелкните, чтобы просмотреть изображение с полным размером](iteration-5-create-unit-tests-cs/_static/image2.png))

[![ссылки после добавления MOQ](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)

**Рис. 02**. ссылки после добавления MOQ ([щелкните, чтобы просмотреть изображение с полным размером](iteration-5-create-unit-tests-cs/_static/image4.png))

## <a name="creating-unit-tests-for-the-service-layer"></a>Создание модульных тестов для слоя служб

Начнем с создания набора модульных тестов для нашего уровня обслуживания приложения диспетчера контактов. Мы будем использовать эти тесты для проверки логики проверки.

Создайте новую папку с именем Models в проекте ContactManager. Tests. Затем щелкните правой кнопкой мыши папку модели и выберите **Добавить, создать тест**. Появится диалоговое окно **Добавление нового теста** , показанное на рис. 3. Выберите шаблон **модульного теста** и назовите новый тест ContactManagerServiceTest.cs. Нажмите кнопку **ОК** , чтобы добавить новый тест в тестовый проект.

> [!NOTE] 
> 
> Как правило, структура папок тестового проекта должна соответствовать структуре папок проекта ASP.NET MVC. Например, можно разместить тесты контроллера в папке Controllers, проверить модели в папке Models и т. д.

[![Моделс\контактманажерсервицетест.КС](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)

**Рис. 03**. Моделс\контактманажерсервицетест.КС ([щелкните, чтобы просмотреть изображение с полным размером](iteration-5-create-unit-tests-cs/_static/image6.png))

Сначала мы хотим протестировать метод Креатеконтакт (), предоставляемый классом Контактманажерсервице. Мы создадим следующие пять тестов:

- Креатеконтакт () — тесты, Креатеконтакт (), возвращают значение true, если в метод передается допустимый контакт.
- Креатеконтактрекуиредфирстнаме () — проверяет, добавляется сообщение об ошибке в состояние модели, когда контакт с отсутствующим именем передается в метод Креатеконтакт ().
- Креатеконтактрекуиредластнаме () — проверяет, добавляется сообщение об ошибке в состояние модели, когда контакт с отсутствующим последним именем передается в метод Креатеконтакт ().
- Креатеконтактинвалидфоне () — проверяет, что в состояние модели Добавлено сообщение об ошибке, когда в метод Креатеконтакт () передается контакт с недопустимым номером телефона.
- Креатеконтактинвалидемаил () — проверяет, добавляется сообщение об ошибке в состояние модели, когда в метод Креатеконтакт () передается контакт с недопустимым адресом электронной почты.

Первый тест проверяет, что допустимый контакт не создает ошибку проверки. Остальные тесты проверяют все правила проверки.

Код для этих тестов содержится в листинге 1.

**Листинг 1. Моделс\контактманажерсервицетест.КС**

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample1.cs)]

Так как мы используем класс Contact в листинге 1, нам нужно добавить ссылку на Entity Framework Майкрософт в наш тестовый проект. Добавьте ссылку на сборку System. Data. Entity.

Листинг 1 содержит метод с именем Initialize (), дополненный атрибутом [TestInitialize]. Этот метод вызывается автоматически перед выполнением каждого модульного теста (он именуется 5 раз прямо перед каждым модульным тестом). Метод Initialize () создает макет репозитория со следующей строкой кода:

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample2.cs)]

Эта строка кода использует платформу MOQ для создания макета репозитория из интерфейса Иконтактманажеррепоситори. Макет репозитория используется вместо фактического Ентитиконтактманажеррепоситори, чтобы избежать доступа к базе данных при выполнении каждого модульного теста. Макет репозитория реализует методы интерфейса Иконтактманажеррепоситори, но методы фактически не выполняют никаких действий.

> [!NOTE] 
> 
> При использовании платформы MOQ существует различие между \_Моккрепоситори и \_Моккрепоситори. Object. Первое относится к макету&lt;Иконтактманажеррепоситори&gt; класса, который содержит методы для указания того, как будет вести себя макет репозитория. Последнее относится к фактическому макету репозитория, реализующему интерфейс Иконтактманажеррепоситори.

Макет репозитория используется в методе Initialize () при создании экземпляра класса Контактманажерсервице. Все индивидуальные модульные тесты используют этот экземпляр класса Контактманажерсервице.

В листинге 1 содержится пять методов, соответствующих каждому из модульных тестов. Каждый из этих методов снабжен атрибутом [TestMethod]. При выполнении модульных тестов вызывается любой метод с этим атрибутом. Иными словами, любой метод, снабженный атрибутом [TestMethod], является модульным тестом.

Первый модульный тест с именем Креатеконтакт () проверяет, что вызов Креатеконтакт () возвращает значение true, когда в метод передается допустимый экземпляр класса Contact. Тест создает экземпляр класса Contact, вызывает метод Креатеконтакт () и проверяет, возвращает ли Креатеконтакт () значение true.

Оставшиеся тесты проверяют, что при вызове метода Креатеконтакт () с недопустимым контактом метод возвращает значение false, а ожидаемое сообщение об ошибке проверки добавляется в состояние модели. Например, тест Креатеконтактрекуиредфирстнаме () создает экземпляр класса Contact с пустой строкой для своего свойства FirstName. Затем метод Креатеконтакт () вызывается с недопустимым контактом. Наконец, тест проверяет, что Креатеконтакт () возвращает значение false и что состояние модели содержит ожидаемое сообщение об ошибке проверки "имя является обязательным".

Вы можете запустить модульные тесты в листинге 1, выбрав пункт меню **тест, выполнить, все тесты в решении (Ctrl + R, A)** . Результаты тестов отображаются в окне результаты теста (см. рис. 4).

[![результаты теста](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)

**Рис. 04**. Результаты теста ([щелкните, чтобы просмотреть изображение с полным размером](iteration-5-create-unit-tests-cs/_static/image8.png))

## <a name="creating-unit-tests-for-controllers"></a>Создание модульных тестов для контроллеров

Приложение ASP. НЕТМВК управляет потоком взаимодействия с пользователем. При тестировании контроллера необходимо проверить, возвращает ли контроллер правильный результат действия и просмотреть данные. Также может потребоваться проверить, взаимодействует ли контроллер с классами модели так, как ожидалось.

Например, в листинге 2 содержатся два модульных теста для метода Contact Controller Create (). Первый модульный тест проверяет, что при передаче допустимого контакта в метод Create () метод Create () выполняет перенаправление к действию индекса. Иными словами, при передаче допустимого контакта метод Create () должен возвращать Редиректтораутересулт, представляющий действие индекса.

Мы не хотим тестировать слой служб ContactManager при тестировании уровня контроллера. Поэтому слой служб разменяется следующим кодом в методе Initialize:

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample3.cs)]

В модульном тесте Креатевалидконтакт () мы раз поведение вызова метода Service Layer Креатеконтакт () с помощью следующей строки кода:

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample4.cs)]

Эта строка кода приводит к тому, что фиктивная служба ContactManager возвращает значение true при вызове метода Креатеконтакт (). При макетирование слоя служб можно протестировать поведение нашего контроллера, не требуя выполнения кода на уровне службы.

Второй модульный тест проверяет, что действие Create () возвращает представление создания, когда в метод передается недопустимый контакт. В результате метод Креатеконтакт () уровня службы возвращает значение false со следующей строкой кода:

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample5.cs)]

Если метод Create () ведет себя по мере ожидания, он должен возвращать представление Create, когда слой служб возвращает значение false. Таким образом, контроллер может отобразить сообщения об ошибках проверки в представлении создания, и пользователь сможет исправить эти недопустимые свойства контакта.

Если планируется построение модульных тестов для контроллеров, необходимо вернуть явные имена представлений из действий контроллера. Например, не возвращайте представление следующим образом:

Возврат представления ();

Вместо этого верните представление следующим образом:

Возврат представления ("создать");

Если при возврате представления используется неявное значение, свойство Виевресулт. ViewName возвращает пустую строку.

**Листинг 2. Контроллерс\контактконтроллертест.КС**

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample6.cs)]

## <a name="summary"></a>Сводка

В этой итерации мы создали модульные тесты для нашего приложения диспетчера контактов. Эти модульные тесты можно запустить в любое время, чтобы убедиться, что наше приложение работает так, как мы и надеемся. Модульные тесты действуют как безопасность в нашем приложении, что позволяет нам безопасно изменять наше приложение в будущем.

Мы создали два набора модульных тестов. Сначала мы протестировали логику проверки, создав модульные тесты для нашего уровня служб. Далее мы протестировали логику управления потоком, создав модульные тесты для нашего уровня контроллера. При тестировании уровня служб мы разизолируи наши тесты для нашего уровня службы на уровне репозитория, развершив макетирование нашего слоя репозитория. При тестировании уровня контроллера мы изолируем тесты для нашего уровня контроллера, развершив макетирование слоя служб.

В следующей итерации мы изменим приложение диспетчера контактов таким образом, чтобы оно поддерживало группы контактов. Мы добавим эти новые функции в наше приложение, используя процесс разработки программного обеспечения, именуемый разработкой на основе тестирования.

> [!div class="step-by-step"]
> [Назад](iteration-4-make-the-application-loosely-coupled-cs.md)
> [Вперед](iteration-6-use-test-driven-development-cs.md)
