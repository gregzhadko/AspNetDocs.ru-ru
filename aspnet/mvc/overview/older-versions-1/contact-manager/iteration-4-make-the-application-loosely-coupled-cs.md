---
uid: mvc/overview/older-versions-1/contact-manager/iteration-4-make-the-application-loosely-coupled-cs
title: 'Итерация #4 - Сделать приложение слабо связаны (C) Документы Майкрософт'
author: rick-anderson
description: В этой четвертой итерации мы воспользуемся несколькими шаблонами проектирования программного обеспечения, чтобы упростить обслуживание и изменение приложения Contact Manager. Для ...
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 829f589f-e201-4f6e-9ae6-08ae84322065
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-4-make-the-application-loosely-coupled-cs
msc.type: authoredcontent
ms.openlocfilehash: c4ba6c9a130995c095653f4316a5fefdfc03b91d
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542369"
---
# <a name="iteration-4--make-the-application-loosely-coupled-c"></a>Итерация 4. Создание слабых связей в приложении (C#)

[корпорацией Майкрософт](https://github.com/microsoft)

[Скачать код](iteration-4-make-the-application-loosely-coupled-cs/_static/contactmanager_4_cs1.zip)

> В этой четвертой итерации мы воспользуемся несколькими шаблонами проектирования программного обеспечения, чтобы упростить обслуживание и изменение приложения Contact Manager. Например, мы рефакторизуем наше приложение, чтобы использовать шаблон репозитория и шаблон инъекций зависимостей.

## <a name="building-a-contact-management-aspnet-mvc-application-c"></a>Создание приложения управления контактами ASP.NET MVC (C)

В этой серии учебников мы создаем все приложение Управления Контактами от начала до конца. Приложение Contact Manager позволяет хранить контактную информацию - имена, номера телефонов и адреса электронной почты - для списка людей.

Мы строим приложение по нескольким итерациям. С каждой итерацией мы постепенно совершенствуем приложение. Цель этого подхода с множественной итерацией состоит в том, чтобы вы могли понять причину каждого изменения.

- Итерация #1 - Создайте приложение. В первой итерации мы создаем Контакт-менеджер самым простым способом. Мы добавляем поддержку для основных операций базы данных: Создание, чтение, обновление и удаление (CRUD).

- Итерация #2 - Сделать приложение хорошо выглядеть. В этой итерации мы улучшаем внешний вид приложения, изменяя страницу по умолчанию ASP.NET MVC просмотра и каскадный стиль листа.

- Итерация #3 - Добавить проверку формы. В третьей итерации мы добавляем базовую проверку формы. Мы не позволяем людям подавать форму без заполнения требуемых полей формы. Мы также проверяем адреса электронной почты и номера телефонов.

- Итерация #4 - Сделать приложение слабо связаны. В этой четвертой итерации мы воспользуемся несколькими шаблонами проектирования программного обеспечения, чтобы упростить обслуживание и изменение приложения Contact Manager. Например, мы рефакторизуем наше приложение, чтобы использовать шаблон репозитория и шаблон инъекций зависимостей.

- Итерация #5 - Создание модульных тестов. В пятой итерации мы упрощаем обслуживание и модификацию нашего приложения путем добавления модульных тестов. Мы издеваемся над нашими классами моделей данных и строим модульные тесты для наших контроллеров и логики проверки.

- Итерация #6 - Использование тест-ориентированной разработки. В этой шестой итерации мы добавляем новую функциональность в наше приложение, написав модульные тесты сначала и написав код против модульных тестов. В этой итерации мы добавляем контактные группы.

- Итерация #7 - Добавить функциональность Ajax. В седьмой итерации мы улучшаем отзывчивость и производительность нашего приложения, добавляя поддержку Ajax.

## <a name="this-iteration"></a>Эта итерация

В этой четвертой итерации приложения Contact Manager мы рефакторизуем приложение, чтобы сделать приложение более свободно связанным. При совмещении приложения можно изменить код в одной части приложения без необходимости изменять код в других частях приложения. Свободно связанные приложения более устойчивы к изменениям.

В настоящее время вся логика доступа и проверки данных, используемая приложением Contact Manager, содержится в классах контроллеров. Это плохая идея. Всякий раз, когда вам нужно изменить одну часть приложения, вы рискуете ввести ошибки в другую часть приложения. Например, если вы измените логику проверки, вы рискуете ввести новые ошибки в логику доступа к данным или контроллера.

> [!NOTE] 
> 
> (SRP), класс никогда не должен иметь более одной причины для изменения. Смешивание контроллера, проверки и логики базы данных является массовым нарушением принципа единой ответственности.

Существует несколько причин, по которым может потребоваться изменить приложение. Возможно, потребуется добавить новую функцию в приложение, возможно, потребуется исправить ошибку в приложении, или, возможно, потребуется изменить способ реализации функции приложения. Приложения редко статичны. Они, как правило, растут и мутируют с течением времени.

Представьте себе, например, что вы решили изменить способ реализации слоя доступа к данным. В настоящее время приложение Contact Manager использует рамочную программу Корпорации Майкрософт для доступа к базе данных. Однако может быть принято решение о переходе на новую или альтернативную технологию доступа к данным, такую как ADO.NET службы данных или NHibernate. Однако, поскольку код доступа к данным не изолирован от кода проверки и контроллера, нет никакого способа изменить код доступа к данным в приложении без изменения другого кода, который не имеет прямого отношения к доступу к данным.

С другой стороны, при слабом соединении приложения можно вносить изменения в одну часть приложения, не касаясь других частей приложения. Например, можно переключить технологии доступа к данным без изменения логики проверки или контроллера.

В этой итерации мы воспользуемся несколькими шаблонами проектирования программного обеспечения, которые позволяют нам рефакторировать наше приложение Contact Manager в более слабо ежефное приложение. Когда мы закончим, менеджер по контактам не будет делать ничего, что он не делал раньше. Тем не менее, мы сможем изменить приложение более легко в будущем.

> [!NOTE] 
> 
> Рефакторинг — это процесс переписывания приложения таким образом, чтобы оно не теряло существующую функциональность.

## <a name="using-the-repository-software-design-pattern"></a>Использование шаблона проектирования программного обеспечения репозитория

Наше первое изменение заключается в том, чтобы воспользоваться шаблоном проектирования программного обеспечения, который называется шаблоном репозитория. Мы будем использовать шаблон репозитория, чтобы изолировать наш код доступа к данным от остальной части нашего приложения.

Реализация шаблона репозитория требует от нас выполнения следующих двух шагов:

1. Выбор интерфейса
2. Создание конкретного класса, который реализует интерфейс

Во-первых, нам нужно создать интерфейс, описывающий все методы доступа к данным, которые нам необходимо выполнить. Интерфейс IContactManagerRepository содержится в листинге 1. Интерфейс описывает пять методов: CreateContact(), DeleteContact(), EditContact(), GetContact и ListContacts().

**Список 1 - Модели-IContactManagerRepository.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample1.cs)]

Далее нам нужно создать конкретный класс, который реализует интерфейс IContactManagerRepository. Поскольку мы используем рамку Сущности Майкрософт для доступа к базе данных, мы создадим новый класс под названием EntityContactManagerRepository. Этот класс содержится в листинге 2.

**Список 2 - Модели-EntityContactManagerRepository.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample2.cs)]

Обратите внимание, что класс EntityContactManagerRepository реализует интерфейс IContactManagerRepository. Класс реализует все пять методов, описанных этим интерфейсом.

Вы можете задаться вопросом, почему мы должны беспокоиться с интерфейсом. Почему нам нужно создать интерфейс и класс, который его реализует?

За одним исключением, остальная часть нашего приложения будет взаимодействовать с интерфейсом, а не с конкретным классом. Вместо вызова методов, выставленных классом EntityContactManagerRepository, мы назовем методы, выставленные интерфейсом IContactManagerRepository.

Таким образом, мы можем реализовать интерфейс с новым классом без необходимости изменять оставшуюся часть нашего приложения. Например, в будущем мы можем реализовать класс DataServicesContactManagerRepository, который реализует интерфейс IContactManagerRepository. Класс DataServicesContactManagerRepository может использовать ADO.NET службы обработки данных для доступа к базе данных вместо рамочной базы Сущности Майкрософт.

Если наш код приложения запрограммирован на интерфейс IContactManagerRepository вместо конкретного класса EntityContactContactManagerRepository, то мы можем переключать конкретные классы, не изменяя ни одного из остальных наших кодов. Например, мы можем перейти из класса EntityContactManagerRepository в класс DataServicesContactManagerRepository без изменения нашей логики доступа к данным или проверки.

Программирование интерфейсов (абстракций) вместо конкретных классов делает наше приложение более устойчивым к изменениям.

> [!NOTE] 
> 
> Вы можете быстро создать интерфейс из конкретного класса в Visual Studio, выбрав вариант меню Refactor, Extract Interface. Например, сначала можно создать класс EntityContactManagerRepository, а затем использовать интерфейс Extract Для автоматического создания интерфейса IContactManagerRepository.

## <a name="using-the-dependency-injection-software-design-pattern"></a>Использование шаблона проектирования программного обеспечения для инъекций зависимостей

Теперь, когда мы перенесли наш код доступа к данным в отдельный класс репозитория, нам необходимо изменить наш контроллер Контакта, чтобы использовать этот класс. Мы воспользуемся шаблоном проектирования программного обеспечения, называемым инъекцией зависимости, чтобы использовать класс репозитория в нашем контроллере.

Модифицированный контроллер контакта содержится в листинге 3.

**Список 3 - Контролеры/КонтактКонтроллер.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample3.cs)]

Обратите внимание, что контроллер контакта в листинге 3 имеет два конструктора. Первый конструктор передает конкретный экземпляр интерфейса IContactManagerRepository второму конструктору. Класс контроллера контакта использует *инъекцию зависимости конструктора.*

Единственное место, где используется класс EntityContactManagerRepository, находится в первом конструкторе. Остальная часть класса использует интерфейс IContactManagerRepository вместо конкретного класса EntityContactContactManagerRepository.

Это упрощает переключение реализаций класса IContactManagerRepository в будущем. Если вы хотите использовать класс DataServicesContactRepository вместо класса EntityContactManagerRepository, просто измените первый конструктор.

Инъекция зависимости конструктора также делает класс контроллера контакта очень проверяемым. В модульных тестах вы можете мгновенно настроить контроллер Контакта, пройдя макет реализации класса IContactManagerRepository. Эта функция инъекций зависимости будет очень важна для нас в следующей итерации, когда мы создадим модульные тесты для приложения Contact Manager.

> [!NOTE] 
> 
> Если вы хотите полностью отделить класс контроллера контакта от конкретной реализации интерфейса IContactManagerRepository, то вы можете воспользоваться инфраструктурой, которая поддерживает инъекцию зависимостей, такую как StructureMap или Microsoft Entity Framework (MEF). Воспользовавшись инфраструктурой впрыска зависимостей, вам никогда не нужно ссылаться на конкретный класс в коде.

## <a name="creating-a-service-layer"></a>Создание уровня обслуживания

Возможно, вы заметили, что наша логика проверки все еще смешивается с логикой контроллера в измененном классе контроллеров в листинге 3. По той же причине, что это хорошая идея, чтобы изолировать нашу логику доступа к данным, это хорошая идея, чтобы изолировать нашу логику проверки.

Чтобы устранить эту проблему, мы можем создать отдельный [*слой обслуживания.*](http://martinfowler.com/eaaCatalog/serviceLayer.html) Слой обслуживания представляет собой отдельный слой, который мы можем вставить между нашими классами контроллера и репозитория. Слой обслуживания содержит нашу бизнес-логику, включая всю нашу логику проверки.

ContactManagerService содержится в листинге 4. Он содержит логику проверки из класса контроллера Контакт.

**Список 4 - Модели/ContactManagerService.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample4.cs)]

Обратите внимание, что конструктор для ContactManagerService требует валидацииDictionary. Слой обслуживания общается со слоем контроллера через этот валидативсловарь. Мы подробно обсуждаем Валидератию в следующем разделе, когда мы обсуждаем шаблон Декоратора.

Кроме того, обратите внимание, что ContactManagerService реализует интерфейс IContactManagerService. Вы всегда должны стремиться к программированию против интерфейсов, а не конкретных классов. Другие классы в приложении Contact Manager не взаимодействуют с классом ContactManagerService напрямую. Вместо этого, за одним исключением, остальная часть приложения Contact Manager запрограммирована на интерфейс IContactManagerService.

Интерфейс IContactManagerService содержится в листинге 5.

**Список 5 - Модели-IContactManagerService.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample5.cs)]

Измененный класс контроллера контакта содержится в листинге 6. Обратите внимание, что контроллер контакта больше не взаимодействует с репозиторием ContactManager. Вместо этого контроллер контакта взаимодействует с службой ContactManager. Каждый слой изолирован как можно больше от других слоев.

**Список 6 - Контролеры**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample6.cs)]

Наше приложение больше не противоречит принципу единой ответственности (SRP). Контроллер контакта в листинге 6 был лишен всякей ответственности, кроме контроля за потоком выполнения приложения. Вся логика проверки была удалена из контроллера Контакта и перемещена в уровень обслуживания. Вся логика базы данных была перемещена в слой репозитория.

## <a name="using-the-decorator-pattern"></a>Использование шаблона декоратора

Мы хотим быть в состоянии полностью отделить наш слой обслуживания от нашего слоя контроллера. В принципе, мы должны быть в состоянии компилировать наш уровень обслуживания в отдельной сборке от нашего слоя контроллера без необходимости добавлять ссылку на наше приложение MVC.

Тем не менее, наш уровень обслуживания должен быть в состоянии передавать сообщения об ошибках проверки обратно в слой контроллера. Как мы можем включить уровень службы для передачи сообщений об ошибках проверки без соединения контроллера и уровня обслуживания? Мы можем воспользоваться шаблоном разработки программного обеспечения под названием [шаблон Decorator.](http://en.wikipedia.org/wiki/Decorator_pattern)

Контроллер использует ModelStateDictionary под названием ModelState для представления ошибок проверки. Поэтому может возникнуть соблазн передать ModelState из слоя контроллера в уровень обслуживания. Однако использование ModelState в уровне обслуживания сделает ваш уровень обслуживания зависимым от функции ASP.NET платформы MVC. Это было бы плохо, потому что, когда-нибудь, вы можете использовать слой службы с приложением WPF вместо ASP.NET приложения MVC. В этом случае вы не хотите ссылаться на ASP.NET платформу MVC для использования класса ModelStateDictionary.

Шаблон Decorator позволяет обернуть существующий класс в новый класс для реализации интерфейса. Наш проект «Контакт-менеджер» включает в себя класс ModelStateWrapper, содержащийся в листинге 7. Класс ModelStateWrapper реализует интерфейс в листинге 8.

**Список 7 - Модели (проверка) ModelStateWrapper.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample7.cs)]

**Список 8 - Модели (Проверка) - IValidationDictionary.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample8.cs)]

Если вы внимательно посмотрите на листинг 5, то вы увидите, что слой службы ContactManager использует интерфейс IValidationDictionary исключительно. Служба ContactManager не зависит от класса ModelStateDictionary. Когда контроллер контакта создает службу ContactManager, контроллер обертывает свою ModelState следующим образом:

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample9.cs)]

## <a name="summary"></a>Сводка

В этой итерации мы не добавили новую функциональность в приложение Contact Manager. Цель этой итерации состояла в том, чтобы рефакторинг приложения Contact Manager, чтобы было легче поддерживать и изменять.

Во-первых, мы внедрили шаблон проектирования программного обеспечения Repository. Мы перенесли весь код доступа к данным в отдельный класс репозитория ContactManager.

Мы также изолировали нашу логику проверки от нашей логики контроллера. Мы создали отдельный слой службы, содержащий весь наш код проверки. Слой контроллера взаимодействует со слоем службы, а слой обслуживания взаимодействует со слоем репозитория.

Когда мы создали уровень обслуживания, мы воспользовались шаблоном Decorator, чтобы изолировать ModelState от нашего сервисного слоя. В нашем сервисном слое мы запрограммированы на интерфейс IValidationDictionary вместо ModelState.

Наконец, мы воспользовались шаблоном проектирования программного обеспечения, названным шаблоном инъекций зависимостей. Этот шаблон позволяет нам программировать против интерфейсов (абстракций) вместо конкретных классов. Реализация шаблона проектирования инъекций зависимостей также делает наш код более проверяемым. В следующей итерации мы добавляем модульные тесты в наш проект.

> [!div class="step-by-step"]
> [Назад](iteration-3-add-form-validation-cs.md)
> [Вперед](iteration-5-create-unit-tests-cs.md)
