---
uid: mvc/overview/older-versions-1/contact-manager/iteration-4-make-the-application-loosely-coupled-cs
title: 'Итерация #4 – Создание слабых связей в приложении (C#) | Документация Майкрософт'
author: microsoft
description: В этой четвертой итерации мы воспользоваться преимуществами нескольких шаблонов дизайна программного обеспечения, чтобы упростить обслуживании и изменении приложения диспетчера контактов. Для ...
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 829f589f-e201-4f6e-9ae6-08ae84322065
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-4-make-the-application-loosely-coupled-cs
msc.type: authoredcontent
ms.openlocfilehash: 955991c148d48020c66cbc63ec6da45e3a9cc282
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57045311"
---
<a name="iteration-4--make-the-application-loosely-coupled-c"></a>Итерация #4 – Создание слабых связей в приложении (C#)
====================
по [Microsoft](https://github.com/microsoft)

[Скачать код](iteration-4-make-the-application-loosely-coupled-cs/_static/contactmanager_4_cs1.zip)

> В этой четвертой итерации мы воспользоваться преимуществами нескольких шаблонов дизайна программного обеспечения, чтобы упростить обслуживании и изменении приложения диспетчера контактов. Например мы выполнили рефакторинг наше приложение, чтобы использовать шаблон репозитория и шаблон внедрения зависимостей.


## <a name="building-a-contact-management-aspnet-mvc-application-c"></a>Создание приложения управления контактами ASP.NET MVC (C#)

В этой серии руководств мы создаем всего приложения управления контактами от начала до конца. Приложение диспетчера контактов позволяет хранить контактные данные - имена, номера телефонов и адреса электронной почты — список людей.

Мы создаем приложение через несколько итераций. С каждой итерацией мы постепенно улучшить приложение. Этот подход с несколькими итерации предназначена для того, чтобы можно было понять причину для каждого изменения.

- Итерация #1 - Создание приложения. В первой итерации мы создадим Contact Manager простейшим способом невозможно. Мы добавили поддержку для основных операций базы данных: Создание, чтение, обновление и удаление (CRUD).

- #2 - итерация приложения красиво выглядеть. В этой итерации мы улучшить внешний вид приложения, изменив значение по умолчанию master страница представления ASP.NET MVC и каскадные таблицы стилей.

- Итерации #3 - Добавление проверки форм. В третьей итерации мы добавим проверки базовой форме. Мы запретить Отправка формы без завершения обязательные поля. Кроме того, мы проверяем, адреса электронной почты и номера телефонов.

- Итерация #4 - Создание слабых связей в приложении. В этой четвертой итерации мы воспользоваться преимуществами нескольких шаблонов дизайна программного обеспечения, чтобы упростить обслуживании и изменении приложения диспетчера контактов. Например мы выполнили рефакторинг наше приложение, чтобы использовать шаблон репозитория и шаблон внедрения зависимостей.

- Итерации #5 - Создание модульных тестов. В пятой итерации мы вам наше приложение проще обслуживании и изменении путем добавления модульных тестов. Мы макетирование наших классов модели данных и создания модульных тестов для контроллеров и логику проверки.

- Итерация #6 - использование управляемой тестами разработки. В этой шестой итерации мы добавляем новые функциональные возможности в наше приложение, сначала написание модульных тестов и написании кода в отношении модульные тесты. В этой итерации мы добавляем групп контактов.

- Итерации #7 - Добавление функций Ajax. В седьмой итерации мы повысить скорость реагирования и производительность приложения, добавляя поддержку Ajax.

## <a name="this-iteration"></a>Эта итерация

В этой четвертой итерации приложения диспетчера контактов мы выполнили рефакторинг приложения, чтобы сделать приложение более слабо. Когда приложение слабо связанный, можно изменить код в одной части приложения без изменения кода в других частях приложения. Слабосвязанные приложения более устойчивы к изменить.

В настоящее время всю логику, доступа и проверки данных используется приложением диспетчера контактов содержится в классы контроллера. Это не рекомендуется. Каждый раз, когда необходимо внести изменения одной части приложения, то существует риск появления ошибок в другой части приложения. Например если изменить логику проверки, существует риск появления новых ошибок в логике данных access или контроллера.

> [!NOTE] 
> 
> (SRP), класс никогда не должен иметь более чем одну причину для изменения. Смешивание контроллера, проверки и логику базы данных является массовое нарушением принципа персональной ответственности.


Существует несколько причин, которые может потребоваться изменить приложение. Может потребоваться добавить новый компонент в приложение, может потребоваться исправление ошибки в приложении, или может потребоваться изменить способ реализации компонента приложения. Приложения, редко статический. Они стремятся расти и изменяется со временем.

К примеру, представьте себе, что вы хотите изменить, как реализовать слой доступа к данным. Справа теперь Contact Manager приложение использует Microsoft Entity Framework для доступа к базе данных. Тем не менее можно перенести в технологии доступа к данным новых или альтернативных, таких как службы ADO.NET Data Services или NHibernate. Тем не менее поскольку код доступа к данным не изолированы от кода проверки и контроллера, нет способа изменить код доступа к данным в приложении без изменения другой код, который не имеет прямого отношения к доступ к данным.

Когда приложение слабо связанный, с другой стороны, внесения изменений в одной части приложения не изменяя при этом другие части приложения. Например вы можете технологии доступа к данным без изменения логики проверки или контроллера.

В этой итерации мы воспользоваться преимуществами нескольких шаблонов дизайна программного обеспечения, которые мы можем выполнить рефакторинг наше приложение диспетчера контактов в приложении более разобщенными. После этого мы диспетчера контактов, выиграл t выполнить любые действия, он сделать перед. Тем не менее мы сможем изменить приложение, проще в будущем.

> [!NOTE] 
> 
> Рефакторинг — это процесс перезаписи приложения таким образом, что он не потерять существующие функциональные возможности.


## <a name="using-the-repository-software-design-pattern"></a>С помощью конструктивного шаблона репозитория программного обеспечения

Наши первое изменение — воспользоваться шаблоном проектирования программного обеспечения, вызывается шаблон репозитория. Мы будем использовать шаблон репозитория для изоляции наш код доступа к данным от остальной части приложения.

Реализация шаблона репозитория требует выполните следующие два действия:

1. Создание интерфейса
2. Создали конкретный класс, реализующий интерфейс

Во-первых нам нужно создать интерфейс, который описывает все методы доступа к данным, которые необходимо выполнить. Интерфейс IContactManagerRepository содержится в листинге 1. Этот интерфейс описывает пять методов: CreateContact(), DeleteContact(), EditContact(), GetContact и ListContacts().

**В листинге 1 - Models\IContactManagerRepositiory.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample1.cs)]

Далее нам нужно создать конкретный класс, реализующий интерфейс IContactManagerRepository. Так как мы используем Microsoft Entity Framework для доступа к базе данных, мы создадим новый класс с именем EntityContactManagerRepository. Этот класс содержится в листинге 2.

**В листинге 2 - Models\EntityContactManagerRepository.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample2.cs)]

Обратите внимание на то, что класс EntityContactManagerRepository реализует интерфейс IContactManagerRepository. Класс реализует все пять методов, описанных в этом интерфейсе.

Может возникнуть вопрос, зачем нам нужно возиться с интерфейсом. Зачем нам нужно создать интерфейс и класс, реализующий его?

За одним исключением остальная часть нашего приложения будет взаимодействовать с интерфейс и не конкретного класса. Вместо вызова методов, предоставляемых классом EntityContactManagerRepository, мы будем называть методов, предоставляемых интерфейсом IContactManagerRepository.

Таким образом, мы можем реализовать интерфейс с помощью нового класса без изменения в оставшейся части нашего приложения. Например в будущем, мы может потребоваться реализация DataServicesContactManagerRepository класса, реализующий интерфейс IContactManagerRepository. Класс DataServicesContactManagerRepository может использовать службы ADO.NET Data Services для доступа к базе данных вместо Microsoft Entity Framework.

Если в коде приложения запрограммированы IContactManagerRepository интерфейс вместо конкретного класса EntityContactManagerRepository мы можем переключиться конкретные классы без изменения любого из остальная часть нашего кода. Например мы можем переключиться из класса EntityContactManagerRepository класс DataServicesContactManagerRepository не изменяя логику доступа или проверки данных.

Программирование для интерфейсов (абстракций), а не конкретные классы делает наше приложение более устойчивым к изменить.

> [!NOTE] 
> 
> Можно быстро создать интерфейс из конкретного класса в Visual Studio, выбрав параметр меню рефакторинга, извлечение интерфейса. Например можно сначала создать класс EntityContactManagerRepository и затем использовать извлечение интерфейса для автоматического создания интерфейса IContactManagerRepository.


## <a name="using-the-dependency-injection-software-design-pattern"></a>Используя шаблон проектирования программного обеспечения для внедрения зависимостей

Теперь, когда мы перенесены наш код доступа к данным на отдельный класс репозитория, нам нужно изменить контакт контроллер для использования этого класса. Мы будет использовать программное обеспечение шаблон, который называется внедрения зависимостей, чтобы использовать класс репозитория в своем контроллере.

В листинге 3 содержится измененный контроллера контактов.

**Листинг 3 - Controllers\ContactController.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample3.cs)]

Обратите внимание на то, что контроллер контактов в листинге 3 имеет два конструктора. Первый конструктор передается конкретный экземпляр интерфейса IContactManagerRepository второй конструктор. Использует класс контроллера контакт *внедрение зависимостей конструктора*.

Один и только на месте, что используется класс EntityContactManagerRepository находится в первый конструктор. Оставшаяся часть класса использует IContactManagerRepository интерфейс вместо конкретного класса EntityContactManagerRepository.

Это позволяет легко переключиться в реализации класса IContactManagerRepository в будущем. Если вы хотите использовать класс DataServicesContactRepository вместо класса EntityContactManagerRepository, просто измените первый конструктор.

Внедрение зависимостей конструктора также делает очень пригодного для тестирования на класс Contact контроллера. В модульных тестах можно создать экземпляр контроллера контактов, передав макетную реализацию класса IContactManagerRepository. Эта функция внедрения зависимостей будет очень важны для нас, в следующей итерации, при конструировании модульных тестов для приложения диспетчера контактов.

> [!NOTE] 
> 
> Если вы хотите полностью отвязать класс контроллера контактов из конкретной реализации интерфейса IContactManagerRepository вы можете воспользоваться преимуществами платформа, которая поддерживает внедрение зависимостей, например StructureMap или Microsoft Платформа Entity Framework (MEF). Используя преимущества платформы внедрения зависимостей, не требуется ссылаться на конкретный класс в коде.


## <a name="creating-a-service-layer"></a>Создание уровня службы

Вы могли заметить, что наша логика проверки будет по-прежнему путать логику контроллера в классе контроллера, измененный в листинге 3. По этой же причине, что рекомендуется изолировать наших логики доступа к данным рекомендуется изолировать наша логика проверки.

Чтобы устранить эту проблему, мы можем создать отдельный [ *слой служб*](http://martinfowler.com/eaaCatalog/serviceLayer.html). Уровень служб — это отдельный слой, который мы можем вставить наш контроллером и классы репозитория. Слой служб содержит наш бизнес-логики, включая все наша логика проверки.

ContactManagerService содержится в листинге 4. Он содержит логику проверки из класса контроллера, обратитесь в службу.

**Листинг 4 - Models\ContactManagerService.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample4.cs)]

Обратите внимание на то, что конструктор для ContactManagerService требует ValidationDictionary. Слой служб взаимодействует с уровня контроллера через этот ValidationDictionary. При обсуждении шаблона Decorator, мы обсудим ValidationDictionary подробно в следующем разделе.

Кроме того, обратите внимание, что ContactManagerService реализует интерфейс IContactManagerService. Вы всегда должны стремиться программировать интерфейсами, а не конкретные классы. Другие классы в приложении диспетчера контактов не взаимодействовать с классом ContactManagerService напрямую. Вместо этого за одним исключением, остальная часть приложения диспетчера контактов запрограммированы в интерфейсе IContactManagerService.

Интерфейс IContactManagerService содержится в листинге 5.

**В листинге 5 - Models\IContactManagerService.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample5.cs)]

В листинге 6 содержится измененный класс контроллера контактов. Обратите внимание на то, что контроллеру контакт больше не взаимодействует с репозитория ContactManager. Вместо этого обратитесь в службу контроллера взаимодействует со службой ContactManager. Каждый слой изолированное максимально из других слоев.

**В листинге 6 - Controllers\ContactController.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample6.cs)]

Наше приложение больше не выполняется за один принцип ответственности (SRP). Контроллер контактов в листинге 6 были вырезаны каждые ответственности, отличные от управления потоком выполнения приложения. Вся логика проверки был удален из контроллера контактов и помещено в слой служб. Вся логика базы данных был отправлен в репозиторий слой.

## <a name="using-the-decorator-pattern"></a>С помощью шаблона-декоратора

Мы хотим иметь возможность полностью отвязать наш слой служб от наш слой контроллера. В принципе мы должны иметь возможность компиляции наш слой служб в отдельную сборку из наших уровня контроллера не нужно добавить ссылку на наше приложение MVC.

Тем не менее наш слой служб необходимо иметь возможность передавать проверки сообщения об ошибках на уровне контроллера. Как мы можем дать уровень служб для передачи сообщений об ошибках проверки без взаимозависимость контроллера и уровень служб? Мы можем воспользоваться шаблоном проектирования программного обеспечения с именем [шаблона Decorator](http://en.wikipedia.org/wiki/Decorator_pattern).

Контроллер использует ModelStateDictionary, с именем ModelState для представления ошибок проверки. Таким образом вы может возникнуть желание передачи ModelState из уровня контроллера уровня службы. Тем не менее с помощью ModelState в слое служб будет зависеть от уровень службы в состав платформы ASP.NET MVC. Это будет неправильный, так как когда-нибудь, может потребоваться использовать уровень служб с помощью приложения WPF, а не приложение ASP.NET MVC. В этом случае t было нужно сослаться платформа ASP.NET MVC с помощью класса ModelStateDictionary.

Шаблон декоратора позволяет переносить существующий класс в новый класс для реализации интерфейса. Наш проект Contact Manager включает в себя ModelStateWrapper класса, содержащегося в листинге 7. Класс ModelStateWrapper реализует интерфейс в листинг 8.

**Листинг 7 - Models\Validation\ModelStateWrapper.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample7.cs)]

**Листинг 8 - Models\Validation\IValidationDictionary.cs**

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample8.cs)]

Если вы Обратите внимание на листинге 5 появится исключительно использует интерфейс IValidationDictionary слой служб ContactManager. Служба ContactManager не зависящее от класса ModelStateDictionary. Когда контроллер контактов создает службу ContactManager, контроллер создает оболочку для его ModelState следующим образом:

[!code-csharp[Main](iteration-4-make-the-application-loosely-coupled-cs/samples/sample9.cs)]

## <a name="summary"></a>Сводка

В этой итерации мы не добавили никаких новых функциональных возможностей в приложение диспетчера контактов. Цель этой итерации — рефакторинг, чтобы он проще в обслуживании и изменять приложения диспетчера контактов.

Во-первых мы реализовали конструктивного шаблона репозитория программного обеспечения. Мы перешли все код доступа к данным на отдельный класс репозитория ContactManager.

Мы также изолированные наша логика проверки от логику контроллера. Мы создали отдельную службу слой, содержащий все наш код проверки. На уровне контроллера взаимодействует с уровня службы и уровень служб взаимодействует с уровня репозитория.

Когда мы создавали слой служб, мы воспользовались преимуществами шаблона Decorator для изоляции ModelState от наших уровня службы. В наш слой служб мы запрограммированы для интерфейса IValidationDictionary вместо ModelState.

Наконец мы воспользовались преимуществами шаблоном проектирования программного обеспечения, с именем шаблон внедрения зависимостей. Этот шаблон позволяет программировать с использованием интерфейсов (абстракций), а не конкретные классы. Реализации шаблона разработки внедрения зависимостей также делает код более тестируем. В следующей итерации мы добавляем в наш проект модульных тестов.

> [!div class="step-by-step"]
> [Назад](iteration-3-add-form-validation-cs.md)
> [Вперед](iteration-5-create-unit-tests-cs.md)
