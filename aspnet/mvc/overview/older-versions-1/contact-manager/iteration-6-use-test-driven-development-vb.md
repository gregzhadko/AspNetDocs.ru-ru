---
uid: mvc/overview/older-versions-1/contact-manager/iteration-6-use-test-driven-development-vb
title: 'Итерация #6 – использование разработки, управляемой тестами (Visual Basic) | Документация Майкрософт'
author: microsoft
description: В этой шестой итерации мы добавляем новые функциональные возможности в наше приложение, сначала написание модульных тестов и написании кода в отношении модульные тесты. В этой итерации...
ms.author: riande
ms.date: 02/20/2009
ms.assetid: e1fd226f-3f8e-4575-a179-5c75b240333d
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-6-use-test-driven-development-vb
msc.type: authoredcontent
ms.openlocfilehash: 3fd252b94e55f02215a2733f218e68b26486691f
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59397114"
---
# <a name="iteration-6--use-test-driven-development-vb"></a>Итерация #6 – использование разработки, управляемой тестами (VB)

по [Microsoft](https://github.com/microsoft)

[Скачать код](iteration-6-use-test-driven-development-vb/_static/contactmanager_6_vb1.zip)

> В этой шестой итерации мы добавляем новые функциональные возможности в наше приложение, сначала написание модульных тестов и написании кода в отношении модульные тесты. В этой итерации мы добавляем групп контактов.


## <a name="building-a-contact-management-aspnet-mvc-application-vb"></a>Создание приложения управления контактами ASP.NET MVC (VB)
  

В этой серии руководств мы создаем всего приложения управления контактами от начала до конца. Приложение диспетчера контактов позволяет хранить контактные данные - имена, номера телефонов и адреса электронной почты — список людей.

Мы создаем приложение через несколько итераций. С каждой итерацией мы постепенно улучшить приложение. Этот подход с несколькими итерации предназначена для того, чтобы можно было понять причину для каждого изменения.

- Итерация #1 - Создание приложения. В первой итерации мы создадим Contact Manager простейшим способом невозможно. Мы добавили поддержку для основных операций базы данных: Создание, чтение, обновление и удаление (CRUD).

- #2 - итерация приложения красиво выглядеть. В этой итерации мы улучшить внешний вид приложения, изменив значение по умолчанию master страница представления ASP.NET MVC и каскадные таблицы стилей.

- Итерации #3 - Добавление проверки форм. В третьей итерации мы добавим проверки базовой форме. Мы запретить Отправка формы без завершения обязательные поля. Кроме того, мы проверяем, адреса электронной почты и номера телефонов.

- Итерация #4 - Создание слабых связей в приложении. В этой четвертой итерации мы воспользоваться преимуществами нескольких шаблонов дизайна программного обеспечения, чтобы упростить обслуживании и изменении приложения диспетчера контактов. Например мы выполнили рефакторинг наше приложение, чтобы использовать шаблон репозитория и шаблон внедрения зависимостей.

- Итерации #5 - Создание модульных тестов. В пятой итерации мы вам наше приложение проще обслуживании и изменении путем добавления модульных тестов. Мы макетирование наших классов модели данных и создания модульных тестов для контроллеров и логику проверки.

- Итерация #6 - использование управляемой тестами разработки. В этой шестой итерации мы добавляем новые функциональные возможности в наше приложение, сначала написание модульных тестов и написании кода в отношении модульные тесты. В этой итерации мы добавляем групп контактов.

- Итерации #7 - Добавление функций Ajax. В седьмой итерации мы повысить скорость реагирования и производительность приложения, добавляя поддержку Ajax.

## <a name="this-iteration"></a>Эта итерация

В предыдущей итерации приложения диспетчера контактов мы создали модульные тесты, чтобы предоставить подстраховку для нашего кода. Мы хотели сделать код более устойчивым к изменить мотивация для создания модульных тестов. С помощью модульных тестов на месте мы к счастью, внести изменения, чтобы наш код и немедленно узнаете ли мы нарушили существующие функциональные возможности.

В этой итерации мы используем модульных тестов для абсолютно другой цели. В этой итерации, мы используем модульные тесты как часть принципы разработки приложений, которые вызывается *управляемой тестами разработки*. Когда вы на практике разработки, управляемой тестами, сначала писать тесты, а затем написать код для тестов.

Точнее, улицей с двусторонним управляемой тестами разработки, существует три действия, выполненные при создании кода (красный или зеленый/рефакторинга):

1. Написать модульный тест, происходит сбой (красный)
2. Написать код, передающий модульного теста (зеленый)
3. Рефакторинг кода (рефакторинг)

Во-первых можно написать модульный тест. Модульный тест следует express ведут себя намерения для как предполагается, что ваш код. При создании модульного теста, возникнет ошибка модульного теста. Тест не выполняется, поскольку код приложения, проходить этот тест еще не записаны.

Далее вы пишется только код, чтобы модульный тест для передачи. Целью является написание кода laziest, sloppiest и быстрее всего можно так. Вы должны будете тратить времени на размышления об архитектуре приложения. Вместо этого следует сосредоточиться на написании минимальный объем кода, необходимого для удовлетворения намерение выраженному модульного теста.

Наконец после написания кода недостаточно, можно шаг назад и рассмотрим общую архитектуру приложения. На этом шаге вы переписать (рефакторинг) код, используя преимущества разработки программного обеспечения шаблоны — например шаблон репозитория--таким образом, чтобы ваш код более понятным. Комплекту можно переписать код на этом шаге поскольку ваш код будет охвачен модульными тестами.

Существует множество преимуществ, возникающие в результате практики управляемой тестами разработки. Во-первых, управляемой тестами разработки приходится сосредоточиться на коде, который фактически должна быть записана. Так как постоянно находятся в фокусе просто написание кода, недостаточно для передачи конкретного теста, не смогут никогда в weeds и запись большого объема кода, который никогда не будет использоваться.

Во-вторых методика проектирования «сначала тест» приходится писать код с точки зрения использования кода. Другими словами улицей с двусторонним разработка с тестированием, вы постоянно тесты пишутся с точки зрения пользователя. Таким образом управляемой тестами разработки может привести чище и понятнее API-интерфейсы.

Наконец управляемой тестами разработки приходится написание модульных тестов в рамках обычного процесса написания приложения. По мере приближения срока выполнения проекта тестирования обычно является первым, что идет окна. Улицей с двусторонним управляемой тестами разработки, с другой стороны, вы скорее всего будет тем самым эффективный о написании модульных тестов, так как в управляемой тестами разработки упрощает модульных тестов центра в процесс построения приложения.

> [!NOTE] 
> 
> Дополнительные сведения о разработке с постоянным тестированием, советую прочитать книгу Майкла Физерса **эффективная работа со старым кодом**.


В этой итерации мы добавим новый компонент в наше приложение диспетчера контактов. Мы добавили поддержку для группы контактов. Можно использовать, обратитесь к групп Организация контактов на категории, например, Business и дружественной.

Мы добавим эти новые функции к нашему приложению процесса разработки с постоянным тестированием. Наши модульных тестов мы напишем первые и напишем весь наш код для этих тестов.

## <a name="what-gets-tested"></a>Что возвращает протестированы

Как уже говорилось в предыдущих итерациях, обычно не написание модульных тестов для логики доступа к данным или просмотра логики. Так как доступ к базе данных выполняется относительно медленно нигде не t создавать модульные тесты для логики доступа к данным. Так как доступ к представлению требуется развертывать веб-сервер, который выполняется относительно медленно нигде не t создавать модульные тесты для логики представления. Если тест запускается снова и снова очень быстро писать модульный тест

Так как разработка с тестированием определяется модульные тесты, мы изначально сосредоточиться на написании контроллера и бизнес-логики. Мы не касается базы данных или представления. Мы не будем изменять базу данных или создать наши представления до окончания работы с этим руководством. Для начала можно протестировать новые.

## <a name="creating-user-stories"></a>Создание пользовательских описаний функциональности

Улицей с двусторонним управляемой тестами разработки, всегда начинается с создания теста. Здесь сразу возникает вопрос: Как же решить, какой тест, чтобы писать сначала? Чтобы ответить на этот вопрос, следует написать набор [ *пользовательские истории*](http://en.wikipedia.org/wiki/User_stories).

Пользовательская История — очень краткое описание требования к программному обеспечению (обычно одно предложение). Она должна быть нетехнических описание является обязательным, написанные с точки зрения пользователя.

Здесь s набор описаний функциональности пользователей, которые описывают возможности, необходимые для новых функциональных возможностей обратитесь к группе:

1. Пользователь может просматривать список групп контактов.
2. Пользователь может создать новую группу контактов.
3. Пользователь может удалить существующую группу контактов.
4. Пользователь может выбрать группу контактов, при создании нового контакта.
5. Пользователь может выбрать группу контактов, при редактировании существующего контакта.
6. Список групп контактов отображается в представлении индекса.
7. Когда пользователь щелкает группе контактов, отображается список совпадающих контактов.

Обратите внимание, что этот список описаний функциональности пользователей вполне понятно клиентом. Нет сведений о технической реализации не упоминается.

Находясь в процессе построения приложения, набора пользовательских историй может стать более точные параметры. Пользовательская История может разбить на несколько материалов (требования). Например вы решите, что создание контактов группы необходимо привлечь проверки. Отправка группе контактов без имени должен вернуть ошибку проверки.

После создания списка пользовательских историй, вы готовы написать первый модульный тест. Мы начнем с создания модульного теста для просмотра списка контактов групп.

## <a name="listing-contact-groups"></a>Список групп контактов

Наш первый пользовательская История стала, пользователь должен быть возможность просмотреть список групп контактов. Нам нужно express этой истории с тестом.

Создание нового модульного теста щелкните правой кнопкой мыши папку Controllers в проекте ContactManager.Tests, выбрав **Add, новый тест**и выбрав **модульного теста** шаблона (см. рис. 1). Имя нового модульного тестирования GroupControllerTest.vb и нажмите кнопку **ОК** кнопки.


[![Добавление GroupControllerTest модульного теста](iteration-6-use-test-driven-development-vb/_static/image1.jpg)](iteration-6-use-test-driven-development-vb/_static/image1.png)

**Рис 01**: Добавление GroupControllerTest модульного теста ([Просмотр полноразмерного изображения](iteration-6-use-test-driven-development-vb/_static/image2.png))


Наш первый модульный тест, содержащийся в листинге 1. Этот тест проверяет, что метод Index() контроллера группы возвращает набор групп. Тест проверяет, что коллекция групп возвращается в представлении данных.

**Listing 1 - Controllers\GroupControllerTest.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample1.vb)]

При первом вводе кода в листинге 1 в Visual Studio, вы получите массу красной волнистой линией. Мы не создали GroupController или группу классов.

На этом этапе мы можем даже построения t нашего приложения, поэтому мы можем t выполнение наш первый модульный тест. Хороший s. Что считается непройденного теста. Таким образом теперь у нас есть разрешение на запуск в написании кода приложения. Нам нужно написать код, чтобы выполнить наш тест.

Класс контроллера группа в листинге 2 содержит минимальный код, необходимый для передачи модульного теста. Действие Index() возвращает статически закодированный список групп (группы класс определен в листинге 3).

**В листинге 2 - Controllers\GroupController.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample2.vb)]

**Листинг 3 - Models\Group.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample3.vb)]

Когда мы добавляем классы GroupController и группы в свой проект, наш первый модульный тест успешно завершает (см. рис. 2). Мы проделали минимального объема работы, необходимые для успешного прохождения теста. Пришло время отпраздновать.


[![Успех!](iteration-6-use-test-driven-development-vb/_static/image2.jpg)](iteration-6-use-test-driven-development-vb/_static/image3.png)

**Рис. 02**: Успех! ([Просмотр полноразмерного изображения](iteration-6-use-test-driven-development-vb/_static/image4.png))


## <a name="creating-contact-groups"></a>Создание групп контактов

Теперь можно перейти к второй пользовательской истории. Необходимо иметь возможность создавать новые группы контактов. Нам нужно express задавать ее с тестом.

В листинге 4 проверить, что вызов Create(), метод с новой группой добавляет группу в список групп, возвращаемый методом Index(). Другими словами Если создать новую группу затем я должен иметь возможность получить новую группу из списка групп, возвращаемый методом Index().

**Listing 4 - Controllers\GroupControllerTest.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample4.vb)]

Тест в листинге 4 вызывает у контроллера группы Create() метод с помощью нового контакта группы. После этого тест проверяет, что вызов контроллера группы Index() метод возвращает новую группу в представлении данных.

Измененный контроллер группа в листинге 5 содержит минимальные изменения, необходимые для передачи нового теста.

**В листинге 5 - Controllers\GroupController.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample5.vb)]

## <a name="the-group-controller-in-listing-5-has-a-new-create-action-this-action-adds-a-group-to-a-collection-of-groups-notice-that-the-index-action-has-been-modified-to-return-the-contents-of-the-collection-of-groups"></a>На контроллере группа в листинге 5 доступно новое действие Create(). Это действие добавляет группу коллекцию групп. Обратите внимание на то, что действие Index() был изменен для возврата содержимого коллекции групп.

Опять же мы провели минимально необходимую трудозатрат, необходимых для передачи модульного теста. После этих изменений к контроллеру группы, все наши модульные тесты пройдены.

## <a name="adding-validation"></a>Добавление проверки

Это требование не был указан явно в описание функциональности пользователя. Тем не менее разумно требуют наличия имя группы. В противном случае объединения контактов в группы не будет очень полезно.

В листинге 6 содержит новый тест, который выражает задавать ее. Этот тест проверяет, что попытка создать группу без указания результатов имя в сообщение об ошибке проверки в состояние модели.

**Listing 6 - Controllers\GroupControllerTest.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample6.vb)]

Для удовлетворения требований этого теста, необходимо добавить свойство Name к нашему классу группы (см. Листинг 7). Кроме того необходимо добавить это крохотная логику проверки для нашей группы контроллера s Create() действие (см. Листинг 8).

**Листинг 7 - Models\Group.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample7.vb)]

**Листинг 8 - Controllers\GroupController.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample8.vb)]

Обратите внимание на то, что контроллер группы Create() действия теперь содержит логику проверки и базы данных. В настоящее время базы данных, используемое контроллером группы состоит из не более чем коллекции в памяти.

## <a name="time-to-refactor"></a>Время для оптимизации кода

Третий шаг в красный или зеленый/рефакторинг — часть рефакторинга. На этом этапе необходимо отойти от нашего кода и рассмотрим, как мы можем выполнить рефакторинг наше приложение, чтобы улучшить его разработки. В рабочей области Refactor является рабочей области, по которому мы тщательно продумываю лучший способ реализации принципов проектирования программного обеспечения и шаблоны.

Мы можете изменить наш код способом, который мы решили повысить разработки кода. У нас есть средство подстраховки модульных тестов, которые препятствуют нарушить имеющуюся функциональность.

Прямо сейчас, нашего контроллера группы — это все не так с точки зрения Хорошая архитектура программного обеспечения. Контроллер группа содержит запутанную путаницы проверки и код доступа к данным. Чтобы избежать нарушения принципа персональной ответственности, нам нужно разделить эти проблемы на различные классы.

Наш рефакторингу класс контроллера группы содержится в Листинг 9. Контроллер был изменен для использования на уровне службы ContactManager. Это же слоя служб, который мы используем с контроллером контакта.

Листинг 10 содержит новые методы, добавленные ContactManager уровня службы для поддержки проверки, перечисление и создании групп. Интерфейс IContactManagerService обновляется, чтобы добавить новые методы.

Листинг 11 содержит новый FakeContactManagerRepository класс, реализующий интерфейс IContactManagerRepository. В отличие от класса EntityContactManagerRepository, который также реализует интерфейс IContactManagerRepository наш класс FakeContactManagerRepository не взаимодействуют с базой данных. Класс FakeContactManagerRepository использует коллекцию в памяти как прокси для базы данных. Мы будем использовать этот класс в нашем модульные тесты, как слой имитацией хранилища.

**Листинг 9 - Controllers\GroupController.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample9.vb)]

**Листинг 10 - Controllers\ContactManagerService.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample10.vb)]

**Листинг 11 - Controllers\FakeContactManagerRepository.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample11.vb)]


Изменение IContactManagerRepository, интерфейс требует использовать для реализации CreateGroup() и ListGroups() методов в классе EntityContactManagerRepository. Laziest и быстрый способ сделать это — добавить методы-заглушки, которые выглядят следующим образом:

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample12.vb)]


И, наконец эти изменения в структуре приложения потребуется внести некоторые изменения в нашей модульные тесты. Теперь нам нужно использовать FakeContactManagerRepository, при выполнении модульных тестов. Обновленный класс GroupControllerTest содержится в листинг 12.

**Listing 12 - Controllers\GroupControllerTest.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample13.vb)]

После мы убедитесь, что все эти изменения, опять же, все наши модульные тесты пройдены. Мы завершили весь цикл красный, зеленый/рефакторинга. Мы реализовали первый две пользовательские истории. Теперь у нас есть поддержка модульных тестов для требований, представленных в пользовательских историй. Реализация остальная часть описания функциональности пользователей включает в себя повторяющиеся одинаковый цикл, красный, зеленый/рефакторинга.

## <a name="modifying-our-database"></a>Изменение базы данных

К сожалению несмотря на то, что мы удовлетворили всем требованиям, выраженный с нашей модульных тестов, наши задачи не выполняются. По-прежнему нужно изменить нашу базу данных.

Нам нужно создать новую таблицу базы данных группы. Выполните следующие действия.

1. В окне обозревателя решений щелкните правой кнопкой мыши папку «таблицы» и выберите пункт меню **добавить новую таблицу**.
2. Введите два столбцы, описанные ниже в конструкторе таблиц.
3. Пометьте столбец идентификатора как первичный ключ и столбец Identity.
4. Сохраните новую таблицу с именем группы, щелкнув значок дискеты.

<a id="0.12_table01"></a>


| **Имя столбца** | **Тип данных** | **Разрешить значения NULL** |
| --- | --- | --- |
| Идентификатор | int | False |
| name | nvarchar(50) | False |


Далее нам нужно удалить все данные из таблицы Contacts (в противном случае мы не сможем создать связь между таблицами контакты и группы). Выполните следующие действия.

1. Щелкните правой кнопкой мыши таблицу контактов и выберите пункт меню **Показать таблицу данных**.
2. Удалите все строки.

Далее нам нужно определить связь между таблицей базы данных группы и существующую таблицу базы данных контактов. Выполните следующие действия.

1. Дважды щелкните таблицу контактов в окне обозревателя серверов, чтобы открыть конструктор таблиц.
2. Добавьте новый столбец целое число в таблицу контактов с именем GroupId.
3. Щелкните кнопку Relationship, чтобы открыть диалоговое окно связи по внешнему ключу (см. рис. 3).
4. Нажмите кнопку Добавить.
5. Нажмите кнопку с многоточием, отображаемый рядом с кнопкой таблицы и столбцы спецификации.
6. В диалоговом окне таблиц и столбцов выберите группы как таблицу первичного ключа и идентификатор в качестве столбца первичного ключа. Выберите контакты в качестве таблицы внешнего ключа и GroupId как столбец внешнего ключа (см. рис. 4). Нажмите кнопку "ОК".
7. В разделе **спецификация INSERT и UPDATE**, выберите значение **Cascade** для **удалить правило**.
8. Нажмите кнопку «Закрыть», чтобы закрыть диалоговое окно связи по внешнему ключу.
9. Нажмите кнопку "Сохранить", чтобы сохранить изменения в таблицу контактов.


[![Создание связи таблицы базы данных](iteration-6-use-test-driven-development-vb/_static/image3.jpg)](iteration-6-use-test-driven-development-vb/_static/image5.png)

**Рис 03**: Создание связи таблицы базы данных ([Просмотр полноразмерного изображения](iteration-6-use-test-driven-development-vb/_static/image6.png))


[![Указание связей между таблицами](iteration-6-use-test-driven-development-vb/_static/image4.jpg)](iteration-6-use-test-driven-development-vb/_static/image7.png)

**Рис. 04**: Указание связей между таблицами ([Просмотр полноразмерного изображения](iteration-6-use-test-driven-development-vb/_static/image8.png))


### <a name="updating-our-data-model"></a>Обновление модели данных

Далее нам нужно обновить модель данных, чтобы представлять новую таблицу базы данных. Выполните следующие действия.

1. Дважды щелкните файл ContactManagerModel.edmx в папке Models, чтобы открыть конструктор сущностей.
2. Щелкните правой кнопкой мыши в области конструктора и выберите пункт меню **обновить модель из базы данных**.
3. В мастере обновлений выберите группы таблицы и нажмите кнопку Готово кнопки мыши (см. рис. 5).
4. Щелкните правой кнопкой мыши сущность группы и выберите пункт меню **Переименовать**. Измените имя *группы* сущность *группы* (в единственном числе).
5. Щелкните правой кнопкой мыши свойство навигации группы, которое отображается в нижней части сущность "Контакт". Измените имя *группы* свойство навигации, чтобы *группы* (в единственном числе).


[![Обновление модели Entity Framework из базы данных](iteration-6-use-test-driven-development-vb/_static/image5.jpg)](iteration-6-use-test-driven-development-vb/_static/image9.png)

**05 рис**: Обновление модели из базы данных Entity Framework ([Просмотр полноразмерного изображения](iteration-6-use-test-driven-development-vb/_static/image10.png))


После выполнения этих действий, модель данных будет представлять таблицы контактов и групп. Конструктор сущностей должно отображаться обеих сущностей (см. рис. 6).


[![Конструктор сущностей, группа и контакт](iteration-6-use-test-driven-development-vb/_static/image6.jpg)](iteration-6-use-test-driven-development-vb/_static/image11.png)

**Рис 06**: Конструктор сущностей, группа и Contact ([Просмотр полноразмерного изображения](iteration-6-use-test-driven-development-vb/_static/image12.png))


### <a name="creating-our-repository-classes"></a>Создание классов наш репозиторий

Далее нам нужно реализовать наш класс репозитория. В ходе этой итерации мы добавили несколько новых методов в интерфейсе IContactManagerRepository при написании кода, чтобы удовлетворить наши модульных тестов. Окончательная версия интерфейса IContactManagerRepository содержится в листинге 14.

**Листинг 14 - Models\IContactManagerRepository.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample14.vb)]

Еще не реализован фактически любой из методов, относящиеся к работе с групп, контактов, в нашем реальных EntityContactManagerRepository классе. В настоящее время в классе EntityContactManagerRepository есть методы-заглушки для каждого из методов группе контактов, перечисленных в интерфейсе IContactManagerRepository. Например метод ListGroups() в данный момент выглядит следующим образом:

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample15.vb)]

Методы-заглушки позволила нам скомпилировать наше приложение и модульные тесты. Тем не менее теперь пришло время для фактической реализации этих методов. Окончательная версия класса EntityContactManagerRepository содержится в листинге 13.

**Листинг 13 - Models\EntityContactManagerRepository.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample16.vb)]

### <a name="creating-the-views"></a>Создание представлений

Приложения ASP.NET MVC, при использовании механизма представления ASP.NET по умолчанию. Таким образом Дон t создавать представления в ответ на одному из модульных тестов. Тем не менее, так как приложение будет бесполезен без представлений, мы можем t завершения этой итерации без создания и изменения представления, содержащиеся в приложении диспетчера контактов.

Нам необходимо создать следующие новые представления для управления группами связи (см. рис. 7):

- Views\Group\Index.aspx - отображает список групп контактов
- Views\Group\Delete.aspx - форма отображает подтверждение для удаления группы контактов


[![Представление Index группы](iteration-6-use-test-driven-development-vb/_static/image7.jpg)](iteration-6-use-test-driven-development-vb/_static/image13.png)

**07 рис**: Представление Index группы ([Просмотр полноразмерного изображения](iteration-6-use-test-driven-development-vb/_static/image14.png))


Нам нужно изменить следующие существующие представления, так, чтобы они включали групп контактов:

- Views\Home\Create.aspx
- Views\Home\Edit.aspx
- Views\Home\Index.aspx

Для проверки измененного представления приложения Visual Studio, сопровождающий этот учебник. Например на рис. 8 показана в представление Index контакт.


[![Представление Index контакта](iteration-6-use-test-driven-development-vb/_static/image8.jpg)](iteration-6-use-test-driven-development-vb/_static/image15.png)

**Рис 08**: Представление Index контакт ([Просмотр полноразмерного изображения](iteration-6-use-test-driven-development-vb/_static/image16.png))


## <a name="summary"></a>Сводка

В этой итерации мы добавили новые функциональные возможности в наше приложение диспетчера контактов, следуя методика проектирования испытания при разработке приложения. Мы начали с создания набора пользовательских историй. Мы создали набор модульных тестов, соответствующий требованиям, выраженному описаний функциональности пользователей. Наконец мы написали ровно столько кода, в соответствии с требованиями, выраженному модульные тесты.

После мы завершения, написание кода, недостаточно для удовлетворения требований, выраженному модульные тесты, мы обновили наши базы данных и представлений. Мы добавили новую таблицу групп к базе данных и обновление модели данных Entity Framework. Мы также создали и изменения из набора представлений.

В следующей итерации--последней итерации — мы перепишите наше приложение, чтобы воспользоваться преимуществами Ajax. Используя преимущества Ajax, здесь мы повысить скорость реагирования и производительность приложения диспетчера контактов.

> [!div class="step-by-step"]
> [Назад](iteration-5-create-unit-tests-vb.md)
> [Вперед](iteration-7-add-ajax-functionality-vb.md)
