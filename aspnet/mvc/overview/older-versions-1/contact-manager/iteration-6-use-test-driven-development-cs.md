---
uid: mvc/overview/older-versions-1/contact-manager/iteration-6-use-test-driven-development-cs
title: 'Итерация #6 - Используйте тестовую разработку (СЗ) Документы Майкрософт'
author: rick-anderson
description: В этой шестой итерации мы добавляем новую функциональность в наше приложение, написав модульные тесты сначала и написав код против модульных тестов. В этой итерации,...
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 013c3c26-7dc3-41d1-8064-f233c86008b5
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-6-use-test-driven-development-cs
msc.type: authoredcontent
ms.openlocfilehash: d0e8f30a075cc79c7410ffe1b8bf02da2bd44443
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542330"
---
# <a name="iteration-6--use-test-driven-development-c"></a>Итерация 6. Использование разработки, управляемой тестами (C#)

[корпорацией Майкрософт](https://github.com/microsoft)

[Скачать код](iteration-6-use-test-driven-development-cs/_static/contactmanager_6_cs1.zip)

> В этой шестой итерации мы добавляем новую функциональность в наше приложение, написав модульные тесты сначала и написав код против модульных тестов. В этой итерации мы добавляем контактные группы.

## <a name="building-a-contact-management-aspnet-mvc-application-c"></a>Создание приложения управления контактами ASP.NET MVC (C)

В этой серии учебников мы создаем все приложение Управления Контактами от начала до конца. Приложение Contact Manager позволяет хранить контактную информацию - имена, номера телефонов и адреса электронной почты - для списка людей.

Мы строим приложение по нескольким итерациям. С каждой итерацией мы постепенно совершенствуем приложение. Цель этого подхода с множественной итерацией состоит в том, чтобы вы могли понять причину каждого изменения.

- Итерация #1 - Создайте приложение. В первой итерации мы создаем Контакт-менеджер самым простым способом. Мы добавляем поддержку для основных операций базы данных: Создание, чтение, обновление и удаление (CRUD).

- Итерация #2 - Сделать приложение хорошо выглядеть. В этой итерации мы улучшаем внешний вид приложения, изменяя страницу по умолчанию ASP.NET MVC просмотра и каскадный стиль листа.

- Итерация #3 - Добавить проверку формы. В третьей итерации мы добавляем базовую проверку формы. Мы не позволяем людям подавать форму без заполнения требуемых полей формы. Мы также проверяем адреса электронной почты и номера телефонов.

- Итерация #4 - Сделать приложение слабо связаны. В этой четвертой итерации мы воспользуемся несколькими шаблонами проектирования программного обеспечения, чтобы упростить обслуживание и изменение приложения Contact Manager. Например, мы рефакторизуем наше приложение, чтобы использовать шаблон репозитория и шаблон инъекций зависимостей.

- Итерация #5 - Создание модульных тестов. В пятой итерации мы упрощаем обслуживание и модификацию нашего приложения путем добавления модульных тестов. Мы издеваемся над нашими классами моделей данных и строим модульные тесты для наших контроллеров и логики проверки.

- Итерация #6 - Использование тест-ориентированной разработки. В этой шестой итерации мы добавляем новую функциональность в наше приложение, написав модульные тесты сначала и написав код против модульных тестов. В этой итерации мы добавляем контактные группы.

- Итерация #7 - Добавить функциональность Ajax. В седьмой итерации мы улучшаем отзывчивость и производительность нашего приложения, добавляя поддержку Ajax.

## <a name="this-iteration"></a>Эта итерация

В предыдущей итерации приложения Contact Manager мы создали модульные тесты, чтобы обеспечить защиту нашего кода. Мотивация для создания модульных тестов заключалась в том, чтобы сделать наш код более устойчивым к изменениям. С модульными тестами на месте, мы можем с радостью внести какие-либо изменения в наш код и сразу же знать, нарушили ли мы существующую функциональность.

В этой итерации мы используем модульные тесты для совершенно другой цели. В этой итерации мы используем модульные тесты как часть философии проектирования приложений, *называемой разработкой, управляемой тестами.* Когда вы практикуете разработку, управляемую тестами, вы сначала пишете тесты, а затем пишете код против тестов.

Точнее, при практике разработки, управляемой тестами, есть три шага, которые вы выполняете при создании кода (Красный/Зеленый/Рефактор):

1. Написать модульный тест, который не удается (красный)
2. Напишите код, который проходит модульный тест (зеленый)
3. Рефактор код (Refactor)

Во-первых, вы пишете модульный тест. Модульный тест должен выразить ваше намерение, как вы ожидаете, что ваш код будет вести себя. При первом создании модульного теста модульный тест должен выполнить неудачу. Тест должен выполнить неудачу, поскольку вы еще не написали ни одного кода приложения, удовлетворяя тест.

Далее, вы пишете достаточно кода для того, чтобы модульный тест прошел. Цель состоит в том, чтобы написать код самым ленивым, небрежным и быстрым способом. Не следует тратить время на размышления об архитектуре приложения. Вместо этого следует сосредоточиться на написании минимального количества кода, необходимого для удовлетворения намерения, выраженного в модульном тесте.

Наконец, после того, как вы написали достаточно кода, вы можете сделать шаг назад и рассмотреть общую архитектуру приложения. На этом этапе вы переписываете (рефакторинг) свой код, пользуясь шаблонами проектирования программного обеспечения, такими как шаблон репозитория, чтобы ваш код был более обслуживаемым. Вы можете бесстрашно переписать свой код на этом этапе, потому что ваш код покрыт модульными тестами.

Есть много преимуществ, которые являются результатом практики тестовых разработки. Во-первых, разработка, ориентированная на тестирование, заставляет вас сосредоточиться на коде, который на самом деле должен быть написан. Поскольку вы постоянно сосредоточены на том, чтобы просто написать достаточно кода, чтобы пройти определенный тест, вам не дают забродить по сорнякам и писать огромное количество кода, который вы никогда не будете использовать.

Во-вторых, методология проектирования «первый тест» вынуждает вас писать код с точки зрения того, как будет использоваться ваш код. Другими словами, при практике разработки, управляемой тестами, вы постоянно пишете свои тесты с точки зрения пользователя. Таким образом, разработка, основанная на тестах, может привести к созданию более чистых и понятных AA.

Наконец, тестовая разработка заставляет вас писать модульные тесты как часть нормального процесса написания приложения. По мере приближения крайнего срока реализации проекта тестирование, как правило, является первым, что выходит из окна. С другой стороны, при практике разработки, управляемой тестами, вы, скорее всего, будете добродетельны в написании модульных тестов, поскольку разработка, управляемая тестами, делает модульные тесты центральными для процесса создания приложения.

> [!NOTE] 
> 
> Чтобы узнать больше о разработке, управляемой тестами, я рекомендую вам прочитать книгу Майкла Перья **Работая эффективно с Наследие мною .**

В этой итерации мы добавляем новую функцию в наше приложение Contact Manager. Мы добавляем поддержку Контактным группам. Вы можете использовать контактные группы для организации контактов по таким категориям, как группы бизнеса и друзей.

Мы добавим эту новую функциональность в наше приложение, следуя процессу разработки на основе тестирования. Сначала мы напишем модульные тесты и напишем весь наш код против этих тестов.

## <a name="what-gets-tested"></a>Что проходит тестирование

Как мы обсуждали в предыдущей итерации, обычно вы не пишете модульные тесты для логики доступа к данным или логики представления. Вы не пишете модульные тесты для логики доступа к данным, поскольку доступ к базе данных является относительно медленной операцией. Вы не пишете модульные тесты для логики представления, потому что доступ к представлению требует вращения веб-сервера, который является относительно медленной операцией. Вы не должны писать модульный тест, если тест не может быть выполнен снова и снова очень быстро

Поскольку разработка, основанная на тестировании, определяется модульными тестами, мы изначально фокусируемся на написании контроллера и бизнес-логики. Мы избегаем прикосновения к базе данных или представлениям. Мы не будем изменять базу данных или создавать наши представления до самого конца этого урока. Начнем с того, что может быть проверено.

## <a name="creating-user-stories"></a>Создание историй пользователей

При практике разработки, управляемой тестами, вы всегда начинаете с написания теста. Это сразу же поднимает вопрос: Как вы решаете, какой тест написать в первую очередь? Чтобы ответить на этот вопрос, вы должны написать набор [**пользовательских историй.**](http://en.wikipedia.org/wiki/User_stories)

История пользователя представляет собой очень краткое (обычно одно предложение) описание требования к программному обеспечению. Это должно быть нетехническое описание требования, написанного с точки зрения пользователя.

Вот набор пользовательских историй, описывающие функции, необходимые для новой функциональности Контактной группы:

1. Пользователь может просматривать список контактных групп.
2. Пользователь может создать новую контактную группу.
3. Пользователь может удалить существующую контактную группу.
4. Пользователь может выбрать контактную группу при создании нового контакта.
5. Пользователь может выбрать контактную группу при редактировании существующего контакта.
6. Список контактных групп отображается в представлении Индекса.
7. Когда пользователь нажимает на контактную группу, отображается список соответствующих контактов.

Обратите внимание, что этот список пользовательских историй полностью понятен клиенту. Подробности технической реализации не упоминаются.

В процессе создания приложения набор пользовательских историй может стать более изысканным. Вы можете разбить историю пользователя на несколько историй (требований). Например, можно решить, что создание новой контактной группы должно включать проверку. Отправка контактной группы без имени должна вернуть ошибку проверки.

После создания списка пользовательских историй вы будете готовы написать свой первый модульный тест. Начнем с создания модульного теста для просмотра списка контактных групп.

## <a name="listing-contact-groups"></a>Перечисление контактных групп

Наша первая история пользователя заключается в том, что пользователь должен иметь возможность просматривать список контактных групп. Мы должны выразить эту историю с тестом.

Создайте новый модульный тест, нажав на папку контроллеров в проекте ContactManager.Tests, выбрав **добавить, новый тест**и выбрав шаблон **Unit Test** (см. рисунок 1). Назовите новый модульный тест GroupControllerTest.cs и нажмите кнопку **OK.**

[![Добавление единого теста GroupControllerTest](iteration-6-use-test-driven-development-cs/_static/image1.jpg)](iteration-6-use-test-driven-development-cs/_static/image1.png)

**Рисунок 01**: Добавление модульного теста GroupControllerTest[(Нажмите, чтобы просмотреть полноразмерное изображение)](iteration-6-use-test-driven-development-cs/_static/image2.png)

Наш первый модульный тест содержится в листинге 1. Этот тест проверяет, что метод Индекса () контроллера группы возвращает набор групп. Тест проверяет, что коллекция групп возвращается в данные зрения.

**Список 1 - Контролеры**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample1.cs)]

При первом вводе кода в листинге 1 в Visual Studio, вы получите много красных линий squiggly. Мы не создавали классы GroupController или Group.

На данный момент, мы не можем даже построить наше приложение, чтобы мы не могли выполнить наш первый модульный тест. Это хорошо. Это считается неудачным испытанием. Поэтому теперь у нас есть разрешение начать писать код приложения. Нам нужно написать достаточно кода для выполнения нашего теста.

Класс контроллера группы в листинге 2 содержит минимум кода, необходимого для прохождения модульного теста. Действие Индекс () возвращает статический закодированный список групп (класс группы определяется в листинге 3).

**Список 2 - Контролеры группыКонтрол.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample2.cs)]

**Список 3 - Модели-Group.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample3.cs)]

После добавления в наш проект классов GroupController и Group, наш первый модульный тест успешно завершается (см. рисунок 2). Мы проделали минимальную работу, необходимую для прохождения теста. Настало время праздновать.

[![Успех!](iteration-6-use-test-driven-development-cs/_static/image2.jpg)](iteration-6-use-test-driven-development-cs/_static/image3.png)

**Рисунок 02**: Успех! ([Нажмите, чтобы просмотреть полноразмерное изображение](iteration-6-use-test-driven-development-cs/_static/image4.png))

## <a name="creating-contact-groups"></a>Создание контактных групп

Теперь мы можем перейти ко второй истории пользователя. Мы должны быть в состоянии создать новые контактные группы. Мы должны выразить это намерение с помощью теста.

Тест в листинге 4 проверяет, что вызов метода Create() с новой группой добавляет Группу в список групп, возвращенных методом Index() . Другими словами, если я создаю новую группу, то я смогу получить новую группу обратно из списка групп, возвращенных методом Индекса () .

**Список 4 - Контролеры**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample4.cs)]

Тест в листинге 4 вызывает метод создания контроллера группы с новой контактной группой. Далее тест проверяет, что вызов метода контроллера группы () возвращает новую группу в виде данных.

Модифицированный контроллер группы в листинге 5 содержит минимум изменений, необходимых для прохождения нового теста.

**Список 5 - Контролеры группыКонтрол.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample5.cs)]

## <a name="the-group-controller-in-listing-5-has-a-new-create-action-this-action-adds-a-group-to-a-collection-of-groups-notice-that-the-index-action-has-been-modified-to-return-the-contents-of-the-collection-of-groups"></a>Контроллер группы в листинге 5 имеет новое действие Create(). Это действие добавляет группу в коллекцию групп. Обратите внимание, что действие Index () было изменено, чтобы вернуть содержимое коллекции групп.

Еще раз, мы выполнили минимальный объем работы, необходимой для прохождения модульного теста. После внесения этих изменений в контроллер Группы все наши модульные тесты проходят.

## <a name="adding-validation"></a>Добавление проверки

Это требование не было четко указано в истории пользователя. Тем не менее, разумно требовать, чтобы Группа имеет имя. В противном случае организация контактов в группы была бы не очень полезной.

Список 6 содержит новый тест, который выражает это намерение. Этот тест проверяет, что попытка создания группы без предоставления имени приводит к сообщению об ошибке проверки в состоянии модели.

**Список 6 - Контролеры**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample6.cs)]

Для того, чтобы выполнить этот тест, нам необходимо добавить свойство Name в наш класс группы (см. листинг 7). Кроме того, нам нужно добавить немного логики проверки в наше действие контроллера группы Create() (см. список 8).

**Листинг 7 - Модели-Group.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample7.cs)]

**Список 8 - Контролеры группыКонтрол.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample8.cs)]

Обратите внимание, что действие контроллера группы Create() теперь содержит как валидацию, так и логику базы данных. В настоящее время база данных, используемая контроллером Группы, состоит не более чем из коллекции в памяти.

## <a name="time-to-refactor"></a>Время рефакторинга

Третьим шагом в Red/Green/Refactor является рефакторная часть. На этом этапе мы должны отойти от нашего кода и подумать о том, как мы можем рефакторинг нашего приложения, чтобы улучшить его дизайн. Этап Refactor – это этап, на котором мы тщательно думаем о наилучшем способе реализации принципов и шаблонов разработки программного обеспечения.

Мы можем изменить наш код любым способом, который мы выбираем для улучшения дизайна кода. У нас есть сеть безопасности модульных тестов, которые мешают нам нарушать существующую функциональность.

Прямо сейчас, наш контроллер группы беспорядок с точки зрения хорошего дизайна программного обеспечения. Контроллер группы содержит запутанный беспорядок проверки и кода доступа к данным. Чтобы не нарушать принцип единой ответственности, мы должны разделить эти проблемы на разные классы.

Наш рефакторинговый класс контроллера группы содержится в листинге 9. Контроллер был изменен, чтобы использовать уровень обслуживания ContactManager. Это тот же уровень обслуживания, который мы используем с контроллером Контакта.

Список 10 содержит новые методы, добавленные в уровень службы ContactManager для поддержки проверки, листинга и создания групп. Интерфейс IContactManagerService был обновлен, чтобы включить новые методы.

Список 11 содержит новый класс FakeContactManagerRepository, который реализует интерфейс IContactManagerRepository. В отличие от класса EntityContactManagerRepository, который также реализует интерфейс IContactManagerRepository, наш новый класс FakeContactManagerRepository не общается с базой данных. Класс FakeContactManagerRepository использует коллекцию в памяти в качестве прокси для базы данных. Мы будем использовать этот класс в наших модульных тестах в качестве поддельного слоя репозитория.

**Список 9 - Контролеры группыКонтрол.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample9.cs)]

**Список 10 - Контролеры/ContactManagerService.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample10.cs)]

**Список 11 - Контроллеры-FakeContactManagerRepository.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample11.cs)]

Изменение интерфейса IContactManagerRepository требует использования для реализации методов CreateGroup() и ListGroups() в классе EntityContactManagerRepository. Самый ленивый и быстрый способ сделать это, чтобы добавить заглушки методы, которые выглядят следующим образом:   

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample12.cs)]

Наконец, эти изменения в дизайне нашего приложения требуют от нас внесения некоторых изменений в наши модульные тесты. Теперь нам нужно использовать FakeContactManagerRepository при выполнении модульных тестов. Обновленный класс GroupControllerTest содержится в списке 12.

**Список 12 - Контролеры**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample13.cs)]

После того, как мы сделаем все эти изменения, еще раз, все наши модульные тесты проходят. Мы завершили весь цикл Red/Green/Refactor. Мы реализовали первые две истории пользователей. Теперь у нас есть вспомогательные модульные тесты для требований, выраженных в пользовательских историях. Реализация оставшейся части пользовательских историй включает повторение одного и того же цикла Red/Green/Refactor.

## <a name="modifying-our-database"></a>Изменение нашей базы данных

К сожалению, несмотря на то, что мы выполнили все требования, выраженные нашими модульными испытаниями, наша работа не завершена. Нам все еще нужно изменить нашу базу данных.

Нам необходимо создать новую таблицу баз данных Группы. Выполните следующие действия.

1. В окне Server Explorer щелкните по папке Таблицы и выберите вариант меню **Добавить новую таблицу.**
2. Введите две колонки, описанные ниже в таблице Designer.
3. Отметьте столбец Id в качестве основного ключа и столбца identity.
4. Сохраните новую таблицу с именем Группы, нажав значок дискеты.

<a id="0.11_table01"></a>

| **Имя столбца** | **Тип данных** | **Разрешить значения NULL** |
| --- | --- | --- |
| Идентификатор | INT | False |
| name | nvarchar(50) | False |

Далее нам нужно удалить все данные из таблицы Контактов (в противном случае мы не сможем создать связь между таблицами Контактов и Групп). Выполните следующие действия.

1. Нажмите правой кнопкой мыши таблицы Контакты и выберите вариант меню **Показать таблицы данных**.
2. Удалите все строки.

Далее нам необходимо определить взаимосвязь между таблицей базы данных групп и существующей таблицей базы данных Контактов. Выполните следующие действия.

1. Дважды щелкните таблицу Контактов в окне Server Explorer, чтобы открыть конструктор таблицы.
2. Добавьте новую колонку integer в таблицу Контактов под названием GroupId.
3. Нажмите кнопку «Отношения», чтобы открыть диалог по ключевым отношениям с иностранными отношениями (см. рисунок 3).
4. Нажмите кнопку Добавить.
5. Нажмите кнопку ellipsis, которая отображается рядом с кнопкой спецификации таблицы и столбцов.
6. В диалоге таблиц и столбцов выберите группы в качестве основной ключевой таблицы и Id в качестве основного ключевого столбца. Выберите Контакты в качестве иностранной ключевой таблицы и GroupId в качестве иностранной ключевой колонки (см. рисунок 4). Нажмите кнопку "ОК".
7. В соответствии со **спецификацией INSERT и UPDATE**выберите значение **Каскад** для **Правила Удаления.**
8. Нажмите кнопку "Закрыть", чтобы закрыть диалог по отношениям с иностранными ключевыми отношениями.
9. Нажмите кнопку «Сохранить», чтобы сохранить изменения в таблице Контактов.

[![Создание отношения таблицы базы данных](iteration-6-use-test-driven-development-cs/_static/image3.jpg)](iteration-6-use-test-driven-development-cs/_static/image5.png)

**Рисунок 03**: Создание отношения таблицы базы данных ([Нажмите, чтобы просмотреть полноразмерное изображение](iteration-6-use-test-driven-development-cs/_static/image6.png))

[![Определение отношений таблицы](iteration-6-use-test-driven-development-cs/_static/image4.jpg)](iteration-6-use-test-driven-development-cs/_static/image7.png)

**Рисунок 04**: Указание отношений таблицы[(Нажмите, чтобы просмотреть полноразмерное изображение)](iteration-6-use-test-driven-development-cs/_static/image8.png)

### <a name="updating-our-data-model"></a>Обновление нашей модели данных

Далее нам необходимо обновить нашу модель данных, чтобы представить новую таблицу баз данных. Выполните следующие действия.

1. Дважды щелкните файл ContactManagerModel.edmx в папке Модели, чтобы открыть Entity Designer.
2. Нажмите правой щелкните поверхность конструктора и выберите вариант меню **Модель обновления из базы данных.**
3. В «Мастере обновления» выберите таблицу групп и нажмите кнопку «Завершение» (см. рисунок 5).
4. Нажмите правой кнопкой мыши сущность группы и выберите вариант меню **Переименовать**. Измените название сущности *групп* ы на *группу* (единственное).
5. Нажмите справа на навигационное свойство групп, которое отображается в нижней части объекта Контакт. Измените название навигационного свойства *групп* на *группу* (единственное).

[![Обновление модели рамочной базы из базы данных](iteration-6-use-test-driven-development-cs/_static/image5.jpg)](iteration-6-use-test-driven-development-cs/_static/image9.png)

**Рисунок 05**: Обновление модели рамочной сущности из базы данных[(Нажмите, чтобы просмотреть полноразмерное изображение)](iteration-6-use-test-driven-development-cs/_static/image10.png)

После завершения этих шагов модель данных будет представлять таблицы контактов и групп. Дизайнер сущности должен показать оба объекта (см. рисунок 6).

[![Сущность Дизайнер отображения группы и контакта](iteration-6-use-test-driven-development-cs/_static/image6.jpg)](iteration-6-use-test-driven-development-cs/_static/image11.png)

**Рисунок 06**: Сущность Дизайнер отображения группы и контакта[(Нажмите, чтобы посмотреть полноразмерное изображение](iteration-6-use-test-driven-development-cs/_static/image12.png))

### <a name="creating-our-repository-classes"></a>Создание наших классов репозитория

Далее нам необходимо реализовать наш класс репозитория. В течение этой итерации мы добавили несколько новых методов в интерфейс IContactManagerRepository при написании кода, чтобы удовлетворить наши модульные тесты. Окончательная версия интерфейса IContactManagerRepository содержится в листинге 14.

**Список 14 - Модели-IContactManagerRepository.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample14.cs)]

На самом деле мы не реализовали ни одного из методов, связанных с работой с контактными группами. В настоящее время класс EntityContactManagerRepository имеет методы заглушки для каждого из методов контактной группы, перечисленных в интерфейсе IContactManagerRepository. Например, метод ListGroups() в настоящее время выглядит следующим образом:

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample15.cs)]

Методы заглушки позволили нам компилировать наше приложение и пройти модульные тесты. Однако сейчас настало время реально реализовать эти методы. Окончательная версия класса EntityContactManagerRepository содержится в листинге 13.

**Листинг 13 - Модели-EntityContactManagerRepository.cs**

[!code-csharp[Main](iteration-6-use-test-driven-development-cs/samples/sample16.cs)]

### <a name="creating-the-views"></a>Создание представлений

ASP.NET приложение MVC при использовании движка представления ASP.NET по умолчанию. Таким образом, вы не создаете представления в ответ на определенный модульный тест. Однако, поскольку приложение было бы бесполезным без представлений, мы не можем завершить эту итерацию без создания и изменения представлений, содержащихся в приложении Contact Manager.

Нам необходимо создать следующие новые представления для управления контакт-группами (см. рисунок 7):

- Views'Group-Index.aspx - Отображает список контактных групп
- Views-Group-Delete.aspx - Отображает форму подтверждения для удаления контактной группы

[![Представление индекса группы](iteration-6-use-test-driven-development-cs/_static/image7.jpg)](iteration-6-use-test-driven-development-cs/_static/image13.png)

**Рисунок 07**: Представление индекса группы[(Нажмите, чтобы посмотреть полноразмерное изображение)](iteration-6-use-test-driven-development-cs/_static/image14.png)

Нам необходимо изменить следующие существующие представления, чтобы они включали контактные группы:

- Просмотры:Home'Create.aspx
- Просмотры-Home-Edit.aspx
- Просмотры»Home-Index.aspx

Вы можете увидеть измененные представления, посмотрев приложение Visual Studio, которое сопровождает этот учебник. Например, на рисунке 8 показано представление индекса контакта.

[![Представление индекса контакта](iteration-6-use-test-driven-development-cs/_static/image8.jpg)](iteration-6-use-test-driven-development-cs/_static/image15.png)

**Рисунок 08**: Представление контактного индекса[(Нажмите, чтобы посмотреть полноразмерное изображение)](iteration-6-use-test-driven-development-cs/_static/image16.png)

## <a name="summary"></a>Сводка

В этой итерации мы добавили новую функциональность в наше приложение Contact Manager, следуя методологии проектирования приложений, разработанной на основе тестов. Мы начали с создания набора пользовательских историй. Мы создали набор модульных тестов, соответствующих требованиям, выраженным историями пользователей. Наконец, мы написали достаточно кода, чтобы удовлетворить требования, выраженные модульными тестами.

После того, как мы закончили писать достаточно кода, чтобы удовлетворить требования, выраженные модульными тестами, мы обновили нашу базу данных и представления. Мы добавили новую таблицу групп в нашу базу данных и обновили нашу модель рамочных данных entity. Мы также создали и изменили набор представлений.

В следующей итерации - окончательной итерации - мы переписываем наше приложение, чтобы воспользоваться преимуществами Ajax. Воспользовавшись преимуществами Ajax, мы улучшим отзывчивость и производительность приложения Contact Manager.

> [!div class="step-by-step"]
> [Назад](iteration-5-create-unit-tests-cs.md)
> [Вперед](iteration-7-add-ajax-functionality-cs.md)
