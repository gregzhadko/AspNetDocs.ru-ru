---
uid: mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application
title: Учебник. Использование устойчивости подключений и перехвата команд с помощью EF в приложении ASP.NET MVC
author: tdykstra
description: В этом учебнике вы узнаете, как использовать устойчивость подключений и перехват команд. Они являются двумя важными функциями Entity Framework 6.
ms.author: riande
ms.date: 01/22/2019
ms.topic: tutorial
ms.assetid: c89d809f-6c65-4425-a3fa-c9f6e8ac89f2
msc.legacyurl: /mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application
msc.type: authoredcontent
ms.openlocfilehash: 276266f8ae9df38529d44742ebe6ac0dc8e79727
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78471402"
---
# <a name="tutorial-use-connection-resiliency-and-command-interception-with-entity-framework-in-an-aspnet-mvc-app"></a>Учебник. Использование устойчивости к подключению и перехват команд с помощью Entity Framework в приложении ASP.NET MVC

Пока приложение запущено локально в IIS Express на компьютере разработчика. Чтобы сделать приложение доступным для других пользователей через Интернет, необходимо развернуть его на веб-сайте поставщика услуг размещения и развернуть базу данных на сервере базы данных.

В этом учебнике вы узнаете, как использовать устойчивость подключений и перехват команд. Они являются двумя важными функциями Entity Framework 6, которые особенно полезны при развертывании в облачной среде: устойчивость подключения (автоматические повторы для временных ошибок) и перехват команд (перехват всех запросов SQL, отправленных в базу данных для записи или изменения журнала).

Это необязательное руководство по устойчивости к подключению и перехвату команд. Если пропустить этот учебник, в последующих руководствах потребуется внести несколько незначительных изменений.

Изучив это руководство, вы:

> [!div class="checklist"]
> * Включить устойчивость подключений
> * Включить перехват команд
> * Тестирование новой конфигурации

## <a name="prerequisites"></a>предварительные требования

* [Сортировка, фильтрация и разбиение на страницы](sorting-filtering-and-paging-with-the-entity-framework-in-an-asp-net-mvc-application.md)

## <a name="enable-connection-resiliency"></a>Включить устойчивость подключений

При развертывании приложения в Windows Azure вы развертываете базу данных в базе данных SQL Windows Azure, облачной службе базы данных. Ошибки временного подключения обычно чаще возникают при подключении к облачной службе базы данных, чем когда веб-сервер и сервер базы данных напрямую соединяются друг с другом в одном центре обработки данных. Даже если облачный веб-сервер и облачная служба базы данных размещаются в одном центре обработки данных, между ними есть больше сетевых подключений, которые могут иметь проблемы, такие как подсистемы балансировки нагрузки.

Кроме того, облачная служба обычно совместно используется другими пользователями. Это означает, что их скорость реагирования может быть затронута. А доступ к базе данных может регулироваться. Регулирование означает, что служба базы данных создает исключения при попытке доступа к ней чаще, чем разрешено в Соглашение об уровне обслуживания (SLA).

Многие или большинство проблем с подключением при доступе к облачной службе являются временными, то есть они разрешаются в течение короткого периода времени. Поэтому при попытке выполнить операцию базы данных и получить тип ошибки, которая обычно является временной, можно повторить операцию после короткого ожидания, и операция может быть выполнена успешно. Вы можете предоставить пользователям гораздо больше возможностей, если вы обрабатываете временные ошибки, автоматически повторяя попытку, делая большинство из них невидимыми для клиента. Функция устойчивости подключений в Entity Framework 6 автоматизирует процесс повторного выполнения запросов SQL.

Для конкретной службы базы данных необходимо соответствующим образом настроить функцию устойчивости подключений.

- Он должен определять, какие исключения, вероятно, будут временными. Необходимо повторить ошибки, вызванные временной потерей подключения к сети, а не ошибки, вызванные ошибками в программе, например.
- Время между повторными попытками неудачной операции должно дожидаться соответствующего времени. Можно подождать больше времени между попытками пакетной обработки, чем веб-страница в Интернете, где пользователь ожидает ответа.
- Необходимо повторить необходимое количество раз, прежде чем оно будет выдаваться. Может потребоваться повторить попытку в пакетном процессе, который будет находиться в интерактивном приложении.

Эти параметры можно настроить вручную для любой среды базы данных, поддерживаемой поставщиком Entity Framework, но значения по умолчанию, которые обычно подходят для интерактивного приложения, использующего базу данных SQL Windows Azure, уже настроены. Это параметры, которые вы будете реализовывать для приложения университета Contoso.

Все, что необходимо сделать для включения устойчивости подключения, — создать класс в сборке, производной от класса [DbConfiguration](https://msdn.microsoft.com/data/jj680699.aspx) , и в этом классе задать *стратегию выполнения*базы данных SQL, которая в EF является еще одним термином для *политики повтора*.

1. В папке DAL добавьте файл класса с именем *SchoolConfiguration.CS*.
2. Замените код шаблона следующим кодом:

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample1.cs)]

    Entity Framework автоматически выполняет код, найденный в классе, производном от `DbConfiguration`. Класс `DbConfiguration` можно использовать для задания конфигурации в коде, который в противном случае можно было бы сделать в файле *Web. config* . Дополнительные сведения см. в разделе [EntityFramework Code-based Configuration](https://msdn.microsoft.com/data/jj680699).
3. В *StudentController.CS*добавьте инструкцию `using` для `System.Data.Entity.Infrastructure`.

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample2.cs)]
4. Измените все блоки `catch`, которые блокируют `DataException` исключения, чтобы они перехватывать исключения `RetryLimitExceededException`. Пример:

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample3.cs?highlight=1)]

    Вы использовали `DataException`, чтобы попытаться выбрать ошибки, которые могут быть временными, чтобы дать понятное сообщение "повторить попытку". Но теперь, когда вы включили политику повтора, единственные ошибки, скорее всего, будут уже выполнены и завершились неудачно, а фактическое исключение будет заключено в исключение `RetryLimitExceededException`.

Дополнительные сведения см. в статье [Entity Frameworkная логика устойчивости и повторных попыток подключения](https://msdn.microsoft.com/data/dn456835).

## <a name="enable-command-interception"></a>Включить перехват команд

Теперь, когда вы включили политику повтора, как проверить, работает ли она должным образом? Не так просто принудительно выполнять временную ошибку, особенно если вы работаете локально, и вам было бы очень сложно интегрировать фактические временные ошибки в автоматизированный модульный тест. Чтобы протестировать функцию устойчивости подключений, необходим способ перехвата запросов, которые Entity Framework отправляется в SQL Server, и замены SQL Server ответа на тип исключения, который обычно является временным.

Можно также использовать перехват запросов, чтобы реализовать оптимальную методику для облачных приложений: [регистрировать задержку и успех или неудачу всех вызовов внешних служб](../../../../aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry.md#log) , таких как службы баз данных. EF6 предоставляет [специальный API для ведения журнала](https://msdn.microsoft.com/data/dn469464) , который упрощает ведение журнала, но в этом разделе учебника вы узнаете, как использовать [функцию перехвата](https://msdn.microsoft.com/data/dn469464) Entity Framework напрямую, как для ведения журнала, так и для моделирования временных ошибок.

### <a name="create-a-logging-interface-and-class"></a>Создание интерфейса и класса ведения журнала

[Для ведения журнала](../../../../aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry.md#log) рекомендуется использовать интерфейс, а не вызовы с жестким кодированием к классу System. Diagnostics. Trace или журналу. Это упрощает изменение механизма ведения журнала в дальнейшем, если вам когда-либо потребуется это сделать. Итак, в этом разделе вы создадите интерфейс ведения журнала и класс для его реализации./p >

1. Создайте папку в проекте и назовите ее *Logging*.
2. В папке *Logging* создайте файл класса с именем *ILogger.CS*и замените код шаблона следующим кодом:

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample4.cs)]

    Интерфейс предоставляет три уровня трассировки для указания относительной важности журналов, и один предназначен для предоставления сведений о задержке для вызовов внешних служб, таких как запросы к базе данных. Методы ведения журнала имеют перегрузки, которые позволяют передавать исключение. Это значит, что сведения об исключении, включая трассировку стека и внутренние исключения, надежно регистрируются классом, реализующим интерфейс, вместо того, чтобы полагаться на него в каждом вызове метода ведения журнала в рамках всего приложения.

    Методы Трацеапи позволяют контролировать задержку каждого вызова к внешней службе, такой как база данных SQL.
3. В папке *Logging* создайте файл класса с именем *Logger.CS*и замените код шаблона следующим кодом:

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample5.cs)]

    Для трассировки в реализации используется System. Diagnostics. Это встроенная функция .NET, которая позволяет легко создавать и использовать сведения трассировки. Существует много прослушивателей, которые можно использовать с трассировкой System. Diagnostics для записи журналов в файлы, например, или для записи их в хранилище BLOB-объектов в Azure. Ознакомьтесь с некоторыми вариантами и ссылками на другие ресурсы, чтобы получить дополнительные сведения об [устранении неполадок веб-сайтов Azure в Visual Studio](https://docs.microsoft.com/azure/app-service-web/web-sites-dotnet-troubleshoot-visual-studio). В этом учебнике будут рассмотрены только журналы в окне **вывода** Visual Studio.

    В рабочем приложении можно рассматривать пакеты трассировки, отличные от System. Diagnostics, а интерфейс ILogger позволяет относительно легко переключиться на другой механизм трассировки, если вы решили это сделать.

### <a name="create-interceptor-classes"></a>Создание классов перехватчиков

Далее предстоит создать классы, которые будут вызываться Entity Framework каждый раз, когда будет отправлен запрос в базу данных, один из которых имитирует временные ошибки и один для ведения журнала. Эти классы перехватчика должны быть производными от класса `DbCommandInterceptor`. В них написаны переопределения методов, которые автоматически вызываются при выполнении запроса. В этих методах можно проверить или зарегистрировать запрос, отправляемый в базу данных, а также изменить запрос перед его отправкой в базу данных или вернуть что-либо в Entity Framework, не передавая запрос в базу данных.

1. Чтобы создать класс перехватчика, который будет регистрировать каждый запрос SQL, отправленный в базу данных, создайте файл класса с именем *SchoolInterceptorLogging.CS* в папке *DAL* и замените код шаблона следующим кодом:

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample6.cs)]

    Для успешных запросов или команд этот код записывает журнал сведений со сведениями о задержке. Для исключений создается журнал ошибок.
2. Чтобы создать класс перехватчика, который будет создавать фиктивные временные ошибки при вводе в поле **поиска** "Throw", создайте файл класса с именем *SchoolInterceptorTransientErrors.CS* в папке *DAL* и замените код шаблона следующим кодом:

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample7.cs)]

    Этот код переопределяет только метод `ReaderExecuting`, который вызывается для запросов, которые могут возвращать несколько строк данных. Если вы хотите проверить устойчивость подключения для других типов запросов, можно также переопределить методы `NonQueryExecuting` и `ScalarExecuting`, как это делает перехватчик ведения журнала.

    При запуске страницы Student и вводе в качестве строки поиска "Throw" Этот код создает фиктивное исключение базы данных SQL для ошибки с номером 20, тип которого обычно является временным. Другие номера ошибок, в настоящее время распознаваемые как временные, — 64, 233, 10053, 10054, 10060, 10928, 10929, 40197, 40501 и 40613, но они могут быть изменены в новых версиях базы данных SQL.

    Код возвращает исключение, Entity Framework вместо выполнения запроса и передачи результатов запроса. Временное исключение возвращается четыре раза, а затем код возвращается к нормальной процедуре передачи запроса в базу данных.

    Так как все заносится в журнал, вы сможете увидеть, что Entity Framework пытается выполнить запрос четыре раза, прежде чем он будет завершен, и единственное различие в приложении заключается в том, что для отображения страницы с результатами запроса требуется больше времени.

    Количество повторных попыток, которое Entity Framework будет доступно для настройки; код указывает четыре раза, так как это значение по умолчанию для политики выполнения базы данных SQL. При изменении политики выполнения также изменяется код, указывающий, сколько раз создаются временные ошибки. Можно также изменить код, чтобы создать больше исключений, чтобы Entity Framework выдаст исключение `RetryLimitExceededException`.

    Значение, введенное в поле поиска, будет находиться в `command.Parameters[0]` и `command.Parameters[1]` (оно используется для имени, а другое для фамилии). При обнаружении значения "% Throw%" в этих параметрах "a" заменяется "Throw", чтобы некоторые учащиеся были найдены и возвращались.

    Это просто удобный способ проверки устойчивости подключения на основе изменения некоторых входных данных в пользовательском интерфейсе приложения. Можно также написать код, который создает временные ошибки для всех запросов или обновлений, как описано далее в комментариях к методу *дбинтерцептион. Add* .
3. В *Global. asax*добавьте следующие `using` операторы:

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample8.cs)]
4. Добавьте выделенные строки в метод `Application_Start`:

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample9.cs?highlight=7-8)]

    Эти строки кода приводят к тому, что код перехватчика будет выполняться, когда Entity Framework отправляет запросы в базу данных. Обратите внимание, что, поскольку вы создали отдельные классы перехватчиков для моделирования временных ошибок и ведения журнала, вы можете независимо включать и отключать их.

    Перехватчики можно добавлять с помощью метода `DbInterception.Add` в любом месте кода; Он не должен находиться в методе `Application_Start`. Другой вариант — разместить этот код в классе DbConfiguration, созданном ранее, чтобы настроить политику выполнения.

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample10.cs?highlight=6-7)]

    При помещении этого кода следует избегать выполнения `DbInterception.Add` для одного перехватчика более одного раза или получить дополнительные экземпляры перехватчика. Например, если вы добавите перехватчик записи в журнал дважды, то увидите два журнала для каждого запроса SQL.

    Перехватчики выполняются в порядке регистрации (порядок, в котором вызывается метод `DbInterception.Add`). Порядок может быть важен в зависимости от того, что вы делаете в перехватчике. Например, перехватчик может изменить команду SQL, которую он получает в свойстве `CommandText`. Если команда SQL изменилась, следующий перехватчик вернет команду SQL, а не исходную команду SQL.

    Вы написали код моделирования временной ошибки таким образом, который позволяет вызывать временные ошибки, вводя другое значение в пользовательском интерфейсе. В качестве альтернативы можно написать код перехватчика, чтобы всегда создавать последовательность временных исключений без проверки конкретного значения параметра. Затем можно добавить перехватчик, только если нужно создать временные ошибки. Однако при этом не добавляйте перехватчик до завершения инициализации базы данных. Иными словами, перед созданием временных ошибок выполните по крайней мере одну операцию с базой данных, например запрос к одному из наборов сущностей. Entity Framework выполняет несколько запросов во время инициализации базы данных и не выполняется в транзакции, поэтому ошибки во время инициализации могут привести к несогласованному состоянию контекста.

## <a name="test-the-new-configuration"></a>Тестирование новой конфигурации

1. Нажмите клавишу **F5** , чтобы запустить приложение в режиме отладки, а затем перейдите на вкладку **students (учащиеся** ).
2. Взгляните на окно **вывода** Visual Studio, чтобы просмотреть выходные данные трассировки. Возможно, придется прокрутить последние ошибки JavaScript, чтобы перейти к журналам, записанным вашим средством ведения журнала.

    Обратите внимание, что можно увидеть фактические SQL запросы, отправленные в базу данных. Вы увидите некоторые начальные запросы и команды, которые Entity Framework начать работу, проверив таблицу журнала версии и миграции базы данных (вы узнаете о миграции в следующем руководстве). Отобразится запрос на разбиение на страницы, чтобы узнать, сколько учащихся, и, наконец, вы видите запрос, получит данные учащегося.

    ![Ведение журнала для обычного запроса](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image1.png)
3. На странице **учащихся** введите "Throw" в качестве строки поиска и нажмите кнопку " **Поиск**".

    ![Выдать строку поиска](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image2.png)

    Вы заметите, что браузер перестает отвечать на несколько секунд, а Entity Framework повторяет запрос несколько раз. Первая повторная попытка выполняется очень быстро, а затем ждет до тех пор, пока не будет увеличена каждая дополнительная попытка. Этот процесс ожидания перед каждой повторной попыткой называется *экспоненциальной*задержкой.

    Когда отобразится страница, отображающая учащихся, у которых в своих именах есть «an», просмотрите окно вывод, и вы увидите, что один и тот же запрос попытался пять раз, первые четыре раза возвращают временные исключения. Для каждой временной ошибки вы увидите журнал, который вы написали при создании временной ошибки в классе `SchoolInterceptorTransientErrors` ("возвращение временной ошибки для команды..."), и журнал будет записан, когда `SchoolInterceptorLogging` получает исключение.

    ![Выходные данные журнала, отображающие повторные попытки](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image3.png)

    Так как вы указали строку поиска, запрос, возвращающий данные учащегося, является параметризованным:

    [!code-sql[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample11.sql)]

    Вы не записываете значения параметров, но это можно сделать. Если вы хотите просмотреть значения параметров, можно написать код ведения журнала, чтобы получить значения параметров из свойства `Parameters` объекта `DbCommand`, полученного в методах перехватчика.

    Обратите внимание, что этот тест нельзя повторить, пока приложение не будет перезапущено. Если вы хотите иметь возможность проверить устойчивость подключения несколько раз в одном запуске приложения, можно написать код для сброса счетчика ошибок в `SchoolInterceptorTransientErrors`.
4. Чтобы увидеть разницу в стратегии выполнения (политика повтора), закомментируйте `SetExecutionStrategy`ную строку в *SchoolConfiguration.CS*, снова запустите страницу students в режиме отладки и выполните поиск по запросу "Throw".

    На этот раз отладчик останавливается на первом созданном исключении сразу же после того, как он пытается выполнить запрос в первый раз.

    ![Фиктивное исключение](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image4.png)
5. Раскомментируйте строку *сетексекутионстратеги* в *SchoolConfiguration.CS*.

## <a name="get-the-code"></a>Получение кода

[Скачать завершенный проект](https://webpifeed.blob.core.windows.net/webpifeed/Partners/ASP.NET%20MVC%20Application%20Using%20Entity%20Framework%20Code%20First.zip)

## <a name="additional-resources"></a>Дополнительные ресурсы

Ссылки на другие ресурсы Entity Framework можно найти в [материалах, рекомендуемых для доступа к данным ASP.NET](../../../../whitepapers/aspnet-data-access-content-map.md).

## <a name="next-steps"></a>Дальнейшие действия

Изучив это руководство, вы:

> [!div class="checklist"]
> * Включена устойчивость подключения
> * Включено перехват команд
> * Тестирование новой конфигурации

Перейдите к следующей статье, чтобы узнать о Code First миграции и развертывании Azure.
> [!div class="nextstepaction"]
> [Code First миграции и развертывание Azure](migrations-and-deployment-with-the-entity-framework-in-an-asp-net-mvc-application.md)
