---
uid: mvc/overview/getting-started/getting-started-with-ef-using-mvc/handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application
title: Руководство. Обработка параллелизма с помощью EF в приложении ASP.NET MVC 5
description: В этом руководстве показано, как использовать оптимистичный параллелизм для обработки конфликтов, когда несколько пользователей одновременно обновляют одну и ту же сущность.
author: tdykstra
ms.author: riande
ms.topic: tutorial
ms.date: 01/15/2019
ms.assetid: be0c098a-1fb2-457e-b815-ddca601afc65
msc.legacyurl: /mvc/overview/getting-started/getting-started-with-ef-using-mvc/handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application
msc.type: authoredcontent
ms.openlocfilehash: 43c5fdff5601c9bff32300d3460de0079a498d28
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78499392"
---
# <a name="tutorial-handle-concurrency-with-ef-in-an-aspnet-mvc-5-app"></a>Руководство. Обработка параллелизма с помощью EF в приложении ASP.NET MVC 5

В предыдущих руководствах вы узнали, как обновлять данные. В этом руководстве показано, как использовать оптимистичный параллелизм для обработки конфликтов, когда несколько пользователей одновременно обновляют одну и ту же сущность. Вы изменяете веб-страницы, которые работают с сущностью `Department`, так что они обрабатывали ошибки параллелизма. На следующих рисунках показаны страницы "Edit" (Редактирование) и "Delete" (Удаление), включая некоторые сообщения, которые отображаются при возникновении конфликта параллелизма.

![Department_Edit_page_2_after_clicking_Save](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image10.png)

![Department_Edit_page_2_after_clicking_Save](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image15.png)

Изучив это руководство, вы:

> [!div class="checklist"]
> * Дополнительные сведения о конфликтах параллелизма
> * Добавить оптимистичный параллелизм
> * Изменение контроллера подразделения
> * Проверка параллельной обработки
> * Обновление страницы удаления

## <a name="prerequisites"></a>предварительные требования

* [Асинхронные и хранимые процедуры](async-and-stored-procedures-with-the-entity-framework-in-an-asp-net-mvc-application.md)

## <a name="concurrency-conflicts"></a>Конфликты параллелизма

Конфликт параллелизма возникает, когда один пользователь отображает данные сущности, чтобы изменить их, а другой пользователь обновляет данные той же сущности до того, как изменение первого пользователя будет записано в базу данных. Если не включить обнаружение таких конфликтов, то пользователь, обновляющий базу данных последним, перезаписывает изменения другого пользователя. Во многих приложениях такой риск допустим: при небольшом числе пользователей или обновлений, а также в случае, если перезапись некоторых изменений не является критической, стоимость реализации параллелизма может перевесить его преимущества. В этом случае вам не нужно настраивать приложение для обработки конфликтов параллелизма.

### <a name="pessimistic-concurrency-locking"></a>Пессимистичный параллелизм (блокировка)

Если приложению нужно предотвратить случайную потерю данных в сценариях параллелизма, одним из способов сделать это являются блокировки базы данных. Это называется *пессимистичным параллелизмом*. Например, перед чтением строки из базы данных вы запрашиваете блокировку для доступа для обновления или только для чтения. Если заблокировать строку для обновления, другие пользователи не могут заблокировать ее для обновления или только для чтения, так как получат копию данных, которые находятся в процессе изменения. Если заблокировать строку только для чтения, другие пользователи также могут заблокировать ее только для чтения, но не для обновления.

Управление блокировками имеет недостатки. Оно может оказаться сложным с точки зрения программирования. Оно требует значительных ресурсов управления базами данных, а также может вызвать проблемы с производительностью по мере увеличения числа пользователей приложения. Поэтому не все системы управления базами данных поддерживают пессимистичный параллелизм. Entity Framework не предоставляет встроенную поддержку для нее, и в этом руководстве не показано, как его реализовать.

### <a name="optimistic-concurrency"></a>Оптимистический параллелизм

Альтернативой пессимистичному параллелизму является *оптимистичный параллелизм*. Оптимистическая блокировка допускает появление конфликтов параллелизма, а затем обрабатывает их соответствующим образом. Например, Джон запускает страницу редактирования отделы, изменяет сумму **бюджета** для английского отдела с $350 000,00 на $0,00.

Прежде чем Джон нажмет кнопку " **сохранить**", Мария выполняет ту же страницу и изменит поле " **Дата начала** " с 9/1/2007 на 8/8/2013.

Джон щелкает " **сохранить** " и видит свое изменение при возврате браузера на страницу индекса, затем Джейн щелкает **Save (сохранить**). Дальнейший ход событий определяется порядком обработки конфликтов параллелизма. Некоторые параметры перечислены ниже:

- Вы можете отслеживать, для какого свойства пользователь изменил и обновил только соответствующие столбцы в базе данных. В этом примере сценария данные не будут потеряны, так как эти два пользователя обновляли разные свойства. В следующий раз, когда кто-то просматривает англоязычный отдел, он увидит изменения в Джон и Мария — дату начала 8/8/2013 и бюджет на нуль долларов.

    Этот метод обновления помогает снизить число конфликтов, которые могут привести к потере данных, но не позволяет избежать такой потери, когда конкурирующие изменения вносятся в одно свойство сущности. То, работает ли Entity Framework в таком режиме, зависит от того, как вы реализуете код обновления. В веб-приложении это часто нецелесообразно, так как может потребоваться обрабатывать большой объем состояний, чтобы отслеживать все исходные значения свойств для сущности, а также новые значения. Обработка большого объема состояний может повлиять на производительность приложения, так как требует ресурсов сервера или должна быть включена непосредственно в веб-страницу (например, в скрытые поля) или файл cookie.
- Вы можете позволить Марии изменить перезапись изменений Джон. В следующий раз, когда кто-то просматривает английский язык, он увидит 8/8/2013 и восстановленное значение $350 000,00. Такой подход называется *победой клиента* или *сохранением последнего внесенного изменения*. (Все значения от клиента имеют приоритет над тем, что есть в хранилище данных.) Как отмечалось в разделе Введение в этот раздел, если вы не выполняете кодирование для обработки параллелизма, это происходит автоматически.
- Вы можете предотвратить обновление Марии в базе данных. Как правило, выводится сообщение об ошибке, отображается его текущее состояние и пользователь может повторно применить изменения, если он по-прежнему хочет сделать это. Это называется *победой хранилища*. (Значения в хранилище данных имеют приоритет над значениями, отправленными клиентом.) В этом руководстве вы реализуете сценарий Store WINS. Данный метод гарантирует, что никакие изменения не перезаписываются без оповещения пользователя о случившемся.

### <a name="detecting-concurrency-conflicts"></a>Обнаружение конфликтов параллелизма

Можно разрешить конфликты, обрабатывая исключения [оптимистикконкурренциексцептион](https://msdn.microsoft.com/library/system.data.optimisticconcurrencyexception.aspx) , которые создает Entity Framework. Чтобы определить, когда именно нужно выдавать исключения, платформа Entity Framework должна быть в состоянии обнаруживать конфликты. Поэтому нужно соответствующим образом настроить базу данных и модель данных. Ниже приведены некоторые варианты для реализации обнаружения конфликтов:

- Включите в таблицу базы данных столбец отслеживания, который позволяет определять, когда была изменена строка. Затем можно настроить Entity Framework, чтобы включить этот столбец в предложение `Where` команд SQL `Update` или `Delete`.

    Тип данных столбца отслеживания обычно равен [rowversion](https://msdn.microsoft.com/library/ms182776(v=sql.110).aspx). Значение [rowversion](https://msdn.microsoft.com/library/ms182776(v=sql.110).aspx) — это порядковый номер, увеличивающийся при каждом обновлении строки. В команде `Update` или `Delete` предложение `Where` включает исходное значение столбца отслеживания (версия исходной строки). Если обновляемая строка была изменена другим пользователем, значение в столбце `rowversion` отличается от исходного значения, поэтому инструкция `Update` или `Delete` не может найти обновляемую строку из-за предложения `Where`. Когда Entity Framework обнаружит, что ни одна из строк не была обновлена командой `Update` или `Delete` (т. е. Если число затронутых строк равно нулю), это интерпретируется как конфликт параллелизма.
- Настройте Entity Framework, чтобы включить исходные значения каждого столбца в таблице в предложении `Where` для команд `Update` и `Delete`.

    Как и в первом случае, если при первом чтении строки было изменено какое-либо значение в строке, предложение `Where` не вернет строку для обновления, которая Entity Framework интерпретируется как конфликт параллелизма. Для таблиц базы данных, имеющих много столбцов, этот подход может привести к созданию очень больших `Where` предложений и может потребовать, чтобы вы поддерживали большие объемы состояний. Как было указано ранее, обслуживание большого объема состояний может негативно повлиять на производительность приложения. Поэтому в общем случае данный подход не рекомендуется, кроме того, он не применяется и в этом руководстве.

    Если вы хотите реализовать этот подход к параллелизму, необходимо пометить все свойства, не являющиеся первичными ключами, в сущности, для которой необходимо отслеживание параллелизма, добавив к ним атрибут [ConcurrencyCheck](https://msdn.microsoft.com/library/system.componentmodel.dataannotations.concurrencycheckattribute.aspx) . Это изменение позволяет Entity Framework включить все столбцы в предложение SQL `WHERE` инструкций `UPDATE`.

В оставшейся части этого учебника вы добавите свойство отслеживания [rowversion](https://msdn.microsoft.com/library/ms182776(v=sql.110).aspx) в сущность `Department`, создадите контроллер и представления и проверите, правильно ли работает все.

## <a name="add-optimistic-concurrency"></a>Добавить оптимистичный параллелизм

В *моделс\департмент.КС*добавьте свойство отслеживания с именем `RowVersion`.

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample1.cs?highlight=20-22)]

Атрибут [timestamp](https://msdn.microsoft.com/library/system.componentmodel.dataannotations.timestampattribute.aspx) указывает, что этот столбец будет включаться в предложение `Where` `Update` и `Delete` команды, отправляемые в базу данных. Атрибут называется [меткой времени](https://msdn.microsoft.com/library/system.componentmodel.dataannotations.timestampattribute.aspx) , так как предыдущие версии SQL Server использовали тип данных [timestamp](https://msdn.microsoft.com/library/ms182776(v=SQL.90).aspx) SQL до того, как он заменил значение [rowversion](https://msdn.microsoft.com/library/ms182776(v=sql.110).aspx) SQL. Тип для [rowversion](https://msdn.microsoft.com/library/ms182776(v=sql.110).aspx) — массив байтов.

Если вы предпочитаете использовать API Fluent, можно использовать метод [исконкурренцитокен](https://msdn.microsoft.com/library/gg679501(v=VS.103).aspx) для указания свойства отслеживания, как показано в следующем примере:

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample2.cs)]

Добавив свойство, вы изменили модель базы данных, поэтому нужно выполнить еще одну миграцию. Введите в консоли диспетчера пакетов (PMC) следующие команды:

[!code-console[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample3.cmd)]

## <a name="modify-department-controller"></a>Изменение контроллера подразделения

В *контроллерс\департментконтроллер.КС*добавьте инструкцию `using`:

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample4.cs)]

В файле *DepartmentController.CS* измените все четыре вхождения "LastName" на "FullName", чтобы раскрывающиеся списки администратора отдела содержали полное имя инструктора, а не только фамилию.

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample5.cs?highlight=1)]

Замените существующий код для метода `HttpPost` `Edit` следующим кодом:

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample6.cs)]

Если метод `FindAsync` возвращает значение null, кафедра была удалена другим пользователем. Приведенный код использует значения отправленной формы для создания сущности отдела, чтобы страница редактирования могла быть отображена с сообщением об ошибке. Кроме того, повторно создать сущность кафедры не нужно, если вы выводите только сообщение об ошибке без повторного отображения полей кафедры.

Представление сохраняет исходное значение `RowVersion` в скрытом поле, а метод получает его в параметре `rowVersion`. Перед вызовом `SaveChanges` нужно поместить это исходное значение свойства `RowVersion` в коллекцию `OriginalValues` для сущности. Затем, когда Entity Framework создает команду SQL `UPDATE`, эта команда будет включать предложение `WHERE`, которое ищет строку с исходным значением `RowVersion`.

Если команда `UPDATE` не затрагивает ни одной строки (ни одна из строк не имеет исходного значения `RowVersion`), Entity Framework создает исключение `DbUpdateConcurrencyException`, а код в блоке `catch` получает затронутую `Department` сущность из объекта исключения.

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample7.cs)]

Этот объект содержит новые значения, введенные пользователем в его свойстве `Entity`, а значения, считываемые из базы данных, можно получить, вызвав метод `GetDatabaseValues`.

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample8.cs)]

Метод `GetDatabaseValues` возвращает значение null, если пользователь удалил строку из базы данных; в противном случае необходимо привести возвращенный объект к классу `Department`, чтобы получить доступ к свойствам `Department`. (Поскольку вы уже проверяли на удаление, `databaseEntry` будет иметь значение null, только если отдел был удален после выполнения `FindAsync` и до `SaveChanges`.)

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample9.cs)]

Затем код добавляет пользовательское сообщение об ошибке для каждого столбца, в котором значения базы данных отличаются от значений, введенных пользователем на странице редактирования.

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample10.cs)]

В более длинном сообщении об ошибке объясняется, что произошло и что делать с ним:

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample11.cs)]

Наконец, код устанавливает `RowVersion` значение объекта `Department` в новое значение, полученное из базы данных. Это новое значение `RowVersion` будет сохранено в скрытом поле при повторном отображении страницы "Edit" (Редактирование). Когда пользователь в следующий раз нажимает кнопку **Save** (Сохранить), перехватываются только те ошибки параллелизма, которые возникли с момента повторного отображения страницы "Edit" (Редактирование).

В *виевс\департмент\едит.кштмл*Добавьте скрытое поле, чтобы сохранить значение свойства `RowVersion`, сразу после скрытого поля для свойства `DepartmentID`:

[!code-cshtml[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample12.cshtml?highlight=18)]

## <a name="test-concurrency-handling"></a>Проверка параллельной обработки

Запустите сайт и щелкните **отделы**.

Щелкните правой кнопкой мыши гиперссылку **изменить** для английского Отдела и выберите пункт **Открыть в новой вкладке,** а затем щелкните гиперссылку **изменить** для английского Отдела. На двух вкладках отображаются одни и те же сведения.

Измените поле на первой вкладке браузера и нажмите кнопку **Save** (Сохранить).

В браузере отображается страница индекса с измененным значением.

Измените поле на второй вкладке браузера и нажмите кнопку **сохранить**. Отображается сообщение об ошибке:

![Department_Edit_page_2_after_clicking_Save](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image10.png)

Снова нажмите кнопку **Save** (Сохранить). Значение, введенное на второй вкладке браузера, сохраняется вместе с исходным значением данных, измененных в первом браузере. Сохраненные значения отображаются при открытии страницы индекса.

## <a name="update-the-delete-page"></a>Обновление страницы удаления

Для страницы "Delete" (Удаление) платформа Entity Framework обнаруживает конфликты параллелизма, вызванные схожим изменением кафедры. Когда метод `HttpGet` `Delete` отображает представление подтверждения, представление включает исходное значение `RowVersion` в скрытое поле. Затем это значение доступно для метода `HttpPost` `Delete`, который вызывается, когда пользователь подтверждает удаление. Когда Entity Framework создает команду SQL `DELETE`, она включает предложение `WHERE` с исходным значением `RowVersion`. Если команда приводит к нулевой строке (то есть изменилась строка после отображения страницы подтверждения удаления), возникает исключение параллелизма, а метод `HttpGet Delete` вызывается с флагом ошибки `true`, чтобы отобразить страницу подтверждения с сообщением об ошибке. Также возможно, что было затронуто нулевое число строк, поскольку строка была удалена другим пользователем, поэтому в этом случае отображается другое сообщение об ошибке.

В *DepartmentController.CS*замените метод `HttpGet` `Delete` следующим кодом:

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample13.cs)]

Этот метод принимает необязательный параметр, который указывает, отображается ли страница повторно после ошибки параллелизма. Если этот флаг имеет значение `true`, в представление отправляется сообщение об ошибке с помощью свойства `ViewBag`.

Замените код в методе `HttpPost` `Delete` (с именем `DeleteConfirmed`) следующим кодом:

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample14.cs)]

В шаблонном коде, который вы только что заменили, этот метод принимал только идентификатор записи:

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample15.cs)]

Вы изменили этот параметр на `Department` экземпляр сущности, созданный связывателем модели. Это предоставляет доступ к значению свойства `RowVersion` в дополнение к ключу записи.

[!code-csharp[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample16.cs)]

Вы также изменили имя метода действия с `DeleteConfirmed` на `Delete`. Шаблонный код с именем `HttpPost` метод `Delete` `DeleteConfirmed`, чтобы присвоить методу `HttpPost` уникальную сигнатуру. (Среда CLR требует, чтобы перегруженные методы имели различные параметры метода.) Теперь, когда сигнатуры уникальны, можно придерживаться соглашения MVC и использовать одно и то же имя для методов `HttpPost` и `HttpGet` DELETE.

При перехвате ошибки параллелизма код повторно отображает страницу подтверждения удаления и предоставляет флаг, указывающий, что нужно отобразить сообщение об ошибке параллелизма.

В *виевс\департмент\делете.кштмл*замените код шаблона следующим кодом, который добавляет поле сообщения об ошибке и скрытые поля для свойств DepartmentID и rowversion. Изменения выделены.

[!code-cshtml[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample17.cshtml?highlight=9-10,21,52-54)]

Этот код добавляет сообщение об ошибке между заголовками `h2` и `h3`:

[!code-cshtml[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample18.cshtml)]

Он заменяет `LastName` `FullName` в поле `Administrator`:

[!code-cshtml[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample19.cshtml)]

Наконец, он добавляет скрытые поля для свойств `DepartmentID` и `RowVersion` после инструкции `Html.BeginForm`:

[!code-cshtml[Main](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample20.cshtml)]

Запустите страницу индекса отделов. Щелкните правой кнопкой мыши гиперссылку **Удалить** для английского Отдела и выберите пункт **Открыть в новой вкладке,** а затем на первой вкладке щелкните гиперссылку **изменить** для английского Отдела.

В первом окне измените одно из значений и нажмите кнопку **сохранить**.

Изменение будет подтверждено на странице индекса.

На второй вкладке нажмите кнопку **Delete** (Удалить).

Вы видите сообщение об ошибке параллелизма, а значения кафедры обновляются с использованием актуальных сведений из базы данных.

![Department_Delete_confirmation_page_with_concurrency_error](handling-concurrency-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image15.png)

Если нажать кнопку **Delete** (Удалить) еще раз, вы будете перенаправлены на страницу индекса, которая показывает, что кафедра была удалена.

## <a name="get-the-code"></a>Получение кода

[Скачать завершенный проект](https://webpifeed.blob.core.windows.net/webpifeed/Partners/ASP.NET%20MVC%20Application%20Using%20Entity%20Framework%20Code%20First.zip)

## <a name="additional-resources"></a>Дополнительные ресурсы

Ссылки на другие ресурсы Entity Framework можно найти в [ресурсах, рекомендуемых для доступа к данным ASP.NET](../../../../whitepapers/aspnet-data-access-content-map.md).

Дополнительные сведения о других способах обработки различных сценариев параллелизма см. в разделе [шаблоны оптимистичного параллелизма](https://msdn.microsoft.com/data/jj592904) и [Работа со значениями свойств](https://msdn.microsoft.com/data/jj592677) на сайте MSDN. В следующем учебнике показано, как реализовать наследование "один таблица на иерархию" для сущностей `Instructor` и `Student`.

## <a name="next-steps"></a>Дальнейшие действия

Изучив это руководство, вы:

> [!div class="checklist"]
> * Дополнительные сведения о конфликтах параллелизма
> * Добавлена Оптимистическая блокировка
> * Измененный контроллер подразделения
> * Протестированная Обработка параллелизма
> * Обновление страницы удаления

Перейдите к следующей статье, чтобы узнать, как реализовать наследование в модели данных.
> [!div class="nextstepaction"]
> [Реализация наследования в модели данных](implementing-inheritance-with-the-entity-framework-in-an-asp-net-mvc-application.md)
