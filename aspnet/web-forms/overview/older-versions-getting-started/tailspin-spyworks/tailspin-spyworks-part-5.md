---
uid: web-forms/overview/older-versions-getting-started/tailspin-spyworks/tailspin-spyworks-part-5
title: Часть 5. бизнес-логика | Документация Майкрософт
author: JoeStagner
description: В этой серии руководств подробно описаны все шаги, предпринятые для создания примера приложения Tailspin Spyworks. Часть 5 добавляет некоторую бизнес-логику.
ms.author: riande
ms.date: 07/21/2010
ms.assetid: eaef475a-ca91-47ea-a4a7-d074005ed80c
msc.legacyurl: /web-forms/overview/older-versions-getting-started/tailspin-spyworks/tailspin-spyworks-part-5
msc.type: authoredcontent
ms.openlocfilehash: c60eece9223c47304786d7b0d0ca4b11ac0572e9
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78511548"
---
# <a name="part-5-business-logic"></a>Часть 5. бизнес-логика

кем [Джо Stagner)](https://github.com/JoeStagner)

> В Tailspin Spyworks. демонстрируется, как чрезвычайно прост в создании мощных масштабируемых приложений для платформы .NET. Здесь показано, как использовать замечательные новые функции в ASP.NET 4 для создания Интернет-магазина, включая покупку, оформление и администрирование.
> 
> В этой серии руководств подробно описаны все шаги, предпринятые для создания примера приложения Tailspin Spyworks. Часть 5 добавляет некоторую бизнес-логику.

## <a id="_Toc260221671"></a>Добавление бизнес-логики

Мы хотим, чтобы наши товары были доступны при каждом посещении веб-узла. Посетители смогут просматривать и добавлять элементы в корзину покупок, даже если они не зарегистрированы или не вошли в систему. Когда они готовы к извлечению, им будет предоставлена возможность проверки подлинности и, если они еще не являются участниками, они смогут создать учетную запись.

Это означает, что нам потребуется реализовать логику для преобразования корзины покупок из анонимного состояния в состояние "зарегистрированный пользователь".

Давайте создадим каталог с именем "classes", затем щелкните правой кнопкой мыши папку и создайте новый файл "class" с именем MyShoppingCart.cs

![](tailspin-spyworks-part-5/_static/image1.jpg)

![](tailspin-spyworks-part-5/_static/image1.png)

Как упоминалось ранее, мы будем расширять класс, реализующий страницу Мишоппингкарт. aspx, и будем делать это с помощью. Мощная конструкция "разделяемого класса" NET.

Созданный вызов для нашего файла MyShoppingCart.aspx.cf выглядит следующим образом.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample1.cs)]

Обратите внимание на использование ключевого слова partial.

Только что созданный файл класса выглядит следующим образом.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample2.cs)]

Мы будем объединять наши реализации, добавив ключевое слово partial в этот файл.

Теперь наш новый файл класса выглядит следующим образом.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample3.cs)]

Первый метод, который будет добавлен в наш класс, — это метод AddItem. Это метод, который в конечном итоге будет вызываться, когда пользователь щелкнет ссылку "добавить в рисунок" на страницах списка продуктов и сведений о продукте.

Добавьте следующий текст в операторы using в верхней части страницы.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample4.cs)]

И добавьте этот метод в класс Мишоппингкарт.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample5.cs)]

Мы используем LINQ to Entities, чтобы узнать, уже находится ли элемент в корзине. Если да, то обновляется количество элементов в заказе, в противном случае мы создаем новую запись для выбранного элемента.

Чтобы вызвать этот метод, мы выполним страницу Аддтокарт. aspx, которая не только наследует классу этого метода, но затем выводит текущую покупку a = корзина после добавления элемента.

Щелкните правой кнопкой мыши имя решения в обозревателе решений и добавьте новую страницу с именем Аддтокарт. aspx, как было сделано ранее.

Несмотря на то, что эту страницу можно использовать для отображения промежуточных результатов, подобных проблемам с низкими расходами, и т. д. в нашей реализации страница не будет отображена, а вместо этого вызывать логику "Add" и перенаправление.

Для этого мы добавим следующий код на странице событие загрузки страницы\_.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample6.cs)]

Обратите внимание, что мы получаем продукт для добавления в корзину для покупок из параметра QueryString и вызовом метода AddItem нашего класса.

Если ошибки не обнаружены, управление передается странице SHoppingCart. aspx, которая будет полностью реализована далее. Если возникает ошибка, возникает исключение.

В настоящее время мы еще не реализовали глобальный обработчик ошибок, чтобы это исключение было бы необработанным нашим приложением, но это будет устранено чуть позже.

Обратите внимание также на использование инструкции Debug. Fail () (доступно через `using System.Diagnostics;)`

Приложение выполняется внутри отладчика. в этом методе отображается подробное диалоговое окно со сведениями о состоянии приложений, а также указанном сообщении об ошибке.

При запуске в рабочей среде инструкция Debug. Fail () игнорируется.

В коде, приведенном выше, следует вызвать метод в именах классов покупательской корзины "Жетшоппингкартид".

Добавьте код для реализации метода следующим образом.

Обратите внимание, что мы также добавили кнопки обновления и извлечения и метку, в которой можно отобразить корзину "итог".

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample7.cs)]

Теперь мы можем добавлять элементы в нашу корзину для покупок, но мы не реализовали логику для вывода корзины после добавления продукта.

Таким образом, на странице Мишоппингкарт. aspx мы добавим элемент управления EntityDataSource и элемент управления Гридвире следующим образом.

[!code-aspx[Main](tailspin-spyworks-part-5/samples/sample8.aspx)]

Вызовите форму в конструкторе, чтобы можно было дважды щелкнуть кнопку "Обновить корзину" и создать обработчик событий щелчка, указанный в объявлении в разметке.

Эти сведения будут реализованы позже, но это позволит нам создавать и запускать приложение без ошибок.

При запуске приложения и добавлении элемента в корзину для покупок вы увидите это.

![](tailspin-spyworks-part-5/_static/image2.jpg)

Обратите внимание, что мы отклоняете отображение сетки "по умолчанию", реализуя три настраиваемых столбца.

Первый — это редактируемое, "привязанное" поле для количества:

[!code-aspx[Main](tailspin-spyworks-part-5/samples/sample9.aspx)]

Далее следует вычисляемый столбец, в котором отображается итог по номенклатуре строки (стоимость товара для заказанного количества):

[!code-aspx[Main](tailspin-spyworks-part-5/samples/sample10.aspx)]

Наконец, у нас есть пользовательский столбец, содержащий элемент управления CheckBox, который пользователь будет использовать для указания, что элемент должен быть удален из диаграммы покупок.

[!code-aspx[Main](tailspin-spyworks-part-5/samples/sample11.aspx)]

![](tailspin-spyworks-part-5/_static/image3.jpg)

Как видите, строка «итог заказа» пуста, поэтому мы добавим некоторую логику для вычисления итогового значения заказа.

Сначала мы реализуем метод "подытог" для нашего класса Мишоппингкарт.

Добавьте следующий код в файл MyShoppingCart.cs.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample12.cs)]

Затем на странице\_загрузки обработчика событий можно будет вызвать метод подытога. В то же время мы добавим тест, чтобы проверить, пуста ли корзина для покупок, и соответствующим образом настроить отображение.

Теперь, если корзина для покупок пуста, мы получаем это:

![](tailspin-spyworks-part-5/_static/image4.jpg)

В противном случае мы видим итог.

![](tailspin-spyworks-part-5/_static/image5.jpg)

Однако эта страница еще не завершена.

Нам потребуется дополнительная логика для повторного вычисления корзины покупок путем удаления элементов, отмеченных для удаления, и определения новых значений количества, которые могут быть изменены пользователем в сетке.

Позволяет добавить метод "RemoveItem" в наш класс покупательской корзины в MyShoppingCart.cs для решения ситуации, когда пользователь помечает элемент для удаления.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample13.cs)]

Теперь давайте обходим метод для решения ситуации, когда пользователь просто изменяет качество для упорядочения в GridView.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample14.cs)]

Благодаря базовым функциям удаления и обновления на месте мы можем реализовать логику, которая фактически обновляет корзину покупок в базе данных. (В MyShoppingCart.cs)

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample15.cs)]

Обратите внимание, что этот метод предполагает наличие двух параметров. Одна из них — идентификатор покупательской корзины, а другая — массив объектов определяемого пользователем типа.

Таким образом, чтобы максимально ограничить зависимость нашей логики от особенностей пользовательского интерфейса, мы определили структуру данных, которую мы можем использовать для передачи элементов корзины покупок в наш код без необходимости прямого доступа к элементу управления GridView.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample16.cs)]

В нашем MyShoppingCart.aspx.cs файле мы можем использовать эту структуру в обработчике событий нажатия кнопки обновления, как показано ниже. Обратите внимание, что в дополнение к обновлению корзины мы также будем обновлять итоговую корзину.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample17.cs)]

Обратите внимание на конкретную строку кода:

[!code-javascript[Main](tailspin-spyworks-part-5/samples/sample18.js)]

Функции "MyShoppingCart.aspx.cs" () — это специальная вспомогательная функция, которую мы будем реализовывать в качестве приведенных ниже.

[!code-csharp[Main](tailspin-spyworks-part-5/samples/sample19.cs)]

Это обеспечивает чистый способ доступа к значениям привязанных элементов в элементе управления GridView. Поскольку элемент управления CheckBox "Remove Item" не привязан, мы будем обращаться к нему через метод Финдконтрол ().

На этом этапе разработки проекта мы готовы к реализации процесса извлечения.

Перед этим мы будем использовать Visual Studio для создания базы данных членства и добавления пользователя в репозиторий членства.

> [!div class="step-by-step"]
> [Назад](tailspin-spyworks-part-4.md)
> [Вперед](tailspin-spyworks-part-6.md)
