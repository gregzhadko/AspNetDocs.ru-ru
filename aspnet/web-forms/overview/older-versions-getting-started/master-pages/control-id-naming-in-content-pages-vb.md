---
uid: web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-vb
title: Контролировать именование идентификатор на страницах содержимого (Visual Basic) | Документация Майкрософт
author: rick-anderson
description: Показано, как элементы управления ContentPlaceHolder служить контейнером именования и таким образом, чтобы программно работа с элементом управления, которые трудно (через FindControl)...
ms.author: riande
ms.date: 06/10/2008
ms.assetid: dbb024a6-f043-4fc5-ad66-56556711875b
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-vb
msc.type: authoredcontent
ms.openlocfilehash: dd60d02c2c3840edd4c0e1244623fcea0cb2db0b
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59386324"
---
# <a name="control-id-naming-in-content-pages-vb"></a>Именование идентификатора элемента управления на страницах содержимого (VB)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачать код](http://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_VB.zip) или [скачать PDF](http://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_VB.pdf)

> Показано, как элементы управления ContentPlaceHolder служить контейнером именования и таким образом, чтобы программно работа с элементом управления, которые трудно (через FindControl). Ищет этой проблемы и обходные пути. Также рассматриваются способы программного доступа к результирующее значение ClientID.


## <a name="introduction"></a>Вступление

Все серверные элементы управления ASP.NET включают `ID` свойство, которое однозначно определяет элемент управления и является средством, по которому элемент управления осуществляется программным способом в классе фонового кода. Аналогичным образом, может включать элементы HTML-документа `id` атрибут, который уникально определяет элемент; они `id` значения часто используются в клиентский сценарий для создавать программную ссылку на конкретный элемент HTML. Учитывая это, вы может предполагается, что при отображении серверного элемента управления ASP.NET в формат HTML, его `ID` значение используется как `id` значение отображаемому элементу HTML. Это не обязательно так потому, что в некоторых случаях один элемент управления с одним `ID` значение может встречаться несколько раз в созданной разметке. Рассмотрим элемент GridView, который включает в себя поле TemplateField в элемент управления Label Web с `ID` значение `ProductName`. Если GridView привязан к источнику данных во время выполнения, эта метка повторяется один раз для каждой строки GridView. Всех преобразуемых потребностей метка уникальный `id` значение.

Для обработки таких сценариев, ASP.NET позволяет некоторых элементов управления обозначать как контейнеры именования. Контейнер именования служит новый `ID` пространства имен. У их готовый для просмотра всех серверных элементов управления, которые отображаются в контейнере именования `id` с префиксом `ID` именования контейнерного элемента управления. Например `GridView` и `GridViewRow` классы представляют собой контейнеры именования. Следовательно, элемент управления Label, определенных в поле GridView TemplateField с `ID` `ProductName` присваивается росчерка `id` значение `GridViewID_GridViewRowID_ProductName`. Так как *GridViewRowID* уникален для каждой строки GridView, полученный в результате `id` значения уникальны.

> [!NOTE]
> [ `INamingContainer` Интерфейс](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx) используется для указания, что конкретного элемента управления сервера ASP.NET должны выступать в качестве контейнера именования. `INamingContainer` Интерфейс не читаемых поперек, любые методы, которые должны быть реализованы в серверном элементе управления; вместо этого он используется в качестве маркера. При формировании уже визуализированной разметке, если элемент управления реализует этот интерфейс затем механизм ASP.NET автоматически добавляет его `ID` значение для его дочерних элементов к просмотру `id` значения атрибутов. Этот процесс рассматривается более подробно в шаге 2.


Контейнеры именования не только изменить создаваемые `id` значение атрибута, но также влияет на способы управления может программным способом указания из вспомогательного класса страницы ASP.NET. `FindControl("controlID")` Метод обычно используется для программно сослаться на веб-элемент управления. Тем не менее `FindControl` не действовать через контейнеры именования. Следовательно, нельзя использовать непосредственно `Page.FindControl` метод для ссылки на элементы управления в элементе управления GridView или других контейнера именования.

Как вы может surmised, главных страниц и элементов управления ContentPlaceHolder обе реализуются как контейнеры именования. В этом руководстве мы рассмотрим главных страниц влияют на HTML-элемент `id` значения и способов создавать программную ссылку на веб-элементы управления внутри содержимого страницы с помощью `FindControl`.

## <a name="step-1-adding-a-new-aspnet-page"></a>Шаг 1. Добавление новой страницы ASP.NET

Для демонстрации понятий, обсуждавшимся в этом учебнике, давайте добавим новую страницу ASP.NET для нашего веб-сайта. Создать новую страницу содержимого с именем `IDIssues.aspx` в корневой папке, привязав его к `Site.master` главной страницы.


![Добавление содержимого IDIssues.aspx страницы в корневую папку](control-id-naming-in-content-pages-vb/_static/image1.png)

**Рис 01**: Добавление страницы содержания `IDIssues.aspx` в корневую папку


Visual Studio автоматически создает элемент управления содержимым для каждого из четырех элементов управления в ContentPlaceHolder на главной странице. Как отмечалось в [ *несколько элементов управления ContentPlaceHolder и содержимое по умолчанию* ](multiple-contentplaceholders-and-default-content-vb.md) учебника, если отсутствует элемент управления содержимым вместо этого создается содержимое элемента ContentPlaceHolder на главной странице по умолчанию. Так как `QuickLoginUI` и `LeftColumnContent` элементов управления ContentPlaceHolder содержать разметку подходящее значение по умолчанию для этой страницы, продолжим и удалить их соответствующие элементы управления содержимым из `IDIssues.aspx`. На этом этапе декларативная разметка страницы содержимого должны выглядеть следующим образом:


[!code-aspx[Main](control-id-naming-in-content-pages-vb/samples/sample1.aspx)]

В [ *указание названия, метатегов и других заголовков HTML на главной странице* ](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-vb.md) руководстве мы создали пользовательского базового класса страницы (`BasePage`), автоматически настраивает заголовок страницы, если это не задан явно. Для `IDIssues.aspx` странице использовать эту функцию, вспомогательном классе страницы должен быть производным от `BasePage` класса (а не `System.Web.UI.Page`). Измените определение класса фонового кода, таким образом, чтобы он выглядел следующим образом:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample2.vb)]

Наконец, обновите `Web.sitemap` файл, чтобы включить запись для этого нового занятия. Добавить `<siteMapNode>` и присвойте его `title` и `url` атрибуты «Управления идентификатор проблемы именования» и `~/IDIssues.aspx`, соответственно. После этого добавления вашего `Web.sitemap` файла должна выглядеть следующим образом:


[!code-xml[Main](control-id-naming-in-content-pages-vb/samples/sample3.xml)]

Как показано на рис. 2, новые записи карты сайта в `Web.sitemap` сразу отражается в разделе занятий в левом столбце.


![В разделе занятия теперь ссылка на &quot;проблем именования идентификатор элемента управления&quot;](control-id-naming-in-content-pages-vb/_static/image2.png)

**Рис. 02**: В разделе занятия теперь ссылка на «Проблем именования идентификатор элемента управления»


## <a name="step-2-examining-the-renderedidchanges"></a>Шаг 2. Изучение создаваемые`ID`изменения

Чтобы лучше понять изменения ASP.NET делает ядра в готовом для просмотра `id` управляет значения сервера, можно добавить несколько веб-элементы управления для `IDIssues.aspx` странице, а затем просмотреть разметку, отправляемых в браузер. В частности, введите текст «Введите ваш возраст:» следуют TextBox веб-элемент управления. Дальнейшей работы на странице добавьте кнопку веб-элемент управления и элемент управления Label Web. Значение текстового поля `ID` и `Columns` свойства `Age` и 3 соответственно. Задайте `Text` и `ID` свойства для «Отправить» и `SubmitButton`. Очистите метки `Text` и установите его `ID` для `Results`.

На этом этапе содержимого элемента управления должен выглядеть следующим образом:


[!code-aspx[Main](control-id-naming-in-content-pages-vb/samples/sample4.aspx)]

Рис. 3 показана страница при просмотре через конструктор Visual Studio.


[![Tон страницы включает в себя три веб-элементов управления: текстовое поле, кнопку и метку](control-id-naming-in-content-pages-vb/_static/image4.png)](control-id-naming-in-content-pages-vb/_static/image3.png)

**Рис 03**: Страницы включает в себя три веб-элементов управления: текстовое поле, кнопку и метку ([Просмотр полноразмерного изображения](control-id-naming-in-content-pages-vb/_static/image5.png))


Посетите страницу через обозреватель, а затем просмотрите исходный код HTML. Как разметка ниже показано `id` значения HTML-элементов для элементов управления TextBox, Button и Label Web представляют собой сочетание `ID` значения веб-элементов управления и `ID` значения контейнерах именования на странице.


[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample5.html)]

Как отмечалось ранее в этом учебнике, главной страницы и ее элементов управления ContentPlaceHolder служат в качестве контейнеров именования. Следовательно, оба contribute создаваемые `ID` значения вложенных элементов управления. Использовать текстовое поле `id` атрибут, например: `ctl00_MainContent_Age`. Помните, что элемент управления TextBox `ID` значение было `Age`. Это указывается управления ContentPlaceHolder `ID` значение `MainContent`. Кроме того, это значение будет начинаться с префикса главной страницы `ID` значение `ctl00`. В итоге получается `id` значение атрибута, состоящий из `ID` значения главной страницы, элемент управления ContentPlaceHolder и самого текстового поля.

Это показано на рис. 4. Чтобы определить, готовый для просмотра `id` из `Age` TextBox, начинающихся с `ID` значение элемента управления TextBox, `Age`. Затем постепенно иерархии элементов управления. В каждый контейнер именования (эти узлы персиковое цветом), префикс к просмотру текущего `id` с контейнером именования `id`.


![Атрибуты идентификатор готовый к просмотру, на основе на значения Идентификаторов контейнеров именования](control-id-naming-in-content-pages-vb/_static/image6.png)

**Рис. 04**: Готовый к просмотру `id` являются атрибутами на основе `ID` значения контейнеров именования


> [!NOTE]
> Как уже говорилось, `ctl00` часть создаваемые `id` представляет собой атрибут `ID` значение главной страницы, но может возникнуть вопрос, как этот `ID` именно значение. Мы не был указан в любом месте в нашей главной страницы или страницы содержимого. Большинство серверных элементов управления на странице ASP.NET добавляются явным образом с помощью декларативной разметке страницы. `MainContent` Управления ContentPlaceHolder был явно указан в разметке `Site.master`; `Age` TextBox был определен `IDIssues.aspx`элемента разметки. Можно указать `ID` значения для этих типов элементов управления в окне «Свойства» или из декларативного синтаксиса. Другие элементы управления, такие как главной страницы, не определенные в декларативной разметке. Следовательно их `ID` значения должен быть автоматически создан для нас. Задает обработчик ASP.NET `ID` значения во время выполнения для этих элементов управления, идентификаторы которых явно не задан. Она использует шаблон именования `ctlXX`, где *XX* является последовательно увеличивающееся значение целого числа.


Так как Главная страница сама служит в качестве контейнера именования, веб-элементы управления, определенные на главной странице также изменила готовый для просмотра `id` значения атрибутов. Например `DisplayDate` метки, мы добавили на главную страницу в [ *создание макета сайта с главными страницами* ](creating-a-site-wide-layout-using-master-pages-vb.md) учебник содержит следующие визуализации разметки:


[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample6.html)]

Обратите внимание, что `id` атрибут содержит оба главной страницы `ID` значение (`ctl00`) и `ID` значение элемента управления Label Web (`DateDisplay`).

## <a name="step-3-programmatically-referencing-web-controls-viafindcontrol"></a>Шаг 3. Программного обращения к веб-элементов управления с помощью`FindControl`

Каждый серверный элемент управления ASP.NET включает в себя `FindControl("controlID")` метод, который выполняет поиск элемента управления дочерних элементов для элемента управления с именем *controlID*. При обнаружении такой элемент управления, он возвращается; При обнаружении подходящего элемента управления `FindControl` возвращает `Nothing`.

`FindControl` полезно в сценариях, где необходимо доступ к элементу управления, но у вас нет прямой ссылки на него. При работе с веб-элементы управления, например GridView, например, элементы управления внутри поля GridView определяются один раз в декларативном синтаксисе, но во время выполнения создается экземпляр элемента управления для каждой строки GridView. Следовательно существуют средства, которые создаются во время выполнения, но у нас нет прямых ссылок из вспомогательного класса. В результате нам нужно использовать `FindControl` для программной работы с определенного элемента управления внутри полей GridView. (Дополнительные сведения об использовании `FindControl` для доступа к элементам управления, в шаблонах данных веб-элемента управления, см. в разделе [форматирование на основе по данным](../../data-access/custom-formatting/custom-formatting-based-upon-data-vb.md).) Этот же ситуация возникает, если динамическое добавление веб-элементов управления на веб-форму, раздел подробно [создание динамических данных пользовательские интерфейсы с](https://msdn.microsoft.com/library/aa479330.aspx).

Чтобы проиллюстрировать использование `FindControl` метод для поиска элементов управления на странице содержимого, создайте обработчик событий для `SubmitButton`в `Click` событий. В обработчике событий, добавьте следующий код, который программным образом ссылается на `Age` TextBox и `Results` метки с помощью `FindControl` метода и затем отображает сообщение в `Results` на основе ввода пользователя.

> [!NOTE]
> Само собой, нам не нужно использовать `FindControl` ссылки на элементы управления метку и текстовое поле для этого примера. Мы может ссылаться на них непосредственно через их `ID` значения свойств. Я использую `FindControl` здесь, чтобы продемонстрировать, что происходит при использовании `FindControl` из страницы содержания.


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample7.vb)]

Хотя синтаксис, используемый для вызова `FindControl` метод немного отличается в первых двух строках `SubmitButton_Click`, они семантически эквивалентны. Вспомним, что все элементы управления сервера ASP.NET включают `FindControl` метод. Сюда входят `Page` класс, из которого ASP.NET все классы кода должен быть производным от. Таким образом, вызов `FindControl("controlID")` эквивалентно вызову `Page.FindControl("controlID")`, при условии, что вы еще не переопределен `FindControl` метода в классе фонового кода или в пользовательский базовый класс.

После ввода этого кода, посетите `IDIssues.aspx` странице через браузер, введите ваш возраст и нажмите кнопку «Отправить». При нажатии кнопки «Отправить» `NullReferenceException` возникает (см. рис. 5).


[![A Вызывается исключение NullReferenceException](control-id-naming-in-content-pages-vb/_static/image8.png)](control-id-naming-in-content-pages-vb/_static/image7.png)

**05 рис**: Объект `NullReferenceException` возникает ([Просмотр полноразмерного изображения](control-id-naming-in-content-pages-vb/_static/image9.png))


Если вы задали точку останова в `SubmitButton_Click` обработчик событий, вы увидите, что оба вызовы `FindControl` возвращают `Nothing`. `NullReferenceException` Возникает при попытке получить доступ к `Age` текстового поля `Text` свойство.

Проблема в том, что `Control.FindControl` поиск только *управления*его дочерних элементов, которые находятся в том же контейнере именования. Так как главной страницы представляет собой новый контейнер именования, вызов `Page.FindControl("controlID")` никогда не пронизывающая объект главной страницы `ctl00`. (См. рис. 4 для просмотра иерархии элементов управления, показывающий `Page` объект в качестве родительского объекта главной страницы `ctl00`.) Таким образом `Results` метки и `Age` TextBox не найдены и `ResultsLabel` и `AgeTextBox` присваиваются значения `Nothing`.

Существует два способа решения для этой задачи: мы можем перейти, один контейнер именования одновременно, для соответствующего элемента управления; или можно создать собственную `FindControl` метод, который пронизывающая контейнерах именования. Давайте рассмотрим каждое из этих вариантов.

### <a name="drilling-into-the-appropriate-naming-container"></a>Детализируя соответствующим именованием контейнера

Для использования `FindControl` ссылка `Results` метки или `Age` текстовое поле, необходимо вызвать `FindControl` из элемента управления предка в том же контейнере именования. Как показано на рис. 4, `MainContent` управления ContentPlaceHolder является единственным предком `Results` или `Age` , находящегося в том же контейнере именования. Другими словами, вызов `FindControl` метода из `MainContent` элемента управления, как показано в приведенном ниже фрагменте кода корректно возвращает ссылку на `Results` или `Age` элементов управления.


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample8.vb)]

Тем не менее, мы не может работать с `MainContent` ContentPlaceHolder из вспомогательного класса страницу содержимого, с помощью синтаксиса выше, поскольку оно определено ContentPlaceHolder на главной странице. Вместо этого необходимо использовать `FindControl` для получения ссылки на `MainContent`. Замените код в `SubmitButton_Click` обработчика событий следующие изменения:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample9.vb)]

Если зайти на страницу через браузер, введите ваш возраст и нажмите кнопку «Отправить», `NullReferenceException` возникает. Если вы задали точку останова в `SubmitButton_Click` обработчик событий, вы увидите, что это исключение возникает при попытке вызова `MainContent` объекта `FindControl` метод. `MainContent` Объект равен `Nothing` поскольку `FindControl` метод не может найти объект с именем «MainContent». Основной причиной является совпадает с семантикой `Results` метки и `Age` элемента управления TextBox: `FindControl` начинается поиск в верхней части иерархии элементов управления и не действовать контейнерах именования, но `MainContent` ContentPlaceHolder — на главной странице, который представляет собой контейнер именования.

Прежде чем мы можем использовать `FindControl` для получения ссылки на `MainContent`, необходимо сначала ссылку на элемент управления главной страницы. После получения ссылки на главную страницу мы можно получить ссылку на `MainContent` ContentPlaceHolder через `FindControl` и после этого, ссылки на `Results` метки и `Age` TextBox (опять же, с помощью `FindControl`). Но как мы получаем ссылку на главную страницу? Проверив `id` атрибуты в созданной разметке это очевидно при взгляде, главной страницы `ID` значение `ctl00`. Таким образом, мы могли бы использовать `Page.FindControl("ctl00")` для получения ссылки на главную страницу, затем использовать этот объект для получения ссылки `MainContent`, и т. д. В следующем фрагменте показано эту логику:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample10.vb)]

Хотя этот код определенно будет работать, предполагается, что автоматически созданное главной страницы `ID` всегда будет `ctl00`. Это никогда не следует делать предположений в отношении значения, формируемые автоматически.

К счастью, доступна ссылка на главную страницу через `Page` класса `Master` свойство. Таким образом, вместо того чтобы использовать `FindControl("ctl00")` для получения ссылки главной страницы, чтобы получить доступ к `MainContent` ContentPlaceHolder, можно вместо этого использовать `Page.Master.FindControl("MainContent")`. Обновление `SubmitButton_Click` обработчик событий следующим кодом:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample11.vb)]

На этот раз просмотре страницы через браузер, введите ваш возраст и нажав кнопку «Отправить» отображает сообщение в `Results` метки, как ожидалось.


[![Tвозраста пользователя он отображается в метке](control-id-naming-in-content-pages-vb/_static/image11.png)](control-id-naming-in-content-pages-vb/_static/image10.png)

**Рис 06**: Возраста пользователя отображается в метке ([Просмотр полноразмерного изображения](control-id-naming-in-content-pages-vb/_static/image12.png))


### <a name="recursively-searching-through-naming-containers"></a>Рекурсивный поиск в контейнерах именования

Причина в предыдущем примере ссылка на `MainContent` управления ContentPlaceHolder на главной странице, а затем `Results` метки и `Age` элементы управления TextBox с `MainContent`, обусловлено тем, `Control.FindControl` только метод выполняет поиск в рамках *управления*контейнер именования элемента. Наличие `FindControl` остаются в контейнере именования имеет смысл в большинстве случаев так, как два элемента управления в двух разных контейнерах именования может иметь такую же `ID` значения. Рассмотрим случай GridView, который определяет элемент управления Label Web `ProductName` в одном из его полей TemplateField. При привязке данных к GridView, во время выполнения, `ProductName` метка создается для каждой строки GridView. Если `FindControl` поиск всех имен контейнеров и мы, называемых `Page.FindControl("ProductName")`, того, какой экземпляр метки должны `FindControl` возврата? `ProductName` Метки в первой строке GridView? Этому параметру в последней строке?

Так что наличие `Control.FindControl` поиска просто *управления*именования элемента контейнера имеет смысл в большинстве случаев. Но в других случаях, например в каталог, с которыми мы, где у нас есть уникальный `ID` во всех контейнерах именования и хотите избежать необходимости тщательно ссылаться на каждый контейнер именования в иерархии элементов управления, чтобы доступ к элементу управления. Наличие `FindControl` переменная типа variant, рекурсивно ищет все контейнеры именования позволяет находить слишком. К сожалению .NET Framework не поддерживает такой метод.

Хорошая новость состоит, можно создать собственную `FindControl` метод, рекурсивный поиск всех контейнерах именования. На самом деле, с помощью *методы расширения* мы может добавить третью `FindControlRecursive` метод `Control` класс сопровождающее текущих `FindControl` метод.

> [!NOTE]
> Методы расширения являются компонентом новых в C# 3.0 и Visual Basic 9, которые являются языки, входящие в состав .NET Framework версии 3.5 и Visual Studio 2008. Короче говоря методы расширения позволяют разработчикам создавать новый метод для существующего типа класса через специальный синтаксис. Дополнительные сведения об этой полезные функции, см. в моей статье [расширение базового типа функциональные возможности с помощью методов расширения](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx).


Чтобы создать метод расширения, добавьте новый файл `App_Code` папку с именем `PageExtensionMethods.vb`. Добавить метод расширения с именем `FindControlRecursive` , принимающий в качестве входных данных `String` параметр с именем `controlID`. Для правильной работы методов расширения, нам было крайне важно, что класс помечены как `Module` и что методы расширения предшествовать `<Extension()>` атрибута. Кроме того, все методы расширения необходимо принять в качестве первого параметра объект типа, к которому применяется метод расширения.

Добавьте следующий код, чтобы `PageExtensionMethods.vb` файл, чтобы определить это `Module` и `FindControlRecursive` метод расширения:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample12.vb)]

Этот код в месте, вернуться к `IDIssues.aspx` вспомогательном классе страницы и закомментируйте текущего `FindControl` вызовы методов. Замените вызовы `Page.FindControlRecursive("controlID")`. Ясном о методах расширения то, что они отображаются непосредственно в раскрывающихся списках IntelliSense. Как показано на рис. 7, когда вы вводите `Page` и нажмите клавишу периода `FindControlRecursive` метод включен в IntelliSense раскрывающегося списка вместе с другой `Control` методы класса.


[![EМетоды расширения, включенные в IntelliSense раскрывающихся](control-id-naming-in-content-pages-vb/_static/image14.png)](control-id-naming-in-content-pages-vb/_static/image13.png)

**07 рис**: Методы расширения, включенные в IntelliSense раскрывающихся ([Просмотр полноразмерного изображения](control-id-naming-in-content-pages-vb/_static/image15.png))


Введите следующий код в `SubmitButton_Click` обработчик событий, а затем, посетив страницу, введя свой возраст и нажав кнопку «Отправить». Как показано на рис. 6, полученный результат будет сообщение, «возраст лет!»


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample13.vb)]

> [!NOTE]
> Так как методы расширения новичок в C# 3.0 и Visual Basic 9, если вы используете Visual Studio 2005 не может использовать методы расширения. Вместо этого необходимо реализовать `FindControlRecursive` метод во вспомогательном классе. [Рик Штраль](http://www.west-wind.com/WebLog/default.aspx) имеет такой пример в этой записи блога, [главного страниц ASP.NET и `FindControl` ](http://www.west-wind.com/WebLog/posts/5127.aspx).


## <a name="step-4-using-the-correctidattribute-value-in-client-side-script"></a>Шаг 4. С использованием правильного`id`атрибута значение в скрипт на стороне клиента

В описанных в этом руководстве Общие сведения о подготовке к просмотру веб-элемент управления `id` атрибут очень часто используется в сценарии на стороне клиента для создавать программную ссылку на конкретный элемент HTML. Например, следующий код JavaScript ссылается на элемент HTML с его `id` и выводит его значение в модальное окно сообщения:


[!code-csharp[Main](control-id-naming-in-content-pages-vb/samples/sample14.cs)]

Вспомним, что в ASP.NET страницы, не используйте контейнер именования, отображаемому элементу HTML `id` атрибут идентична веб-элемента управления `ID` значение свойства. По этой причине возникает соблазн жестко в `id` значения атрибутов в код JavaScript. То есть если вы знаете, вам требуется доступ к `Age` TextBox веб-элемента управления посредством скриптов на стороне клиента, сделать это через вызов `document.getElementById("Age")`.

Проблема этого подхода, что при с помощью главных страниц (или других имен контейнерных элементов управления), отображаемый HTML-код `id` не путать с веб-элемента управления `ID` свойство. Вашим первым порывом может быть посетить страницу через обозреватель и просмотра исходного кода, чтобы определить фактический `id` атрибута. Если известно, готовый для просмотра `id` значение, можно было вставить его в вызов `getElementById` для доступа к элементу HTML, вам нужно работать с помощью клиентского скрипта. Этот подход является идеальным, так как некоторые изменения на страницу иерархию элементов управления или изменения `ID` именования элементов управления будет изменена итоговый `id` атрибут, тем самым разрушает ваш код JavaScript.

Хорошая новость в том, что `id` отображается значение атрибута, отображаемый на серверный код через веб-элемента управления [ `ClientID` свойство](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx). Это свойство следует использовать для определения `id` атрибута значение, используемое в скрипт на стороне клиента. Например, чтобы добавить функции JavaScript на страницу, при вызове отображает значение `Age` соответствующее текстовое поле в модальное окно сообщения, добавьте следующий код, чтобы `Page_Load` обработчик событий:


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample15.vb)]

Приведенный выше код вставляет значение `Age` текстового поля `ClientID` свойство в вызов JavaScript `getElementById`. Если вы посетите эту страницу через обозреватель и просмотреть исходный код HTML, вы обнаружите следующий код JavaScript:


[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample16.html)]

Обратите внимание, что как правильное `id` значением атрибута `ctl00_MainContent_Age`, отображается в вызове `getElementById`. Поскольку это значение вычисляется во время выполнения, он работает независимо от того, последующие изменения в иерархии элементов управления страницы.

> [!NOTE]
> В этом примере JavaScript просто показано, как добавить функцию JavaScript, которая правильно ссылается на элемент HTML, преобразовываемый для просмотра серверного элемента управления. Чтобы использовать эту функцию необходимо создавать дополнительные JavaScript для вызова функции, при загрузке документа или при некоторых специальных действий пользователя процесс. Дополнительные сведения об этих и щелкните ссылку, чтение [работа с клиентского сценария](https://msdn.microsoft.com/library/aa479302.aspx).


## <a name="summary"></a>Сводка

Некоторые серверные элементы управления ASP.NET выступать в качестве контейнерах именования, что негативно влияет на создаваемые `id` атрибут значения дочерних элементов управления, а также область элементов управления canvassed по `FindControl` метод. В зависимости от того, главные страницы самой главной страницы и ее элементов управления ContentPlaceHolder именования контейнеров. Следовательно, нужно поместить д немного больше усилий, чтобы программно обращаться к элементам управления в страницу содержимого с помощью `FindControl`. В этом учебнике мы рассмотрели два способа: детализации в элемент управления ContentPlaceHolder и при вызове метода его `FindControl` метод; и последовательное нашего собственного `FindControl` реализации, рекурсивно выполняет поиск по всем контейнерах именования.

Помимо проблем на стороне сервера, контейнерах именования вводят в зависимости от того, ссылки на веб-элементы управления также существуют проблемы на стороне клиента. При отсутствии контейнеров именования, веб-элемента управления в `ID` значение свойства и подготавливается к просмотру `id` значение атрибута — это один в том же. Но с добавлением контейнера именования, готовый для просмотра `id` атрибута включает в себя `ID` значения веб-элемента управления и именования контейнеров в происхождение собственной иерархии элементов управления. Эти проблемы именования являются не проблема, пока вы используете веб-элемента управления `ClientID` свойство, чтобы определить, готовый для просмотра `id` атрибута значение в ваш скрипт на стороне клиента.

Счастливого вам программирования!

### <a name="further-reading"></a>Дополнительные сведения

Дополнительные сведения по темам, обсуждавшимся в этом руководстве см. в следующих ресурсах:

- [Главные страницы ASP.NET и `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx)
- [Создание динамических данных запись пользовательских интерфейсов](https://msdn.microsoft.com/library/aa479330.aspx)
- [Расширение функциональных возможностей базового типа с помощью методов расширения](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)
- [Как выполнить: Содержимое страницы руководство](https://msdn.microsoft.com/library/xxwa0ff0.aspx)
- [Главной страницы: Советы, приемы и ловушки](http://www.odetocode.com/articles/450.aspx)
- [Работа с скрипт на стороне клиента](https://msdn.microsoft.com/library/aa479302.aspx)

### <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор из нескольких книг по ASP/ASP.NET и основатель веб-узла 4GuysFromRolla.com, работает с веб-технологиями Microsoft с 1998 года. Скотт — независимый консультант, преподаватель и автор. Его последняя книга — [ *Sams Teach самостоятельно ASP.NET 3.5 за 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Скоттом можно связаться по адресу [ mitchell@4GuysFromRolla.com ](mailto:mitchell@4GuysFromRolla.com) или через его блог по адресу [ http://ScottOnWriting.NET ](http://scottonwriting.net/).

### <a name="special-thanks-to"></a>Особая благодарность

В этой серии руководств пособий рецензировалась многими компетентными редакторами. Стали Зак Джонс и Suchi Barnerjee Лиз Шалок в этом руководстве. Хотите поработать с моих последующих статей для MSDN? Если Да, напишите мне [ mitchell@4GuysFromRolla.com ](mailto:mitchell@4GuysFromRolla.com).

> [!div class="step-by-step"]
> [Назад](urls-in-master-pages-vb.md)
> [Вперед](interacting-with-the-master-page-from-the-content-page-vb.md)
