---
uid: web-forms/overview/older-versions-getting-started/master-pages/specifying-the-master-page-programmatically-vb
title: Задание главной страницы программным способом (VB) | Документация Майкрософт
author: rick-anderson
description: Просматривает настройку главной страницы страницы содержимого программным путем с помощью обработчика событий инициализации.
ms.author: riande
ms.date: 07/28/2008
ms.assetid: 0edcd653-f24a-41aa-aef4-75f868fe5ac2
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/specifying-the-master-page-programmatically-vb
msc.type: authoredcontent
ms.openlocfilehash: 3b039b22bef38ae6ebf80be070820dc1638f87f4
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78457308"
---
# <a name="specifying-the-master-page-programmatically-vb"></a>Программное указание эталонной страницы (VB)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачать код](https://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_09_VB.zip) или [скачать PDF](https://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_09_VB.pdf)

> Просматривает настройку главной страницы страницы содержимого программным путем с помощью обработчика событий инициализации.

## <a name="introduction"></a>Введение

Так как пример инаугурационный в [*создании макета на уровне сайта с использованием главных страниц*](creating-a-site-wide-layout-using-master-pages-vb.md), все страницы содержимого ссылаются на главную страницу декларативно с помощью атрибута `MasterPageFile` в директиве `@Page`. Например, следующая директива `@Page` связывает страницу содержимого с главной страницей `Site.master`:

[!code-aspx[Main](specifying-the-master-page-programmatically-vb/samples/sample1.aspx)]

[Класс`Page`](https://msdn.microsoft.com/library/system.web.ui.page.aspx) в пространстве имен `System.Web.UI` содержит [свойство`MasterPageFile`](https://msdn.microsoft.com/library/system.web.ui.page.masterpagefile.aspx) , которое возвращает путь к главной странице страницы содержимого. Это свойство задается директивой `@Page`. Это свойство также можно использовать для программного указания главной страницы страницы содержимого. Этот подход удобен, если необходимо динамически назначить главную страницу на основе внешних факторов, например, если пользователь посещает страницу.

В этом учебнике мы добавим на наш веб-сайт вторую главную страницу и динамически решили, какую главную страницу использовать во время выполнения.

## <a name="step-1-a-look-at-the-page-lifecycle"></a>Шаг 1. Обзор жизненного цикла страницы

Каждый раз при поступлении запроса на веб-сервер для страницы ASP.NET, которая является страницей содержимого, подсистема ASP.NET должна запредохранительить элементы управления содержимым страницы на соответствующие элементы управления ContentPlaceHolder главной страницы. Это слияние создает одну иерархию элементов управления, которая затем может выполнять стандартный жизненный цикл страницы.

На рис. 1 показана эта Fusion. На шаге 1 на рис. 1 показано начальное содержимое и иерархии элементов управления главной страницы. В конце этапа предварительной инициализации элементы управления содержимым на странице добавляются к соответствующему элементов управления ContentPlaceHolder на главной странице (шаг 2). После этого Fusion Главная страница выступает в качестве корня иерархии элемента управления "плавкий предохранитель". Затем эта иерархия управления плавким предохранителем добавляется на страницу для создания окончательной иерархии элементов управления (шаг 3). В итоге иерархия элементов управления страницы включает иерархию элементов управления "плавкий предохранитель".

[![иерархии элементов управления главной страницы и страницы содержимого на этапе предварительной инициализации подключаются друг к другу](specifying-the-master-page-programmatically-vb/_static/image2.png)](specifying-the-master-page-programmatically-vb/_static/image1.png)

**Рис. 01**. Иерархия элементов управления главной страницы и страницы содержимого на этапе предварительной инициализации переключается ([щелкните, чтобы просмотреть изображение с полным размером](specifying-the-master-page-programmatically-vb/_static/image3.png))

## <a name="step-2-setting-themasterpagefileproperty-from-code"></a>Шаг 2. Установка свойства`MasterPageFile`из кода

Какая Главная страница, партакес в этом Fusion, зависит от значения свойства `MasterPageFile` объекта `Page`. Установка атрибута `MasterPageFile` в директиве `@Page` имеет чистый результат назначения свойства `MasterPageFile` `Page`на этапе инициализации, что является самым первым этапом жизненного цикла страницы. Можно также задать это свойство программным способом. Однако крайне важно, чтобы это свойство было задано до того, как Fusion будет показано на рис. 1.

В начале этапа предварительной инициализации объект `Page` вызывает [событие`PreInit`](https://msdn.microsoft.com/library/system.web.ui.page.preinit.aspx) и вызывает его [метод`OnPreInit`](https://msdn.microsoft.com/library/system.web.ui.page.onpreinit.aspx). Чтобы задать главную страницу программно, можно либо создать обработчик событий для `PreInit` события, либо переопределить метод `OnPreInit`. Давайте рассмотрим оба подхода.

Начните с открытия `Default.aspx.vb`, файла класса программной части для домашней страницы сайта. Добавьте обработчик событий для события `PreInit` страницы, введя следующий код:

[!code-vb[Main](specifying-the-master-page-programmatically-vb/samples/sample2.vb)]

Здесь можно задать свойство `MasterPageFile`. Обновите код таким образом, чтобы он назначил значение "~/Сите.Мастер" свойству `MasterPageFile`.

[!code-vb[Main](specifying-the-master-page-programmatically-vb/samples/sample3.vb)]

Если задать точку останова и начать отладку, вы увидите, что при посещении страницы `Default.aspx` или при выполнении обратной передачи на эту страницу выполняется обработчик событий `Page_PreInit`, а свойство `MasterPageFile` присваивается «~/Сите.мастер».

Кроме того, можно переопределить метод `OnPreInit` класса `Page` и установить в нем свойство `MasterPageFile`. В этом примере не следует задавать главную страницу на конкретной странице, а не `BasePage`. Вспомним, что мы создали пользовательский класс базовой страницы (`BasePage`) в разделе [*Указание заголовка, Meta-тегов и других заголовков HTML в руководстве по главной странице*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-vb.md) . В настоящее время `BasePage` переопределяет метод `OnLoadComplete` класса `Page`, где он задает свойство `Title` страницы на основе данных схемы узла. Теперь обновите `BasePage`, чтобы переопределить метод `OnPreInit` для программного указания главной страницы.

[!code-vb[Main](specifying-the-master-page-programmatically-vb/samples/sample4.vb)]

Так как все страницы содержимого являются производными от `BasePage`, все они теперь имеют программно назначенную главную страницу. На этом этапе обработчик событий `PreInit` в `Default.aspx.vb` является избыточным; Вы можете удалить его.

### <a name="what-about-thepagedirective"></a>Что насчет директивы`@Page`?

Что может показаться немного запутанным, так как свойства страниц содержимого `MasterPageFile` теперь указываются в двух местах: программно в методе `OnPreInit` класса `BasePage`, а также с помощью атрибута `MasterPageFile` в директиве `@Page` каждой страницы содержимого.

Первым этапом жизненного цикла страницы является стадия инициализации. На этом этапе свойству `MasterPageFile` объекта `Page` присваивается значение атрибута `MasterPageFile` в директиве `@Page` (если оно указано). Этап предварительной инициализации соответствует этапу начальной настройки, и здесь мы программно устанавливаем свойство `MasterPageFile` объекта `Page`, тем самым переписывая значение, присвоенное из директивы `@Page`. Так как мы настраиваете свойство `MasterPageFile` объекта `Page` программным способом, можно удалить атрибут `MasterPageFile` из директивы `@Page`, не влияя на взаимодействие с конечным пользователем. Чтобы убедить этого, удалите атрибут `MasterPageFile` из директивы `@Page` в `Default.aspx`, а затем перейдите на страницу в браузере. Как и ожидалось, выходные данные будут такими же, как и до удаления атрибута.

Задано ли свойство `MasterPageFile` с помощью директивы `@Page` или программным способом, не применяется к опыту конечного пользователя. Однако во время разработки для создания представления WYSIWYG в конструкторе Visual Studio использует атрибут `MasterPageFile` в директиве `@Page`. Если вы вернетесь в `Default.aspx` в Visual Studio и перейдите к конструктору, вы увидите сообщение "ошибка главной страницы: страница содержит элементы управления, для которых требуется ссылка на главную страницу, но ничего не указано" (см. рис. 2).

Вкратце, необходимо оставить атрибут `MasterPageFile` в директиве `@Page`, чтобы работать с богатыми возможностями во время разработки в Visual Studio.

[![Visual Studio использует атрибут MasterPageFile директивы @Page для визуализации представления конструктора.](specifying-the-master-page-programmatically-vb/_static/image5.png)](specifying-the-master-page-programmatically-vb/_static/image4.png)

**Рис. 02**. Visual Studio использует атрибут `MasterPageFile` директивы `@Page` для отрисовки представления конструктора ([щелкните, чтобы просмотреть изображение с полным размером](specifying-the-master-page-programmatically-vb/_static/image6.png))

## <a name="step-3-creating-an-alternative-master-page"></a>Шаг 3. создание альтернативной главной страницы

Так как эталонная страница страницы содержимого может быть задана программно во время выполнения, можно динамически загружать определенную главную страницу на основе некоторых внешних критериев. Эта функция может оказаться полезной в ситуациях, когда макет сайта должен меняться в зависимости от пользователя. Например, веб-приложение подсистемы блогов может позволить пользователям выбрать макет для своего блога, где каждый макет связан с другой главной страницей. Во время выполнения, когда посетитель просматривает блог пользователя, веб-приложению потребуется определить макет блога и динамически связать соответствующую главную страницу со страницей содержимого.

Давайте рассмотрим, как динамически загружать главную страницу во время выполнения на основе некоторых внешних критериев. Сейчас наш веб-сайт содержит только одну главную страницу (`Site.master`). Для иллюстрации выбора главной страницы во время выполнения требуется другая эталонная страница. Этот шаг посвящен созданию и настройке новой главной страницы. На шаге 4 рассматривается определение главной страницы для использования во время выполнения.

Создайте новую главную страницу в корневой папке с именем `Alternate.master`. Также добавьте новую таблицу стилей на веб-сайт с именем `AlternateStyles.css`.

[![добавить на веб-сайт еще одну главную страницу и файл CSS](specifying-the-master-page-programmatically-vb/_static/image8.png)](specifying-the-master-page-programmatically-vb/_static/image7.png)

**Рис. 03**. Добавление на веб-сайт еще одной главной страницы и CSS-файла ([щелкните, чтобы просмотреть изображение с полным размером](specifying-the-master-page-programmatically-vb/_static/image9.png))

Я разработал главную страницу `Alternate.master`, чтобы заголовок отображался в верхней части страницы, по центру и ВМФ фону. Я рассмотрел левый столбец и переместил это содержимое под элементом управления `MainContent` ContentPlaceHolder, который теперь занимает всю ширину страницы. Кроме того, я никсед список неупорядоченных занятий и заменил его горизонтальным списком, приведенным выше `MainContent`. Я также обновил шрифты и цвета, используемые главной страницей (и, по расширению, страницам содержимого). На рис. 4 показан `Default.aspx` при использовании главной страницы `Alternate.master`.

> [!NOTE]
> ASP.NET включает возможность определения *тем*. Тема — это коллекция изображений, файлов CSS и параметров свойств веб-элементов управления, связанных со стилями, которые могут быть применены к странице во время выполнения. Темы можно выполнять, если макеты веб-узла отличаются только в отображаемых изображениях и их правилах CSS. Если макеты отличаются более значительно, например, при использовании различных веб-элементов управления или при наличии совершенно отличающегося макета, необходимо использовать отдельные главные страницы. Дополнительные сведения о темах см. в разделе, посвященном более подробному ознакомлению в конце этого руководства.

[![наши страницы содержимого теперь могут использовать новый внешний вид и поведение](specifying-the-master-page-programmatically-vb/_static/image11.png)](specifying-the-master-page-programmatically-vb/_static/image10.png)

**Рис. 04**. Теперь страницы содержимого могут использовать новый внешний вид и поведение ([щелкните, чтобы просмотреть изображение с полным размером](specifying-the-master-page-programmatically-vb/_static/image12.png))

Когда разметка для главной страницы и страницы содержимого имеет плавкий предохранитель, класс `MasterPage` проверяет, что каждый элемент управления содержимым на странице содержимого ссылается на ContentPlaceHolder на главной странице. Исключение возникает при обнаружении элемента управления содержимым, ссылающегося на несуществующий элемент ContentPlaceHolder. Иными словами, крайне важно, чтобы Главная страница, назначенная странице содержимого, соимела ContentPlaceHolder для каждого элемента управления содержимым на странице содержимого.

Главная страница `Site.master` содержит четыре элемента управления ContentPlaceHolder:

- `head`
- `MainContent`
- `QuickLoginUI`
- `LeftColumnContent`

Некоторые страницы содержимого на веб-сайте включают только один или два элемента управления содержимым. Другие включают элемент управления содержимым для каждого из доступных элементов управления ContentPlaceHolder. Если новая Главная страница (`Alternate.master`) может быть назначена этим страницам содержимого, имеющим элементы управления содержимым для всех элементов управления ContentPlaceHolder в `Site.master`, то важно, чтобы `Alternate.master` также включал те же элементы управления ContentPlaceHolder, что и `Site.master`.

Чтобы страница `Alternate.master` была похожа на «мой» (см. рис. 4), сначала определите стили главной страницы в таблице стилей `AlternateStyles.css`. Добавьте следующие правила в `AlternateStyles.css`:

[!code-css[Main](specifying-the-master-page-programmatically-vb/samples/sample5.css)]

Затем добавьте следующую декларативную разметку в `Alternate.master`. Как видите, `Alternate.master` содержит четыре элемента управления ContentPlaceHolder с теми же `ID` значениями, что и элементы управления ContentPlaceHolder в `Site.master`. Более того, он включает элемент управления ScriptManager, который необходим для страниц на нашем веб-сайте, использующих платформу ASP.NET AJAX.

[!code-aspx[Main](specifying-the-master-page-programmatically-vb/samples/sample6.aspx)]

### <a name="testing-the-new-master-page"></a>Тестирование новой главной страницы

Чтобы протестировать эту новую главную страницу, обновите метод `OnPreInit` класса `BasePage` таким образом, чтобы свойству `MasterPageFile` было присвоено значение `"~/Alternate.maser"` а затем посетить веб-сайт. Каждая страница должна работать без ошибок, за исключением двух: `~/Admin/AddProduct.aspx` и `~/Admin/Products.aspx`. Добавление продукта к элементу DetailsView в `~/Admin/AddProduct.aspx` приводит к `NullReferenceException` из строки кода, которая пытается задать свойство `GridMessageText` главной страницы. При посещении `~/Admin/Products.aspx` создается `InvalidCastException` при загрузке страницы с сообщением: "не удалось привести объект типа" ASP. Alternate\_Master "к типу" ASP. site\_Master ".

Эти ошибки возникают из-за того, что `Site.master` класс кода программной части включает открытые события, свойства и методы, не определенные в `Alternate.master`. В разметке этих двух страниц имеется директива `@MasterType`, которая ссылается на главную страницу `Site.master`.

[!code-aspx[Main](specifying-the-master-page-programmatically-vb/samples/sample7.aspx)]

Кроме того, обработчик событий `ItemInserted` DetailsView в `~/Admin/AddProduct.aspx` содержит код, который приводит слабо типизированное свойство `Page.Master` к объекту типа `Site`. Директива `@MasterType` (используется таким образом) и приведение в обработчике событий `ItemInserted` тесно связывает `~/Admin/AddProduct.aspx` и `~/Admin/Products.aspx` страниц с главной страницей `Site.master`.

Чтобы разорвать эту тесную связь, можно использовать `Site.master` и `Alternate.master` быть производными от общего базового класса, который содержит определения для открытых членов. После этого можно обновить директиву `@MasterType`, чтобы она ссылалась на этот общий базовый тип.

### <a name="creating-a-custom-base-master-page-class"></a>Создание пользовательского базового класса главной страницы

Добавьте новый файл класса в папку `App_Code` с именем `BaseMasterPage.vb` и получите его от `System.Web.UI.MasterPage`. Необходимо определить метод `RefreshRecentProductsGrid` и свойство `GridMessageText` в `BaseMasterPage`, но мы не можем просто переместить их из `Site.master` поскольку эти члены работают с веб-элементами управления, характерными для главной страницы `Site.master` (`RecentProducts` метка GridView и `GridMessage`).

Необходимо настроить `BaseMasterPage` таким образом, чтобы эти члены были определены там, но фактически реализуются производными классами `BaseMasterPage`(`Site.master` и `Alternate.master`). Этот тип наследования можно реализовать, пометив класс как `MustInherit` и его члены как `MustOverride`. Вкратце, добавление этих ключевых слов в класс и его два члена объявляют, что `BaseMasterPage` не реализованы `RefreshRecentProductsGrid` и `GridMessageText`, но его производные классы будут.

Также необходимо определить событие `PricesDoubled` в `BaseMasterPage` и предоставить средства производными классами для вызова события. Шаблон, используемый в .NET Framework, чтобы упростить это поведение, — создать открытое событие в базовом классе и добавить защищенный, переопределяемый метод с именем `OnEventName`. Производные классы могут затем вызвать этот метод, чтобы вызвать событие, или переопределить его для выполнения кода непосредственно до или после вызова события.

Обновите класс `BaseMasterPage`, чтобы он содержал следующий код:

[!code-vb[Main](specifying-the-master-page-programmatically-vb/samples/sample8.vb)]

Затем перейдите к `Site.master` классу кода программной части и порождаете его из `BaseMasterPage`. Поскольку `BaseMasterPage` содержит члены, помеченные `MustOverride` необходимо переопределить эти элементы в `Site.master`. Добавьте ключевое слово `Overrides` в определения метода и свойства. Также обновите код, вызывающий событие `PricesDoubled` в обработчике событий `Click` кнопки `DoublePrice` с вызовом метода `OnPricesDoubled` базового класса.

После этих изменений `Site.master` класс кода программной части должен содержать следующий код:

[!code-vb[Main](specifying-the-master-page-programmatically-vb/samples/sample9.vb)]

Также необходимо обновить класс кода программной части `Alternate.master`, чтобы он был производным от `BaseMasterPage` и переопределить два члена `MustOverride`. Но поскольку `Alternate.master` не содержит GridView, в котором перечислены самые последние продукты, или метка, которая отображает сообщение после добавления нового продукта в базу данных, этим методам не нужно ничего делать.

[!code-vb[Main](specifying-the-master-page-programmatically-vb/samples/sample10.vb)]

### <a name="referencing-the-base-master-page-class"></a>Ссылка на базовый класс главной страницы

Теперь, когда мы завершили работу с классом `BaseMasterPage` и создали две главные страницы, наш последний шаг — это обновить `~/Admin/AddProduct.aspx` и `~/Admin/Products.aspx` страницы, чтобы они ссылались на этот общий тип. Начните с изменения директивы `@MasterType` на обеих страницах из:

[!code-aspx[Main](specifying-the-master-page-programmatically-vb/samples/sample11.aspx)]

на:

[!code-aspx[Main](specifying-the-master-page-programmatically-vb/samples/sample12.aspx)]

Вместо ссылки на путь к файлу свойство `@MasterType` теперь ссылается на базовый тип (`BaseMasterPage`). Следовательно, строго типизированное `Master` свойство, используемое в обеих страницах, теперь имеет тип `BaseMasterPage` (вместо типа `Site`). После этого изменения вернитесь `~/Admin/Products.aspx`. Ранее это привело к ошибке приведения, так как страница настроена на использование главной страницы `Alternate.master`, но директива `@MasterType` ссылалась на файл `Site.master`. Но теперь страница отображается без ошибок. Это обусловлено тем, что Главная страница `Alternate.master` может быть приведена к объекту типа `BaseMasterPage` (поскольку он расширяет ее).

В `~/Admin/AddProduct.aspx`необходимо внести одно небольшое изменение. Обработчик событий `ItemInserted` элемента управления DetailsView использует как строго типизированное свойство `Master`, так и слабо типизированное свойство `Page.Master`. Мы исправили строго типизированную ссылку, когда мы обновили директиву `@MasterType`, но нам по-прежнему нужно обновить слабо типизированную ссылку. Замените следующую строку кода:

[!code-vb[Main](specifying-the-master-page-programmatically-vb/samples/sample13.vb)]

Со следующим параметром, который приводит `Page.Master` к базовому типу:

[!code-vb[Main](specifying-the-master-page-programmatically-vb/samples/sample14.vb)]

## <a name="step-4-determining-what-master-page-to-bind-to-the-content-pages"></a>Шаг 4. определение главной страницы для привязки к страницам содержимого

В настоящее время наш класс `BasePage` задает для всех страниц содержимого свойства `MasterPageFile` жестко запрограммированным значением на этапе предварительной инициализации жизненного цикла страницы. Мы можем обновить этот код для создания главной страницы на основе какого-либо внешнего фактора. Возможно, эталонная страница загружается в зависимости от настроек пользователя, вошедшего в систему. В этом случае нам пришлось бы написать код в методе `OnPreInit` в `BasePage`, который ищет параметры главной страницы текущего пользователя.

Давайте создадим веб-страницу, позволяющую пользователю выбрать, какую эталонную страницу следует использовать — `Site.master` или `Alternate.master`-и сохранить этот выбор в переменной сеанса. Начните с создания новой веб-страницы в корневом каталоге с именем `ChooseMasterPage.aspx`. При создании этой страницы (или любой другой страницы содержимого, исходя этого) вам не нужно привязывать ее к главной странице, так как Главная страница задается программно в `BasePage`. Однако если вы не привязываете новую страницу к главной странице, декларативная разметка по умолчанию для новой страницы содержит веб-форму и другое содержимое, предоставленное главной страницей. Вам потребуется вручную заменить эту разметку соответствующими элементами управления содержимым. По этой причине я могу легко привязать новую страницу ASP.NET к главной странице.

> [!NOTE]
> Поскольку `Site.master` и `Alternate.master` имеют одинаковый набор элементов управления ContentPlaceHolder, не имеет значения, какая Главная страница выбрана при создании страницы содержимого. Для обеспечения согласованности я предлагаю использовать `Site.master`.

[![добавить новую страницу содержимого на веб-сайт](specifying-the-master-page-programmatically-vb/_static/image14.png)](specifying-the-master-page-programmatically-vb/_static/image13.png)

**Рис. 05**. Добавление новой страницы содержимого на веб-сайт ([щелкните, чтобы просмотреть изображение с полным размером](specifying-the-master-page-programmatically-vb/_static/image15.png))

Обновите файл `Web.sitemap`, включив в него запись для этого занятия. Добавьте следующую разметку под `<siteMapNode>` для занятия Master Pages и ASP.NET AJAX:

[!code-xml[Main](specifying-the-master-page-programmatically-vb/samples/sample15.xml)]

Прежде чем добавлять содержимое на `ChooseMasterPage.aspx` страницу, обновите класс кода программной части страницы, чтобы он наследовался от `BasePage` (а не `System.Web.UI.Page`). Затем добавьте на страницу элемент управления DropDownList, задайте для его свойства `ID` значение `MasterPageChoice`и добавьте два элемента ListItem с `Text` значениями "~/Сите.Мастер" и "~/Алтернате.Мастер".

Добавьте на страницу веб-элемент управления Button и задайте для его свойств `ID` и `Text` значение `SaveLayout` и "сохранить вариант макета" соответственно. На этом этапе декларативная разметка страницы должна выглядеть следующим образом:

[!code-aspx[Main](specifying-the-master-page-programmatically-vb/samples/sample16.aspx)]

При первом посещении страницы необходимо отобразить выбранный в данный момент выбор главной страницы пользователя. Создайте обработчик событий `Page_Load` и добавьте следующий код:

[!code-vb[Main](specifying-the-master-page-programmatically-vb/samples/sample17.vb)]

Приведенный выше код выполняется только при первом посещении страницы (а не при последующих обратных передачах). Сначала он проверяет, существует ли переменная сеанса `MyMasterPage`. В этом случае он пытается найти соответствующий элемент ListItem в элементе DropDownList `MasterPageChoice`. Если найден соответствующий элемент ListItem, его свойство `Selected` имеет значение `True`.

Нам также нужен код, сохраняющий выбранный пользователем вариант в `MyMasterPage` переменной сеанса. Создайте обработчик событий для `Click` события кнопки `SaveLayout` и добавьте следующий код:

[!code-vb[Main](specifying-the-master-page-programmatically-vb/samples/sample18.vb)]

> [!NOTE]
> К моменту, когда обработчик событий `Click` выполняется при обратной передаче, Главная страница уже выбрана. Таким образом, выбор раскрывающегося списка пользователя не вступит в силу до перехода на следующую страницу. `Response.Redirect` заставляет браузер повторно запрашивать `ChooseMasterPage.aspx`.

После завершения `ChooseMasterPage.aspx`ной страницы наша последняя задача заключается в том, чтобы `BasePage` назначить свойство `MasterPageFile` на основе значения переменной сеанса `MyMasterPage`. Если для переменной сеанса не задано значение по умолчанию `BasePage` `Site.master`.

[!code-vb[Main](specifying-the-master-page-programmatically-vb/samples/sample19.vb)]

> [!NOTE]
> Я переместил код, который назначает свойство `MasterPageFile` объекта `Page` из обработчика событий `OnPreInit` и в два отдельных метода. Первый метод, `SetMasterPageFile`, присваивает свойству `MasterPageFile` значение, возвращаемое вторым методом, `GetMasterPageFileFromSession`. Я пометил метод `SetMasterPageFile` `Overridable` таким образом, чтобы будущие классы, расширяющие `BasePage`, при необходимости могут переопределить его для реализации пользовательской логики. Ниже приведен пример переопределения свойства `BasePage``SetMasterPageFile` в следующем руководстве.

После этого кода посетите страницу `ChooseMasterPage.aspx`. Изначально выбирается Главная страница `Site.master` (см. рис. 6), но пользователь может выбрать другую главную страницу из раскрывающегося списка.

[![страницы содержимого отображаются с помощью главной страницы Site. master](specifying-the-master-page-programmatically-vb/_static/image17.png)](specifying-the-master-page-programmatically-vb/_static/image16.png)

**Рис. 6**. страницы содержимого отображаются с помощью главной страницы `Site.master` ([щелкните, чтобы просмотреть изображение с полным размером](specifying-the-master-page-programmatically-vb/_static/image18.png))

[![страницы содержимого теперь отображаются с помощью главной страницы альтернативного мастера.](specifying-the-master-page-programmatically-vb/_static/image20.png)](specifying-the-master-page-programmatically-vb/_static/image19.png)

**Рис. 07**. страницы содержимого теперь отображаются с помощью главной страницы `Alternate.master` ([щелкните, чтобы просмотреть изображение с полным размером](specifying-the-master-page-programmatically-vb/_static/image21.png))

## <a name="summary"></a>Сводка

При посещении страницы содержимого ее элементы управления содержимым имеют плавкие предохранители с элементами управления ContentPlaceHolder главной страницы. Эталонная страница страницы содержимого обозначается свойством `MasterPageFile` `Page` класса, которое назначается атрибуту `MasterPageFile` директивы `@Page` на этапе инициализации. Как было показано в этом руководстве, можно присвоить значение свойству `MasterPageFile`, пока оно выполняется до окончания этапа предварительной инициализации. Возможность программно указывать главную страницу открывает дверцу для более сложных сценариев, таких как динамическая привязка страницы содержимого к главной странице на основе внешних факторов.

Поздравляем с программированием!

### <a name="further-reading"></a>Дополнительные материалы

Дополнительные сведения о разделах, обсуждаемых в этом руководстве, см. в следующих ресурсах:

- [Схема жизненного цикла страницы ASP.NET](http://emanish.googlepages.com/Asp.Net2.0Lifecycle.PNG)
- [Общие сведения о жизненном цикле страницы ASP.NET](https://msdn.microsoft.com/library/ms178472.aspx)
- [Общие сведения о темах и обложках ASP.NET](https://msdn.microsoft.com/library/ykzx33wh.aspx)
- [Главные страницы: советы, приемы и ловушки](http://www.odetocode.com/articles/450.aspx)
- [Темы в ASP.NET](http://www.odetocode.com/articles/423.aspx)

### <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор нескольких книг по ASP/ASP. NET и основатель 4GuysFromRolla.com, работал с веб-технологиями майкрософт с 1998. Скотт работает как независимый консультант, преподаватель и модуль записи. Его последняя книга — [*Sams обучать себя ASP.NET 3,5 за 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672329972/4guysfromrollaco). Скотт можно получить по адресу [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com) или через свой блог по адресу [http://ScottOnWriting.NET](http://scottonwriting.net/).

### <a name="special-thanks-to"></a>Специальная благодарность

Эта серия руководств была рассмотрена многими полезными рецензентами. Специалист по интересу для этого руководства был Сучи Банержи. Хотите ознакомиться с моими будущими статьями MSDN? Если да, расположите строку в [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](master-pages-and-asp-net-ajax-vb.md)
> [Вперед](nested-master-pages-vb.md)
