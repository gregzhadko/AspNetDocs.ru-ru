---
uid: web-forms/overview/older-versions-getting-started/continuing-with-ef/maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application
title: Повышение производительности с помощью Entity Framework 4.0 в 4 веб-приложения ASP.NET | Документация Майкрософт
author: tdykstra
description: В этой серии руководств основана на веб-приложение университета Contoso, созданный по началу работы с этой серии руководств Entity Framework 4.0. I...
ms.author: riande
ms.date: 01/26/2011
ms.assetid: 4e43455e-dfa1-42db-83cb-c987703f04b5
msc.legacyurl: /web-forms/overview/older-versions-getting-started/continuing-with-ef/maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application
msc.type: authoredcontent
ms.openlocfilehash: 7d7c66289f09179a98e09532172477d5b06c70bd
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57063901"
---
<a name="maximizing-performance-with-the-entity-framework-40-in-an-aspnet-4-web-application"></a>Повышение производительности с помощью Entity Framework 4.0 в 4 веб-приложения ASP.NET
====================
по [том Дайкстра](https://github.com/tdykstra)

> В этой серии руководств основан на веб-приложение университета Contoso, которая создается с [Приступая к работе с Entity Framework 4.0](https://asp.net/entity-framework/tutorials#Getting%20Started) серии руководств. Если вы не прошли предыдущих учебных курсах, в качестве отправной точки для этого учебника вы можете [загрузить приложение](https://code.msdn.microsoft.com/ASPNET-Web-Forms-97f8ee9a) , он был создан. Вы также можете [загрузить приложение](https://code.msdn.microsoft.com/ASPNET-Web-Forms-6c7197aa) , созданный путем завершения серии руководств. Если у вас есть вопросы о учебники, их можно разместить [форум ASP.NET Entity Framework](https://forums.asp.net/1227.aspx).


В предыдущем руководстве вы узнали, как обрабатывать конфликты параллелизма. Мы продемонстрируем способах повышения производительности веб-приложения ASP.NET, использующего Entity Framework. Вы узнаете несколько методов для увеличения производительности или для диагностики проблем производительности.

Сведения, представленные в следующих разделах будут полезны в самых разных сценариях:

- Эффективно загружайте связанные данные.
- Управление состоянием представления.

Приведенная ниже информация может быть полезно при наличии отдельных запросов, наличии проблем с производительностью:

- Используйте `NoTracking` параметр слияния.
- Предварительная компиляция запросов LINQ.
- Проверьте запрос команды, отправляемые в базу данных.

Сведения, представленные в следующем разделе может быть полезно для приложений, имеющих очень больших моделей данных:

- Предварительное создание представлений.

> [!NOTE]
> Производительность веб-приложения зависит от многих факторов, включая размер данных, запросов и ответов, скорость запросов к базе данных, сколько запросов на сервере можно поместить в очередь и насколько быстро он может обслуживать их и даже повысить эффективность любого библиотеки клиентских сценариев, который может использоваться. Если важна производительность в приложении, или если тестирования или взаимодействие показывает, что производительность приложения не категории "Удовлетворительно", необходимо следовать обычного протокола для настройки производительности. Измерения для определения возникновения узких мест производительности, а затем исправьте областей, которые будет иметь наибольшее влияние на общую производительность приложения.
> 
> Этот раздел посвящен главным образом способами, в которой можно повысить производительность специально Entity Framework в ASP.NET. Здесь предложения полезны в том случае, если вы определили, что доступ к данным является одной из узкие места производительности в приложении. За исключением того, как было отмечено, методы, которые описаны здесь не должна считаться &quot;рекомендации&quot; в целом, многие из них подходят только в исключительных ситуациях или адрес очень определенным типам узких мест производительности.


Чтобы начать работу с учебником, запустите Visual Studio и откройте веб-приложение университета Contoso, работали в предыдущем учебном курсе.

## <a name="efficiently-loading-related-data"></a>Эффективно загрузка связанных данных

Существует несколько способов, что платформа Entity Framework может загружать связанные данные в свойства навигации сущности:

- *Отложенная загрузка*. При первом чтении сущности связанные данные не извлекаются. Однако при первой попытке доступа к свойству навигации необходимые для этого свойства навигации данные извлекаются автоматически. Это приводит к отправке нескольких запросов к базе данных — один для самой сущности и один каждый раз, что связанные данные для сущности должны извлекаться. 

    [![Image05](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image2.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image1.png)

*Безотложная загрузка*. При чтении сущности связанные данные извлекаются вместе с ней. Обычно такая загрузка представляет собой одиночный запрос с соединением, который получает все необходимые данные. Безотложная загрузка задается на основе `Include` метода, как вы уже видели в этих учебниках.

[![Image07](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image4.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image3.png)

- *Явная загрузка*. Это похоже на отложенной загрузки, за исключением того, что вы явно не извлечете связанные данные в коде; Это не происходит автоматически при доступе к свойству навигации. Загрузка связанных данных вручную с помощью `Load` метод свойства навигации для коллекций, либо использовать `Load` метод ссылочного свойства для свойства, которые содержат один объект. (Например, можно вызвать метод `PersonReference.Load` метод для загрузки `Person` свойство навигации `Department` сущности.)

    [![Image06](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image6.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image5.png)

Так как они не извлекают сразу же значения свойств, отложенная загрузка и явная загрузка также оба называются *отложенная загрузка*.

Отложенная загрузка является поведением по умолчанию для контекста объекта, созданный с помощью конструктора. Если вы откроете *SchoolModel.Designer.cs* файл, определяющий класс контекста объекта, вы найдете три метода-конструктора и каждого из них включает в себя следующую инструкцию:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample1.cs)]

Как правило, если вы знаете связанные данные потребуются для каждой сущности, полученного, упреждающая загрузка предлагает наилучшую производительность, поскольку одиночный запрос к базе данных обычно эффективнее нескольких отдельных запросов для каждой полученной сущности. С другой стороны, если вам нужно получить доступ к свойствам навигации сущности только редко или только для небольших набор сущностей, отложенная загрузка или явная загрузка может быть эффективнее, так как Безотложная загрузка будет получено больше данных, чем необходимо.

В веб-приложения отложенная загрузка может быть сравнительно мало пользы в любом случае, так, как выполнять действия пользователя, которые влияют на потребность в связанные данные в браузер, который не имеет подключения к контексту объекта, который к просмотру страницы. С другой стороны Если databind элемента управления обычно известно, какие требуются данные и поэтому обычно рекомендации для выбора упреждающую или отложенной загрузки на основе определяется разрешениями, подходящими в каждом сценарии.

Кроме того элемент управления с привязкой к данным может использовать объект сущности, после удаления контекста объекта. В этом случае произойдет сбой при попытке отложенную загрузку для свойства навигации. Сообщение об ошибке появляется очевиден: &quot;`The ObjectContext instance has been disposed and can no longer be used for operations that require a connection.`&quot;

`EntityDataSource` Управления по умолчанию отключает отложенную загрузку. Для `ObjectDataSource` управления что вы используете для данного учебника (или если можно получить доступ к контексту объекта в коде страницы), существует несколько способов внесения отложенная загрузка отключена по умолчанию. Его можно отключить при создании экземпляра контекста объекта. Например, можно добавить следующую строку в метод конструктора `SchoolRepository` класса:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample2.cs)]

Для приложения университета Contoso вносятся автоматически отключите отложенную загрузку, так что это свойство не должны быть заданы при создании экземпляра контекста контекст объекта.

Откройте *SchoolModel.edmx* модели данных, щелкните область конструктора и затем в панели «Свойства» задайте **отложенная загрузка включена** свойства `False`. Сохраните и закройте модели данных.

[![Image04](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image8.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image7.png)

## <a name="managing-view-state"></a>Управление состоянием представления

Чтобы обеспечить возможность обновления, веб-страницу ASP.NET необходимо хранить исходные значения свойств сущности, при отображении страницы. Во время обратной передачи, обработки элемент управления можно повторно создать исходное состояние сущности и вызвать его `Attach` метод перед применением изменений и вызов `SaveChanges` метод. По умолчанию элементы управления данными веб-форм ASP.NET используют состояние представления для хранения оригинальных значений. Тем не менее состояние представления может повлиять на производительность, поскольку он хранится в скрытых полях, которые может существенно увеличить размер страницы, которая отправляется к обозревателю и от него.

Методы управления состояние представления или альтернативные варианты, например состояние сеанса, не уникальные для Entity Framework, так в этом руководстве не могу в этом разделе подробно. Дополнительные сведения см. по ссылкам в конце этого руководства.

Тем не менее, версия 4 ASP.NET предлагает новый способ работы с состоянием представления, каждый разработчик ASP.NET, веб-форм приложений следует обратить внимание: `ViewStateMode` свойство. Это новый свойство может задаваться на уровне страницы или элемента управления, и это дает возможность отключить состояние представления для страницы по умолчанию и включить только для элементов управления, которым она необходима.

Для приложений, где важна производительность рекомендуется всегда отключить состояние просмотра на уровне страницы и включить только для элементов управления, которые ее требуют. Размер состояния представления на страницах университета Contoso бы значительно возрасти этот метод, но чтобы увидеть, как это работает, мы сделаем это *Instructors.aspx* страницы. Эта страница содержит много элементов управления, включая `Label` элемента управления, имеющего состояние просмотра отключено. Фактически ни один из элементов управления на этой странице необходимо иметь представление состояние включено. ( `DataKeyNames` Свойство `GridView` управления определяет состояния, которая должна сохраняться между обратными передачами, но эти значения хранятся в состоянии элемента управления, которое не влияют `ViewStateMode` свойство.)

`Page` Директивы и `Label` разметка элемента управления, в настоящее время, аналогичный приведенному ниже:

[!code-aspx[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample3.aspx)]

Внесите следующие изменения:

- Добавить `ViewStateMode="Disabled"` для `Page` директива.
- Удалить `ViewStateMode="Disabled"` из `Label` элемента управления.

Теперь разметку приведенной в следующем примере:

[!code-aspx[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample4.aspx)]

Теперь состояние просмотра отключено для всех элементов управления. Если позже добавить элемент управления, который нужно использовать состояние представления, необходимо сделать, включают `ViewStateMode="Enabled"` атрибута для этого элемента управления.

## <a name="using-the-notracking-merge-option"></a>С помощью параметра слияния NoTracking

Когда контексту объекта извлекает строки базы данных и создает представляющие их объекты сущностей, по умолчанию он также отслеживает эти объекты сущности, с помощью его диспетчер состояния объекта. Эти данные отслеживания выступает в роли кэша и используется при обновлении сущности. Поскольку веб-приложения обычно имеет короткоживущего объекта контекста экземпляров, запросы часто возвращают данные, которые не должны отслеживаться, поскольку контекст объекта, который считывает их будет удален, прежде, чем любые элементы, которые он считывает используются еще раз или обновлении.

В Entity Framework, можно указать, отслеживает ли контексту объекта объектов сущностей, задав *merge-параметр*. Можно задать параметр слияния для отдельных запросов, или для наборов сущностей. Если задать для набора сущностей, это означает, что задается параметром слияния по умолчанию для всех запросов, созданных для этого набора сущностей.

Для приложения университета Contoso, отслеживания не нужен для любого набора сущностей, которые доступны из репозитория, чтобы можно было задать параметр слияния `NoTracking` для этих наборов сущностей, при создании экземпляра контекста объекта в класс репозитория. (Обратите внимание, что в данном случае параметр слияния не будет заметно влияет на производительность приложения. `NoTracking` Скорее всего улучшить производительность наблюдаемый только в определенных сценариях защиты с большим объемом данных.)

В папке DAL, откройте *SchoolRepository.cs* и добавьте в метод-конструктор, который задает параметр слияния, для наборы сущностей, что хранилище имеет доступ к:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample5.cs)]

## <a name="pre-compiling-linq-queries"></a>Предварительная компиляция запросов LINQ

При первом Entity Framework выполняет запрос Entity SQL в рамках жизненного цикла данного `ObjectContext` экземпляра, потребуется некоторое время для компиляции запроса. Результат компиляции кэшируется, который означает, что последующие выполнения запроса, намного быстрее. Запросы LINQ имеют схожий шаблон, за исключением того, что некоторые действия, необходимые для компиляции запроса выполняется каждый раз при выполнении запроса. Другими словами для запросов LINQ, по умолчанию не все результаты компиляции кэшируются.

Если у вас есть запрос LINQ, который предполагается выполнять несколько раз в жизни контекста объекта, можно написать код, который заставляет все результаты компиляции кэшироваться при первом запуске запроса LINQ.

Как пример, вы сделаете это для двух `Get` методы в `SchoolRepository` класс, один из которых не принимает никаких параметров ( `GetInstructorNames` метод) и один, который требует параметра ( `GetDepartmentsByAdministrator` метод). Эти методы так, как они используются теперь фактически не требуется скомпилировать, поскольку они не являются запросов LINQ.

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample6.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample7.cs)]

Тем не менее таким образом, вы можете опробовать скомпилированных запросов, будет продолжить так, как если бы они были записаны как следующие запросы LINQ:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample8.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample9.cs)]

Можно изменить код в этих методах что показано выше, и запустите приложение, чтобы убедиться, что он работает, прежде чем продолжить. Однако приведенные ниже инструкции перейти сразу к предварительно скомпилированные версии их создания.

Создайте файл класса в *DAL* папки, назовите его *SchoolEntities.cs*и замените существующий код следующим кодом:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample10.cs)]

Этот код создает разделяемый класс, расширяющий класс контекста автоматически созданный объект. Разделяемый класс содержит два скомпилированные запросы LINQ с помощью `Compile` метод `CompiledQuery` класса. Он также создает методы, которые можно использовать для вызова запросов. Сохраните и закройте этот файл.

Затем в *SchoolRepository.cs*, измените существующий `GetInstructorNames` и `GetDepartmentsByAdministrator` методы в хранилище класса таким образом, чтобы они вызывают скомпилированных запросов:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample11.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample12.cs)]

Запустите *Departments.aspx* страницу, чтобы убедиться, что оно работает, как и раньше. `GetInstructorNames` Метод вызывается для заполнения раскрывающегося списка администраторов и `GetDepartmentsByAdministrator` метод вызывается при нажатии кнопки **обновление** чтобы убедитесь, что не instructor из более чем одного администратора отдел.

[![Image03](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image10.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image9.png)

Вы уже предварительно скомпилированные запросы только для того, чтобы узнать, как это сделать, не так, как он позволяет улучшить значительно производительность приложения университета Contoso. Предварительная компиляция запросов LINQ добавить уровень сложности в код, поэтому убедитесь, что это делается только для запросов, которые фактически описывают узкие места производительности в приложении.

## <a name="examining-queries-sent-to-the-database"></a>Анализ запросов, отправляемых в базу данных

Когда вы изучаете проблемы с производительностью, иногда бывает полезно знать точный команды SQL, Entity Framework отправляет в базу данных. Если вы работаете с `IQueryable` объекта, один из способов сделать это является использование `ToTraceString` метод.

В *SchoolRepository.cs*, измените код в `GetDepartmentsByName` метода в соответствии со следующим примером:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample13.cs)]

`departments` Переменной должен быть приведен к `ObjectQuery` введите только потому, что `Where` создает метод в конце предыдущей строки `IQueryable` объекта; без `Where` метод, приведение было бы не нужно.

Установите точку останова на `return` строки, а затем запустите *Departments.aspx* страницы в отладчике. Когда будет достигнута точка останова, изучите `commandText` переменных в **"Локальные"** окно и используйте средство визуализации текста (увеличительное стекло в **значение** столбец) для отображения его значения в **Визуализатор текста** окна. Вы увидите вся команда SQL, полученный в результате этот код:

[![Image08](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image12.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image11.png)

Кроме того функция IntelliTrace в Visual Studio Ultimate позволяет просмотреть команды SQL, созданные платформой Entity Framework, не требуется вносить изменения в код или даже установить точку останова.

> [!NOTE]
> Следующие процедуры можно выполнить только в том случае, если вы используете Visual Studio Ultimate.


Восстановить исходный код в `GetDepartmentsByName` метод, а затем выполните *Departments.aspx* страницы в отладчике.

В Visual Studio выберите **Отладка** меню, затем **IntelliTrace**, а затем **события IntelliTrace**.

[![Image11](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image14.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image13.png)

В **IntelliTrace** окно, нажмите кнопку **прервать все**.

[![Image12](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image16.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image15.png)

**IntelliTrace** окне отображается список последних событий:

[![Image09](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image18.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image17.png)

Нажмите кнопку **ADO.NET** строки. Он расширяет Показать текст команды:

[![Image10](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image20.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image19.png)

Вся команда текстовую строку можно скопировать в буфер обмена из **"Локальные"** окна.

Предположим, что вы работали с базой данных с помощью дополнительные таблицы, связи и столбцов, чем простой `School` базы данных. Может оказаться, что запрос, который собирает всю информацию, необходимо в одном `Select` инструкции, содержащей несколько `Join` предложений становится слишком сложной для эффективной работы. В этом случае можно перейти от Безотложная загрузка для явной загрузки для упрощения запроса.

Например, попробуйте изменить код в `GetDepartmentsByName` метод в *SchoolRepository.cs*. В настоящее время тем, что метод имеет запрос объектов с `Include` методы для `Person` и `Courses` свойства навигации. Замените `return` инструкции с кодом, который выполняет явную загрузку, как показано в следующем примере:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample14.cs)]

Запустите *Departments.aspx* в отладчик и проверьте **IntelliTrace** окно еще раз, как вы делали раньше. Когда выполнялся отдельный запрос перед, вы увидите длинную последовательность из них.

[![Image13](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image22.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image21.png)

Щелкните первый **ADO.NET** строки, чтобы увидеть, что произошло с сложного запроса можно просмотреть ранее.

[![Image14](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image24.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image23.png)

Запрос из отделов стала простой `Select` запрос, не имеющий `Join` предложение, но его следует с помощью отдельных запросов, которые получают сопутствующие курсы и администратора, используя набор двух запросов для каждого отдела возвращаемых первоначальным методом запрос.

> [!NOTE]
> Если оставить отложенная загрузка включена, шаблон, который здесь можно увидеть с помощью множества приемов, и тот же запрос может быть вызвано отложенную загрузку. Шаблон, который вы обычно хотите избежать — отложенная загрузка связанных данных для каждой строки таблицы первичного. Если вы убедились, что одиночный запрос с соединением является слишком сложным, чтобы быть эффективным, обычно будет возможность повысить производительность в таких случаях путем изменения основного запроса использовать безотложную загрузку.


## <a name="pre-generating-views"></a>Предварительное создание представлений

Когда `ObjectContext` сначала создается объект в новый домен приложения, Entity Framework создает набор классов, используемых для доступа к базе данных. Эти классы называются *представления*, и если у вас есть очень большой модели данных, создание этих представлений могут вызвать задержку ответа веб сайта, на первый запрос страницы после инициализации нового домена приложения. Эта задержка первого запроса можно уменьшить путем создания представлений во время компиляции, а не во время выполнения.

> [!NOTE]
> Если приложение не имеет слишком большой моделью, или если он имеет большой модели данных, но вы не беспокоит возможная проблема производительности, которая затрагивает только первый запрос страницы, после перезапуска IIS, этот раздел можно пропустить. Просмотр, создание не происходит каждый раз при создании экземпляра `ObjectContext` объекта, так как представления, кэшируются в домене приложения. Таким образом Если часто перезапуск приложения в IIS, очень мало запросов страниц целесообразно использовать заранее созданные представления.


Можно предварительно создать представления, используя *EdmGen.exe* средство командной строки или с помощью *Text Template Transformation Toolkit* шаблона (T4). В этом руководстве вы используете шаблон T4.

В *DAL* папки, добавьте в файл с помощью **текстового шаблона** шаблона (под **Общие** узел в **установленные шаблоны** списка), и назовите его *SchoolModel.Views.tt*. Замените существующий код в файле следующим кодом:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample15.cs)]

Этот код формирует представления для *.edmx* файл, расположенный в той же папке, что шаблон и с тем же именем файла шаблона. Например, если файл шаблона называется *SchoolModel.Views.tt*, он будет искать файл модели данных с именем *SchoolModel.edmx*.

Сохраните файл, а затем щелкните правой кнопкой мыши файл в **обозревателе решений** и выберите **пользовательское средство**.

[![Image02](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image26.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image25.png)

Visual Studio создает файл кода, создающий представления, которая называется *SchoolModel.Views.cs* на основе шаблона. (Вы могли заметить, что создается файл кода, даже в том случае, прежде чем выбрать **пользовательское средство**, как только вы сохраните файл шаблона.)

[!["Image01"](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image28.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image27.png)

Теперь можно запустить приложение и убедиться, что оно работает, как и раньше.

Дополнительные сведения о предварительно созданные представления см. следующие ресурсы:

- [Практическое руководство. Предварительное создание представлений для повышения производительности запросов](https://msdn.microsoft.com/library/bb896240.aspx) веб-сайте MSDN. Содержит сведения об использовании `EdmGen.exe` средство командной строки, чтобы заранее создать представления.
- [Изоляция производительности предкомпилированный или до создания представлений в Entity Framework 4](https://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/isolating-performance-with-precompiled-pre-generated-views-in-the-entity-framework-4.aspx) в блоге группы консультирования клиентов Windows Server AppFabric.

На этом завершается во введении к повышению производительности в веб-приложения ASP.NET, использующего Entity Framework. Дополнительные сведения см. в следующих ресурсах:

- [Вопросы производительности (Entity Framework)](https://msdn.microsoft.com/library/cc853327.aspx) веб-сайте MSDN.
- [Сообщения, связанные с производительностью, в блоге группы Entity Framework](https://blogs.msdn.com/b/adonet/archive/tags/performance/).
- [EF параметры слияния и скомпилированные запросы](https://blogs.msdn.com/b/dsimmons/archive/2010/01/12/ef-merge-options-and-compiled-queries.aspx). Запись блога с объяснением непредсказуемого поведения скомпилированных запросов и объединения параметрами как `NoTracking`. Если вы планируете использовать скомпилированные запросы и изменять параметры слияния в приложении, сначала прочтите следующее.
- [Entity Framework связанные сообщения в блоге данных и моделирования группы консультирования клиентов](https://blogs.msdn.com/b/dmcat/archive/tags/entity+framework/). Включает в себя записи об скомпилированных запросов и обнаружить проблемы с производительностью с помощью Visual Studio Profiler 2010.
- [Обсуждение форума Entity Framework советы по повышению производительности высокой сложности запросов](https://social.msdn.microsoft.com/Forums/adodotnetentityframework/thread/ffe8b2ab-c5b5-4331-8988-33a872d0b5f6).
- [Рекомендации по управлению состоянием ASP.NET](https://msdn.microsoft.com/library/z1hkazw7.aspx).
- [Использование Entity Framework и элемент управления ObjectDataSource. Пользовательское разбиение по страницам](http://geekswithblogs.net/Frez/articles/using-the-entity-framework-and-the-objectdatasource-custom-paging.aspx). Запись блога, которая основана на ContosoUniversity приложение, созданное в этих руководствах объясняется, как реализовать разбиение по страницам в *Departments.aspx* страницы.

Следующем учебном курсе рассматриваются некоторые из важных улучшений для Entity Framework, которые появились в версии 4.

> [!div class="step-by-step"]
> [Назад](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application.md)
> [Вперед](what-s-new-in-the-entity-framework-4.md)
