---
uid: web-forms/overview/older-versions-getting-started/continuing-with-ef/maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application
title: Увеличение производительности с помощью Entity Framework 4,0 в веб-приложении ASP.NET 4 | Документация Майкрософт
author: tdykstra
description: Эта серия руководств основана на веб-приложении университета Contoso, которое создается начало работы с руководством по Entity Framework 4,0. Он...
ms.author: riande
ms.date: 01/26/2011
ms.assetid: 4e43455e-dfa1-42db-83cb-c987703f04b5
msc.legacyurl: /web-forms/overview/older-versions-getting-started/continuing-with-ef/maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application
msc.type: authoredcontent
ms.openlocfilehash: 5630200a1ad1d30f6d89b38e15179f15b699fa9f
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78439266"
---
# <a name="maximizing-performance-with-the-entity-framework-40-in-an-aspnet-4-web-application"></a>Увеличение производительности с помощью Entity Framework 4,0 в веб-приложении ASP.NET 4

от [Tom Dykstra)](https://github.com/tdykstra)

> Эта серия руководств основана на веб-приложении университета Contoso, которое создается [Начало работы с руководством по Entity Framework 4,0](https://asp.net/entity-framework/tutorials#Getting%20Started) . Если вы не выполнили предыдущие учебники, в качестве отправной точки для этого учебника вы можете скачать созданное [приложение](https://code.msdn.microsoft.com/ASPNET-Web-Forms-97f8ee9a) . Вы также можете [скачать приложение](https://code.msdn.microsoft.com/ASPNET-Web-Forms-6c7197aa) , созданное с помощью полной серии руководств. Если у вас есть вопросы о учебниках, их можно опубликовать на [форуме ASP.NET Entity Framework](https://forums.asp.net/1227.aspx).

В предыдущем руководстве вы узнали, как справляться с конфликтами параллелизма. В этом руководстве приведены параметры для повышения производительности веб-приложения ASP.NET, использующего Entity Framework. Вы узнаете о нескольких методах максимизации производительности или диагностике проблем с производительностью.

Сведения, представленные в следующих разделах, скорее всего, будут полезны в самых разных сценариях:

- Эффективная загрузка связанных данных.
- Управление состоянием представления.

Сведения, представленные в следующих разделах, могут быть полезны при наличии отдельных запросов, представляющих проблемы с производительностью.

- Используйте параметр слияния `NoTracking`.
- Предварительно компилировать запросы LINQ.
- Проверьте команды запроса, отправленные в базу данных.

Сведения, представленные в следующем разделе, потенциально полезны для приложений с очень большими моделями данных:

- Предварительно создавать представления.

> [!NOTE]
> Производительность веб-приложений зависит от многих факторов, в том числе от размера данных запроса и ответа, скорости запросов к базе данных, количества запросов, которые сервер может поставить в очередь, а также от того, насколько быстро он может их обслуживать, а также эффективность любого библиотеки клиентских скриптов, которые вы можете использовать. Если в вашем приложении важна производительность или если тестирование или опыт показывает, что производительность приложения не подходит, следует соблюдать стандартный протокол для настройки производительности. Определите, где возникают узкие места производительности, а затем разрешите области, которые будут оказывать наибольшее влияние на общую производительность приложения.
> 
> В этом разделе основное внимание уделяется способам, с помощью которых можно улучшить производительность специально для Entity Framework в ASP.NET. Рекомендации здесь полезны, если вы определили, что доступ к данным является одним из узких мест производительности в приложении. Если не указано иное, описанные здесь методы не должны рассматриваться &quot;рекомендациями&quot; в целом, многие из них подходят только в исключительных ситуациях или для решения самых узких мест, связанных с производительностью.

Чтобы начать работу с руководством, запустите Visual Studio и откройте веб-приложение Contoso университета, с которым вы работали в предыдущем руководстве.

## <a name="efficiently-loading-related-data"></a>Эффективная загрузка связанных данных

Существует несколько способов, с помощью которых Entity Framework может загружать связанные данные в свойства навигации сущности:

- *Отложенная загрузка*. При первом чтении сущности связанные данные не извлекаются. Однако при первой попытке доступа к свойству навигации необходимые для этого свойства навигации данные извлекаются автоматически. В результате в базу данных отправляются несколько запросов — одна для самой сущности, а другая — каждый раз, когда необходимо извлечь связанные данные для сущности. 

    [![Image05](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image2.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image1.png)

*Безотложная загрузка*. При чтении сущности связанные данные извлекаются вместе с ней. Обычно такая загрузка представляет собой одиночный запрос с соединением, который получает все необходимые данные. Вы указываете безотлагательную загрузку с помощью метода `Include`, как вы уже видели в этих учебниках.

[![Image07](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image4.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image3.png)

- *Явная загрузка*. Это похоже на отложенную загрузку за исключением того, что вы явно извлечете связанные данные в коде. Это не происходит автоматически при доступе к свойству навигации. Связанные данные загружаются вручную с помощью метода `Load` свойства навигации для коллекций или с помощью метода `Load` ссылочного свойства для свойств, содержащих один объект. (Например, вызов метода `PersonReference.Load` для загрузки свойства навигации `Person` сущности `Department`.)

    [![Image06](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image6.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image5.png)

Поскольку они не извлекают значения свойств немедленно, отложенная загрузка и явная загрузка также называются *отложенной загрузкой*.

Отложенная загрузка является поведением по умолчанию для контекста объекта, созданного конструктором. При открытии файла *SchoolModel.Designer.CS* , определяющего класс контекста объекта, можно найти три метода конструктора, каждый из которых включает следующую инструкцию:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample1.cs)]

Как правило, если известно, что для каждой полученной сущности необходимы связанные данные, безотлагательная загрузка обеспечивает наилучшую производительность, поскольку один запрос, отправленный в базу данных, обычно более эффективен, чем отдельные запросы для каждой полученной сущности. С другой стороны, если нужно получить доступ к свойствам навигации сущности только редко или только для небольшого набора сущностей, отложенная загрузка или явная загрузка может оказаться более эффективной, поскольку при безотлагательной загрузке будут извлекаться больше данных, чем требуется.

В веб-приложении отложенная загрузка может быть относительно незначительной величиной, так как действия пользователя, влияющие на необходимость связанных данных, выполняются в браузере, который не имеет соединения с контекстом объекта, который визуализирует страницу. С другой стороны, при привязку элемента управления, как правило, известно, какие данные вам нужны, и, как правило, лучше выбрать нерешенную загрузку или отложенную загрузку в зависимости от того, что подходит для каждого сценария.

Кроме того, элемент управления с привязкой к данным может использовать объект сущности после удаления контекста объекта. В этом случае попытка отложенной загрузки свойства навигации завершится ошибкой. Полученное сообщение об ошибке можно очистить: &quot;`The ObjectContext instance has been disposed and can no longer be used for operations that require a connection.`&quot;

Элемент управления `EntityDataSource` отключает отложенную загрузку по умолчанию. Для элемента управления `ObjectDataSource`, который вы используете для текущего учебника (или при доступе к контексту объекта из кода страницы), существует несколько способов сделать отложенную загрузку отключенной по умолчанию. Его можно отключить при создании экземпляра контекста объекта. Например, в метод конструктора класса `SchoolRepository` можно добавить следующую строку:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample2.cs)]

Для приложения университета Contoso вы сделаете контекст объекта автоматически отключать отложенную загрузку, чтобы это свойство не запускалось при создании экземпляра контекста.

Откройте модель данных *счулмодел. EDMX* , щелкните область конструктора, а затем в области Свойства установите для свойства **Enabled отложенная загрузка** значение `False`. Сохраните и закройте модель данных.

[![Image04](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image8.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image7.png)

## <a name="managing-view-state"></a>Управление состоянием представления

Чтобы обеспечить функциональность обновления, на веб-странице ASP.NET должны храниться исходные значения свойств сущности при подготовке страницы к просмотру. Во время обработки обратной передачи элемент управления может повторно создать исходное состояние сущности и вызвать метод `Attach` сущности перед применением изменений и вызовом метода `SaveChanges`. По умолчанию ASP.NET элементы управления данными веб-форм используют состояние представления для хранения исходных значений. Однако состояние представления может повлиять на производительность, так как оно хранится в скрытых полях, что может существенно увеличить размер страницы, отправляемой в браузер и из нее.

Методы управления состоянием представления или такие альтернативы, как состояние сеанса, не уникальны для Entity Framework, поэтому в этом учебнике подробно рассматривается этот раздел. Дополнительные сведения см. по ссылкам в конце этого руководства.

Однако версия 4 ASP.NET предоставляет новый способ работы с состоянием представления, который должен знать каждый разработчик ASP.NET приложений веб-форм: `ViewStateMode` свойство. Это новое свойство может быть задано на уровне страницы или элемента управления и позволяет отключать состояние представления по умолчанию для страницы и включать его только для элементов управления, которым она нужна.

Для приложений, в которых важна производительность, рекомендуется всегда отключать состояние просмотра на уровне страницы и включать его только для элементов управления, которым он необходим. Размер представления на страницах университета Contoso не был существенно уменьшен с помощью этого метода, но чтобы увидеть, как он работает, вы сделаете это на странице *инструкторы. aspx* . Эта страница содержит множество элементов управления, в том числе элемент управления `Label` с отключенным состоянием представления. Ни один из элементов управления на этой странице не должен включать состояние просмотра. (Свойство `DataKeyNames` элемента управления `GridView` указывает состояние, которое должно поддерживаться между обратными передачами, но эти значения хранятся в состоянии элемента управления, которое не зависит от свойства `ViewStateMode`.)

Директива `Page` и разметка элемента управления `Label` в данный момент напоминает следующий пример:

[!code-aspx[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample3.aspx)]

Выполните следующие изменения:

- Добавьте `ViewStateMode="Disabled"` в директиву `Page`.
- Удалите `ViewStateMode="Disabled"` из элемента управления `Label`.

Теперь разметка напоминает следующий пример:

[!code-aspx[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample4.aspx)]

Состояние представления теперь отключено для всех элементов управления. Если позднее добавить элемент управления, который должен использовать состояние представления, то все, что нужно, — это включить атрибут `ViewStateMode="Enabled"` для этого элемента управления.

## <a name="using-the-notracking-merge-option"></a>Использование параметра слияния with Tracking

Когда контекст объекта получает строки базы данных и создает объекты сущностей, которые их представляют, по умолчанию они также отслеживают эти объекты сущностей с помощью диспетчера состояний объектов. Эти данные отслеживания действуют как кэш и используются при обновлении сущности. Так как веб-приложение обычно имеет кратковременные экземпляры контекста объектов, запросы часто возвращают данные, которые не нужно относить, так как контекст объекта, считывающий их, будет удален до тех пор, пока не будут использованы операции чтения.

В Entity Framework можно указать, будет ли контекст объекта отслеживать объекты сущностей, установив *параметр слияния*. Параметр MERGE можно задать для отдельных запросов или для наборов сущностей. Если задать его для набора сущностей, то это означает, что вы устанавливаете параметр слияния по умолчанию для всех запросов, создаваемых для этого набора сущностей.

Для приложения университета Contoso отслеживание не требуется для всех наборов сущностей, доступ к которым осуществляется из репозитория, поэтому можно установить параметр слияния для `NoTracking` этих наборов сущностей при создании экземпляра контекста объекта в классе репозитория. (Обратите внимание, что в этом руководстве Установка параметра слияния не оказывает заметного влияния на производительность приложения. Параметр `NoTracking`, скорее всего, сделает наблюдаемое улучшение производительности только в определенных сценариях с большими объемами данных.)

В папке DAL откройте файл *SchoolRepository.CS* и добавьте метод-конструктор, который задает параметр Merge для наборов сущностей, к которым обращается репозиторий:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample5.cs)]

## <a name="pre-compiling-linq-queries"></a>Предварительная компиляция запросов LINQ

В первый раз, когда Entity Framework выполняет Entity SQL запрос в течение жизненного цикла данного экземпляра `ObjectContext`, компиляция запроса занимает некоторое время. Результат компиляции кэшируется, что означает, что последующие выполнения запроса выполняются гораздо быстрее. Запросы LINQ соответствуют аналогичному шаблону, за исключением того, что некоторые операции, необходимые для компиляции запроса, выполняются при каждом выполнении запроса. Иными словами, для запросов LINQ по умолчанию кэшируются не все результаты компиляции.

При наличии запроса LINQ, который будет повторяться в течение всего времени существования контекста объекта, можно написать код, который вызывает кэширование всех результатов компиляции при первом выполнении запроса LINQ.

Как показано на рисунке, это делается для двух `Get` методов в классе `SchoolRepository`, один из которых не принимает никаких параметров (метод `GetInstructorNames`) и один, для которого требуется параметр (метод `GetDepartmentsByAdministrator`). Эти методы, в действительности, не должны компилироваться, так как они не являются запросами LINQ:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample6.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample7.cs)]

Однако, чтобы можно было испытать скомпилированные запросы, вы продолжите, как если бы они были написаны в виде следующих запросов LINQ:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample8.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample9.cs)]

Вы можете изменить код в этих методах на показанный выше и запустить приложение, чтобы убедиться, что оно работает, прежде чем продолжить. Но приведенные ниже инструкции позволяют сразу перейти к созданию предварительно скомпилированных версий.

Создайте файл класса в папке *DAL* , назовите его *SchoolEntities.CS*и замените существующий код следующим кодом:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample10.cs)]

Этот код создает разделяемый класс, расширяющий автоматически созданный класс контекста объекта. Разделяемый класс включает два скомпилированных запроса LINQ с помощью метода `Compile` класса `CompiledQuery`. Он также создает методы, которые можно использовать для вызова запросов. Сохраните и закройте этот файл.

Затем в *SchoolRepository.CS*измените существующие методы `GetInstructorNames` и `GetDepartmentsByAdministrator` в классе репозитория так, чтобы они вызывали скомпилированные запросы:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample11.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample12.cs)]

Запустите страницу *departmentss. aspx* , чтобы убедиться, что она работает, как и раньше. Метод `GetInstructorNames` вызывается для заполнения раскрывающегося списка администратором, а метод `GetDepartmentsByAdministrator` вызывается при нажатии кнопки **Обновить** , чтобы убедиться, что ни один из преподавателей не является администратором нескольких отделов.

[![Image03](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image10.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image9.png)

Вы выполнили предварительно скомпилированные запросы в приложении Contoso университета, чтобы узнать, как это сделать, не так как это значительно улучшает бы повысить производительность. Предварительная компиляция запросов LINQ добавляет к коду уровень сложности, поэтому убедитесь, что он выполняется только для запросов, которые представляют узкие места производительности в приложении.

## <a name="examining-queries-sent-to-the-database"></a>Проверка запросов, отправленных в базу данных

При изучении проблем с производительностью иногда бывает полезно определить точные команды SQL, отправляемые Entity Framework в базу данных. Если вы работаете с объектом `IQueryable`, одним из способов сделать это является использование метода `ToTraceString`.

В *SchoolRepository.CS*измените код в методе `GetDepartmentsByName` в соответствии со следующим примером:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample13.cs)]

`departments` переменная должна быть приведена к типу `ObjectQuery` только потому, что метод `Where` в конце предыдущей строки создает объект `IQueryable`. без метода `Where` приведение не потребуется.

Установите точку останова на `return` строке, а затем запустите страницу *departmentss. aspx* в отладчике. При достижении точки останова изучите переменную `commandText` в окне **локальные** и используйте визуализатор текста (лупа в столбце **значение** ), чтобы отобразить его значение в окне **визуализатора текста** . Можно увидеть всю команду SQL, полученную в результате этого кода:

[![Image08](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image12.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image11.png)

В качестве альтернативы функция IntelliTrace в Visual Studio Ultimate предоставляет способ просмотра команд SQL, созданных Entity Framework, которые не нуждаются в изменении кода или даже задании точки останова.

> [!NOTE]
> Следующие процедуры можно выполнять только в том случае, если у вас Visual Studio Ultimate.

Восстановите исходный код в методе `GetDepartmentsByName`, а затем запустите страницу *departmentss. aspx* в отладчике.

В Visual Studio выберите меню **Отладка** , затем **IntelliTrace**, а затем **события IntelliTrace**.

[![Image11](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image14.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image13.png)

В окне **IntelliTrace** щелкните **прервать все**.

[![Image12](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image16.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image15.png)

В окне **IntelliTrace** отображается список недавних событий:

[![Image09](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image18.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image17.png)

Щелкните строку **ADO.NET** . Он разворачивается для отображения текста команды:

[![Image10](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image20.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image19.png)

Вы можете скопировать всю строку текста команды в буфер обмена из окна **локальные** .

Предположим, что вы работали с базой данных с большим количеством таблиц, связей и столбцов, чем у простой `School` базы данных. Может оказаться, что запрос, собирающий всю необходимую информацию в одной `Select` инструкции, содержащей несколько `Join`ных предложений, станет слишком сложной для эффективной работы. В этом случае можно переключиться с безотлагательной загрузки на явную загрузку, чтобы упростить запрос.

Например, попробуйте изменить код в методе `GetDepartmentsByName` в *SchoolRepository.CS*. В настоящее время в этом методе имеется запрос объектов, который содержит `Include` методы для свойств навигации `Person` и `Courses`. Замените инструкцию `return` кодом, который выполняет явную загрузку, как показано в следующем примере:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample14.cs)]

Запустите страницу *departmentss. aspx* в отладчике и снова проверьте окно **IntelliTrace** . Теперь, когда ранее существовал один запрос, вы увидите их длинную последовательность.

[![Image13](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image22.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image21.png)

Щелкните первую строку **ADO.NET** , чтобы увидеть, что произошло с сложным запросом, который вы просматривали ранее.

[![Image14](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image24.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image23.png)

Запрос из отделов стал простым `Select`ным запросом без предложения `Join`, но за ним следуют отдельные запросы, которые извлекают связанные курсы и администратора, используя набор из двух запросов для каждого отдела, возвращенного исходным запросом.

> [!NOTE]
> Если вы оставляете отложенную загрузку, то шаблон, который вы видите здесь, с тем же запросом повторяется несколько раз, может быть результатом отложенной загрузки. Шаблон, который, как правило, следует избегать, — это данные, связанные с отложенной загрузкой для каждой строки основной таблицы. Если вы не прошли проверку того, что один запрос на соединение слишком сложен, чтобы быть эффективным, вы, как правило, сможете повысить производительность в таких случаях, изменив основной запрос для использования безотлагательной загрузки.

## <a name="pre-generating-views"></a>Предварительное создание представлений

Когда объект `ObjectContext` впервые создается в новом домене приложения, Entity Framework создает набор классов, используемых для доступа к базе данных. Эти классы называются *представлениями*. при наличии очень большой модели данных создание этих представлений может замедлить ответ веб-сайта на первый запрос страницы после инициализации нового домена приложения. Эту задержку первого запроса можно сократить, создав представления во время компиляции, а не во время выполнения.

> [!NOTE]
> Если приложение не имеет чрезвычайно большой модели данных или имеет большую модель данных, но вы не беспокоитесь о проблеме с производительностью, которая влияет только на самый первый запрос страницы после перезапуска IIS, этот раздел можно пропустить. Создание представления не происходит при каждом создании экземпляра объекта `ObjectContext`, так как представления кэшируются в домене приложения. Таким образом, если вы часто не используете приложение в IIS, очень небольшое количество запросов страниц может оказаться выгодным для предварительно созданных представлений.

Представления можно предварительно создавать с помощью программы командной строки *EdmGen. exe* или шаблона средства *преобразования текстовых шаблонов* (T4). В этом учебнике используется шаблон T4.

В папке *DAL* добавьте файл с помощью шаблона **текстового шаблона** (он находится в узле **Общие** в списке **установленные шаблоны** ) и назовите его *SchoolModel.views.TT*. Замените существующий код в файле следующим кодом:

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample15.cs)]

Этот код создает представления для файла *EDMX* , расположенного в той же папке, что и шаблон, и имеет то же имя, что и файл шаблона. Например, если файл шаблона называется *SchoolModel.views.TT*, он будет искать файл модели данных с именем *счулмодел. EDMX*.

Сохраните файл, щелкните его правой кнопкой мыши в **Обозреватель решений** и выберите пункт **запустить настраиваемый инструмент**.

[![Image02](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image26.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image25.png)

Visual Studio создает файл кода, который создает представления с именем *SchoolModel.views.CS* на основе шаблона. (Возможно, вы заметили, что файл кода создается даже перед нажатием на кнопку **Запустить пользовательский инструмент**, как только вы сохраните файл шаблона.)

[![image01](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image28.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image27.png)

Теперь можно запустить приложение и убедиться, что оно работает, как было раньше.

Дополнительные сведения о предварительно созданных представлениях см. в следующих ресурсах:

- [Пошаговое руководство. Предварительное создание представлений для повышения производительности запросов](https://msdn.microsoft.com/library/bb896240.aspx) на веб-сайте MSDN. Объясняется, как использовать средство командной строки `EdmGen.exe` для предварительного создания представлений.
- [Изоляция производительности с предкомпилированными или предварительно созданными представлениями в Entity Framework 4](https://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/isolating-performance-with-precompiled-pre-generated-views-in-the-entity-framework-4.aspx) в блоге группы консультирования клиентов Windows Server AppFabric.

Это завершает вводные сведения о повышении производительности веб-приложения ASP.NET, использующего Entity Framework. Для получения дополнительных сведений см. следующие ресурсы:

- [Рекомендации по производительности (Entity Framework)](https://msdn.microsoft.com/library/cc853327.aspx) на веб-сайте MSDN.
- [Записи, связанные с производительностью, в блоге Entity Framework Team](https://blogs.msdn.com/b/adonet/archive/tags/performance/).
- [Параметры слияния EF и скомпилированные запросы](https://blogs.msdn.com/b/dsimmons/archive/2010/01/12/ef-merge-options-and-compiled-queries.aspx). Запись блога, объясняющая непредвиденное поведение скомпилированных запросов и параметров слияния, таких как `NoTracking`. Если вы планируете использовать скомпилированные запросы или манипулировать параметрами слияния в приложении, сначала прочтите этот параметр.
- Записи, [связанные с Entity Framework, в блоге группы консультирования по клиентам данных и моделирования](https://blogs.msdn.com/b/dmcat/archive/tags/entity+framework/). Включает записи в скомпилированные запросы и использование профилировщика Visual Studio 2010 для обнаружения проблем с производительностью.
- [Entity Framework обсуждение с рекомендациями по повышению производительности запросов с высокой степенью сложности](https://social.msdn.microsoft.com/Forums/adodotnetentityframework/thread/ffe8b2ab-c5b5-4331-8988-33a872d0b5f6).
- [Рекомендации по управлению состоянием ASP.NET](https://msdn.microsoft.com/library/z1hkazw7.aspx).
- [С помощью Entity Framework и элемента ObjectDataSource: Custom paging](http://geekswithblogs.net/Frez/articles/using-the-entity-framework-and-the-objectdatasource-custom-paging.aspx). Запись блога, которая основана на приложении ContosoUniversity, созданном в этих руководствах, чтобы объяснить, как реализовать разбиение на страницы на странице *Departments. aspx* .

В следующем учебнике рассматриваются некоторые важные улучшения Entity Framework, новые в версии 4.

> [!div class="step-by-step"]
> [Назад](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application.md)
> [Вперед](what-s-new-in-the-entity-framework-4.md)
