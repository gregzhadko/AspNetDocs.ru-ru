---
uid: web-forms/overview/moving-to-aspnet-20/the-asp-net-2-0-page-model
title: Страничная модель ASP.NET 2.0 | Документация Майкрософт
author: microsoft
description: В ASP.NET 1.x, разработчики были Выбор между модель встроенного кода и кода программной модели кода. Кода могут быть реализованы с помощью либо attr Src...
ms.author: riande
ms.date: 02/20/2005
ms.assetid: af4575a3-0ae3-4638-ba4d-218fad7a1642
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/the-asp-net-2-0-page-model
msc.type: authoredcontent
ms.openlocfilehash: 09f8389a04c5600ca9ee8365a9dc5a0d607c0a4d
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59403926"
---
# <a name="the-aspnet-20-page-model"></a>Страничная модель ASP.NET 2.0

по [Microsoft](https://github.com/microsoft)

> В ASP.NET 1.x, разработчики были Выбор между модель встроенного кода и кода программной модели кода. Кода могут быть реализованы с помощью атрибута Src или атрибут CodeBehind @Page директива. В ASP.NET 2.0 разработчики по-прежнему имеют возможность выбора из встроенного кода и кода, но были внесены значительные улучшения в модель кода.


В ASP.NET 1.x, разработчики были Выбор между модель встроенного кода и кода программной модели кода. Кода могут быть реализованы с помощью атрибута Src или атрибут CodeBehind @Page директива. В ASP.NET 2.0 разработчики по-прежнему имеют возможность выбора из встроенного кода и кода, но были внесены значительные улучшения в модель кода.

## <a name="improvements-in-the-code-behind-model"></a>Улучшения в модели кода

Чтобы полностью понять изменения в модель фонового кода в ASP.NET 2.0, мы рекомендуем быстро просмотреть модели, так как он существовал в ASP.NET 1.x.

## <a name="the-code-behind-model-in-aspnet-1x"></a>Модель фонового кода в ASP.NET 1.x

В ASP.NET 1.x, модель фонового кода состоял из ASPX-файл (Webform) и файл кода, содержащий программный код. Оба файла были соединены с помощью @Page директив в файле ASPX. Каждый элемент управления на странице ASPX имел соответствующее объявление в файле кода в качестве переменной экземпляра. Файл с выделенным кодом также содержится код для привязки событий и созданный код, необходимый для конструктора Visual Studio. Эта модель работала довольно хорошо, но так как каждый элемент ASP.NET на странице ASPX пройти соответствующий код в файл с выделенным кодом, было не true разделение кода и содержимое. Например если конструктор добавлен новый серверный элемент управления на ASPX-файл вне Интегрированной среды разработки Visual Studio, приложение будет нарушена из-за отсутствия объявления для этого элемента управления в файле кода.

## <a name="the-code-behind-model-in-aspnet-20"></a>Модель фонового кода в ASP.NET 2.0

ASP.NET 2.0 значительно улучшает эту модель. В ASP.NET 2.0 кода реализуется с помощью нового *разделяемые классы* в ASP.NET 2.0. Класс кода в ASP.NET 2.0 определяется как разделяемый класс, это означает, что он содержит только часть определения класса. Оставшаяся часть определения класса создается динамически с ASP.NET 2.0, с помощью страницы ASPX, во время выполнения или при предкомпилированного веб-сайта. Связь между файл с выделенным кодом и страницы ASPX по-прежнему установлено с помощью директивы @ Page. Тем не менее вместо атрибута фонового кода или Src, ASP.NET 2.0 теперь использует атрибут CodeFile. Атрибут Inherits также используется для указания имени класса для страницы.

Типичная директива @ Page может выглядеть следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample1.aspx)]

Определение типичных класса в файле фонового кода ASP.NET 2.0 может выглядеть следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample2.cs)]

> [!NOTE]
> C# и Visual Basic являются только управляемые языки, которые в настоящее время поддерживает разделяемые классы. Таким образом разработчики, использующие J# не будет иметь возможность использовать модель фонового кода в ASP.NET 2.0.


Новая модель расширяет возможности модели кода, так как разработчики получают файлы кода, которые содержат только код, который они создали. Появились также true разделение кода и содержимое из-за объявления переменных не экземпляр в файле кода.

> [!NOTE]
> Так как разделяемый класс для ASPX-страницы является, где выполняется привязка события, Visual Basic разработчики могут реализовать увеличение незначительно увеличить производительность с помощью ключевого слова дескрипторов в коде для привязки событий. C# имеет ключевое слово не эквивалент.


## <a name="new--page-directive-attributes"></a>Новые атрибуты директива @ Page

ASP.NET 2.0 добавляет многие новые атрибуты в директиву @ Page. Следующие атрибуты являются новыми в ASP.NET 2.0.

## <a name="async"></a>Async

Атрибут Async позволяет настроить страницу для асинхронного выполнения. Также охватывают асинхронных страниц позже в данном модуле.

## <a name="asynctimeout"></a>AsyncTimeout

Указанное время ожидания для асинхронных страниц. Значение по умолчанию составляет 45 секунд.

## <a name="codefile"></a>CodeFile

Атрибут CodeFile является заменой для атрибута фонового кода в Visual Studio 2002/2003.

### <a name="codefilebaseclass"></a>CodeFileBaseClass

Атрибут CodeFileBaseClass используется в тех случаях, когда несколько страниц, являются производными от одного базового класса. Из-за реализации разделяемых классов в ASP.NET, без этого атрибута базовый класс, который использует общие стандартных полей для ссылки на элементы управления, объявленные в страницы ASPX не будет работать должным образом так как ASP. Модуль компиляции сеть автоматически создаст новые элементы, в зависимости от элементов управления на странице. Таким образом, если требуется общий базовый класс для двух или более страниц в ASP.NET, будет необходимо определить укажите базового класса в атрибуте CodeFileBaseClass и наследуйте класс от этого базового класса каждого класса страницы. Атрибут CodeFile также является обязательным при использовании этого атрибута.

## <a name="compilationmode"></a>CompilationMode

Этот атрибут можно задать свойство CompilationMode страницы ASPX. Свойство CompilationMode является перечислением, содержащий значения **всегда**, **автоматически**, и **никогда**. По умолчанию используется **всегда**. **Автоматически** параметр будет препятствовать динамически по возможности компиляции страницы ASP.NET. Исключение из динамической компиляции страниц повышает производительность. Тем не менее если страница, на которой исключается содержит этот код, который должен быть скомпилирован, ошибка возникает при просмотре страницы.

## <a name="enableeventvalidation"></a>EnableEventValidation

Этот атрибут указывает, проверяются ли события обратной передачи и обратного вызова. Когда эта функция включена, аргументы к обратной передаче или события обратного вызова проверяются, чтобы убедиться, что они исходят из серверного элемента управления, который изначально к просмотру их.

## <a name="enabletheming"></a>EnableTheming

Этот атрибут указывает, используются ли темы ASP.NET на странице. Значение по умолчанию — **false**. Охваченных тем ASP.NET [10 модуль](profiles-themes-and-web-parts.md).

## <a name="linepragmas"></a>LinePragmas

Этот атрибут указывает, следует ли добавлять строки директивы pragma во время компиляции. Прагмы способами используемым отладчиками для выделения определенных разделов кода.

## <a name="maintainscrollpositiononpostback"></a>MaintainScrollPositionOnPostback

Этот атрибут указывает, внедряется ли JavaScript в страницы для сохранения позиции прокрутки между обратными передачами. Этот атрибут является **false** по умолчанию.

Если этот атрибут имеет **true**, ASP.NET добавит &lt;скрипт&gt; блок при обратной передаче, который выглядит следующим образом:

[!code-html[Main](the-asp-net-2-0-page-model/samples/sample3.html)]

Обратите внимание, что для этого блока скрипта src WebResource.axd. Этот ресурс не физический путь. При запросе этот сценарий, ASP.NET динамически создает скрипт.

### <a name="masterpagefile"></a>MasterPageFile

Этот атрибут указывает файл главной страницы для текущей страницы. Путь может быть относительным или абсолютным. Главные страницы охваченных [4 модуля](master-pages.md).

## <a name="stylesheettheme"></a>StyleSheetTheme

Этот атрибут можно переопределить свойства внешнего вида пользовательского интерфейса, определенные темы ASP.NET 2.0. Темы рассматриваются в [10 модуль](profiles-themes-and-web-parts.md).

## <a name="theme"></a>Тема

Определяет тему для страницы. Если значение не указано для атрибута StyleSheetTheme, атрибут Theme переопределяет все стили, применимые к элементам управления на странице.

## <a name="title"></a>Заголовок

Задает заголовок для страницы. Указанное здесь значение будет отображаться в &lt;title&gt; элемент отображаемой страницы.

### <a name="viewstateencryptionmode"></a>ViewStateEncryptionMode

Задает значение перечисления ViewStateEncryptionMode. Доступные значения: **всегда**, **автоматически**, и **никогда**. Значение по умолчанию — **автоматически**. Если этот атрибут присвоено значение **автоматически**, шифруется viewstate — это элемент управления запрашивает его путем вызова **RegisterRequiresViewStateEncryption** метод.

## <a name="setting-public-property-values-via-the--page-directive"></a>Задание значений открытого свойства с помощью директива @ Page

Другой новой возможностью в директиву @ Page в ASP.NET 2.0 является возможность задать начальное значение из общих свойств базового класса. Предположим, например, что у вас есть открытое свойство именем **SomeText** в базового класса и d, как она будет инициализирована **Hello** при загрузке страницы. Это можно сделать, просто установив его в директиве @ Page следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample4.aspx)]

**SomeText** атрибута директивы @ Page задает начальное значение свойства SomeText в базовом классе для *Hello!*. Видеоролик ниже приведено пошаговое описание начальное значение открытого свойства в базовом классе, используя директиву @ Page.


![](the-asp-net-2-0-page-model/_static/image1.png)


[Открыть весь экран](the-asp-net-2-0-page-model/_static/setprop1.wmv)


## <a name="new-public-properties-of-the-page-class"></a>Новые открытые свойства класса страницы

Приведенные ниже открытые свойства являются новыми в ASP.NET 2.0.

## <a name="apprelativetemplatesourcedirectory"></a>AppRelativeTemplateSourceDirectory

Возвращает путь относительно приложения к страницы или элемента управления. Например, для страницы, расположенный http://app/folder/page.aspx, это свойство возвращает ~ / folder /.

## <a name="apprelativevirtualpath"></a>AppRelativeVirtualPath

Возвращает относительный виртуальный путь к каталогу для страницы или элемента управления. Например, для страницы, расположенный http://app/folder/page.aspx, это свойство возвращает ~ / folder/page.aspx.

## <a name="asynctimeout"></a>AsyncTimeout

Возвращает или задает время ожидания, используемое для обработки асинхронной страницы. (Асинхронных страниц будет рассматриваться далее в этом модуле.)

## <a name="clientquerystring"></a>ClientQueryString

Свойство только для чтения, которое возвращает часть строки запроса запрошенного URL-адреса. Это значение является URL-кодированием. Метод UrlDecode класса HttpServerUtility можно использовать для его декодирования отсутствует.

## <a name="clientscript"></a>ClientScript

Это свойство возвращает объект ClientScriptManager, который может использоваться для управления ASP.NETs вывод сценария на стороне клиента. (Позже в этом модуле рассматривается класса ClientScriptManager.)

## <a name="enableeventvalidation"></a>EnableEventValidation

Это свойство определяет, включена ли проверка события для события обратной передачи и обратного вызова. При включении проверяются аргументы к обратной передаче или события обратного вызова, убедитесь, что они исходят из серверного элемента управления, который изначально к просмотру их.

## <a name="enabletheming"></a>EnableTheming

Это свойство Возвращает или задает логическое значение, указывающее, применяется ли тема ASP.NET 2.0 на страницу.

## <a name="form"></a>Form

Это свойство возвращает HTML-формы на странице ASPX, как объект HtmlForm.

## <a name="header"></a>Header

Это свойство возвращает ссылку на объект HtmlHead, который содержит заголовок страницы. Возвращаемый объект HtmlHead можно использовать для получения и задания таблицы стилей, метатегов и т. д.

## <a name="idseparator"></a>IdSeparator

Это свойство только для чтения получает символ, используемый для разделения идентификаторов элементов управления, создавая уникальный идентификатор для элементов управления на странице ASP.NET. Он не предназначен для использования непосредственно в вашем коде.

## <a name="isasync"></a>IsAsync

Это свойство позволяет асинхронных страниц. Асинхронные страницы рассматриваются далее в этом модуле.

## <a name="iscallback"></a>IsCallback

Это свойство только для чтения возвращает **true** Если страницы является результатом обратного вызова. Обратных звонков, рассматриваются далее в этом модуле.

## <a name="iscrosspagepostback"></a>IsCrossPagePostBack

Это свойство только для чтения возвращает **true** Если страница является частью межстраничной обратной передачи. Далее в этом модуле рассматриваются межстраничной обратной передачи.

## <a name="items"></a>Элементы

Возвращает ссылку на экземпляр IDictionary, содержащий все объекты, хранящиеся в контексте страницы. Можно добавить элементы к этому объекту IDictionary, и они будут доступны вам на протяжении всего времени существования контекста.

## <a name="maintainscrollpositiononpostback"></a>MaintainScrollPositionOnPostBack

Это свойство управляет ли ASP.NET генерирует JavaScript-код, который поддерживает прокручиваются страницы позицию в браузере после обратной передаче. (Подробности этого свойства были описаны ранее в этом модуле.)

## <a name="master"></a>Master

Это свойство только для чтения возвращает ссылку на экземпляр MasterPage для страницы, к которому был применен главной страницы.

## <a name="masterpagefile"></a>MasterPageFile

Возвращает или задает имя файла главной страницы для страницы. Это свойство можно задать только в методе PreInit.

## <a name="maxpagestatefieldlength"></a>MaxPageStateFieldLength

Это свойство Возвращает или задает максимальную длину для состояния страницы в байтах. Если свойство имеет значение положительное число, состояние представления страницы будет разбить на несколько скрытых полей, чтобы он не превышает количество байтов, заданному. Если свойство является отрицательным числом, состояние представления не быть разбивается на фрагменты.

## <a name="pageadapter"></a>PageAdapter

Возвращает ссылку на объект PageAdapter, изменяет страницы для запрашивающего браузера.

## <a name="previouspage"></a>PreviousPage

Возвращает ссылку на предыдущую страницу Server.Transfer или межстраничной обратной передачи.

## <a name="skinid"></a>Идентификатор SkinID

Задает обложку для применения к странице ASP.NET 2.0.

## <a name="stylesheettheme"></a>StyleSheetTheme

Это свойство Возвращает или задает таблицу стилей, которая применяется к странице.

## <a name="templatecontrol"></a>TemplateControl

Возвращает ссылку на содержащий элемент управления для страницы.

## <a name="theme"></a>Тема

Получает или задает имя темы ASP.NET 2.0, примененных к этой странице. Это значение должно быть равно до метода PreInit.

## <a name="title"></a>Заголовок

Это свойство получает или задает заголовок для страницы, полученный из заголовка страницы.

## <a name="viewstateencryptionmode"></a>ViewStateEncryptionMode

Возвращает или задает ViewStateEncryptionMode страницы. См. Подробное описание этого свойства ранее в этом модуле.

## <a name="new-protected-properties-of-the-page-class"></a>Новый защищенные свойства класса страницы

Ниже приведены новые защищенного свойства класса страницы в ASP.NET 2.0.

## <a name="adapter"></a>Адаптер

Возвращает ссылку на ControlAdapter, которое осуществляет отрисовку страницы на устройстве, который запросил.

## <a name="asyncmode"></a>AsyncMode

Это свойство указывает, обрабатывается ли страница асинхронно. Он предназначен для использования средой выполнения, а не непосредственно в код.

## <a name="clientidseparator"></a>ClientIDSeparator

Это свойство возвращает символ, используемый в качестве разделителя, при создании уникальных клиентских идентификаторов для элементов управления. Он предназначен для использования средой выполнения, а не непосредственно в код.

## <a name="pagestatepersister"></a>PageStatePersister

Это свойство возвращает объект PageStatePersister для страницы. Это свойство в основном используется разработчиками элементов управления ASP.NET.

## <a name="uniquefilepathsuffix"></a>UniqueFilePathSuffix

Это свойство возвращает уникальный суффикс, добавляемый в путь к файлу для кэширования браузеров. Значение по умолчанию — \_ \_ufps = и число из 6 цифр.

## <a name="new-public-methods-for-the-page-class"></a>Новые общие методы для класса страницы

К классу страницы ASP.NET 2.0 появились следующие общие методы.

## <a name="addonprerendercompleteasync"></a>AddOnPreRenderCompleteAsync

Этот метод регистрирует делегаты обработчика событий для выполнения асинхронной страницы. Асинхронные страницы рассматриваются далее в этом модуле.

## <a name="applystylesheetskin"></a>ApplyStyleSheetSkin

Применяет свойства в таблице стилей страницы на страницу.

## <a name="executeregisteredasynctasks"></a>ExecuteRegisteredAsyncTasks

Этот метод существ асинхронной задачи.

### <a name="getvalidators"></a>GetValidators

Возвращает коллекцию проверяющих элементов управления для указанной группы проверки или группы проверки по умолчанию, если ничего не указано.

## <a name="registerasynctask"></a>Метод RegisterAsyncTask

Этот метод регистрирует новый асинхронной задачи. Асинхронные страницы рассматриваются далее в этом модуле.

## <a name="registerrequirescontrolstate"></a>RegisterRequiresControlState

Этот метод сообщает ASP.NET, что состояние элемента управления страницы должны сохраняться.

## <a name="registerrequiresviewstateencryption"></a>RegisterRequiresViewStateEncryption

Этот метод сообщает ASP.NET, что состояние представления страницы требует шифрования.

## <a name="resolveclienturl"></a>ResolveClientUrl

Возвращает относительный URL-адрес, который может использоваться для клиентских запросов для изображений и т. д.

## <a name="setfocus"></a>SetFocus

Этот метод будет установить фокус на элемент управления, который указывается при начальной загрузке страницы.

## <a name="unregisterrequirescontrolstate"></a>UnregisterRequiresControlState

Этот метод отменяет регистрацию элемент управления, который передается как больше не требуется сохранение состояния элемента управления.

## <a name="changes-to-the-page-lifecycle"></a>Изменения в жизненный цикл страницы

Жизненный цикл страницы в ASP.NET 2.0 не существенно изменилось, но есть несколько новых методов, которые следует учитывать. Ниже описан жизненный цикл страницы ASP.NET 2.0.

## <a name="preinit-new-in-aspnet-20"></a>PreInit (новое в ASP.NET 2.0)

События PreInit является самым ранним этапом жизненного цикла, разработчик может получить доступ. Добавление этого события позволяет программно изменять темы ASP.NET 2.0, главных страниц, доступ к свойствам профиля ASP.NET 2.0 и т. д. Если вы находитесь в обратной передачи состояния, важно осознавать, что Viewstate еще не был применен к элементам управления на этом этапе жизненного цикла. Таким образом Если разработчик изменяет свойство элемента управления на этом этапе, он скорее всего перезаписывается позже в жизненном цикле страницы.

## <a name="init"></a>Init

Событие Init не отличается от ASP.NET 1.x. Это будет место для чтения или инициализации свойства элементов управления на странице. В этой рабочей области, главные страницы, темы и т.д. уже применены к странице.

## <a name="initcomplete-new-in-20"></a>InitComplete (введено в версии 2.0)

Событие InitComplete вызывается в конце стадии инициализации страницы. На этом этапе жизненного цикла, доступны элементы управления на странице, но их состояние еще не заполнены.

## <a name="preload-new-in-20"></a>Предварительная загрузка (новое в версии 2.0)

Это событие вызывается после применения всех данных обратной передачи и непосредственно перед страницы\_нагрузки.

## <a name="load"></a>Load

Событие Load не отличается от ASP.NET 1.x.

## <a name="loadcomplete-new-in-20"></a>LoadComplete (введено в версии 2.0)

Событие LoadComplete последнего события находится в стадии загрузки страницы. На этом этапе все данные обратной передачи и viewstate была применена к странице.

## <a name="prerender"></a>PreRender

При желании для состояние представления сохраняется должным образом для элементов управления, которые динамически добавляются на страницу, события PreRender является позднее можно будет добавить их.

## <a name="prerendercomplete-new-in-20"></a>PreRenderComplete (введено в версии 2.0)

На этапе PreRenderComplete все элементы управления были добавлены к странице и странице готов к просмотру. События PreRenderComplete — это последнее событие, возникающее перед сохранением состояние представления страницы.

## <a name="savestatecomplete-new-in-20"></a>SaveStateComplete (введено в версии 2.0)

Событие SaveStateComplete вызывается сразу после сохранения состояния viewstate и управления для всей страницы. Это последнее событие, прежде чем фактически отображении страницы в браузере.

## <a name="render"></a>Прорисовка

Метод Render не изменялась после ASP.NET 1.x. Именно HtmlTextWriter инициализируется и отображении страницы в браузере.

## <a name="cross-page-postback-in-aspnet-20"></a>Межстраничной обратной передачи в ASP.NET 2.0

В ASP.NET 1.x, обратные передачи требовались для публикации на ту же страницу. Не допускались межстраничной обратной передачи. ASP.NET 2.0 добавлена возможность отправки обратно на другую страницу в интерфейсе IButtonControl. Любой элемент управления, который реализует новый интерфейс IButtonControl (кнопки LinkButton и ImageButton помимо сторонние пользовательские элементы управления) можно воспользоваться преимуществами этой новой функциональности, посредством использования атрибута PostBackUrl. В следующем коде показано элемент управления кнопки, который выполняет обратную передачу вторую страницу.

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample5.aspx)]

При обратной отправке страницы, страницы, которая инициирует обратную передачу доступен через свойство PreviousPage на второй странице. Эта функциональная возможность реализуется с помощью нового веб-форма\_DoPostBackWithOptions клиентской функции, если элемент управления выполняет обратную передачу другой страницы ASP.NET 2.0 отображает для страницы. Новый обработчик WebResource.axd, который порождает скрипт клиенту предоставляется эта функция JavaScript.

Видеоролик ниже приведено пошаговое описание межстраничных обратную передачу.


![](the-asp-net-2-0-page-model/_static/image2.png)


[Открыть весь экран](the-asp-net-2-0-page-model/_static/xpage1.wmv)


## <a name="more-details-on-cross-page-postbacks"></a>Дополнительные сведения о межстраничной обратной передачи

### <a name="viewstate"></a>ViewState

Может запрос самостоятельно уже дальнейшие действия в состояние представления с первой страницы в сценарии межстраничной обратной передачи. В конце концов любой элемент управления, который реализует интерфейс IPostBackDataHandler будет сохранять свое состояние через viewstate, таким образом доступ к свойствам элемента управления на второй странице межстраничной обратной передачи, необходимо иметь доступ к состояние представления страницы. ASP.NET 2.0 берет на себя этот сценарий с помощью нового скрытое поле на второй странице вызывается \_ \_PREVIOUSPAGE. \_ \_PREVIOUSPAGE поле формы содержит viewstate для первой страницы, таким образом, чтобы получить доступ к свойствам всех элементов управления на второй странице.

### <a name="circumventing-findcontrol"></a>Обход FindControl

В пошаговом руководстве видео межстраничной обратной передачи я использовал метод FindControl для получения ссылки на элемент управления TextBox на первой странице. Этот метод хорошо подходит для этой цели, но FindControl является дорогостоящим и требует написания дополнительного кода. К счастью ASP.NET 2.0 представляет собой альтернативу FindControl для этой цели, которая будет работать во многих сценариях. PreviousPageType-директива позволяет иметь строго типизированную ссылку на предыдущую страницу, используя имя типа или virtualPath-атрибут. Атрибут TypeName позволяет указать тип предыдущей страницы, хотя атрибут VirtualPath позволяет ссылаться на предыдущую страницу, используя виртуальный путь. После установки PreviousPageType-директива, необходимо предоставить элементы управления, и т.д., к которому вы хотите разрешить доступ с помощью открытых свойств.

## <a name="lab-1-cross-page-postback"></a>Лабораторное занятие 1 межстраничной обратной передачи

В этой лабораторной работе вы создадите приложение, использующее новые функции межстраничной обратной передачи ASP.NET 2.0.

1. Откройте Visual Studio 2005 и создайте новый веб-узла ASP.NET.
2. Добавьте новый веб-форма вызывается page2.aspx.
3. Откройте страницу Default.aspx в представлении конструктора и добавьте элемент управления Button и элемент управления TextBox. 

    1. Предоставить элемент управления Button с Идентификатором **SubmitButton** и текстовое поле управления Идентификатором **UserName**.
    2. Присвойте свойству PostBackUrl кнопки page2.aspx.
4. Откройте page2.aspx в представлении источника.
5. Добавьте директиву @ PreviousPageType, как показано ниже:
6. Добавьте следующий код к странице\_нагрузку на page2.aspx кода: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample6.cs)]
7. Постройте проект, щелкнув меню "сборка" в сборке.
8. Добавьте приведенный ниже код программной части для Default.aspx: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample7.cs)]
9. Изменение страницы\_нагрузки в page2.aspx следующим: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample8.cs)]
10. Выполните построение проекта.
11. Запустите проект.
12. Введите свое имя в текстовое поле и нажмите кнопку.
13. Что такое результат?

## <a name="asynchronous-pages-in-aspnet-20"></a>Асинхронные страницы в среде ASP.NET 2.0

Многие проблемы конфликтов в ASP.NET, вызваны задержка внешних вызовов (например, вызовы веб службы или базы данных), задержка ввода-ВЫВОДА файла и т. д. При запросе от приложения ASP.NET, ASP.NET использует один из рабочих потоков для обслуживания этого запроса. Этот запрос является владельцем этого потока до завершения запроса и отправки ответа. ASP.NET 2.0 ищет для устранения проблемы задержки с помощью таких проблем, добавив возможность асинхронного выполнения страницы. Это означает, что рабочий поток можно запустить запрос, который затем передается дополнительных выполнение другому потоку, тем самым возврат в пул доступных потоков быстро. После завершения файлового ввода-ВЫВОДА, обращение к базе данных и др., новый поток получается из пула потоков для завершения запроса.

Первым шагом в создании асинхронного выполнения страницы является установка **Async** атрибутов директивы page следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample9.aspx)]

Этот атрибут сообщает ASP.NET, в реализации интерфейса IHttpAsyncHandler для страницы.

Следующим шагом является вызов метода AddOnPreRenderCompleteAsync в определенный момент жизненный цикл страницы до PreRender. (Этот метод обычно вызывается на странице\_нагрузки.) Метод AddOnPreRenderCompleteAsync принимает два параметра; BeginEventHandler и EndEventHandler. BeginEventHandler возвращает значение IAsyncResult, который затем передается как параметр EndEventHandler.

Видео ниже приведено пошаговое описание запроса асинхронной страницы.


![](the-asp-net-2-0-page-model/_static/image3.png)


[Открыть весь экран](the-asp-net-2-0-page-model/_static/async1.wmv)


> [!NOTE]
> До завершения EndEventHandler асинхронной страницы, выполните следующие действия. не отобразить в обозревателе. Без сомнения, но некоторые разработчики будут рассматривать запросов асинхронного как аналог для асинхронных обратных вызовов. Важно понимать, что они не имеют. Преимущество для асинхронных запросов заключается в том, что первый рабочий поток могут быть возвращены в пул потоков для обслуживания новых запросов, тем самым уменьшая состязания из-за привязки ввода-ВЫВОДА и т. д.


## <a name="script-callbacks-in-aspnet-20"></a>Обратные вызовы из сценария в ASP.NET 2.0

Веб-разработчикам искало способов избежать мерцания, связанных с обратным вызовом. В ASP.NET 1.x, SmartNavigation был наиболее распространенный способ избежать мерцания, но SmartNavigation вызвавшее проблемы для некоторых разработчиков из-за сложности его реализация на стороне клиента. ASP.NET 2.0 решает эту проблему с обратные вызовы из сценария. Обратные вызовы из сценария используйте XMLHttp для запросов к веб-сервера с помощью JavaScript. XMLHttp запрос возвращает XML-данных, который затем можно обрабатывать с помощью модели DOM обозревателя XMLHttp кода будет скрыт от пользователя с новым обработчиком WebResource.axd.

Существуют несколько шагов, которые необходимы для настройки обратный вызов сценария в ASP.NET 2.0.

## <a name="step-1--implement-the-icallbackeventhandler-interface"></a>Шаг 1. Реализация интерфейса ICallbackEventHandler

Чтобы ASP.NET для распознавания страницы как участвующего в обратном вызове скрипт должен реализовывать интерфейс ICallbackEventHandler. Это можно сделать в файле кода следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample10.cs)]

Также это можно сделать с помощью директив like @ Implements так:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample11.aspx)]

При использовании встроенного кода ASP.NET, обычно используется директива @ Implements.

## <a name="step-2--call-getcallbackeventreference"></a>Шаг 2. Вызов GetCallbackEventReference

Как упоминалось ранее, вызов XMLHttp инкапсулирован в обработчик WebResource.axd. При отображении страницы ASP.NET будет добавить вызов веб-форма\_DoCallback, клиентский скрипт, который предоставляется WebResource.axd. Веб-форма\_DoCallback функция заменяет \_ \_doPostBack функция обратного вызова. Помните, что \_ \_doPostBack программно отправляет форму на странице. В сценарии обратного вызова, необходимо предотвратить обратную передачу, так что \_ \_doPostBack не подойдет.

> [!NOTE]
> \_\_doPostBack по-прежнему отображается на страницу в клиентском сценарии обратного вызова сценария. Тем не менее он не используется для обратного вызова.


Аргументы для веб-форма\_DoCallback клиентской функции предоставляются через функцию на сервере GetCallbackEventReference, который обычно вызывается в странице\_нагрузки. Типичный вызов GetCallbackEventReference может выглядеть следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample12.cs)]

> [!NOTE]
> В этом случае cm — это экземпляр объекта ClientScriptManager. Классу ClientScriptManager будет рассматриваться далее в этом модуле.


Существует несколько перегруженных версий GetCallbackEventReference. В этом случае аргументы являются следующим образом:

`this`

Ссылка на элемент управления, где вызывается GetCallbackEventReference. В этом случае это сама страница.

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample13.js)]

Строковый аргумент, который будет передан из клиентского кода на стороне сервера событие. В этом случае обмена мгновенными сообщениями, передача значения из раскрывающегося списка вызывается ddlCompany.

`ShowCompanyName`

Имя клиентской функции, которая будет принимать возвращаемое значение (в форме строки) из события обратного вызова на стороне сервера. Эта функция будет вызываться только в тех случаях, если обратный вызов на стороне сервера выполнена успешно. Таким образом для обеспечения надежности, обычно рекомендуется использовать перегруженную версию GetCallbackEventReference, который принимает в качестве аргумента дополнительную строку, указав имя клиентской функции для выполнения в случае возникновения ошибки.

`null`

Строка, представляющая функции стороны клиента, инициировавший перед обратным вызовом на сервер. В этом случае нет нет такого сценария, поэтому значением аргумента является null.

`true`

Логическое значение, указав ли поведения обратного вызова асинхронно.

Вызов веб-форма\_DoCallback на клиенте будет передавать эти аргументы. Таким образом, когда эта страница отображается на клиенте, этот код будет выглядеть следующим образом:

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample14.js)]

Обратите внимание на то, что сигнатура функции на стороне клиента немного отличается. Клиентской функции передает 5 строк и логическое значение. Дополнительные строки (который имеет значение null, если в приведенном выше примере) содержит функции стороны клиента, который будет обрабатывать все ошибки из обратного вызова на стороне сервера.

## <a name="step-3--hook-the-client-side-control-event"></a>Шаг 3. Подключить клиентский элемент управления событие

Обратите внимание, что возвращаемое значение GetCallbackEventReference выше был назначен строковой переменной. Эта строка используется для подключения на стороне клиента событие элемента управления, который инициирует обратный вызов. В этом примере обратный вызов инициируется раскрывающийся список на странице, поэтому я бы хотел подключить *OnChange* событий.

Чтобы подключить событие на стороне клиента, просто добавляется обработчик к разметке клиентские следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample15.cs)]

Помните, что *cbRef* является возвращаемым значением из вызова GetCallbackEventReference. Она содержит вызов веб-форма\_DoCallback, который был показан выше.

## <a name="step-4--register-the-client-side-script"></a>Шаг 4. Регистрация клиентского скрипта

Вспомним, что вызов GetCallbackEventReference указано, что клиентский скрипт с именем **ShowCompanyName** будет выполняться после успешного завершения обратного вызова на стороне сервера. Этот скрипт должен быть добавлен на страницу, с помощью экземпляра ClientScriptManager. (Класса ClientScriptManager будет рассказано далее в этом модуле.) Как выполнять такие:

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample16.js)]

## <a name="step-5--call-the-methods-of-the-icallbackeventhandler-interface"></a>Шаг 5. Вызовите методы интерфейса ICallbackEventHandler

ICallbackEventHandler содержит два метода, которые необходимо реализовать в коде. Они являются **RaiseCallbackEvent** и **GetCallbackEvent**.

**RaiseCallbackEvent** принимает в качестве аргумента строку и не возвращает ничего. Строковый аргумент передается из клиентского вызова веб-форма\_DoCallback. В этом случае это значение является *значение* атрибут называется ddlCompany раскрывающегося списка. Код на стороне сервера должен размещаться в методе RaiseCallbackEvent. Например если обратного вызова совершает WebRequest на внешний ресурс, этот код должен располагаться в RaiseCallbackEvent.

**GetCallbackEvent** отвечает за обработку возврата обратного вызова клиента. Он не принимает аргументы и возвращает строку. Строку, которая его возвращает будут передаваться в качестве аргумента функции клиентской стороны, в этом случае *ShowCompanyName*.

Когда вы выполнили описанные выше действия, вы будете готовы выполнить обратный вызов сценария в ASP.NET 2.0.


![](the-asp-net-2-0-page-model/_static/image4.png)


[Открыть весь экран](the-asp-net-2-0-page-model/_static/callback1.wmv)


В любом браузере, поддерживающем вызовах XMLHttp поддерживаются обратные вызовы из сценария в ASP.NET. Включает все современные браузеры используется уже сегодня. Internet Explorer использует объекта XMLHttp ActiveX, а других современных браузеров (включая предстоящих Internet Explorer 7) используйте встроенный объект XMLHttp. Чтобы программно определять, если браузер поддерживает обратные вызовы, можно использовать **Request.Browser.SupportCallback** свойство. Это свойство будет возвращать **true** если запрашивающий клиент поддерживает обратные вызовы из сценария.

## <a name="working-with-client-script-in-aspnet-20"></a>Работа с клиентского сценария в ASP.NET 2.0

Клиентские сценарии в среде ASP.NET 2.0 осуществляется через использование класса ClientScriptManager. Следит за клиентских скриптов, используя тип и имя класса ClientScriptManager. Это предотвращает тот же сценарий программными средствами на страницу добавляется более одного раза.

> [!NOTE]
> После сценарий успешно зарегистрирован на странице, все последующие попытки зарегистрировать тот же скрипт просто приведет к скрипт не зарегистрирован еще раз. Повторяющиеся скрипты не будут добавлены, и исключение не возникает. Чтобы избежать ненужных вычислений, существуют методы, которые можно использовать для определения, уже зарегистрирован ли скрипт таким образом, не пытайтесь зарегистрировать более одного раза.


Методы класса ClientScriptManager должны быть знакомы всем текущем разработчикам ASP.NET:

## <a name="registerclientscriptblock"></a>RegisterClientScriptBlock

Этот метод добавляет скрипт к началу страницы, отображаемой страницы. Это полезно для добавления функций, которые будут вызываться явным образом на клиенте.

Существует две перегруженные версии этого метода. Три из четырех аргументов являются общими для них. Они приведены ниже.

`type (string)`

***Тип*** аргумент определяет тип скрипта. Обычно рекомендуется использовать тип страницы (это. GetType()) для типа.

`key (string)`

***Ключ*** аргумент — это определяемые пользователем ключ для скрипта. Это должно быть уникальным для каждого сценария. Если попытаться добавить скрипт в один и тот же ключ и тип, уже добавленных сценария, он не добавляется.

`script (string)`

***Скрипт*** аргумент является строка, содержащая фактическое сценарий для добавления. Рекомендуется использовать для создания скрипта и затем использовать метод ToString() StringBuilder для назначения StringBuilder ***скрипт*** аргумент.

При использовании перегруженных RegisterClientScriptBlock, который принимает только три аргумента, необходимо включить элементы сценария (&lt;сценарий&gt; и &lt;/script&gt;) в скрипте.

Вы можете использовать перегрузку, принимающую четвертый аргумент RegisterClientScriptBlock. Четвертый аргумент — логическое значение, указывающее ли ASP.NET следует добавить элементы сценария для вас. Если этот аргумент равен **true**, сценарий не должен содержать элементы сценария явным образом.

Метод IsClientScriptBlockRegistered используется для определения, если скрипт уже был зарегистрирован. Это позволяет избежать попытка повторно зарегистрировать скрипт, который уже был зарегистрирован.

### <a name="registerclientscriptinclude-new-in-20"></a>RegisterClientScriptInclude (введено в версии 2.0)

Тег RegisterClientScriptInclude создает блок сценария, ссылающийся на внешний файл скрипта. У него есть две перегрузки. Одна перегрузка берет ключ и URL-адрес. Второй добавляет третий аргумент, задающий тип.

Например следующий код приводит блок сценария, связанный с jsfunctions.js в корневой папке сценариев приложения:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample17.cs)]

Этот код создает следующий код в отображаемой странице:

[!code-html[Main](the-asp-net-2-0-page-model/samples/sample18.html)]

> [!NOTE]
> Блок скрипта отображается в нижней части страницы.


Метод IsClientScriptIncludeRegistered используется для определения, если скрипт уже был зарегистрирован. Это позволяет избежать попытка повторно зарегистрировать скрипт.

## <a name="registerstartupscript"></a>RegisterStartupScript

Метод RegisterStartupScript принимает те же аргументы, что метод RegisterClientScriptBlock. Скрипт, зарегистрированный с RegisterStartupScript выполняет после загрузки страницы, но до события OnLoad на стороне клиента. В версии 1.X, скрипты, зарегистрированные с помощью RegisterStartupScript были размещены непосредственно перед закрывающим &lt;/form&gt; тег пока скрипты, зарегистрированные с помощью RegisterClientScriptBlock были размещены сразу же после открытия &lt;формы&gt; тега. В ASP.NET 2.0, оба размещается непосредственно перед закрывающим &lt;/form&gt; тега.

> [!NOTE]
> Если зарегистрировать функцию с RegisterStartupScript, этой функции не будет выполняться, пока вы явно вызвать в код на стороне клиента.


Метод IsStartupScriptRegistered позволяет определить, если скрипт уже был зарегистрирован и избежать попытка повторно зарегистрировать скрипт.

## <a name="other-clientscriptmanager-methods"></a>Другие методы ClientScriptManager

Ниже приведен ряд других полезных методов класса ClientScriptManager.


|  <strong>GetCallbackEventReference</strong>   |                                                 См. в разделе обратные вызовы из сценария ранее в этом модуле.                                                 |
|-----------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
|  <strong>GetPostBackClientHyperlink</strong>  |                Возвращает ссылку на JavaScript (javascript:&lt;вызовите&gt;), можно использовать для отправки обратно из клиентского события.                 |
|  <strong>GetPostBackEventReference</strong>   |                                   Возвращает строку, которая может использоваться для Инициируйте вызов post обратно от клиента.                                    |
|      <strong>GetWebResourceUrl</strong>       | Возвращает URL-адрес ресурса, внедренного в сборку. Необходимо использовать в сочетании с <strong>RegisterClientScriptResource</strong>. |
| <strong>RegisterClientScriptResource</strong> |     Регистрирует веб-ресурс со страницей. Это ресурсы, внедренных в сборку и обрабатываются новый обработчик WebResource.axd.      |
|     <strong>RegisterHiddenField</strong>      |                                                 Регистрирует скрытое поле формы со страницей.                                                 |
|  <strong>RegisterOnSubmitStatement</strong>   |                                  Регистрирует код на стороне клиента, который выполняется при отправке формы HTML.                                   |

