---
uid: web-forms/overview/moving-to-aspnet-20/the-asp-net-2-0-page-model
title: Модель страницы ASP.NET 2,0 | Документация Майкрософт
author: microsoft
description: В ASP.NET 1. x разработчики имели возможность выбора между встроенной моделью кода и моделью кода программной части. Код программной части можно реализовать с помощью атрибута src...
ms.author: riande
ms.date: 02/20/2005
ms.assetid: af4575a3-0ae3-4638-ba4d-218fad7a1642
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/the-asp-net-2-0-page-model
msc.type: authoredcontent
ms.openlocfilehash: bcb71b2b5a484e8756406867e08e8aa699a9024d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78440712"
---
# <a name="the-aspnet-20-page-model"></a>Модель страницы ASP.NET 2,0

по [Майкрософт](https://github.com/microsoft)

> В ASP.NET 1. x разработчики имели возможность выбора между встроенной моделью кода и моделью кода программной части. Код программной части можно реализовать с помощью атрибута src или атрибута CodeBehind директивы @Page. В ASP.NET 2,0 разработчики по-прежнему имеют возможность выбора между встроенным кодом и кодом программной части, но в модели кода программной части были внесены значительные улучшения.

В ASP.NET 1. x разработчики имели возможность выбора между встроенной моделью кода и моделью кода программной части. Код программной части можно реализовать с помощью атрибута src или атрибута CodeBehind директивы @Page. В ASP.NET 2,0 разработчики по-прежнему имеют возможность выбора между встроенным кодом и кодом программной части, но в модели кода программной части были внесены значительные улучшения.

## <a name="improvements-in-the-code-behind-model"></a>Усовершенствования в модели кода программной части

Чтобы полностью понять изменения в модели кода программной части в ASP.NET 2,0, лучше быстро проверить модель в том виде, в котором она существовала в ASP.NET 1. x.

## <a name="the-code-behind-model-in-aspnet-1x"></a>Модель кода программной части в ASP.NET 1. x

В ASP.NET 1. x модель кода программной части состояла из ASPX-файла (WebForms) и файла кода программной части, содержащего программный код. Два файла были подключены с помощью директивы @Page в файле ASPX. Каждый элемент управления на странице ASPX имеет соответствующее объявление в файле кода программной части как переменную экземпляра. Файл кода программной части также содержал код для привязки событий и созданного кода, необходимого для конструктора Visual Studio. Эта модель хорошо работала, но, поскольку каждый элемент ASP.NET на странице ASPX должен иметь соответствующий код в файле кода программной части, нет фактического разделения кода и содержимого. Например, если конструктор добавил новый серверный элемент управления в файл ASPX за пределами интегрированной среды разработки Visual Studio, приложение будет нарушено из-за отсутствия объявления для этого элемента управления в файле кода программной части.

## <a name="the-code-behind-model-in-aspnet-20"></a>Модель кода программной части в ASP.NET 2,0

ASP.NET 2,0 значительно улучшилась на основе этой модели. В ASP.NET 2,0 код программной части реализуется с помощью новых *разделяемых классов* , предоставляемых в ASP.NET 2,0. Класс кода программной части в ASP.NET 2,0 определен как разделяемый класс, то есть он содержит только часть определения класса. Оставшаяся часть определения класса создается динамически с помощью ASP.NET 2,0 при помощи страницы ASPX во время выполнения или при предварительной компиляции веб-сайта. Ссылка между файлом кода программной части и страницей ASPX по-прежнему устанавливается с помощью директивы @ Page. Однако вместо атрибута CodeBehind или src ASP.NET 2,0 теперь использует атрибут CodeFile. Атрибут Inherits также используется для указания имени класса для страницы.

Типичная директива @ Page может выглядеть следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample1.aspx)]

Типичное определение класса в файле кода программной части ASP.NET 2,0 может выглядеть следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample2.cs)]

> [!NOTE]
> C#и Visual Basic являются единственными управляемыми языками, которые в настоящее время поддерживают разделяемые классы. Поэтому разработчики, использующие J#, не смогут использовать модель кода программной части в ASP.NET 2,0.

Новая модель расширяет модель кода программной части, поскольку разработчики теперь будут иметь файлы кода, содержащие только созданный им код. Он также обеспечивает истинное разделение кода и содержимого, поскольку в файле кода программной части нет объявлений переменных экземпляра.

> [!NOTE]
> Поскольку разделяемый класс для ASPX-страницы — это место, где происходит привязка событий, Visual Basic разработчики могут реализовать небольшое увеличение производительности, используя ключевое слово Handles в коде программной части для привязки событий. C#не имеет эквивалентного ключевого слова.

## <a name="new--page-directive-attributes"></a>Новые атрибуты директивы @ Page

ASP.NET 2,0 добавляет в директиву @ Page множество новых атрибутов. Следующие атрибуты являются новыми в ASP.NET 2,0.

## <a name="async"></a>Асинхронный режим

Атрибут async позволяет настроить страницу для асинхронного выполнения. Хорошо покрываете асинхронные страницы позже в этом модуле.

## <a name="asynctimeout"></a>AsyncTimeout

Указывает время ожидания для асинхронных страниц. Значение по умолчанию — 45 секунд.

## <a name="codefile"></a>CodeFile

Атрибут CodeFile является заменой атрибута CodeBehind в Visual Studio 2002/2003.

### <a name="codefilebaseclass"></a>кодефилебасекласс

Атрибут Кодефилебасекласс используется в случаях, когда требуется, чтобы несколько страниц были производными от одного базового класса. Из-за реализации разделяемых классов в ASP.NET без этого атрибута базовый класс, использующий общие общие поля для ссылок на элементы управления, объявленные на странице ASPX, не будет работать должным образом, так как ядро компиляции ASP. мультисети автоматически создаст новые элементы на основе элементов управления на странице. Поэтому, если вам нужен общий базовый класс для двух или более страниц в ASP.NET, необходимо определить параметр, определяющий базовый класс в атрибуте Кодефилебасекласс, а затем унаследовать каждый класс страниц от этого базового класса. При использовании этого атрибута также требуется атрибут CodeFile.

## <a name="compilationmode"></a>компилатионмоде

Этот атрибут позволяет задать свойство Компилатионмоде страницы ASPX. Свойство Компилатионмоде — это перечисление, содержащее значения **Always**, **Auto**и **Never**. Значение по умолчанию — **всегда**. Параметр **Auto** не позволит ASP.NET динамически компилировать страницу, если это возможно. Исключение страниц из динамической компиляции повышает производительность. Однако если исключенная страница содержит код, который должен быть скомпилирован, при просмотре страницы возникнет ошибка.

## <a name="enableeventvalidation"></a>енабливентвалидатион

Этот атрибут указывает, проверяются ли обратные вызовы и события обратного вызова. Если этот параметр включен, для обратной передачи или событий обратного вызова проверяется аргументы, чтобы убедиться, что они поступили из серверного элемента управления, который изначально их отрисовывает.

## <a name="enabletheming"></a>енаблесеминг

Этот атрибут указывает, используются ли на странице ASP.NET темы. Значение по умолчанию — **false**. Темы ASP.NET рассматриваются в [модуле 10](profiles-themes-and-web-parts.md).

## <a name="linepragmas"></a>линепрагмас

Этот атрибут указывает, следует ли добавлять строки pragma во время компиляции. Строки pragma — это параметры, используемые отладчиками для пометки конкретных разделов кода.

## <a name="maintainscrollpositiononpostback"></a>маинтаинскроллпоситиононпостбакк

Этот атрибут указывает, внедряется ли JavaScript в страницу, чтобы поддерживать расположение прокрутки между обратными передачами. По умолчанию этот атрибут имеет **значение false** .

Если этот атрибут имеет **значение true**, ASP.NET добавит &lt;скрипт&gt; блок для обратной передачи, который выглядит следующим образом:

[!code-html[Main](the-asp-net-2-0-page-model/samples/sample3.html)]

Обратите внимание, что для этого блока сценария используется src. axd. Этот ресурс не является физическим путем. При запросе этого скрипта ASP.NET динамически создает скрипт.

### <a name="masterpagefile"></a>MasterPageFile

Этот атрибут указывает файл главной страницы для текущей страницы. Путь может быть как относительным, так и абсолютным. Главные страницы рассматриваются в [модуле 4](master-pages.md).

## <a name="stylesheettheme"></a>StyleSheetTheme

Этот атрибут позволяет переопределить свойства отображения пользовательского интерфейса, определенные темой ASP.NET 2,0. Темы рассматриваются в [модуле 10](profiles-themes-and-web-parts.md).

## <a name="theme"></a>Тема

Указывает тему для страницы. Если для атрибута StyleSheetTheme не указано значение, атрибут Theme переопределяет все стили, примененные к элементам управления на странице.

## <a name="title"></a>Title

Задает заголовок для страницы. Указанное здесь значение будет отображаться в элементе &lt;заголовок&gt; отображаемой страницы.

### <a name="viewstateencryptionmode"></a>виевстатинкриптионмоде

Задает значение для перечисления Виевстатинкриптионмоде. Доступные значения **всегда**, **Auto**и **Never**. Значение по умолчанию — **Auto**. Если для этого атрибута задано значение **Auto**, то функция ViewState шифруется, а элемент управления запрашивает его путем вызова метода **регистеррекуиресвиевстатинкриптион** .

## <a name="setting-public-property-values-via-the--page-directive"></a>Задание значений открытых свойств с помощью директивы @ Page

Еще одна новая возможность директивы @ Page в ASP.NET 2,0 — это возможность задать начальное значение общих свойств базового класса. Предположим, например, что у вас есть открытое свойство с именем **сометекст** в базовом классе, и вы d, как оно должно быть инициализировано для **Hello** при загрузке страницы. Это можно сделать, просто задав значение в директиве @ Page следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample4.aspx)]

Атрибут **сометекст** директивы @ Page задает начальное значение свойства сометекст в базовом классе для *Hello!* . Приведенное ниже видео представляет собой пошаговое руководство по установке начального значения общего свойства в базовом классе с помощью директивы @ Page.

![](the-asp-net-2-0-page-model/_static/image1.png)

[Открыть полноэкранное видео](the-asp-net-2-0-page-model/_static/setprop1.wmv)

## <a name="new-public-properties-of-the-page-class"></a>Новые открытые свойства класса Page

Следующие общие свойства являются новыми в ASP.NET 2,0.

## <a name="apprelativetemplatesourcedirectory"></a>аппрелативетемплатесаурцедиректори

Возвращает относительный путь приложения к странице или элементу управления. Например, для страницы, расположенной в http://app/folder/page.aspx, свойство возвращает значение ~/фолдер/.

## <a name="apprelativevirtualpath"></a>аппрелативевиртуалпас

Возвращает путь относительного виртуального каталога к странице или элементу управления. Например, для страницы, расположенной в http://app/folder/page.aspx, свойство возвращает значение ~/Фолдер/Паже.аспкс.

## <a name="asynctimeout"></a>AsyncTimeout

Возвращает или задает время ожидания, используемое для асинхронной обработки страницы. (Асинхронные страницы будут рассмотрены далее в этом модуле.)

## <a name="clientquerystring"></a>клиенткуеристринг

Свойство только для чтения, возвращающее часть строки запроса запрошенного URL-адреса. Это значение кодируется в URL-адресе. Для декодирования можно использовать метод Урлдекоде класса HttpServerUtility.

## <a name="clientscript"></a>ClientScript

Это свойство возвращает объект ClientScriptManager, который можно использовать для управления эмиссией ASP на стороне клиента. (Класс ClientScriptManager рассматривается далее в этом модуле.)

## <a name="enableeventvalidation"></a>енабливентвалидатион

Это свойство определяет, включена ли проверка событий для обратной передачи и событий обратного вызова. Если параметр включен, проверяются аргументы для обратной передачи или событий обратного вызова, чтобы убедиться, что они поступили из серверного элемента управления, который изначально их отрисовывает.

## <a name="enabletheming"></a>енаблесеминг

Это свойство получает или задает логическое значение, указывающее, применяется ли тема ASP.NET 2,0 к странице.

## <a name="form"></a>Форма

Это свойство возвращает HTML-форму на странице ASPX в качестве объекта HtmlForm.

## <a name="header"></a>Заголовок

Это свойство возвращает ссылку на объект Хтмлхеад, содержащий верхний колонтитул страницы. Возвращаемый объект Хтмлхеад можно использовать для получения и задания таблиц стилей, Meta-тегов и т. д.

## <a name="idseparator"></a>идсепаратор

Это свойство только для чтения получает символ, который используется для разделения идентификаторов элементов управления, когда ASP.NET создает уникальный идентификатор для элементов управления на странице. Он не предназначен для использования непосредственно в вашем коде.

## <a name="isasync"></a>IsAsync

Это свойство позволяет выполнять асинхронные страницы. Асинхронные страницы обсуждаются далее в этом модуле.

## <a name="iscallback"></a>IsCallback

Это свойство только для чтения возвращает **значение true** , если страница является результатом обратного вызова. Обратные вызовы обсуждаются далее в этом модуле.

## <a name="iscrosspagepostback"></a>искросспажепостбакк

Это свойство только для чтения возвращает **значение true** , если страница является частью обратной передачи между страницами. Обратные передачи между страницами рассматриваются далее в этом модуле.

## <a name="items"></a>Items

Возвращает ссылку на экземпляр IDictionary, который содержит все объекты, хранящиеся в контексте страниц. Вы можете добавлять элементы в этот объект IDictionary, и они будут доступны в течение всего времени существования контекста.

## <a name="maintainscrollpositiononpostback"></a>маинтаинскроллпоситиононпостбакк

Это свойство определяет, будет ли ASP.NET выдавать JavaScript, сохраняющий прокрутку страниц в браузере после обратной передачи. (Сведения об этом свойстве были рассмотрены ранее в этом модуле.)

## <a name="master"></a>master.

Это свойство только для чтения возвращает ссылку на экземпляр MasterPage для страницы, к которой применена Главная страница.

## <a name="masterpagefile"></a>MasterPageFile

Возвращает или задает имя файла главной страницы для страницы. Это свойство может быть задано только в методе прединициализации.

## <a name="maxpagestatefieldlength"></a>MaxPageStateFieldLength

Это свойство возвращает или задает максимальную длину состояния страниц в байтах. Если для свойства задано положительное число, состояние представления страниц будет разбиваться на несколько скрытых полей, чтобы оно не превышало указанное число байтов. Если свойство является отрицательным числом, состояние представления не будет разбиваться на фрагменты.

## <a name="pageadapter"></a>пажеадаптер

Возвращает ссылку на объект Пажеадаптер, который изменяет страницу для запрашивающего браузера.

## <a name="previouspage"></a>PreviousPage

Возвращает ссылку на предыдущую страницу в случае сервера. Передача или обратная передача между страницами.

## <a name="skinid"></a>SkinID

Указывает обложку ASP.NET 2,0, применяемую к странице.

## <a name="stylesheettheme"></a>StyleSheetTheme

Это свойство возвращает или задает таблицу стилей, применяемую к странице.

## <a name="templatecontrol"></a>темплатеконтрол

Возвращает ссылку на содержащий элемент управления для страницы.

## <a name="theme"></a>Тема

Возвращает или задает имя темы ASP.NET 2,0, применяемой к странице. Это значение должно быть задано до метода предварительной инициализации.

## <a name="title"></a>Title

Это свойство получает или задает заголовок страницы, полученный из заголовка страниц.

## <a name="viewstateencryptionmode"></a>виевстатинкриптионмоде

Возвращает или задает Виевстатинкриптионмоде страницы. Подробное описание этого свойства приведено ранее в этом модуле.

## <a name="new-protected-properties-of-the-page-class"></a>Новые защищенные свойства класса Page

Ниже приведены новые защищенные свойства класса Page в ASP.NET 2,0.

## <a name="adapter"></a>Адаптер

Возвращает ссылку на ControlAdapter, которая визуализирует страницу на устройстве, запросившего его.

## <a name="asyncmode"></a>асинкмоде

Это свойство указывает, обрабатывается ли страница в асинхронном режиме. Он предназначен для использования средой выполнения, а не непосредственно в коде.

## <a name="clientidseparator"></a>клиентидсепаратор

Это свойство возвращает символ, используемый в качестве разделителя при создании уникальных идентификаторов клиентов для элементов управления. Он предназначен для использования средой выполнения, а не непосредственно в коде.

## <a name="pagestatepersister"></a>пажестатеперсистер

Это свойство возвращает объект Пажестатеперсистер для страницы. Это свойство в основном используется разработчиками элементов управления ASP.NET.

## <a name="uniquefilepathsuffix"></a>уникуефилепассуффикс

Это свойство возвращает уникальный суффикс, добавляемый к пути к файлу для браузеров кэширования. Значение по умолчанию — \_\_УФПС = и 6-значное число.

## <a name="new-public-methods-for-the-page-class"></a>Новые открытые методы для класса Page

Следующие открытые методы являются новыми для класса Page в ASP.NET 2,0.

## <a name="addonprerendercompleteasync"></a>Метода AddOnPreRenderCompleteAsync

Этот метод регистрирует делегаты обработчика событий для асинхронного выполнения страницы. Асинхронные страницы обсуждаются далее в этом модуле.

## <a name="applystylesheetskin"></a>апплистилешитскин

Применяет свойства в таблице стилей страниц к странице.

## <a name="executeregisteredasynctasks"></a>ексекутерегистередасинктаскс

Этот метод существ асинхронную задачу.

### <a name="getvalidators"></a>Проверяющие элементы управления

Возвращает коллекцию проверяющих элементов управления для указанной группы проверки или группу проверки по умолчанию, если значение не указано.

## <a name="registerasynctask"></a>Метод RegisterAsyncTask

Этот метод регистрирует новую асинхронную задачу. Асинхронные страницы рассматриваются далее в этом модуле.

## <a name="registerrequirescontrolstate"></a>регистеррекуиресконтролстате

Этот метод сообщает ASP.NET, что состояние элемента управления Pages должно быть сохранено.

## <a name="registerrequiresviewstateencryption"></a>регистеррекуиресвиевстатинкриптион

Этот метод сообщает ASP.NET, что в ViewState страницы требуется шифрование.

## <a name="resolveclienturl"></a>ресолвеклиентурл

Возвращает относительный URL-адрес, который может использоваться для клиентских запросов на изображения и т. д.

## <a name="setfocus"></a>Функция SetFocus

Этот метод настроит фокус на элемент управления, указанный при начальной загрузке страницы.

## <a name="unregisterrequirescontrolstate"></a>унрегистеррекуиресконтролстате

Этот метод отменяет регистрацию элемента управления, переданного ему, как больше не требует сохранения состояния элемента управления.

## <a name="changes-to-the-page-lifecycle"></a>Изменения жизненного цикла страницы

Жизненный цикл страницы в ASP.NET 2,0 не изменился, но есть несколько новых методов, о которых следует знать. Жизненный цикл страницы ASP.NET 2,0 описан ниже.

## <a name="preinit-new-in-aspnet-20"></a>Прединициализация (Новая в ASP.NET 2,0)

Событием предварительной инициализации является самый ранний этап жизненного цикла, к которому имеет доступ разработчик. Добавление этого события позволяет программно изменять темы ASP.NET 2,0, главные страницы, свойства доступа для профиля ASP.NET 2,0 и т. д. В состоянии обратной передачи важно понимать, что ViewState еще не применен к элементам управления на этом этапе жизненного цикла. Таким образом, если разработчик изменяет свойство элемента управления на этом этапе, он, скорее всего, будет перезаписан позже в жизненном цикле страниц.

## <a name="init"></a>Init

Событие init не изменилось с ASP.NET 1. x. Здесь вы захотите прочитать или инициализировать свойства элементов управления на странице. На этом этапе главные страницы, темы и т. д. уже применены к странице.

## <a name="initcomplete-new-in-20"></a>Иниткомплете (новое в 2,0)

Событие Иниткомплете вызывается в конце этапа инициализации страниц. На этом этапе жизненного цикла вы можете получить доступ к элементам управления на странице, но их состояние еще не заполнено.

## <a name="preload-new-in-20"></a>Предварительная загрузка (Новая в 2,0)

Это событие вызывается после применения всех данных обратной передачи и непосредственно перед нагрузкой страницы\_.

## <a name="load"></a>Загрузить

Событие загрузки не изменилось с ASP.NET 1. x.

## <a name="loadcomplete-new-in-20"></a>LoadComplete (новое в 2,0)

Событие LoadComplete — это последнее событие на этапе загрузки страниц. На этом этапе на страницу были применены все данные обратной передачи и ViewState.

## <a name="prerender"></a>PreRender

Если вы хотите, чтобы ViewState правильно поддерживался для элементов управления, добавляемых на страницу динамически, событие PreRender является последней возможностью добавить их.

## <a name="prerendercomplete-new-in-20"></a>PreRenderComplete (новое в 2,0)

На этапе PreRenderComplete все элементы управления были добавлены на страницу, и страница готова для подготовки к просмотру. Событие PreRenderComplete — это последнее событие, возникающее перед сохранением представления просмотра страниц.

## <a name="savestatecomplete-new-in-20"></a>Савестатекомплете (новое в 2,0)

Событие Савестатекомплете вызывается сразу после сохранения всех параметров ViewState страницы и состояния элемента управления. Это последнее событие, прежде чем страница будет фактически подготовлена к просмотру в браузере.

## <a name="render"></a>Render

Метод Render не изменился с момента ASP.NET 1. x. Именно здесь инициализируется HtmlTextWriter и страница готовится к просмотру в браузере.

## <a name="cross-page-postback-in-aspnet-20"></a>Обратная передача между страницами в ASP.NET 2,0

В ASP.NET 1. x обратные передачи требовались для отправки на ту же страницу. Обратные передачи между страницами не разрешены. ASP.NET 2,0 добавляет возможность обратной передачи на другую страницу через интерфейс IButtonControl. Любой элемент управления, реализующий новый интерфейс IButtonControl (Button, LinkButton и ImageButton в дополнение к сторонним пользовательским элементам управления), может воспользоваться преимуществами этой новой функции с помощью атрибута Постбаккурл. В следующем коде показан элемент управления Button, который выполняет обратную передачу на вторую страницу.

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample5.aspx)]

При обратной передаче страницы страница, инициирующая обратную передачу, доступна через свойство PreviousPage на второй странице. Эта функция реализуется с помощью новой веб-формы\_Допостбакквисоптионс клиентской функции, которая ASP.NET 2,0 отрисовывается на странице, когда элемент управления выполняет обратную передачу на другую страницу. Эта функция JavaScript предоставляется новым обработчиком WebClient. axd, который выдает скрипт клиенту.

Приведенное ниже видео представляет собой пошаговое руководство по обратной передаче между страницами.

![](the-asp-net-2-0-page-model/_static/image2.png)

[Открыть полноэкранное видео](the-asp-net-2-0-page-model/_static/xpage1.wmv)

## <a name="more-details-on-cross-page-postbacks"></a>Дополнительные сведения о обратных передачах между страницами

### <a name="viewstate"></a>Состояние

Возможно, вы уже запросили себя о том, что происходит с состоянием представления на первой странице сценария межстраничной передачи. В конце концов, любой элемент управления, не реализующий IPostBackDataHandler, сохранит свое состояние через ViewState, поэтому для получения доступа к свойствам этого элемента управления на второй странице обратной передачи между страницами необходимо иметь доступ к ViewState для страницы. ASP.NET 2,0 выполняет этот сценарий, используя новое скрытое поле на второй странице с именем \_\_PREVIOUSPAGE. Поле формы \_\_PREVIOUSPAGE содержит ViewState для первой страницы, чтобы можно было получить доступ к свойствам всех элементов управления на второй странице.

### <a name="circumventing-findcontrol"></a>Обход Финдконтрол

В видео пошаговом руководстве по обратной передаче между страницами я использовал метод Финдконтрол для получения ссылки на элемент управления TextBox на первой странице. Этот метод хорошо работает для этой цели, но Финдконтрол является дорогостоящим и требует написания дополнительного кода. К счастью, ASP.NET 2,0 предоставляет альтернативу Финдконтрол для этой цели, которая будет работать во многих сценариях. Директива Превиауспажетипе позволяет иметь строго типизированную ссылку на предыдущую страницу с помощью атрибута TypeName или VirtualPath. Атрибут TypeName позволяет указать тип предыдущей страницы, в то время как атрибут VirtualPath позволяет ссылаться на предыдущую страницу с помощью виртуального пути. После установки директивы Превиауспажетипе необходимо предоставить элементы управления и т. д., к которым вы хотите разрешить доступ, используя открытые свойства.

## <a name="lab-1-cross-page-postback"></a>Межстраничная передача в лабораторной среде 1

В этом лабораторном занятии будет создано приложение, использующее новую функцию межстраничной передачи данных ASP.NET 2,0.

1. Откройте Visual Studio 2005 и создайте новый веб-сайт ASP.NET.
2. Добавьте новую форму WebForms с именем Page2. aspx.
3. Откройте Default. aspx в представление конструирования и добавьте элемент управления Button и TextBox. 

    1. Присвойте элементу управления Button идентификатор **SubmitButton** , а элемент управления TEXTBOX — идентификатор **имени пользователя**.
    2. Присвойте свойству Постбаккурл кнопки значение Page2. aspx.
4. Откройте Page2. aspx в представлении исходного кода.
5. Добавьте директиву @ Превиауспажетипе, как показано ниже:
6. Добавьте следующий код на страницу\_загрузки кода программной части Page2. aspx: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample6.cs)]
7. Создайте проект, щелкнув сборка в меню Сборка.
8. Добавьте следующий код в код программной части для Default. aspx: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample7.cs)]
9. Измените страницу\_загрузки в Page2. aspx на следующую: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample8.cs)]
10. Создайте проект.
11. Запустите проект.
12. Введите свое имя в текстовое поле и нажмите кнопку.
13. Что такое результат?

## <a name="asynchronous-pages-in-aspnet-20"></a>Асинхронные страницы в ASP.NET 2,0

Многие проблемы, связанные с состязанием в ASP.NET, вызваны задержкой внешних вызовов (например, веб-службы или вызовы баз данных), задержкой операций ввода/вывода файлов и т. д. Когда запрос выполняется для приложения ASP.NET, ASP.NET использует один из его рабочих потоков для обслуживания этого запроса. Этот запрос владеет потоком до тех пор, пока запрос не будет завершен и отправлен ответ. ASP.NET 2,0 ищет устранение проблем задержки при возникновении подобных проблем, добавляя возможность асинхронного выполнения страниц. Это означает, что рабочий поток может запустить запрос, а затем передать дополнительное выполнение другому потоку, тем самым быстро возвращая доступ в пул доступных потоков. Когда файловый ввод-вывод, вызов базы данных и т. д. завершен, новый поток получается из пула потоков для завершения запроса.

Первым этапом асинхронного выполнения страницы является установка атрибута **Async** директивы Page следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample9.aspx)]

Этот атрибут указывает ASP.NET реализовать IHttpAsyncHandler для страницы.

Следующим шагом является вызов метода метода AddOnPreRenderCompleteAsync в точке жизненного цикла страницы перед началом PreRender. (Этот метод обычно вызывается на странице Загрузка\_.) Метод метода AddOnPreRenderCompleteAsync принимает два параметра: Бегиневенсандлер и Ендевенсандлер. Бегиневенсандлер возвращает объект IAsyncResult, который затем передается в качестве параметра в Ендевенсандлер.

Приведенное ниже видео представляет собой пошаговое руководство по асинхронному запросу страницы.

![](the-asp-net-2-0-page-model/_static/image3.png)

[Открыть полноэкранное видео](the-asp-net-2-0-page-model/_static/async1.wmv)

> [!NOTE]
> Асинхронная страница не отображается в браузере до тех пор, пока не завершится Ендевенсандлер. Не имеет сомнения, но некоторые разработчики будут считать асинхронные запросы похожими на асинхронные обратные вызовы. Важно понимать, что это не так. Преимущество асинхронных запросов заключается в том, что первый рабочий поток может быть возвращен в пул потоков для обслуживания новых запросов, тем самым уменьшая состязание за использование операций ввода-вывода и т. д.

## <a name="script-callbacks-in-aspnet-20"></a>Обратные вызовы сценариев в ASP.NET 2,0

Веб-разработчики всегда искали способы предотвращения мерцания, связанного с обратным вызовом. В ASP.NET 1. x Смартнавигатион был наиболее распространенным методом предотвращения мерцания, но Смартнавигатион вызывал проблемы для некоторых разработчиков из-за сложности его реализации на клиенте. ASP.NET 2,0 решает эту ошибку с помощью обратных вызовов скрипта. Обратные вызовы сценариев используют XMLHttp для выполнения запросов к веб-серверу через JavaScript. Запрос XMLHttp возвращает XML-данные, которые затем можно манипулировать через DOM браузера. Код XMLHttp скрыт от пользователя новым обработчиком событий. axd.

Для настройки обратного вызова скрипта в ASP.NET 2,0 необходимо выполнить несколько действий.

## <a name="step-1--implement-the-icallbackeventhandler-interface"></a>Шаг 1. Реализация интерфейса Икаллбаккевенсандлер

Чтобы ASP.NET мог распознать вашу страницу как участие в обратном вызове скрипта, необходимо реализовать интерфейс Икаллбаккевенсандлер. Это можно сделать в файле кода программной части следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample10.cs)]

Это также можно сделать с помощью директивы @ Implements следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample11.aspx)]

При использовании встроенного кода ASP.NET обычно используется директива @ Implements.

## <a name="step-2--call-getcallbackeventreference"></a>Шаг 2. вызов Жеткаллбаккевентреференце

Как упоминалось ранее, вызов XMLHttp инкапсулирован в обработчике файла. axd. Когда страница готовится к просмотру, ASP.NET добавляет вызов\_DoCallback, клиентский сценарий, предоставляемый веб-Resource. axd. \_функция DoCallback заменяет \_\_функции Допостбакк для обратного вызова. Помните, что \_\_Допостбакк программно отправляет форму на страницу. В сценарии обратного вызова необходимо предотвратить обратную передачу, поэтому \_\_Допостбакк не будет достаточным.

> [!NOTE]
> \_\_Допостбакк по-прежнему отображается на странице в сценарии обратного вызова клиентского скрипта. Однако он не используется для обратного вызова.

Аргументы для функции\_DoCallback на стороне клиента предоставляются через функцию на стороне сервера Жеткаллбаккевентреференце, которая обычно вызывается на странице\_Load. Типичный вызов Жеткаллбаккевентреференце может выглядеть следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample12.cs)]

> [!NOTE]
> В этом случае cm является экземпляром ClientScriptManager. Класс ClientScriptManager будет рассмотрен далее в этом модуле.

Существует несколько перегруженных версий Жеткаллбаккевентреференце. В этом случае аргументы имеют следующий вид:

`this`

Ссылка на элемент управления, в котором вызывается Жеткаллбаккевентреференце. В данном случае это сама страница.

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample13.js)]

Строковый аргумент, который будет передан из клиентского кода в событие на стороне сервера. В этом случае Im передает значение раскрывающегося списка с именем Ддлкомпани.

`ShowCompanyName`

Имя клиентской функции, которая будет принимать возвращаемое значение (в виде строки) из события обратного вызова на стороне сервера. Эта функция будет вызываться только при успешном обратном вызове на стороне сервера. Таким образом, для обеспечения надежности, как правило, рекомендуется использовать перегруженную версию Жеткаллбаккевентреференце, которая принимает дополнительный строковый аргумент, указывающий имя клиентской функции для выполнения в случае ошибки.

`null`

Строка, представляющая клиентскую функцию, которая была инициирована перед обратным вызовом на сервер. В этом случае такой сценарий отсутствует, поэтому аргумент имеет значение null.

`true`

Логическое значение, указывающее, следует ли выполнять обратный вызов асинхронно.

Вызов\_DoCallback на клиенте будет передавать эти аргументы. Поэтому при отрисовке этой страницы на клиенте код будет выглядеть следующим образом:

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample14.js)]

Обратите внимание, что сигнатура функции на клиенте немного отличается. Функция на стороне клиента передает 5 строк и логическое значение. Дополнительная строка (которая имеет значение NULL в приведенном выше примере) содержит клиентскую функцию, которая будет выполнять любые ошибки обратного вызова со стороны сервера.

## <a name="step-3--hook-the-client-side-control-event"></a>Шаг 3. подключение события элемента управления на стороне клиента

Обратите внимание, что возвращаемое значение Жеткаллбаккевентреференце выше было назначено строковой переменной. Эта строка используется для подключения клиентского события для элемента управления, инициирующего обратный вызов. В этом примере обратный вызов инициируется раскрывающимся списком на странице, поэтому я хочу подключить событие *onChange* .

Чтобы привязать событие на стороне клиента, просто добавьте обработчик в разметку на стороне клиента следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample15.cs)]

Помните, что *кбреф* — это возвращаемое значение из вызова жеткаллбаккевентреференце. Он содержит вызов WebForms\_DoCallback, показанный выше.

## <a name="step-4--register-the-client-side-script"></a>Шаг 4. Регистрация скрипта на стороне клиента

Вспомним, что вызов Жеткаллбаккевентреференце указал, что клиентский сценарий, именуемый **шовкомпанинаме** , будет выполняться при удачном обратном вызове на стороне сервера. Этот скрипт необходимо добавить на страницу с помощью экземпляра ClientScriptManager. (Класс ClientScriptManager будет обсуждаться далее в этом модуле.) Это можно сделать следующим образом:

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample16.js)]

## <a name="step-5--call-the-methods-of-the-icallbackeventhandler-interface"></a>Шаг 5. вызов методов интерфейса Икаллбаккевенсандлер

Икаллбаккевенсандлер содержит два метода, которые необходимо реализовать в коде. Это **раисекаллбаккевент** и **жеткаллбаккевент**.

**Раисекаллбаккевент** принимает строку в качестве аргумента и не возвращает ничего. Строковый аргумент передается из вызова DoCallback на стороне клиента в форму\_. В этом случае это значение является атрибутом *значения* раскрывающегося списка с именем ддлкомпани. Код на стороне сервера должен быть помещен в метод Раисекаллбаккевент. Например, если обратный вызов делает веб-запрос к внешнему ресурсу, этот код следует поместить в Раисекаллбаккевент.

**Жеткаллбаккевент** отвечает за обработку возврата обратного вызова клиенту. Он не принимает аргументы и возвращает строку. Возвращаемая строка будет передаваться в качестве аргумента в функцию на стороне клиента, в данном случае *шовкомпанинаме*.

После выполнения описанных выше действий можно приступать к выполнению обратного вызова сценария в ASP.NET 2,0.

![](the-asp-net-2-0-page-model/_static/image4.png)

[Открыть полноэкранное видео](the-asp-net-2-0-page-model/_static/callback1.wmv)

Обратные вызовы скриптов в ASP.NET поддерживаются в любом браузере, поддерживающем выполнение вызовов XMLHttp. Это включает в себя все современные браузеры, используемые сегодня. Internet Explorer использует объект ActiveX XMLHttp, а другие современные браузеры (в том числе в предстоящем обозревателе IE 7) используют встроенный объект XMLHttp. Чтобы программно определить, поддерживает ли браузер обратные вызовы, можно использовать свойство **request. browser. суппорткаллбакк** . Это свойство будет возвращать **значение true** , если запрашивающий клиент поддерживает обратные вызовы скрипта.

## <a name="working-with-client-script-in-aspnet-20"></a>Работа с клиентским скриптом в ASP.NET 2,0

Клиентские скрипты в ASP.NET 2,0 управляются с помощью класса ClientScriptManager. Класс ClientScriptManager отслеживает клиентские скрипты, используя тип и имя. Это предотвращает многократную вставку одного и того же сценария на страницу несколько раз.

> [!NOTE]
> После успешной регистрации скрипта на странице любая последующая попытка зарегистрировать такой же сценарий просто приведет к тому, что сценарий не будет зарегистрирован второй раз. Дублирующиеся скрипты не добавляются и исключение не возникает. Чтобы избежать ненужных вычислений, существуют методы, с помощью которых можно определить, зарегистрирован ли скрипт, чтобы не пытаться зарегистрировать его более одного раза.

Методы ClientScriptManager должны быть знакомы всем текущим разработчикам ASP.NET:

## <a name="registerclientscriptblock"></a>регистерклиентскриптблокк

Этот метод добавляет скрипт в верхнюю часть отображаемой страницы. Это полезно для добавления функций, которые будут явно вызываться на клиенте.

Существует две перегруженные версии этого метода. Между ними часто встречаются три аргумента. К ним относятся:

`type (string)`

Аргумент ***типа*** определяет тип скрипта. Обычно рекомендуется использовать тип страницы (this. GetType ()) для типа.

`key (string)`

***Ключевой*** аргумент — это определяемый пользователем ключ для скрипта. Оно должно быть уникальным для каждого скрипта. При попытке добавить скрипт с тем же ключом и типом уже добавленного скрипта он не будет добавлен.

`script (string)`

Аргумент ***скрипта*** — это строка, содержащая фактический скрипт для добавления. Рекомендуется использовать StringBuilder для создания скрипта, а затем использовать метод ToString () на StringBuilder для назначения аргумента ***сценария*** .

Если используется перегруженный Регистерклиентскриптблокк, который принимает только три аргумента, необходимо включить в скрипт элементы скрипта (&lt;скрипт&gt; и &lt;&gt;/script).

Можно использовать перегрузку Регистерклиентскриптблокк, которая принимает четвертый аргумент. Четвертый аргумент — это логическое значение, указывающее, должен ли ASP.NET добавлять элементы скрипта. Если этот аргумент имеет **значение true**, скрипт не должен явно включать элементы скрипта.

Используйте метод Исклиентскриптблоккрегистеред, чтобы определить, был ли уже зарегистрирован скрипт. Это позволяет избежать попытки повторной регистрации скрипта, который уже был зарегистрирован.

### <a name="registerclientscriptinclude-new-in-20"></a>Регистерклиентскриптинклуде (новое в 2,0)

Тег Регистерклиентскриптинклуде создает блок скрипта, ссылающийся на внешний файл скрипта. Он имеет две перегрузки. Одна из них принимает ключ и URL-адрес. Второй добавляет третий аргумент, указывающий тип.

Например, следующий код создает блок скрипта, который ссылается на жсфунктионс. js в корне папки Scripts приложения:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample17.cs)]

Этот код создает следующий код на странице, подготовленной для просмотра:

[!code-html[Main](the-asp-net-2-0-page-model/samples/sample18.html)]

> [!NOTE]
> Блок скрипта отображается в нижней части страницы.

Используйте метод Исклиентскриптинклудерегистеред, чтобы определить, был ли уже зарегистрирован скрипт. Это позволяет избежать попытки повторной регистрации скрипта.

## <a name="registerstartupscript"></a>регистерстартупскрипт

Метод Регистерстартупскрипт принимает те же аргументы, что и метод Регистерклиентскриптблокк. Сценарий, зарегистрированный с помощью Регистерстартупскрипт, выполняется после загрузки страницы, но до события клиентской части OnLoad. В 1. X скрипты, зарегистрированные с помощью Регистерстартупскрипт, были помещены непосредственно перед &lt;закрывающим&gt; тегом, а сценарии, зарегистрированные в Регистерклиентскриптблокк, помещаются сразу после открывающего &lt;формы&gt; тега. В ASP.NET 2,0 оба они помещаются непосредственно перед закрывающим тегом&gt; закрывающий &lt;.

> [!NOTE]
> Если зарегистрировать функцию с помощью Регистерстартупскрипт, эта функция не будет выполняться до тех пор, пока вы явно не назовете ее в коде на стороне клиента.

Используйте метод Исстартупскриптрегистеред, чтобы определить, был ли уже зарегистрирован сценарий, и избежать попытки повторной регистрации скрипта.

## <a name="other-clientscriptmanager-methods"></a>Другие методы ClientScriptManager

Ниже приведены некоторые другие полезные методы класса ClientScriptManager.

|  <strong>жеткаллбаккевентреференце</strong>   |                                                 См. раздел обратные вызовы сценариев ранее в этом модуле.                                                 |
|-----------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
|  <strong>жетпостбаккклиенсиперлинк</strong>  |                Возвращает ссылку на JavaScript (JavaScript:&lt;Call&gt;), которую можно использовать для обратной передачи из события на стороне клиента.                 |
|  <strong>GetPostBackEventReference</strong>   |                                   Возвращает строку, которую можно использовать для инициации обратной передачи от клиента.                                    |
|      <strong>жетвебресаурцеурл</strong>       | Возвращает URL-адрес ресурса, внедренного в сборку. Должен использоваться в сочетании с <strong>регистерклиентскриптресаурце</strong>. |
| <strong>регистерклиентскриптресаурце</strong> |     Регистрирует веб-ресурс со страницей. Это ресурсы, внедренные в сборку и обрабатываемые новым обработчиком. axd.      |
|     <strong>RegisterHiddenField</strong>      |                                                 Регистрирует скрытое поле формы со страницей.                                                 |
|  <strong>регистеронсубмитстатемент</strong>   |                                  Регистрирует код на стороне клиента, который выполняется при отправке HTML-формы.                                   |
