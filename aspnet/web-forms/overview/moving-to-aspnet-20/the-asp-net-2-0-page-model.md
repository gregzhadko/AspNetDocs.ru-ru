---
uid: web-forms/overview/moving-to-aspnet-20/the-asp-net-2-0-page-model
title: Модель страницы ASP.NET 2.0 (англ.) Документы Майкрософт
author: rick-anderson
description: В ASP.NET 1.x у разработчиков был выбор между встроенной моделью кода и моделью кода за кодом. Код-за может быть реализована с помощью либо Src attr ...
ms.author: riande
ms.date: 02/20/2005
ms.assetid: af4575a3-0ae3-4638-ba4d-218fad7a1642
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/the-asp-net-2-0-page-model
msc.type: authoredcontent
ms.openlocfilehash: 6c2435a06d04209db21fb8e075f68ff0b7a9ef7e
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542863"
---
# <a name="the-aspnet-20-page-model"></a>Модель страницы ASP.NET 2.0

[корпорацией Майкрософт](https://github.com/microsoft)

> В ASP.NET 1.x у разработчиков был выбор между встроенной моделью кода и моделью кода за кодом. Закодава может быть реализован либо атрибут Src, @Page либо атрибут CodeBehind директивы. В ASP.NET 2.0 у разработчиков по-прежнему есть выбор между встроенным кодом и кодом, но были значительные усовершенствования модели, стоящей за кодом.

В ASP.NET 1.x у разработчиков был выбор между встроенной моделью кода и моделью кода за кодом. Закодава может быть реализован либо атрибут Src, @Page либо атрибут CodeBehind директивы. В ASP.NET 2.0 у разработчиков по-прежнему есть выбор между встроенным кодом и кодом, но были значительные усовершенствования модели, стоящей за кодом.

## <a name="improvements-in-the-code-behind-model"></a>Улучшения в модели code-behind

Для того, чтобы полностью понять изменения в модели за кодом в ASP.NET 2.0, лучше всего быстро пересмотреть модель, как она существовала в ASP.NET 1.x.

## <a name="the-code-behind-model-in-aspnet-1x"></a>Модель Code-Behind в ASP.NET 1.x

В ASP.NET 1.x модель за кодом состояла из файла ASPX (Webform) и файла с кодом, содержащего программный код. Эти два файла @Page были подключены с помощью директивы в файле ASPX. Каждый элемент управления на странице ASPX имел соответствующее заявление в файле за кодом в качестве переменной экземпляра. Файл с кодом также содержал код для привязки событий и сгенерированный код, необходимый для дизайнера Visual Studio. Эта модель работала довольно хорошо, но из-за того, что каждый элемент ASP.NET на странице ASPX требовал соответствующего кода в файле сзади кода, не было истинного разделения кода и содержимого. Например, если дизайнер добавил новый элемент управления сервером в файл ASPX за пределами Visual Studio IDE, приложение может сломаться из-за отсутствия декларации для этого элемента управления в файле с кодом.

## <a name="the-code-behind-model-in-aspnet-20"></a>Модель Code-Behind в ASP.NET 2.0

ASP.NET 2.0 значительно улучшает эту модель. В ASP.NET 2.0, код-за текует с использованием новых *частичных классов, предусмотренных* в ASP.NET 2.0. Класс за кодом в ASP.NET 2.0 определяется как частичный класс, означающий, что он содержит только часть определения класса. Оставшаяся часть определения класса динамически генерируется ASP.NET 2.0 с помощью страницы ASPX во время выполнения или при предварительной компилировании веб-узла. Связь между файлом с кодом и страницей ASPX по-прежнему устанавливается с помощью директивы «Страница». Однако вместо атрибута CodeBehind или Src ASP.NET 2.0 теперь использует атрибут CodeFile. Атрибут Inherits также используется для указания имени класса для страницы.

Типичная директива «Страница» может выглядеть следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample1.aspx)]

Типичное определение класса в ASP.NET 2.0 код-за файл может выглядеть следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample2.cs)]

> [!NOTE]
> Си-Эи и Visual Basic являются единственными управляемыми языками, которые в настоящее время поддерживают частичные классы. Таким образом, разработчики, использующие J'A, не смогут использовать модель за кодом в ASP.NET 2.0.

Новая модель улучшает модель, за которой стоит код, поскольку разработчики теперь будут иметь файлы кода, содержащие только созданный ими код. Он также предусматривает истинное разделение кода и содержимого, поскольку в файле с переменным кодом нет переменных деклараций экземпляра.

> [!NOTE]
> Поскольку частичный класс для страницы ASPX — это место, где происходит привязка событий, разработчики Visual Basic могут реализовать небольшое увеличение производительности, используя ключевое слово Handles в коде позади, чтобы связать события. У C' нет эквивалентного ключевого слова.

## <a name="new--page-directive-attributes"></a>Новые атрибуты Директивы страницы

ASP.NET 2.0 добавляет много новых атрибутов в директиву «Страница». Следующие атрибуты являются новыми в ASP.NET 2.0.

## <a name="async"></a>Async

Атрибут Async позволяет настроить страницу для асинхронного выполнения. Ну покрытия асинхронных страниц позже в этом модуле.

## <a name="asynctimeout"></a>AsyncTimeout

Указано тайм-аут для асинхронных страниц. По умолчанию она составляет 45 секунд.

## <a name="codefile"></a>Codefile

Атрибут CodeFile является заменой атрибута CodeBehind в Visual Studio 2002/2003.

### <a name="codefilebaseclass"></a>CodeFileBaseClass

Атрибут CodeFileBaseClass используется в тех случаях, когда требуется, чтобы несколько страниц были получены из одного базового класса. Из-за реализации частичных классов в ASP.NET, без этого атрибута базовый класс, который использует общие поля для эталонных элементов управления, заявленные на странице ASPX, не будет работать должным образом, поскольку движок компиляции ASP.NET автоматически создает новые элементы на основе элементов управления на странице. Поэтому, если вы хотите общий базовый класс для двух или более страниц в ASP.NET, вам нужно будет определить указать базовый класс в атрибуте CodeFileBaseClass, а затем получить каждый класс страниц из этого базового класса. Атрибут CodeFile также требуется при использовании этого атрибута.

## <a name="compilationmode"></a>КомпиляцияMode

Этот атрибут позволяет установить свойство CompilationMode страницы ASPX. Свойство CompilationMode представляет собой перечисление, содержащее значения **Всегда,** **Авто**и **Никогда.** По умолчанию **всегда**. Настройка **Auto** предотвратит динамическую компиляцию страницы ASP.NET, если это возможно. Исключение страниц из динамической компиляции повышает производительность. Однако, если исключенная страница содержит код, который должен быть скомпилирован, ошибка будет брошена при просмотре страницы.

## <a name="enableeventvalidation"></a>ВключитьСобытие

Этот атрибут определяет, проверяются ли события послеотката и обратного вызова. При включении аргументы в события послеотката или обратного откидки проверяются, чтобы убедиться, что они возникли из элемента управления сервера, который первоначально их визуалировал.

## <a name="enabletheming"></a>EnableTheming

Этот атрибут определяет, используются ли на странице ASP.NET темы. По умолчанию **является ложным.** ASP.NET темы рассматриваются в [модуле 10](profiles-themes-and-web-parts.md).

## <a name="linepragmas"></a>LinePragmas

Этот атрибут определяет, следует ли добавлять прагмы строк во время компиляции. Линейные прагмы — это варианты, используемые отладчиками для обозначения определенных разделов кода.

## <a name="maintainscrollpositiononpostback"></a>ВедениеScrollpositionOnPostback

Этот атрибут определяет, вводится ли JavaScript на страницу для поддержания позиции прокрутки между postbacks. Этот атрибут **является ложным** по умолчанию.

Когда этот атрибут **истинен,** &lt;ASP.NET&gt; добавим блок скрипта на postback который смотрит как это:

[!code-html[Main](the-asp-net-2-0-page-model/samples/sample3.html)]

Обратите внимание, что src для этого блока скрипта WebResource.axd. Этот ресурс не является физическим путем. Когда этот скрипт запрашивается, ASP.NET динамически создает сценарий.

### <a name="masterpagefile"></a>MasterPageFile

Этот атрибут определяет файл главной страницы для текущей страницы. Путь может быть как относительным, так и абсолютным. Мастер-страницы покрыты [модулем 4](master-pages.md).

## <a name="stylesheettheme"></a>StyleSheetTheme

Этот атрибут позволяет переопределить свойства внешнего вида пользовательского интерфейса, определяемые темой ASP.NET 2.0. Темы описаны в [модуле 10](profiles-themes-and-web-parts.md).

## <a name="theme"></a>Тема

Определяет тему для страницы. Если значение не указано для атрибута StyleSheetTheme, атрибут «Тема» переопределяет все стили, применяемые к элементам управления на странице.

## <a name="title"></a>Title

Устанавливает заголовок для страницы. Значение, указанное здесь, &lt;&gt; будет отображаться в элементе заголовка отображаемых страниц.

### <a name="viewstateencryptionmode"></a>ViewStateEncryptionMode

Устанавливает значение для перечисления ViewStateEncryptionMode. Доступные значения **всегда,** **Авто**, и **никогда**. Значение по умолчанию **— Авто**. Когда этот атрибут установлен на значение **Auto,** состояние представления зашифровано, это контроль запрашивает его, позвонив **методу шифрования RegisterRequiresViewState.**

## <a name="setting-public-property-values-via-the--page-directive"></a>Установка значений государственного имущества с помощью Директивы о страницах

Еще одной новой возможностью директивы «Страница» в ASP.NET 2.0 является возможность установить начальное значение публичных свойств базового класса. Предположим, например, что у вас есть общедоступное свойство **someText** в базовом классе, и вы бы хотели, чтобы она была инициализована **hello** при загрузке страницы. Вы можете достичь этого, просто установив значение в директиве «Страница» следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample4.aspx)]

Атрибут **SomeText** директивы «Страница» устанавливает начальное значение свойства SomeText в базовом классе *на Hello!*. Видео ниже представляет собой пошаговый шаг по установлению начальной стоимости государственной собственности в базовом классе с использованием директивы «Страница».

![](the-asp-net-2-0-page-model/_static/image1.png)

[Открытое полноэкранное видео](the-asp-net-2-0-page-model/_static/setprop1.wmv)

## <a name="new-public-properties-of-the-page-class"></a>Новые публичные свойства класса Страницы

Следующие общественные свойства являются новыми в ASP.NET 2.0.

## <a name="apprelativetemplatesourcedirectory"></a>AppRelativeTemplateИсточник

Возвращает относительно-относительный путь приложения на страницу или элемент управления. Например, для страницы, расположенной по адресу, http://app/folder/page.aspxсвойство возвращается q/folder/.

## <a name="apprelativevirtualpath"></a>AppRelativeVirtualPath

Возвращает относительный виртуальный путь каталога на страницу или элемент управления. Например, для страницы, расположенной по адресу http://app/folder/page.aspx, свойство возвращается q/folder/page.aspx.

## <a name="asynctimeout"></a>AsyncTimeout

Получает или устанавливает тайм-аут, используемый для асинхронной обработки страниц. (Асинхронные страницы будут покрыты позже в этом модуле.)

## <a name="clientquerystring"></a>КлиенткуриСтринг

Свойство только для чтения, возвращающего строку запроса в запрашиваемом URL. Это значение закодировано URL. Для его декодирования можно использовать метод UrlDecode класса HttpServerUtility.

## <a name="clientscript"></a>КлиентСкийсценарий

Это свойство возвращает объект ClientScriptManager, который может быть использован для управления выбросом ASP.NETs сценария на стороне клиента. (Класс ClientScriptManager описан позже в этом модуле.)

## <a name="enableeventvalidation"></a>ВключитьСобытие

Это свойство контролирует, включена ли проверка событий для событий послевозврата и обратного вызова. При включении аргументы в события послеотката или обратного откаста проверяются, чтобы убедиться, что они возникли из управления сервера, который первоначально их визуализировал.

## <a name="enabletheming"></a>EnableTheming

Это свойство получает или устанавливает Boolean, который определяет, является ли ASP.NET 2.0 тема относится к странице.

## <a name="form"></a>Form

Это свойство возвращает форму HTML на странице ASPX в качестве объекта HTMLForm.

## <a name="header"></a>Заголовок

Это свойство возвращает ссылку на объект HtmlHead, содержащий заголовок страницы. Вы можете использовать возвращенный объект HtmlHead для получения/установки листов стилей, меток Meta и т.д.

## <a name="idseparator"></a>ИдСепаратор

Это свойство только для чтения получает символ, который используется для разделения идентификаторов управления, когда ASP.NET строит уникальный идентификатор для элементов управления на странице. Он не предназначен для использования непосредственно в вашем коде.

## <a name="isasync"></a>IsAsync

Это свойство позволяет асинхронные страницы. Асинхронные страницы обсуждаются позже в этом модуле.

## <a name="iscallback"></a>IsCallback

Это только чтение собственности возвращается **верно,** если страница является результатом вызова обратно. Обратный вызов обсуждается позже в этом модуле.

## <a name="iscrosspagepostback"></a>IsCrossPagePostBack

Это только чтение собственности **возвращается верно,** если страница является частью кросс-страницы postback. Кросс-страницы postbacks рассматриваются позже в этом модуле.

## <a name="items"></a>Items

Возвращает ссылку на экземпляр IDictionary, содержащий все объекты, хранящиеся в контексте страниц. Вы можете добавить элементы к этому объекту IDictionary, и они будут доступны вам в течение всего срока действия контекста.

## <a name="maintainscrollpositiononpostback"></a>ВедениеScrollpositiononPostback

Это свойство контролирует, излучает ли ASP.NET JavaScript, который поддерживает положение прокрутки страниц в браузере после возникновения postback. (Детали этого свойства обсуждались ранее в этом модуле.)

## <a name="master"></a>master.

Это свойство только для чтения возвращает ссылку на экземпляр MasterPage для страницы, к которой была применена главная страница.

## <a name="masterpagefile"></a>MasterPageFile

Получает или устанавливает имя файла главной страницы для страницы. Это свойство может быть установлено только в методе PreInit.

## <a name="maxpagestatefieldlength"></a>MaxPageStateFieldДлин

Это свойство получает или устанавливает максимальную длину для состояния страниц в байтах. Если свойство настроено на положительное число, состояние представления страниц будет разбито на несколько скрытых полей, чтобы оно не превышало указанное количество байтов. Если свойство является отрицательным числом, состояние представления не будет разбито на куски.

## <a name="pageadapter"></a>PageAdapter

Возвращает ссылку на объект PageAdapter, который изменяет страницу для запрашивающего браузера.

## <a name="previouspage"></a>ПредыдущаяСтраница

Возвращает ссылку на предыдущую страницу в случаях Server.Transfer или кросс-страницы postback.

## <a name="skinid"></a>SkinID

Упомяните ASP.NET 2.0 кожи, чтобы применить к странице.

## <a name="stylesheettheme"></a>StyleSheetTheme

Это свойство получает или устанавливает лист стиля, который применяется к странице.

## <a name="templatecontrol"></a>TemplateControl

Возвращает ссылку на элемент управления для страницы.

## <a name="theme"></a>Тема

Получает или устанавливает название темы ASP.NET 2.0, применяемой на странице. Это значение должно быть установлено до метода PreInit.

## <a name="title"></a>Title

Это свойство получает или устанавливает название страницы, полученное от заголовка страниц.

## <a name="viewstateencryptionmode"></a>ViewStateEncryptionMode

Получает или устанавливает ViewStateEncryptionMode страницы. Смотрите подробное обсуждение этого свойства ранее в этом модуле.

## <a name="new-protected-properties-of-the-page-class"></a>Новые защищенные свойства класса Страницы

Ниже приведены новые защищенные свойства класса Страницы в ASP.NET 2.0.

## <a name="adapter"></a>Адаптер

Возвращает ссылку на ControlAdapter, который отображает страницу на запрашиваемом устройстве.

## <a name="asyncmode"></a>AsyncMode

Это свойство указывает, обрабатывается ли страница асинхронно. Предназначен для использования времен выполнения, а не непосредственно в коде.

## <a name="clientidseparator"></a>ClientIDСепаратор

Это свойство возвращает символ, используемый в качестве сепаратора при создании уникальных идонов клиента для элементов управления. Предназначен для использования времен выполнения, а не непосредственно в коде.

## <a name="pagestatepersister"></a>PageStatePersister

Это свойство возвращает объект PageStatePersister для страницы. Это свойство в основном используется разработчиками ASP.NET управления.

## <a name="uniquefilepathsuffix"></a>УникальныйFilePathSuffix

Это свойство возвращает уникальный суффикс, который придатимся к пути файла для кэширования браузеров. Значение по \_ \_умолчанию является ufps и 6-значным числом.

## <a name="new-public-methods-for-the-page-class"></a>Новые общедоступные методы для класса Страницы

Следующие общедоступные методы являются новыми для класса Страницы в ASP.NET 2.0.

## <a name="addonprerendercompleteasync"></a>АддонпререндерКомплектАсин

Этот метод регистрирует делегатов обработчика событий для асинхронного выполнения страницы. Асинхронные страницы обсуждаются позже в этом модуле.

## <a name="applystylesheetskin"></a>ApplyStyleSheetSkin

Применяет свойства в листе стиля страниц на страницу.

## <a name="executeregisteredasynctasks"></a>ВыполнениеЗарегистрированныеазадачи

Этот метод является асинхронной задачей.

### <a name="getvalidators"></a>GetValidators

Возвращает коллекцию валидаторов для указанной группы проверки или группы проверки по умолчанию, если ни один из них не указан.

## <a name="registerasynctask"></a>RegisterAsyncTask

Этот метод регистрирует новую задачу асин. Асинхронные страницы рассматриваются позже в этом модуле.

## <a name="registerrequirescontrolstate"></a>РегистрацияТребуетКонтрольГосударства

Этот метод говорит ASP.NET, что состояние управления страницами должно быть упорным.

## <a name="registerrequiresviewstateencryption"></a>РегистрТребуетСяВгогосударственноешифрование

Этот метод говорит ASP.NET, что состояние просмотра страниц требует шифрования.

## <a name="resolveclienturl"></a>ResolveClientUrl

Возвращает относительный URL-адрес, который может быть использован для запросов клиентов на изображения и т.д.

## <a name="setfocus"></a>SetFocus

Этот метод установит фокус на элемент управления, который указан при первоначальной загрузке страницы.

## <a name="unregisterrequirescontrolstate"></a>НерегистрируйтеТребуетКонтрольгосударства

Этот метод будет отменить регистрацию элемента управления, который передается ему, как не требующий сохранения состояния управления.

## <a name="changes-to-the-page-lifecycle"></a>Изменения жизненного цикла Страницы

Жизненный цикл страницы в ASP.NET 2.0 не изменился кардинально, но есть некоторые новые методы, которые вы должны знать. В приведенный ниже жизненный цикл ASP.NET 2.0.

## <a name="preinit-new-in-aspnet-20"></a>PreInit (Новый в ASP.NET 2.0)

Событие PreInit является самым ранним этапом жизненного цикла, к которым может получить сяопрожитель. Добавление этого события позволяет программно менять ASP.NET 2.0 темы, мастер-страницы, свойства доступа для профиля ASP.NET 2.0 и т.д. Если вы находитесь в состоянии послебека, важно понимать, что Viewstate еще не был применен к элементам управления на данном этапе жизненного цикла. Таким образом, если разработчик изменяет свойство элемента управления на данном этапе, он, скорее всего, будет перезаписан позже в жизненном цикле страниц.

## <a name="init"></a>Init

Событие Init не изменилось с ASP.NET 1.x. Здесь вы хотели бы прочитать или инициализировать свойства элементов управления на вашей странице. На этом этапе на страницу уже применяются мастер-страницы, темы и т.д.

## <a name="initcomplete-new-in-20"></a>InitComplete (Новый в 2.0)

Событие InitComplete называется в конце этапа инициализации страниц. На этом этапе жизненного цикла можно получить доступ к элементам управления на странице, но их состояние еще не заселены.

## <a name="preload-new-in-20"></a>Предгрузка (Новая в 2.0)

Это событие вызывается после того, как все данные postback были применены и непосредственно перед загрузкой Страницы.\_

## <a name="load"></a>Загрузить

Событие нагрузки не изменилось с ASP.NET 1.x.

## <a name="loadcomplete-new-in-20"></a>ЗагрузкаПолл (Новый в 2.0)

Событие LoadComplete является последним событием на этапе загрузки страниц. На этом этапе все данные postback и viewstate были применены к странице.

## <a name="prerender"></a>Prerender

Если вы хотите, чтобы состояние представления было надлежащим образом сохранено для элементов управления, которые добавляются на страницу динамически, событие PreRender является последней возможностью добавить их.

## <a name="prerendercomplete-new-in-20"></a>PreRenderComplete (Новый в 2.0)

На этапе PreRenderComplete все элементы управления были добавлены на страницу, и страница готова к визуализации. Событие PreRenderComplete — это последнее событие, поднятое до сохранения состояния просмотра страниц.

## <a name="savestatecomplete-new-in-20"></a>SaveStateComplete (Новый в 2.0)

Событие SaveStateComplete вызывается сразу после сохранения состояния просмотра и управления. Это последнее событие, прежде чем страница фактически отображается в браузере.

## <a name="render"></a>Render

Метод Рендера не изменялся с ASP.NET 1.x. Здесь инициализирован атакжемирован htmlTextWriter и страница отображается в браузере.

## <a name="cross-page-postback-in-aspnet-20"></a>Кросс-Page Postback в ASP.NET 2.0

В ASP.NET 1.x, postbacks были необходимы для того чтобы вывесить к такой же странице. Кросс-страницы postbacks не были разрешены. ASP.NET 2.0 добавляет возможность отправлять на другую страницу через интерфейс IButtonControl. Любой элемент управления, который реализует новый интерфейс IButtonControl (Button, LinkButton и ImageButton в дополнение к сторонним пользовательским элементам управления), может воспользоваться этой новой функциональностью с помощью атрибута PostBackUrl. Следующий код показывает элемент управления кнопки, который публикует обратно на вторую страницу.

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample5.aspx)]

Когда страница размещена обратно, Страница, которая инициирует postback, доступна через свойство PreviousPage на второй странице. Эта функциональность реализуется с\_помощью новой функции клиента WebForm DoPostBackWithOptions, которая ASP.NET 2.0 отображается на странице, когда элемент управления возвращается на другую страницу. Эта функция JavaScript обеспечивается новым обработчиком WebResource.axd, который излучает скрипт для клиента.

Видео ниже является пошаговой перекрестной странице postback.

![](the-asp-net-2-0-page-model/_static/image2.png)

[Открытое полноэкранное видео](the-asp-net-2-0-page-model/_static/xpage1.wmv)

## <a name="more-details-on-cross-page-postbacks"></a>Более подробная информация о Кросс-Page Postbacks

### <a name="viewstate"></a>Viewstate

Возможно, вы уже задали себе вопрос о том, что происходит с состоянием представления с первой страницы в сценарии постбека на перекрестной странице. В конце концов, любой элемент управления, который не реализует IPostBackDataHandler будет сохранять свое состояние через viewstate, так что иметь доступ к свойствам этого элемента управления на второй странице кросс-страницы postback, вы должны иметь доступ к состоянию представления для страницы. ASP.NET 2.0 заботится об этом сценарии, используя \_ \_новое скрытое поле на второй странице под названием PREVIOUSPAGE. Поле \_ \_формы PREVIOUSPAGE содержит состояние представления для первой страницы, чтобы вы могли иметь доступ к свойствам всех элементов управления на второй странице.

### <a name="circumventing-findcontrol"></a>Обход ПоискаКонтроль

В видео-пошаговое решение кросс-страницы postback, я использовал метод FindControl, чтобы получить ссылку на контроль TextBox на первой странице. Этот метод хорошо работает для этой цели, но FindControl является дорогостоящим и требует написания дополнительного кода. К счастью, ASP.NET 2.0 предоставляет альтернативу FindControl для этой цели, которая будет работать во многих сценариях. Директива PreviousPageType позволяет иметь сильно типировую ссылку на предыдущую страницу, используя либо TypeName, либо атрибут VirtualPath. Атрибут TypeName позволяет указать тип предыдущей страницы, в то время как атрибут VirtualPath позволяет ссылаться на предыдущую страницу с помощью виртуального пути. После установки директивы PreviousPageType необходимо предоставить элементы управления и т.д., к которым вы хотите разрешить доступ с помощью общедоступных свойств.

## <a name="lab-1-cross-page-postback"></a>Лаборатория 1 Кросс-Пейдж Постбэк

В этой лаборатории вы создадите приложение, используювшее новую функцию постбека кросс-страницы ASP.NET 2.0.

1. Открыть Visual Studio 2005 и создать новый веб-сайт ASP.NET.
2. Добавьте новую веб-форму под названием page2.aspx.
3. Откройте Default.aspx в представлении design view и добавьте управление кнопки и управление TextBox. 

    1. Дайте кнопке управления ID **SubmitButton** и TextBox управления ID **UserName**.
    2. Установите свойство PostBackUrl кнопки на page2.aspx.
4. Откройте страницу2.aspx в представлении Исходного кода.
5. Добавить директиву «ПредыдущийPageType», как показано ниже:
6. Добавьте следующий код\_в страницу Загрузить страницу page2.aspx в код-за: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample6.cs)]
7. Создайте проект, нажав на меню Build on the Build.
8. Добавьте следующий код в код-задля для Default.aspx: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample7.cs)]
9. Измените\_загрузку страницы в page2.aspx на следующее: 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample8.cs)]
10. Создайте проект.
11. Запустите проект.
12. Введите свое имя в TextBox и нажмите кнопку.
13. Каков результат?

## <a name="asynchronous-pages-in-aspnet-20"></a>Асинхронные страницы в ASP.NET 2.0

Многие проблемы с утверждением в ASP.NET вызваны задержкой внешних вызовов (таких как веб-служба или вызовы базы данных), задержкой в исправления файла и т.д. Когда запрос сделан против ASP.NET приложения, ASP.NET использует один из своих рабочих потоков для обслуживания этого запроса. Этот запрос владеет этим потоком до тех пор, пока запрос не будет завершен и не будет отправлен ответ. ASP.NET 2.0 стремится решить проблемы с задержкой с этими типами проблем, добавив возможность выполнять страницы асинхронно. Это означает, что поток рабочего может начать запрос, а затем передать дополнительное выполнение другому потоку, тем самым быстро вернувшись в доступный пул потока. Когда вызов файла io, вызов базы данных и т.д. завершен, новый поток получается из пула потоков для завершения запроса.

Первым шагом в обеспечении асинхронного выполнения страницы является установка атрибута **Async** директивы страницы следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample9.aspx)]

Этот атрибут говорит ASP.NET для реализации IHttpAsyncHandler для страницы.

Следующим шагом является вызов метода AddOnPreRenderCompleteAsync в точке жизненного цикла страницы до PreRender. (Этот метод обычно вызывается в Page\_Load.) Метод AddOnPreRenderCompleteAsync занимает два параметра; BeginEventHandler и EndEventHandler. BeginEventHandler возвращает IAsyncResult, который затем передается в качестве параметра в EndEventHandler.

Видео ниже является пошаговый шаг асинхронного запроса страницы.

![](the-asp-net-2-0-page-model/_static/image3.png)

[Открытое полноэкранное видео](the-asp-net-2-0-page-model/_static/async1.wmv)

> [!NOTE]
> Страница async не отображается в браузере до завершения EndEventHandler. Без сомнения, но что некоторые разработчики будут думать о async запросы как похожие на async обратных вызовов. Важно понимать, что это не так. Преимущество асинхронных запросов заключается в том, что первый поток рабочего может быть возвращен в пул потоков для обслуживания новых запросов, тем самым уменьшая раздор из-за того, что он связан с истечением времени и т.д.

## <a name="script-callbacks-in-aspnet-20"></a>Обратный вызов в ASP.NET 2.0

Веб-разработчики всегда искали способы предотвратить мерцание, связанное с обратным вызовом. В ASP.NET 1.x, SmartNavigation был наиболее распространенным методом для избежания мерцания, но SmartNavigation вызвало проблемы для некоторых разработчиков из-за сложности его реализации на клиенте. ASP.NET 2.0 решает эту проблему с помощью обратных вызовов скриптов. Обратные вызовы скриптов используют XMLHttp для запросов на веб-сервер через JavaScript. Запрос XMLHttp возвращает данные XML, которыми затем можно манипулировать с помощью DOM браузера. Код XMLHttp скрыт от пользователя новым обработчиком WebResource.axd.

Есть несколько шагов, которые необходимы для настройки вызова скрипта в ASP.NET 2.0.

## <a name="step-1--implement-the-icallbackeventhandler-interface"></a>Шаг 1 : Реализация интерфейса ICallbackEventHandler

Для того, чтобы ASP.NET распознать вашу страницу как участвующую в обратном вызове скриптов, необходимо реализовать интерфейс ICallbackEventHandler. Вы можете сделать это в файле с кодом так:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample10.cs)]

Вы также можете сделать это с помощью директивы «Реализации» следующим образом:

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample11.aspx)]

Обычно при использовании вневого ASP.NET кода используется директива «Реализации».

## <a name="step-2--call-getcallbackeventreference"></a>Шаг 2 : Позвоните GetCallbackEventСправка

Как упоминалось ранее, вызов XMLHttp инкапсулируется в обработчике WebResource.axd. Когда ваша страница будет визуализирована,\_ASP.NET добавит вызов webForm DoCallback, клиентский скрипт, предоставляемый WebResource.axd. Функция WebForm\_DoCallback заменяет функцию \_ \_doPostBack для обратного вызова. Помните, что \_ \_doPostBack программно представляет форму на странице. В сценарии обратного вызова, вы хотите \_ \_предотвратить postback, так doPostBack не будет достаточно.

> [!NOTE]
> \_\_doPostBack по-прежнему отображается на страницу в сценарии обратного вызова сценария клиента. Тем не менее, он не используется для обратного вызова.

Аргументы в пользу\_функции клиента WebForm DoCallback предоставляются через функцию на стороне сервера GetCallbackEventReference, которая обычно называется в Page\_Load. Типичный звонок на GetCallbackEventReference может выглядеть следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample12.cs)]

> [!NOTE]
> В этом случае см является экземпляром ClientScriptManager. Класс ClientScriptManager будет рассмотрен позже в этом модуле.

Есть несколько перегруженных версий GetCallbackEventReference. В этом случае аргументы следующие:

`this`

Ссылка на элемент управления, где GetCallbackEventReference в настоящее время называется. В этом случае, это сама страница.

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample13.js)]

Строка аргумент, который будет передан от клиента стороне кода на сервер стороне события. В этом случае Im передает значение выпадения, называемое ddlCompany.

`ShowCompanyName`

Имя функции клиента, которая будет принимать значение возврата (как строка) от события обратного вызова на стороне сервера. Эта функция будет вызываться только тогда, когда обратный вызов на стороне сервера будет успешным. Поэтому, ради надежности, обычно рекомендуется использовать перегруженную версию GetCallbackEventReference, которая требует дополнительного аргумента строки, определяющей название функции клиента для выполнения в случае ошибки.

`null`

Строка, представляющая функцию стороны клиента, инициированную до обратного вызова на сервер. В этом случае такого сценария нет, поэтому аргумент необылен.

`true`

Булеан, определяющий, следует ли проводить обратный вызов асинхронно.

Вызов webForm\_DoCallback на клиента будет передавать эти аргументы. Поэтому, когда эта страница отображается на клиенте, этот код будет выглядеть так:

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample14.js)]

Обратите внимание, что подпись функции на клиенте немного отличается. Функция клиентской стороны проходит 5 строк и Boolean. Дополнительная строка (которая является нулевой в приведенном выше примере) содержит функцию стороны клиента, которая будет обрабатывать любые ошибки, связанные с обратным вызовом на стороне сервера.

## <a name="step-3--hook-the-client-side-control-event"></a>Шаг 3 : Крюк клиент-сторона событие управления

Обратите внимание, что значение возврата GetCallbackEventReference выше было назначено строке переменной. Эта строка используется для подключения события на стороне клиента для управления, которое инициирует обратный вызов. В этом примере обратный вызов инициируется выпадением на странице, поэтому я хочу подключить событие *OnChange.*

Чтобы подключить событие на стороне клиента, просто добавьте обработчик в разметку на стороне клиента следующим образом:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample15.cs)]

Напомним, что *cbRef* является значением возврата от вызова к GetCallbackEventReference. Он содержит вызов WebForm\_DoCallback, который был показан выше.

## <a name="step-4--register-the-client-side-script"></a>Шаг 4 : Регистрация сценария клиента

Напомним, что вызов в GetCallbackEventReference уточнил, что клиентский скрипт под названием **ShowCompanyName** будет выполнен, когда обратный вызов на стороне сервера будет выполнен. Этот скрипт должен быть добавлен на страницу с помощью экземпляра ClientScriptManager. (Класс ClientScriptManager будет обсуждаться позже в этом модуле.) Вы делаете это так:

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample16.js)]

## <a name="step-5--call-the-methods-of-the-icallbackeventhandler-interface"></a>Шаг 5 : Позвоните методы интерфейса ICallbackEventHandler

ICallbackEventHandler содержит два метода, которые необходимо реализовать в коде. Они **RaiseCallbackEvent** и **GetCallbackEvent**.

**RaiseCallbackEvent** принимает строку в качестве аргумента и ничего не возвращает. Аргумент строки передается от вызова на\_стороне клиента к WebForm DoCallback. В этом случае это значение является атрибутом *значения* выпадения, называемым ddlCompany. Код сервера должен быть помещен в метод RaiseCallbackEvent. Например, если ваш обратный вызов делает WebRequest против внешнего ресурса, этот код должен быть размещен в RaiseCallbackEvent.

**GetCallbackEvent** отвечает за обработку возврата обратного вызова клиенту. Он не принимает никаких аргументов и возвращает строку. Строка, которую она возвращает, будет передана в качестве аргумента функции клиента, в данном случае *ShowCompanyName*.

После того как вы завершили вышеуказанные шаги, вы готовы выполнить обратный вызов скрипта в ASP.NET 2.0.

![](the-asp-net-2-0-page-model/_static/image4.png)

[Открытое полноэкранное видео](the-asp-net-2-0-page-model/_static/callback1.wmv)

Обратные вызовы с криптами в ASP.NET поддерживаются в любом браузере, который поддерживает вызовы XMLHttp. Это включает в себя все современные браузеры в использовании сегодня. Internet Explorer использует объект XMLHttp ActiveX, в то время как другие современные браузеры (включая предстоящий IE 7) используют внутренний объект XMLHttp. Чтобы программно определить, поддерживает ли браузер обратные вызовы, можно использовать свойство **Request.Browser.SupportCallback.** Это свойство **вернется,** если запрашивающий клиент поддерживает обратные вызовы скриптов.

## <a name="working-with-client-script-in-aspnet-20"></a>Работа с клиентским скриптом в ASP.NET 2.0

Клиентские скрипты в ASP.NET 2.0 управляются с помощью класса ClientScriptManager. Класс ClientScriptManager отслеживает клиентские сценарии с использованием типа и имени. Это предотвращает программную вставку одного и того же скрипта на странице несколько раз.

> [!NOTE]
> После того, как скрипт был успешно зарегистрирован на странице, любая последующая попытка зарегистрировать тот же скрипт просто приведет к тому, что сценарий не будет зарегистрирован во второй раз. Дублировать скрипты не добавляется, и никаких исключений не происходит. Чтобы избежать ненужных вычислений, существуют методы, которые можно использовать, чтобы определить, зарегистрирован ли скрипт, чтобы не пытаться зарегистрировать его более одного раза.

Методы ClientScriptManager должны быть знакомы всем действующим ASP.NET разработчикам:

## <a name="registerclientscriptblock"></a>РегистрацияКлиентСКрипт

Этот метод добавляет скрипт в верхнюю часть отображаемой страницы. Это полезно для добавления функций, которые будут явно вызваны для клиента.

Существует две перегруженные версии этого метода. Среди них распространены три из четырех аргументов. К ним относятся:

`type (string)`

Аргумент ***типа*** определяет тип для скрипта. Это, как правило, хорошая идея, чтобы использовать тип страницы (это. GetType()) для типа.

`key (string)`

***Ключевым*** аргументом является пользовательский ключ для скрипта. Это должно быть уникальным для каждого скрипта. Если вы попытаетесь добавить сценарий с тем же ключом и типом уже добавленного скрипта, он не будет добавлен.

`script (string)`

Аргумент ***скрипта*** — это строка, содержащая фактический сценарий для добавления. Рекомендуется использовать StringBuilder для создания скрипта, а затем использовать метод ToString() на StringBuilder для присвоения аргумента ***скрипта.***

Если вы используете перегруженный RegisterClientScriptBlock, который принимает только три&lt;аргумента, вы должны включить элементы скрипта (скрипт и&gt; &lt;/скрипт)&gt;в свой сценарий.

Вы можете использовать перегрузку RegisterClientScriptBlock, которая принимает четвертый аргумент. Четвертым аргументом является Boolean, который определяет, следует ли ASP.NET добавлять элементы сценария для вас. Если этот аргумент **верный,** сценарий не должен включать элементы скрипта явно.

Используйте метод IsClientScriptBlockRegistered, чтобы определить, был ли скрипт уже зарегистрирован. Это позволяет избежать попытки перерегистрации уже зарегистрированного скрипта.

### <a name="registerclientscriptinclude-new-in-20"></a>RegisterClientScriptInclude (Новый в 2.0)

Тег RegisterClientScriptInclude создает блок скрипта, который ссылается на внешний файл скрипта. Он имеет две перегрузки. Один берет ключ и URL. Второй добавляет третий аргумент с указанием типа.

Например, следующий код генерирует блок скриптов, который ссылается на jsfunctions.js в корне папки скриптов приложения:

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample17.cs)]

Этот код создает следующий код на отображаемых страницах:

[!code-html[Main](the-asp-net-2-0-page-model/samples/sample18.html)]

> [!NOTE]
> Блок скрипта отображается в нижней части страницы.

Используйте метод IsClientScriptIncludeRegistered, чтобы определить, был ли скрипт уже зарегистрирован. Это позволяет избежать попытки перерегистрации скрипта.

## <a name="registerstartupscript"></a>РегистрацияStartupScript

Метод RegisterStartupScript использует те же аргументы, что и метод RegisterClientScriptBlock. Скрипт, зарегистрированный в RegisterStartupScript, выполняется после загрузки страницы, но до события на стороне клиента OnLoad. В 1.X скрипты, зарегистрированные в RegisterStartupScript,&gt; были размещены непосредственно перед тегом закрытия/формы, &lt; &lt;&gt; в то время как скрипты, зарегистрированные в RegisterClientScriptBlock, были размещены сразу после тега формы открытия. В ASP.NET 2.0, оба размещаются непосредственно перед закрытием &lt;/ тег формы.&gt;

> [!NOTE]
> Если вы регистрируете функцию в RegisterStartupScript, эта функция не будет выполняться до тех пор, пока вы явно не назовете ее в коде клиентской стороны.

Используйте метод IsStartupScriptRegistered, чтобы определить, был ли скрипт уже зарегистрирован, и избежать попытки перерегистрации скрипта.

## <a name="other-clientscriptmanager-methods"></a>Другие методы ClientScriptManager

Вот некоторые из других полезных методов класса ClientScriptManager.

|  <strong>GetCallbackEventСправка</strong>   |                                                 Смотрите обратные вызовы сценариев ранее в этом модуле.                                                 |
|-----------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
|  <strong>GetPostBackКлиентГиперлинк</strong>  |                Получает ссылку JavaScript (javascript:&lt;вызов),&gt;который может быть использован для публикации от события на стороне клиента.                 |
|  <strong>GetPostBackEventСправка</strong>   |                                   Получает строку, которая может быть использована для инициирования публикации обратно от клиента.                                    |
|      <strong>GetWebResourceUrl</strong>       | Возвращает URL-адрес ресурсу, встроенного в сборку. Необходимо использовать совместно с <strong>RegisterClientScriptResource</strong>. |
| <strong>РегистрацияКлиентСКриптРесурс</strong> |     Регистрация веб-ресурса со страницей. Это ресурсы, встроенные в сборку и обрабатываемые новым обработчиком WebResource.axd.      |
|     <strong>РегистрХидноеполе</strong>      |                                                 Регистрирует скрытое поле формы со страницей.                                                 |
|  <strong>RegisteronSubmitStatement</strong>   |                                  Регистрирует код на стороне клиента, который выполняется при отправке формы HTML.                                   |
