---
uid: web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
title: Профили, темы и веб-части Документы Майкрософт
author: rick-anderson
description: В ASP.NET 2.0 произошли значительные изменения в конфигурации и приборах. Новый API конфигурации ASP.NET позволяет вносить изменения конфигурации pr...
ms.author: riande
ms.date: 02/20/2005
ms.assetid: 92df4051-77c6-492c-bd34-23d24189cea4
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
msc.type: authoredcontent
ms.openlocfilehash: 4bc98cca226a0bd9bd766a21e88b0facf2a4b610
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81543643"
---
# <a name="profiles-themes-and-web-parts"></a>Профили, темы и веб-части

[корпорацией Майкрософт](https://github.com/microsoft)

> В ASP.NET 2.0 произошли значительные изменения в конфигурации и приборах. Новый API конфигурации ASP.NET позволяет осуществлять программные изменения конфигурации. Кроме того, многие новые настройки конфигурации позволяют новые конфигурации и приборы.

ASP.NET 2.0 представляет собой существенное улучшение в области персонализированных веб-сайтов. В дополнение к функциям членства, которые мы уже рассмотрели, ASP.NET профили, темы и веб-части значительно повышают персонализацию на веб-сайтах.

## <a name="aspnet-profiles"></a>профили ASP.NET

ASP.NET профили похожи на сеансы. Разница в том, что профиль является постоянным, в то время как сеанс теряется при закрытии браузера. Еще одна большая разница между сеансами и профилями заключается в том, что профили сильно набраны, поэтому предоставляет вам IntelliSense в процессе разработки.

Профиль определяется либо в файле конфигурации машин, либо в файле web.config для приложения. (Вы не можете определить профиль в файле web.folders web.config.) Приведенный ниже код определяет профиль для хранения имени и фамилии посетителей веб-узла.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample1.xml)]

Тип данных по умолчанию для свойства профиля — System.String. В приведенном выше примере тип данных не указан. Поэтому свойства FirstName и LastName являются типами строки. Как упоминалось ранее, свойства профиля сильно набраны. Приведенный ниже код добавляет новое свойство для возраста типа Int32.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample2.xml)]

Профили обычно используются с проверкой подлинности ASP.NET форм. При использовании в сочетании с аутентификацией Форм каждый пользователь имеет отдельный профиль, связанный с их идентификатором пользователя. Тем не менее, также можно разрешить использование профилей в &lt;анонимном приложении с помощью анонимного элементаИдентификации&gt; в файле конфигурации вместе с атрибутом **allowAnonymous,** как показано ниже:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample3.xml)]

Когда анонимный пользователь просматривает сайт, ASP.NET создает экземпляр **ProfileCommon** для пользователя. Этот профиль использует уникальный идентификатор, хранящийся в файле cookie в браузере, чтобы идентифицировать пользователя как уникального посетителя. Таким образом, вы можете хранить информацию о профиле для пользователей, которые просматривают анонимно.

## <a name="profile-groups"></a>Профильные группы

Можно сгруппировать свойства профилей. По свойствам группировки можно имитировать несколько профилей для конкретного приложения.

Следующая конфигурация настраивает свойство FirstName и LastName для двух групп; Покупатели и перспективы.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample4.xml)]

Затем можно установить свойства на определенную группу следующим образом:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample5.cs)]

## <a name="storing-complex-objects"></a>Хранение объектов комплекса

До настоящего времени приведенные примеры хранили простые типы данных в профиле. Также можно хранить сложные типы данных в профиле, указав метод сериализации с помощью атрибута **serializeAs** следующим образом:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample6.xml)]

В этом случае тип — PurchaseInvoice. Класс PurchaseInvoice должен быть помечен как сериализируемый и может содержать любое количество свойств. Например, если в PurchaseInvoice есть свойство под названием **NumItemsPurchased,** вы можете сослаться на это свойство в коде следующим образом:

[!code-css[Main](profiles-themes-and-web-parts/samples/sample7.css)]

## <a name="profile-inheritance"></a>Профиль Наследование

Можно создать профиль для использования в нескольких приложениях. Создавая класс профиля, который вытекает из ProfileBase, можно повторно использовать профиль в нескольких приложениях, используя атрибут **наследования,** как показано ниже:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample8.xml)]

В этом случае класс **PurchasingProfile** будет выглядеть так:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample9.cs)]

## <a name="profile-providers"></a>Поставщики профилей

ASP.NET профили используют модель поставщика. Поставщик услуг по умолчанию хранит информацию в\_базе данных S'L Server Express в папке App Data веб-приложения с помощью поставщика SqlProfileProvider. Если база данных не существует, ASP.NET автоматически создаст ее при попытке хранения информации.

В некоторых случаях, однако, вы можете разработать свой собственный профиль поставщика. Функция профиля ASP.NET позволяет легко использовать различные провайдеры.

Вы создаете поставщика пользовательских профилей, когда:

- Необходимо хранить информацию о профиле в источнике данных, например, в базе данных FoxPro или в базе данных Oracle, которая не поддерживается поставщиками профилей, включенными в рамку .NET.
- Вам необходимо управлять информацией профиля с помощью схемы базы данных, которая отличается от схемы базы данных, используемой поставщиками, включенными в рамку .NET. Распространенным примером является то, что необходимо интегрировать информацию о профиле с данными пользователей в существующую базу данных сервера S'L.

### <a name="required-classes"></a>Обязательные занятия

Для реализации поставщика профилей создается класс, который наследует абстрактный класс System.Web.ProfileProvider.ProfileProvider. Абстрактный класс **ProfileProvider,** в свою очередь, наследует абстрактный класс System.Configuration.SettingsProvider, который наследует абстрактный класс System.Configuration.Provider.ProviderBase. Из-за этой цепочки наследования, в дополнение к требуемым членам класса **ProfileProvider,** необходимо реализовать требуемых членов классов **SettingsProvider** и **ProviderBase.**

В следующих таблицах описаны свойства и методы, которые необходимо реализовать из абстрактных классов **ProviderBase,** **SettingsProvider**и **ProfileProvider.**

### <a name="providerbase-members"></a>Члены ProviderBase

| **Член** | **Описание** |
| --- | --- |
| Initialize - метод | Принимает в качестве ввода имя экземпляра поставщика и NameValueCollection параметров конфигурации. Используется для набора параметров и значений свойств для экземпляра поставщика, включая значения, связанные с реализацией, и параметры, указанные в конфигурации машины или файле Web.config. |

### <a name="settingsprovider-members"></a>Участники SettingsProvider

| **Член** | **Описание** |
| --- | --- |
| Свойство ApplicationName | Имя приложения, которое хранится с каждым профилем. Поставщик профиля использует имя приложения для отдельного хранения информации о профиле для каждого приложения. Это позволяет нескольким ASP.NET приложениям использовать один и тот же источник данных без конфликта, если одно и то же имя пользователя создано в разных приложениях. Кроме того, несколько ASP.NET приложения могут обмениваться источником данных профиля, указывая одно и то же имя приложения. |
| Метод GetPropertyValues | Принимает в качестве ввода НастройкиКонтекст и объект SettingsPropertyCollection. **НастройкиКонтекст** предоставляет информацию о пользователе. Вы можете использовать эту информацию в качестве основного ключа для получения информации о свойстве профиля для пользователя. Используйте объект **SettingsContext,** чтобы получить имя пользователя и подлинность пользователя или анонимность. **НастройкиPropertyCollection** содержит коллекцию объектов SettingsProperty. Каждый объект **SettingsProperty** предоставляет имя и тип свойства, а также дополнительную информацию, такую как значение значения по умолчанию для свойства и является ли свойство только чтением. Метод **GetPropertyValues** заполняет настройкиPropertyValueValueCollection объектами SettingsPropertyValueValue на основе объектов **SettingsProperty, предоставленных** в качестве ввода. Значения из источника данных для указанного пользователя присваиваются свойствам PropertyValue для каждого объекта **SettingsPropertyValue,** и вся коллекция возвращается. Вызов метода также обновляет значение LastActivityDate для указанного профиля пользователя до текущей даты и времени. |
| Метод SetPropertyValues | Принимает в качестве ввода **НастройкиКонтекст** и объект **SettingsPropertyValueCollection.** **НастройкиКонтекст** предоставляет информацию о пользователе. Вы можете использовать эту информацию в качестве основного ключа для получения информации о свойстве профиля для пользователя. Используйте объект **SettingsContext,** чтобы получить имя пользователя и подлинность пользователя или анонимность. **НастройкиPropertyValueCollection** содержит коллекцию объектов **SettingsPropertyValueValue.** Каждый объект **SettingsPropertyValueValue** предоставляет имя, тип и значение свойства, а также дополнительную информацию, такую как значение значения по умолчанию для свойства и является ли свойство только чтением. Метод **SetPropertyValues** обновляет значения свойств профиля в источнике данных для указанного пользователя. Вызов метода также обновляет значения **LastActivityDate** и LastUpdatedDate для указанного профиля пользователя до текущей даты и времени. |

### <a name="profileprovider-members"></a>Члены ProfileProvider

| **Член** | **Описание** |
| --- | --- |
| Метод DeleteProfiles | Принимает в качестве ввода строку массивимен имена пользователей и удаляет из источника данных все данные профиля и значения свойств для указанных имен, где имя приложения соответствует значению свойства **ApplicationName.** Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакцию и откатить транзакцию и выбросить исключение в случае сбоя операции удаления. |
| Метод DeleteProfiles | Принимает в качестве ввода коллекцию объектов ProfileInfo и удаляет из источника данных всю информацию профиля и значения свойств для каждого профиля, где имя приложения совпадает с значением свойства **ApplicationName.** Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакцию и откат транзакции и выбросить исключение в случае сбоя операции удаления. |
| Метод DeleteInactiveProfiles | Принимает в качестве ввода значение ProfileAuthenticationationOption и объект DateTime и удаляет из источника данных всю информацию профиля и значения свойств, где последняя дата действия меньше или равна указанной дате и времени и где имя приложения соответствует значению свойства **ApplicationName.** Параметр **ProfileAuthenticationationOption** определяет, должны ли быть удалены только анонимные профили, только проверенные профили или все профили. Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакцию и откат транзакции и выбросить исключение в случае сбоя операции удаления. |
| Метод GetAllProfiles | Принимает в качестве ввода значение **ProfileAuthenticationationOption,** целый ряд, который определяет индекс страницы, целый размер, который определяет размер страницы, и ссылка на целый ряд, который будет установлен на общее количество профилей. Возвращает ProfileInfoCollection, содержащий объекты **ProfileInfo** для всех профилей в источнике данных, где имя приложения совпадает со значением свойства **ApplicationName.** Параметр **ProfileAuthenticationationOption** определяет, должны ли быть возвращены только анонимные профили, только проверенные профили или все профили. Результаты, возвращенные методом **GetAllProfiles,** ограничены значениями индекса страницы и размера страницы. Значение размера страницы определяет максимальное количество объектов **ProfileInfo** для возврата в **ProfileInfoCollection.** Значение индекса страницы определяет, какая страница результатов должна вернуться, где 1 определяет первую страницу. Параметр для общего числа записей является из параметра (вы можете использовать **ByRef** в Visual Basic), который устанавливается на общее количество профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы составляет 2 с размером страницы 5, возврат **ProfileInfoCollection** содержит шестой по десятый профили. Общее значение записей устанавливается до 13 при возврате метода. |
| Метод GetAllInactiveProfiles | Принимает в качестве ввода значение **ProfileAuthenticationationOption,** объект **DateTime,** целый ряд, который определяет индекс страницы, целый размер, который определяет размер страницы, и ссылка на целый ряд, который будет установлен на общее количество профилей. Возвращает **ProfileInfoCollection,** содержащий объекты **ProfileInfo** для всех профилей в источнике данных, где дата последнего действия меньше или равна указанному **DateTime** и где имя приложения соответствует значению свойства **ApplicationName.** Параметр **ProfileAuthenticationationOption** определяет, должны ли быть возвращены только анонимные профили, только проверенные профили или все профили. Результаты, возвращенные методом **GetAllInactiveProfiles,** ограничены значениями индекса страницы и размера страницы. Значение размера страницы определяет максимальное количество объектов **ProfileInfo** для возврата в **ProfileInfoCollection.** Значение индекса страницы определяет, какая страница результатов должна вернуться, где 1 определяет первую страницу. Параметр для общего числа записей является из параметра (вы можете использовать **ByRef** в Visual Basic), который устанавливается на общее количество профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы составляет 2 с размером страницы 5, возврат **ProfileInfoCollection** содержит шестой по десятый профили. Общее значение записей устанавливается до 13 при возврате метода. |
| Метод FindProfilesByUserName | Принимает в качестве ввода значение **ProfileAuthenticationationOption,** строку, содержащую имя пользователя, целый ряд, который определяет индекс страницы, целый размер, который определяет размер страницы, и ссылку на целый ряд, который будет установлен на общее количество профилей. Возвращает **ProfileInfoCollection,** содержащий объекты **ProfileInfo** для всех профилей в источнике данных, где имя пользователя совпадает с указанным именем пользователя и где имя приложения соответствует значению свойства **ApplicationName.** Параметр **ProfileAuthenticationationOption** определяет, должны ли быть возвращены только анонимные профили, только проверенные профили или все профили. Если ваш источник данных поддерживает дополнительные возможности поиска, такие как символы подстановочных знаков, можно предоставить более широкие возможности поиска имен пользователей. Результаты, возвращенные методом **FindProfilesByUserName,** ограничены значениями индекса страницы и размера страницы. Значение размера страницы определяет максимальное количество объектов **ProfileInfo** для возврата в **ProfileInfoCollection.** Значение индекса страницы определяет, какая страница результатов должна вернуться, где 1 определяет первую страницу. Параметр для общего числа записей является из параметра (вы можете использовать **ByRef** в Visual Basic), который устанавливается на общее количество профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы составляет 2 с размером страницы 5, возврат **ProfileInfoCollection** содержит шестой по десятый профили. Общее значение записей устанавливается до 13 при возврате метода. |
| FindInactiveProfilesByUserName метод | Принимает в качестве ввода значение **ProfileAuthenticationationOption,** строку, содержащую имя пользователя, объект **DateTime,** целый ряд, который определяет индекс страницы, целый ряд, который определяет размер страницы, и ссылку на целый ряд, который будет установлен на общее количество профилей. Возвращает **ProfileInfoCollection,** содержащий объекты **ProfileInfo** для всех профилей в источнике данных, где имя пользователя совпадает с указанным именем пользователя, где дата последнего действия меньше или равна указанному **DateTime,** и где имя приложения соответствует значению свойства **ApplicationName.** Параметр **ProfileAuthenticationationOption** определяет, должны ли быть возвращены только анонимные профили, только проверенные профили или все профили. Если ваш источник данных поддерживает дополнительные возможности поиска, такие как символы подстановочных знаков, можно предоставить более широкие возможности поиска имен пользователей. Результаты, возвращенные методом **FindInactiveProfilesByUserName,** ограничены значениями индекса страницы и размера страницы. Значение размера страницы определяет максимальное количество объектов **ProfileInfo** для возврата в **ProfileInfoCollection.** Значение индекса страницы определяет, какая страница результатов должна вернуться, где 1 определяет первую страницу. Параметр для общего числа записей является из параметра (вы можете использовать **ByRef** в Visual Basic), который устанавливается на общее количество профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы составляет 2 с размером страницы 5, возврат **ProfileInfoCollection** содержит шестой по десятый профили. Общее значение записей устанавливается до 13 при возврате метода. |
| Метод GetNumberOfActiveProfiles | Принимает в качестве ввода значение **ProfileAuthenticationationOption** и объект **DateTime** и возвращает подсчет всех профилей в источнике данных, где последняя дата действия меньше или равна указанному **DateTime** и где имя приложения соответствует значению свойства **ApplicationName.** Параметр **ProfileAuthenticationationOption** определяет, должны ли учитываться только анонимные профили, только проверенные профили или все профили. |

### <a name="applicationname"></a>ApplicationName

Поскольку поставщики профилей хранят информацию о профиле отдельно для каждого приложения, необходимо убедиться, что схема данных включает имя приложения и что запросы и обновления также включают имя приложения. Например, следующая команда используется для извлечения значения свойства из базы данных на основе имени пользователя и анонимности профиля, и гарантирует, что значение **ApplicationName** включено в запрос.

[!code-sql[Main](profiles-themes-and-web-parts/samples/sample10.sql)]

## <a name="aspnet-themes"></a>ASP.NET темы

## <a name="what-are-aspnet-20-themes"></a>Что такое ASP.NET 2.0 Темы?

Одним из наиболее важных аспектов веб-приложения является последовательный внешний вид на сайте. ASP.NET 1.x разработчики обычно используют Каскадные листы стиля (CSS) для реализации последовательного взгляда и ощущения. ASP.NET 2.0 темы значительно улучшить CSS, потому что они дают разработчику ASP.NET возможность определить внешний вид управления сервером ASP.NET, а также HTML элементов. ASP.NET темы могут быть применены к отдельным элементам управления, конкретной веб-странице или всему веб-приложению. Темы используют комбинацию файлов CSS, дополнительный файл кожи и дополнительный каталог изображений, если изображения необходимы. Файл кожи контролирует внешний вид ASP.NET управления сервером.

## <a name="where-are-themes-stored"></a>Где хранятся темы?

Место, где хранятся темы, отличается в зависимости от сферы их охвата. Темы, которые могут быть применены к любому приложению, хранятся в следующей папке:

`C:\WINDOWS\Microsoft.NET\Framework\v2.x.xxxxx\ASP.NETClientFiles\Themes\<Theme_Name>`

Тема, специфичная для конкретного приложения, хранится в `App\_Themes\<Theme\_Name>` каталоге в корне веб-узла.

> [!NOTE]
> Файл кожи должен изменять только свойства управления сервером, влияющие на внешний вид.

Глобальная тема — это тема, которая может быть применена к любому приложению или веб-узле, работая на веб-сервере. Эти темы хранятся по умолчанию в каталоге ASP.NETClientfiles-Themes, который находится внутри каталога v2.x.xxxxx. Кроме того, вы можете переместить тематические файлы в\_веб-страницу клиента/системы\_aspnet/«версии»/Темы/имя\_темы в корне вашего веб-узла.

Темы, посвященные приложениям, могут применяться только к приложению, в котором находятся файлы. Эти файлы хранятся в каталоге `App\_Themes/<theme\_name>` в корне веб-узла.

## <a name="the-components-of-a-theme"></a>Компоненты темы

Тема состоит из одного или нескольких файлов CSS, дополнительного файла кожи и дополнительной папки Изображений. Файлы CSS могут быть любым именем, которое вы хотите (т.е. default.css или theme.css и т.д.) и должны быть в корне папки тем. Файлы CSS используются для определения обычных классов CSS и атрибутов для конкретных селекторов. Чтобы применить один из классов CSS к элементу страницы, используется свойство **CSSClass.**

Файл кожи — это файл XML, содержащий определения свойств для управления ASP.NET сервером. Код, перечисленный ниже, является примером файла кожи.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample11.aspx)]

**На рисунке 1** ниже показана небольшая ASP.NET страница, просматриваемая без прикладной темы. **На рисунке 2** показан тот же файл с прикладной темой. Цвет фона и цвет текста настраиваются через файл CSS. Внешний вид кнопки и текстовый ящик настроены с помощью файла кожи, перечисленных выше.

![Нет темы](profiles-themes-and-web-parts/_static/image1.gif)

**Рисунок 1**: Нет темы

![Тема Прикладная](profiles-themes-and-web-parts/_static/image2.gif)

**Рисунок 2**: Тема прикладная

Файл кожи, перечисленный выше, определяет кожу по умолчанию для всех элементов управления TextBox и элементов управления кнопками. Это означает, что каждый элемент управления TextBox и управления кнопками, вставленные на странице, будет принимать этот внешний вид. Вы также можете определить кожу, которая может быть применена к конкретным случаям этих элементов управления, используя свойство **SkinID** управления.

Приведенный ниже код определяет кожу для управления кнопками. Только кнопка управления с **свойством SkinID** **goButton** возьмет на себя внешний вид кожи.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample12.aspx)]

Вы можете иметь только одну кожу по умолчанию на тип управления сервером. Если вам требуются дополнительные скины, вы должны использовать свойство SkinID.

## <a name="applying-themes-to-pages"></a>Применение тем на страницах

Тема может быть применена с помощью любого из следующих методов:

- На &lt;страницах&gt; элемент файла web.config
- В @Page директиве страницы
- Программным образом

## <a name="applying-a-theme-in-the-configuration-file"></a>Применение темы в файле конфигурации

Чтобы применить тему в файле конфигурации приложений, используйте следующий синтаксис:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample13.xml)]

Имя темы, указанное здесь, должно соответствовать названию папки тем. Эта папка может существовать либо в любом из мест, упомянутых ранее в этом курсе. Если вы попытаетесь применить тему, которая не существует, произойдет ошибка конфигурации.

## <a name="applying-a-theme-in-the-page-directive"></a>Применение темы в Директиве о Странице

Вы также можете применить тему в директиве «Страница». Этот метод позволяет использовать тему для конкретной страницы.

Чтобы применить тему в @Page директиве, используйте следующий синтаксис:

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample14.aspx)]

Еще раз, тема, указанная здесь должны соответствовать теме папку, как упоминалось ранее. Если вы попытаетесь применить тему, которая не существует, произойдет сбой сборки. Visual Studio также выделит атрибут и уведомит вас, что такой темы не существует.

## <a name="applying-a-theme-programmatically"></a>Применение тема программно

Чтобы применить тему программно, необходимо указать **свойство темы** для страницы в методе **\_Page PreInit.**

Чтобы применить тему программно, используйте следующий синтаксис:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample15.cs)]

Тема должна быть применена в методе PreInit в связи с жизненным циклом страницы. Если применить его после этого момента, тема страниц уже будет применена к времени выполнения, и изменение в этот момент слишком поздно в жизненном цикле. Если вы применяете тему, которая не существует, **httpException** происходит. Когда тема применяется программно, предупреждение о сборке будет происходить, если какой-либо сервер управления имеют свойство SkinID указан. Это предупреждение предназначено для информирования вас о том, что ни одна тема не применяется декларативно и ее можно игнорировать.

## <a name="exercise-1--applying-a-theme"></a>Упражнение 1 : Применение темы

В этом упражнении вы примените тему ASP.NET на веб-узел.

> [!IMPORTANT]
> Если вы используете Microsoft Word для ввода информации в файл кожи, убедитесь, что вы не заменяете регулярные котировки с умными цитатами. Смарт-котировки вызовут проблемы с файлами кожи.

1. Создание нового веб-сайта ASP.NET.
2. Нажмите на проект в Solution Explorer и выберите Добавить новый элемент.
3. Выберите веб-файл конфигурации из списка файлов и нажмите Добавить.
4. Нажмите на проект в Solution Explorer и выберите Добавить новый элемент.
5. Выберите файл кожи и нажмите Добавить.
6. Нажмите Да, когда вас спросили, хотите ли\_вы разместить файл внутри папки App Themes.
7. Нажмите правой кнопкой мыши на\_папку SkinFile внутри папки App Themes в Solution Explorer и выберите Добавить новый элемент.
8. Выберите стиль листа из списка файлов и нажмите Добавить. Теперь у вас есть все файлы, необходимые для реализации новой темы. Тем не менее, Visual Studio назвала ваши темы папку SkinFile. Нажмите на эту папку и измените название на CoolTheme.
9. Откройте файл SkinFile.skin и добавьте следующий код в конце файла: 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample16.aspx)]
10. Сохранить файл SkinFile.skin.
11. Откройте StyleSheet.css.
12. Замените весь текст в нем следующим: 

    [!code-css[Main](profiles-themes-and-web-parts/samples/sample17.css)]
13. Сохранить файл StyleSheet.css.
14. Откройте страницу default.aspx.
15. Добавьте элемент управления TextBox и кнопку.
16. Сохраните страницу. Теперь просмотрите страницу Default.aspx. Он должен отображаться как обычная веб-форма.
17. Откройте файл web.config.
18. Добавьте следующее непосредственно `<system.web>` под тегом открытия: 

    [!code-xml[Main](profiles-themes-and-web-parts/samples/sample18.xml)]
19. Сохранить файл web.config. Теперь просмотрите страницу Default.aspx. Он должен отображаться с прикладной темой.
20. Если он еще не открыт, откройте страницу Default.aspx в Visual Studio.
21. Выберите кнопку.
22. Измените свойство **SkinID,** чтобы перейти к кнопке. Обратите внимание, что Visual Studio предоставляет выпадение с действительными значениями SkinID для управления кнопкой.
23. Сохраните страницу. Теперь снова просмотрите страницу в браузере. Кнопка должна теперь сказать "идти" и должна быть шире по внешнему виду.

Используя свойство **SkinID,** вы можете легко настроить различные скины для различных экземпляров определенного типа управления сервером.

## <a name="the-stylesheettheme-property"></a>Свойство StyleSheetTheme

До тех пор, мы говорили только о прикладируя темы используя свойство темы. При использовании свойства Тема файл кожи переопределяет любые декларативные настройки для управления сервером. Например, в упражнении 1 вы указали SkinID "goButton" для управления кнопкой, и это изменило текст кнопки на "идти". Возможно, вы заметили, что текст собственности кнопки в дизайнер был установлен на "Кнопка", но тема переутомилась, что. Тема всегда переобогнит любые настройки свойств в дизайнере.

Если вы хотите, чтобы иметь возможность переопределить свойства, определенные в файле кожи темы с свойствами, указанными в дизайнере, вы можете использовать **свойство StyleSheetTheme** вместо свойства темы. Свойство StyleSheetTheme такое же, как свойство Тема, за исключением того, что оно не перекрывает все явные настройки свойств, как свойство Тема делает.

Чтобы увидеть это в действии, откройте файл web.config `<pages>` из проекта в упражнении 1 и измените элемент на следующее:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample19.xml)]

Теперь просмотрите страницу Default.aspx, и вы увидите, что управление кнопкой имеет свойство текста "Кнопка" снова. Это потому, что явные настройки свойства в дизайнерпере переопределяет свойство Текст, установленный goButton SkinID.

## <a name="overriding-themes"></a>Главные темы

Глобальная тема может быть переопределена, применяя тему с\_тем же названием в папке App Themes приложения. Тем не менее, тема не применяется в истинном сценарии переопределения. Если время выполнения сталкивается с файлами темы в папке App\_Themes, она будет применять тему с помощью этих файлов и будет игнорировать глобальную тему.

Свойство StyleSheetTheme переизгоровано и может быть переопределено в коде следующим образом:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample20.cs)]

## <a name="web-parts"></a>веб-части

ASP.NET Web Parts — это интегрированный набор элементов управления для создания веб-узлов, позволяющих конечным пользователям изменять содержимое, внешний вид и поведение веб-страниц непосредственно из браузера. Изменения могут быть применены ко всем пользователям на сайте или к отдельным пользователям. Когда пользователи изменяют страницы и элементы управления, настройки могут быть сохранены, чтобы сохранить личные предпочтения пользователя на будущих сеансах браузера, функцию, называемую персонализацией. Эти возможности Web Parts означают, что разработчики могут дать возможность конечным пользователям динамически персонализировать веб-приложение без вмешательства разработчика или администратора.

Используя набор управления Web Parts, вы, как разработчик, можете позволить конечным пользователям:

- Персонализовать содержимое страницы. Пользователи могут добавлять новые элементы управления веб-запчастями на страницу, удалять их, скрывать или минимизировать их, как обычные окна.
- Персонализировать макет страницы. Пользователи могут перетащить управление веб-частьми в другую зону на странице или изменить его внешний вид, свойства и поведение.
- Контроль за экспортом и импортом. Пользователи могут импортировать или экспортировать настройки управления веб-запчастями для использования на других страницах или сайтах, сохраняя свойства, внешний вид и даже данные в элементах управления. Это снижает требования к вводу и конфигурации данных для конечных пользователей.
- Создание соединений. Пользователи могут устанавливать связи между элементами управления, чтобы, например, элемент управления диаграммы мог отображать график для данных в элементе управления биржевым тикером. Пользователи могут персонализировать не только само соединение, но и внешний вид и детали того, как элемент управления диаграммой отображает данные.
- Управление и персонализация настроек на уровне сайта. Авторизованные пользователи могут настроить настройки на уровне сайта, определить, кто может получить доступ к сайту или странице, установить доступ к элементам управления на основе ролей и так далее. Например, пользователь, находящийся в административной роли, может настроить элемент управления web Parts, которым будут пользоваться все пользователи, и запретить пользователям, не являющимся администраторами, персонализировать общий элемент управления.

Обычно вы будете работать с Web Parts одним из трех способов: создание страниц, которые используют элементы управления веб-запчастями, создание отдельных элементов управления веб-запчастями или создание полных персонализированных веб-приложений, таких как портал.

## <a name="page-development"></a>Разработка страниц

Разработчики страниц могут использовать инструменты визуального проектирования, такие как Microsoft Visual Studio 2005, для создания страниц, на которых используются web Parts. Одним из преимуществ в использовании инструмента, такого как Visual Studio, является то, что набор управления Web Parts предоставляет функции для создания и настройки элементов управления веб-запчастями в визуальном конструкторе. Например, можно использовать конструктор, чтобы перетащить зону Web Parts или управление редактором Web Parts на поверхность дизайна, а затем настроить элемент управления прямо в конструкторе с помощью системы управления, предоставляемого набором управления Web Parts. Это может ускорить разработку приложений Web Parts и уменьшить количество кода, который вы должны написать.

## <a name="control-development"></a>Развитие контроля

Вы можете использовать любую существующую ASP.NET управления в качестве управления Web Parts, включая стандартные элементы управления веб-сервером, пользовательские элементы управления сервером и пользовательские элементы управления. Для максимального программного управления средой можно также создавать пользовательские элементы управления Web Parts, получаемые из класса WebPart. Для отдельных разработок управления Web Parts вы, как правило, либо создаете пользовательский контроль и используете его в качестве управления веб-запчастями, либо разрабатываете пользовательский элемент управления веб-запчастями.

В качестве примера разработки пользовательского управления Web Parts можно создать элемент управления, чтобы обеспечить любую из функций, предоставляемых другими ASP.NET управления сервером, которые могут быть полезны для упаковки в качестве персонализированного управления Web Parts: календари, списки, финансовая информация, новости, калькуляторы, богатые текстовые элементы управления для обновления контента, отсвативаемые сетки, которые подключаются к базам данных, диаграммы, которые динамически обновляют свои дисплеи , или информация о погоде и путешествиях. Если вы предоставляете визуальному дизайнеру элемент управления, то любой разработчик страницы, использующий Visual Studio, может просто перетащить элемент управления в зону Web Parts и настроить его во время проектирования без необходимости написания дополнительного кода.

Персонализация является основой функции Web Parts. Это позволяет пользователям изменять - или персонализировать - макет, внешний вид и поведение элементов управления веб-запчастей на странице. Персонализированные настройки долговечны: они сохраняются не только во время текущей сессии браузера (как при состоянии представления), но и в долгосрочном хранении, так что настройки пользователя сохраняются и для будущих сеансов браузера. Персонализация включена по умолчанию для страниц web-части.

Структурные компоненты uI полагаются на персонализацию и обеспечивают основную структуру и услуги, необходимые всем элементам управления Web Parts. Одним из структурных компонентов uI, требуемого на каждой странице Web Parts, является контроль WebPartManager. Хотя этот элемент управления никогда не отображается, он имеет важнейшую задачу координации всех элементов управления веб-запчастями на странице. Например, он отслеживает все отдельные элементы управления веб-запчастями. Он управляет зонами Web Parts (регионами, содержащими элементы управления веб-запчастями на странице) и которые элементы управления находятся в каких зонах. Он также отслеживает и контролирует различные режимы отображения, в которые может находиться страница, такие как режим просмотра, подключения, отсвазаний или каталога, а также вопрос о том, применяются ли изменения персонализации ко всем пользователям или отдельным пользователям. Наконец, он инициирует и отслеживает соединения и связь между элементами управления Web Parts.

Вторым видом структурного компонента UI является зона. Зоны выступают в качестве менеджеров макета на странице Web Parts. Они содержат и организуют элементы управления, которые вытекают из класса части (элемент управления), и обеспечивают возможность делать модульную компоновку страницы в горизонтальной или вертикальной ориентации. Зоны также предлагают общие и последовательные элементы uI (такие как стиль заголовка и колонтитула, название, стиль границы, кнопки действия и так далее) для каждого элемента управления, который они содержат; эти общие элементы известны как хром управления. Несколько специализированных типов зон используются в различных режимах отображения и с различными элементами управления. Различные типы зон описаны в разделе Основные элементы управления веб-части ниже.

Элементы управления веб-элементов, все из которых происходят из класса **Часть,** составляют основной ui на странице Web Parts. Набор управления Web Parts является гибким и инклюзивным в вариантах, которые он дает вам для создания элементов управления. В дополнение к созданию собственных пользовательских элементов управления web Parts, вы также можете использовать существующие ASP.NET управления сервером, пользовательским управлением или пользовательским управлением сервером в качестве элементов управления Web Parts. Основные элементы управления, которые наиболее часто используются для создания страниц веб-запчастей, описаны в следующем разделе.

## <a name="web-parts-essential-controls"></a>Основные элементы управления веб-частями

Набор управления Web Parts обширен, но некоторые элементы управления необходимы либо потому, что они необходимы для работы Web Parts, либо потому, что они являются элементами управления, наиболее часто используемыми на страницах Web Parts. При начале использования Web Parts и создания базовых страниц Web Parts полезно ознакомиться с основными элементами управления веб-запчастями, описанными в следующей таблице.

| **Элемент управления веб-частей** | **Описание** |
| --- | --- |
| Webpartmanager | Управление всеми элементами управления веб-запчастями на странице. Один (и только один) **контроль WebPartManager** требуется для каждой страницы web Parts. |
| Catalogzone | Содержит элементы управления CatalogPart. Используйте эту зону для создания каталога элементов управления веб-запчастями, из которого пользователи могут выбрать элементы управления для добавления на страницу. |
| Editorzone | Содержит элементы управления EditorPart. Используйте эту зону, чтобы пользователи могли отсеивать и персонализировать элементы управления web-частью на странице. |
| Webpartzone | Содержит и предоставляет общий макет для элементов управления WebPart, которые составляют основной uI страницы. Используйте эту зону всякий раз, когда вы создаете страницы с элементами управления веб-запчастями. Страницы могут содержать одну или несколько зон. |
| Connectionszone | Содержит элементы управления WebPartConnection и предоставляет ui ii для управления соединениями. |
| WebPart (GenericWebPart) | Рендерс основного uI; большинство элементов управления веб-элементов uI подпадают под эту категорию. Для максимального программного управления можно создать пользовательские элементы управления Web Parts, которые вытекают из базового управления **WebPart.** Вы также можете использовать существующие элементы управления сервером, элементы управления пользователем или пользовательские элементы управления в качестве элементов управления Web Parts. Всякий раз, когда любой из этих элементов управления помещается в зону, управление **WebPartManager** автоматически обертывает их с помощью элементов управления **GenericWebPart** во время выполнения, так что вы можете использовать их с функциональностью Web Parts. |
| Catalogpart | Содержит список доступных элементов управления веб-запчастями, которые пользователи могут добавить на страницу. |
| Webpartconnection | Создает соединение между двумя элементами управления веб-частью на странице. Соединение определяет один из элементов управления Web Parts как поставщик (данных), а другой как потребитель. |
| Editorpart | Служит базовым классом для специализированного управления редактором. |
| Контроль EditorPart (Внешний видEditorPart, LayoutEditorPart, BehaviorEditorPart и PropertyGridEditorPart) | Разрешить пользователям персонализировать различные аспекты элементов управления пользовательского мнения Web Parts на странице |

## <a name="lab-create-a-web-part-page"></a>Лаборатория: Создание веб-страницы

В этой лаборатории вы создадите страницу веб-части, которая будет сохранять информацию через ASP.NET профили.

### <a name="creating-a-simple-page-with-web-parts"></a>Создание простой страницы с веб-частями

В этой части пошагового листа создается страница, используюв элементы управления Web Parts для отображания статического содержимого. Первым шагом в работе с Web Parts является создание страницы с двумя необходимыми структурными элементами. Во-первых, страница веб-запчастей нуждается в управлении WebPartManager для отслеживания и координации всех элементов управления веб-запчастями. Во-вторых, страница Web Parts нуждается в одной или нескольких зонах, которые представляют собой составные элементы управления, которые содержат элементы управления WebPart или другого сервера и занимают заданную область страницы.

> [!NOTE]
> Вам не нужно ничего делать, чтобы включить персонализацию web Parts; он включен по умолчанию для набора управления Web Parts. При первом запуске страницы Web Parts на сайте ASP.NET настраивает поставщика персонализации по умолчанию для хранения настроек персонализации пользователей. Для получения дополнительной информации о персонализации, см веб-части персонализации Обзор.

### <a name="to-create-a-page-for-containing-web-parts-controls"></a>Создать страницу для элементов управления веб-запчастями

1. Закройте страницу по умолчанию и добавьте новую страницу на сайт под названием WebPartsDemo.aspx.
2. Переключитесь на представление **design.**
3. Из меню **View** убедитесь, что параметры **невизуальных элементов управления** и **деталей** выбраны, чтобы вы могли видеть теги макета и элементы управления, которые не имеют элемента мига.
4. Поместите точку вставки перед `<div>` тегами на поверхности дизайна и нажмите ENTER, чтобы добавить новую строку. Расположите точку вставки перед новым персонажем строки, щелкните элемент управления списка выпадающих строк **формата блока** в меню и выберите опцию **«Заголовк 1».** В заголовке, добавить текст **Веб Части Демонстрация Страница**.
5. Со вкладки **WebParts** в Toolbox перетащите элемент управления **WebPartManager** на страницу, `<div>`позиционируя его сразу после нового символа строки и перед тегами.   
  
   Управление **WebPartManager** не отображает выход, поэтому отображается как серая коробка на поверхности дизайнера.
6. Расположите точку вставки `<div>` в теги.
7. В меню **Layout** щелкните **вставьте таблицу**и создайте новую таблицу с одной строкой и тремя столбцов. Нажмите кнопку **Свойства ячейки,** выберите **верхнюю часть** **списка вертикальных выровней,** нажмите **OK**и **нажмите OK** снова, чтобы создать таблицу.
8. Перетащите элемент управления WebPartзон в левую колонку таблицы. Нажмите правой кнопкой мыши управления **WebPartзон,** выберите **Свойства**и установите следующие свойства:   
  
   ID: Боковая барзона   
  
   ЗаголовокТекст: Боковая панель
9. Перетащите второй элемент управления **WebPart'one** в столбец средней таблицы и установите следующие свойства:   
  
   Id: Мейнзона   
  
   ЗаголовокТекст: Основной
10. Сохраните файл.

Ваша страница теперь имеет две различные зоны, которые вы можете контролировать отдельно. Тем не менее, ни одна из зон не имеет никакого контента, поэтому создание контента является следующим шагом. Для этого пошагового листа вы работаете с элементами управления Web Parts, которые отображают только статическое содержимое.

Расположение зоны web Parts определяется &lt;элементом&gt; zonetemplate. Внутри шаблона зоны можно добавить любой ASP.NET управления, будь то пользовательский элемент управления веб-запчастями, контроль пользователя или существующий элемент управления сервером. Обратите внимание, что здесь вы используете элемент управления этикеткой, и к этому вы просто добавляете статический текст. При размещении регулярного управления сервером в зоне **WebPart'one** ASP.NET рассматривает управление как управление Web Parts во время выполнения, что позволяет функциям Web Parts управлять.

**Создание контента для основной зоны**

1. В представлении **design** перетащите элемент управления **этикеткой** из **стандартной** вкладки Toolbox в область содержимого зоны, чье свойство **ID** настроено на Main'one.
2. Переключитесь на представление **Исходного кода.** Обратите внимание,&gt; что для обертывания элемента **«Метки»** был добавлен элемент &lt;zonetemplate в Mainone.
3. Добавьте **название** атрибута &lt;в элемент&gt; asp:label и установите его значение для Содержимого. Удалите атрибут Text'"Label" из &lt;&gt; элемента asp:Label. Между тегами открытия и &lt;закрытия элемента&gt; asp:label добавьте текст, такой как &lt;Добро&gt; пожаловать на **мою домашнюю страницу** в паре тегов элемента h2. Ваш код должен выглядеть следующим образом. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample21.aspx)]
4. Сохраните файл.

Затем создайте пользовательский элемент управления, который также может быть добавлен на страницу в качестве элемента управления веб-запчастями.

### <a name="to-create-a-user-control"></a>Создание пользовательского элемента управления

1. Добавьте новый веб-контроль пользователя на свой сайт, чтобы служить в качестве управления поиска. Отменить опцию **размещения исходного кода в отдельном файле.** Добавьте его в тот же каталог, что и страница WebPartsDemo.aspx, и назовите его SearchUserControl.ascx.   
  
    > [!NOTE]
    > Пользовательский контроль для этого пошагового управления не реализует фактическую функциональность поиска; он используется только для демонстрации функций Web Parts.
2. Переключитесь на представление **design.** Со **стандартной** вкладки Toolbox перетащите элемент управления TextBox на страницу.
3. Поместите точку вставки после только что добавленного текстового окна и нажмите ENTER, чтобы добавить новую строку.
4. Перетащите элемент управления кнопкой на страницу на новой строке ниже текстового окна, который вы только что добавили.
5. Переключитесь на представление **Исходного кода.** Убедитесь, что исходный код для управления пользователем выглядит следующим примером. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample22.aspx)]
6. Сохраните файл и закройте его.

Теперь вы можете добавить элементы управления web Parts в зону боковой панели. Вы добавляете два элемента управления в зону боковой панели, один из которых содержит список ссылок, а другой — контроль пользователя, созданный в предыдущей процедуре. Ссылки добавляются в качестве стандартного управления сервером **Label,** подобно тому, как вы создали статический текст для основной зоны. Однако, хотя отдельные элементы управления сервером, содержащиеся в управлении пользователем, могут содержаться непосредственно в зоне (например, контроль над этикеткой), в этом случае это не так. Вместо этого они являются частью пользовательского элемента управления, созданного в предыдущей процедуре. Это демонстрирует общий способ упаковки любых элементов управления и дополнительных функциональных возможностей, которые вы хотите в управлении пользователем, а затем ссылки, которые управляют в зоне, как управление веб-части.

Во время выполнения набор управления Web Parts обертывает оба элемента управления с помощью элементов управления GenericWebPart. Когда элемент управления **GenericWebPart** обертывает элемент управления веб-сервера, общий элемент управления является родительским элементом управления, и вы можете получить доступ к управлению сервером через свойство ChildControl родительского управления. Такое использование общих элементов управления позволяет стандартным элементам управления веб-сервера иметь те же основные поведения и атрибуты, что и элементы управления Web Parts, получаемые из класса **WebPart.**

### <a name="to-add-web-parts-controls-to-the-sidebar-zone"></a>Добавление элементов управления веб-запчастями в боковую зону

1. Откройте страницу WebPartsDemo.aspx.
2. Переключитесь на представление **design.**
3. Перетащите созданную вами страницу управления пользователем, SearchUserControl.ascx, из **Solution Explorer** в зону, чье свойство **ID** установлено в Sidebar one, и бросайте его там.
4. Сохранить webPartsDemo.aspx странице.
5. Переключитесь на представление **Исходного кода.**
6. Внутри &lt;элемента asp:webpartzone&gt; для боковой панели, чуть выше ссылки &lt;на пользовательский контроль, добавить элемент asp:label&gt; с содержащимися ссылками, как показано в следующем примере. Кроме того, добавьте атрибут **заголовка** в тег управления пользователем, со значением **поиска,** как показано на рисунке. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample23.aspx)]
7. Сохраните файл и закройте его.

Теперь вы можете проверить свою страницу, просматривая ее в браузере. Страница отображает две зоны. Следующий снимок экрана показывает страницу.

**Демо-страница веб-части с двумя зонами**

![Веб Части VS Прохождение 1 Скриншот](profiles-themes-and-web-parts/_static/image3.gif)

**Рисунок 3**: Веб-части VS Прохождение 1 Скриншот

В заглавной панели каждого элемента управления находится нисходящая стрелка, которая обеспечивает доступ к меню глаголов доступных действий, которые вы можете выполнить на элементе управления. Нажмите на меню глаголов для одного из элементов управления, затем нажмите глагол **Minimize** и обратите внимание, что элемент управления сведен к минимуму. Из меню глаголов щелкните **Restore,** и элемент управления возвращается к нормальному размеру.

### <a name="enabling-users-to-edit-pages-and-change-layout"></a>Предоставление пользователям возможности отсеивать страницы и изменять расположение

Web Parts предоставляет пользователям возможность изменять макет элементов управления веб-запчастями, перетаскивая их из одной зоны в другую. Помимо того, что пользователи могут перемещать элементы управления **WebPart** из одной зоны в другую, можно разрешить пользователям отсеивать различные характеристики элементов управления, включая их внешний вид, макет и поведение. Набор управления Web Parts предоставляет основную функциональность редактирования для элементов управления **WebPart.** Хотя вы не будете делать это в этом пошаговом шаге, вы также можете создать пользовательские элементы управления редактора, которые позволяют пользователям отсеивать функции элементов управления **WebPart.** Как и в том, что касается изменения местоположения элемента управления **WebPart,** редактирование свойств элемента управления зависит от ASP.NET персонализации для сохранения изменений, которые вносят пользователи.

В этой части пошагового листа вы добавляете возможность для пользователей отсеивать основные характеристики любого элемента управления **WebPart** на странице. Чтобы включить эти функции, вы добавляете другой пользовательский пользовательский элемент управления на странице, наряду с элементом &lt;asp:editorzone&gt; и двумя элементами редактирования.

### <a name="to-create-a-user-control-that-enables-changing-page-layout"></a>Создание пользовательского элемента управления, позволяющего изменять макет страницы

1. В Visual Studio, в меню **Файл,** выберите **Новое** подменю и нажмите на опцию **Файл.**
2. В диалоге **Добавить новый элемент** выберите **веб-управление пользователями.** Назовите новый файл DisplayModeMenu.ascx. Отменить опцию **размещения исходного кода в отдельном файле.**
3. Нажмите Добавить, чтобы создать новый элемент управления.
4. Переключитесь на представление **Исходного кода.**
5. Удалите весь существующий код в новом файле и вставьте в следующий код. Этот код управления пользователем использует функции набора управления Web Parts, которые позволяют странице изменить свой режим представления или отображения, а также позволяют изменять внешний вид и макет страницы, пока вы находитесь в определенных режимах отображения. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample24.aspx)]
6. Сохранить файл, нажав значок сохранения на панели инструментов, или выбрав **Сохранить** в меню **файла.**

### <a name="to-enable-users-to-change-the-layout"></a>Чтобы пользователи могли изменить макет

1. Откройте страницу WebPartsDemo.aspx и переключитесь на представление **design.**
2. Расположите точку вставки в представлении **Design** сразу после элемента управления **WebPartManager,** который вы добавили ранее. Добавьте жесткий возврат после текста, чтобы после управления **WebPartManager** была пустая строка. Поместите точку вставки на пустую линию.
3. Перетащите только что созданный пользовательский элемент (файл называется DisplayModeMenu.ascx) на страницу WebPartsDemo.aspx и опустите его на пустую строку.
4. Перетащите элемент управления редактором из раздела **WebParts** в наборе инструментов к оставшейся ячейке открытых таблиц на странице WebPartsDemo.aspx.
5. Из раздела **WebParts** в наборе инструментов перетащите элемент управления AppearanceEditorPart и управление LayoutEditorВ управление в управление **editor'one.**
6. Переключитесь на представление **Исходного кода.** Полученный код в ячейке таблицы должен быть похож на следующий код. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample25.aspx)]
7. Сохранить файл WebPartsDemo.aspx. Вы создали пользовательский элемент управления, который позволяет изменять режимы отображения и изменять макет страницы, и вы ссылались на элементуправления на основной веб-странице.

Теперь можно проверить возможность отсеивания страниц и изменения макета.

### <a name="to-test-layout-changes"></a>Для тестирования изменений макета

1. Загрузите страницу в браузер.
2. Нажмите в меню **отображения режима отсева** и выберите **edit**. Названия зон отображаются.
3. Перетащите контроль **My Links** своим заголовком из зоны боковой панели в нижней части главной зоны. Ваша страница должна выглядеть следующим снимком экрана.

### <a name="web-parts-demo-page-with-my-links-control-moved"></a>Веб-часть Демо-страница с моим управлением Ссылки переехал

![Веб Части VS Прохождение 2 Скриншот](profiles-themes-and-web-parts/_static/image4.gif)

**Рисунок 4**: Веб-части VS Прохождение 2 Скриншот

1. Нажмите в меню **отображения режима отсева** и выберите **просмотр.** Страница обновляется, имена зон исчезают, а элемент управления **«Мои ссылки»** остается там, где вы ее расположили.
2. Чтобы продемонстрировать, что персонализация работает, закройте браузер, а затем загрузите страницу снова. Внесенные изменения сохраняются для будущих сеансов браузера.
3. Из меню **режима отображения** выберите **Edit**.   
  
   Каждый элемент управления на странице теперь отображается с нисходящей стрелкой в заголовке, который содержит меню выпадения глаголов.
4. Нажмите на стрелку, чтобы отобразить меню глаголов в управлении **«Мои ссылки».** Нажмите глагол **"Edit".**   
  
   Отображается элемент управления **редактора,** отображающий добавленное вами элементы управления EditorPart.
5. В разделе **Внешний вид** управления изменениями измените **название** на My Favorites, используйте список выпадающих типов **Chrome,** чтобы выбрать **только заголовок,** а затем нажмите **Apply.** Следующий снимок экрана показывает страницу в режиме отобрачения.

### <a name="web-parts-demo-page-in-edit-mode"></a>Демо-страница веб-запчастей в режиме edit

![Веб Части VS Прохождение 3 Скриншот](profiles-themes-and-web-parts/_static/image5.gif)

**Рисунок 5**: Веб-части VS Прохождение 3 Скриншот

1. Нажмите в меню **режима дисплея** и выберите **«Обзор»,** чтобы вернуться в режим просмотра.
2. Контроль теперь имеет обновленное название и не имеет границы, как показано на следующем снимке экрана.

### <a name="edited-web-parts-demo-page"></a>Отредактированная страница демо-версий веб-запчастей

![Веб Части VS Прохождение 4 Скриншот](profiles-themes-and-web-parts/_static/image6.gif)

**Рисунок 4**: Веб-части VS Прохождение 4 Скриншот

### <a name="adding-web-parts-at-run-time"></a>Добавление веб-запчастей во время выполнения

Вы также можете разрешить пользователям добавлять элементы управления web Parts на свою страницу во время выполнения. Для этого назначаем страницу с каталогом Web Parts, который содержит список элементов управления веб-запчастями, которые вы хотите сделать доступными для пользователей.

**Разрешить пользователям добавлять веб-части во время выполнения**

1. Откройте страницу WebPartsDemo.aspx и переключитесь на представление **design.**
2. С вкладки **WebParts** в Toolbox перетащите элемент управления Каталогом в правую колонку таблицы, под управлением **editorzone.**   
  
   Оба элемента управления могут находиться в одной ячейке таблицы, поскольку они не будут отображаться одновременно.
3. В панели свойств присвоите строку **Добавить веб-части** в свойство HeaderText управления **Каталогом.**
4. Из раздела **WebParts** в Toolbox перетащите контроль DeclarativeCatalogPart в область содержимого управления **Каталогом.**
5. Нажмите на стрелку в правом верхнем углу управления **DeclarativeCatalogPart,** чтобы разоблачить меню задач, а затем выберите **шаблоны edit.**
6. Из **стандартной** части Toolbox перетащите элемент управления **FileUpload** и элемент **акбарита в** раздел **WebPartsTemplate** управления **DeclarativeCatalogPart.**
7. Переключитесь на представление **Исходного кода.** Проинспектировать &lt;исходный код&gt; элемента asp:catalogzone. Обратите внимание, что управление **DeclarativeCatalogPart** содержит элемент &lt;webpartstemplate&gt; с двумя закрытыми элементами сервера, которые вы сможете добавить на свою страницу из каталога.
8. Добавьте свойство **Title** к каждому из элементов управления, добавленное в каталог, используя значение строки, указанное для каждого заголовка, в примере кода ниже. Несмотря на то, что название не является свойством, который обычно можно установить на этих двух элементах управления сервером во время проектирования, когда пользователь добавляет эти элементы управления в зону **WebPart зоны** из каталога во время выполнения, каждый из них обернут элементом управления **GenericWebPart.** Это позволяет им действовать в качестве элементов управления веб-запчастями, поэтому они смогут отображать заголовки.   
  
   Код для двух элементов управления, содержащихся в управлении **DeclarativeCatalogPart,** должен выглядеть следующим образом. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample26.aspx)]
9. Сохраните страницу.

Теперь вы можете протестировать каталог.

### <a name="to-test-the-web-parts-catalog"></a>Для тестирования каталога веб-запчастей

1. Загрузите страницу в браузер.
2. Нажмите в меню **display Mode** drop-down и выберите **Каталог.**   
  
   Отображается каталог под названием **Add Web Parts.**
3. Перетащите элемент управления **My Favorites** из главной зоны обратно в верхнюю часть боковой панели и опишите его там.
4. В каталоге **Add Web Parts** выберите оба флажка, а затем выберите **Main** из списка выпадающих, содержащего доступные зоны.
5. **Нажмите Добавить** в каталоге. Элементы управления добавляются в основную зону. При желании можно добавить несколько экземпляров элементов управления из каталога на свою страницу.   
  
   На следующем снимке экрана показана страница с управлением загрузки файла и календарь в основной зоне. 

![Элементы управления, добавленные в основную зону из каталога](profiles-themes-and-web-parts/_static/image7.gif)

    **Figure 5**: Controls added to Main zone from the catalog
6. Нажмите в меню **отображения режима отсева** и выберите **просмотр.** Каталог исчезает, а страница обновляется.
7. Закройте браузер. Загрузите страницу снова. Изменения, внесенные вами, сохраняются.
