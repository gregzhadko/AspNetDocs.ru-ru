---
uid: web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
title: Профили, темы и веб-части | Документация Майкрософт
author: microsoft
description: Существуют значительные изменения в конфигурации и инструментировании в ASP.NET 2,0. Новый API настройки ASP.NET позволяет вносить изменения в конфигурацию...
ms.author: riande
ms.date: 02/20/2005
ms.assetid: 92df4051-77c6-492c-bd34-23d24189cea4
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
msc.type: authoredcontent
ms.openlocfilehash: cf5c45781be6d003d28c6aa27efa08032579a6dd
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78474642"
---
# <a name="profiles-themes-and-web-parts"></a>Профили, темы и веб-части

по [Майкрософт](https://github.com/microsoft)

> Существуют значительные изменения в конфигурации и инструментировании в ASP.NET 2,0. Новый API настройки ASP.NET позволяет программно вносить изменения в конфигурацию. Кроме того, существует множество новых параметров конфигурации, позволяющих использовать новые конфигурации и инструментирование.

ASP.NET 2,0 представляет значительное улучшение в области персонализированных веб-узлов. Помимо уже охваченных функций членства, ASP.NET профили, темы и веб-части значительно улучшают персонализацию на веб-узлах.

## <a name="aspnet-profiles"></a>Профили ASP.NET

Профили ASP.NET похожи на сеансы. Разница заключается в том, что профиль является постоянным, в то время как сеанс теряется при закрытии браузера. Еще одно существенное различие между сеансами и профилями заключается в том, что профили строго типизированы, поэтому в процессе разработки обеспечивается технология IntelliSense.

Профиль определяется либо в файле конфигурации компьютеров, либо в файле Web. config для приложения. (Нельзя определить профиль во вложенных папках файла Web. config.) В приведенном ниже коде определяется профиль для хранения имен и фамилий посетителей веб-узла.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample1.xml)]

Тип данных по умолчанию для свойства профиля — System. String. В приведенном выше примере тип данных не указан. Поэтому свойства FirstName и LastName имеют тип String. Как упоминалось ранее, свойства профиля строго типизированы. Приведенный ниже код добавляет новое свойство для Age, которое имеет тип Int32.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample2.xml)]

Профили обычно используются с проверкой подлинности ASP.NET Forms. При использовании в сочетании с проверкой подлинности с помощью форм у каждого пользователя есть отдельный профиль, связанный с ИДЕНТИФИКАТОРом пользователя. Однако можно также разрешить использование профилей в анонимном приложении, используя элемент &lt;Анонимаусидентификатион&gt; в файле конфигурации вместе с атрибутом **allowAnonymous** , как показано ниже.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample3.xml)]

Когда анонимный пользователь просматривает сайт, ASP.NET создает для пользователя экземпляр **ProfileCommon** . В этом профиле для идентификации пользователя в качестве уникального посетителя используется уникальный идентификатор, хранящийся в файле cookie в браузере. Таким образом, можно хранить сведения о профиле для пользователей, просматривающих анонимно.

## <a name="profile-groups"></a>Группы профилей

Можно группировать свойства профилей. Группируя свойства, можно имитировать несколько профилей для конкретного приложения.

Следующая конфигурация настраивает свойство FirstName и LastName для двух групп. Покупатели и перспективные клиенты.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample4.xml)]

Затем можно задать свойства для конкретной группы следующим образом:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample5.cs)]

## <a name="storing-complex-objects"></a>Хранение сложных объектов

На данный момент в рассматриваемых примерах хранятся простые типы данных в профиле. Кроме того, можно хранить сложные типы данных в профиле, указав метод сериализации с помощью атрибута **serializeAs** следующим образом:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample6.xml)]

В этом случае типом является Пурчасеинвоице. Класс Пурчасеинвоице должен быть помечен как сериализуемый и может содержать любое количество свойств. Например, если Пурчасеинвоице имеет свойство с именем **нумитемспурчасед**, вы можете ссылаться на это свойство в коде следующим образом:

[!code-css[Main](profiles-themes-and-web-parts/samples/sample7.css)]

## <a name="profile-inheritance"></a>Наследование профилей

Можно создать профиль для использования в нескольких приложениях. Создавая класс профиля, производный от Профилебасе, можно повторно использовать профиль в нескольких приложениях с помощью атрибута **Inherits** , как показано ниже:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample8.xml)]

В этом случае класс **пурчасингпрофиле** будет выглядеть следующим образом:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample9.cs)]

## <a name="profile-providers"></a>Поставщики профилей

Профили ASP.NET используют модель поставщика. Поставщик по умолчанию сохраняет сведения в базе данных SQL Server Express в папке приложения\_данных веб-приложения с помощью поставщика Склпрофилепровидер. Если база данных не существует, ASP.NET автоматически создаст ее, когда профиль попытается сохранить информацию.

Однако в некоторых случаях может потребоваться разработать собственный поставщик профилей. Функция профиля ASP.NET позволяет легко использовать различные поставщики.

Пользовательский поставщик профилей создается в следующих случаях:

- Данные профиля необходимо хранить в источнике данных, например в базе данных FoxPro или в базе данных Oracle, которые не поддерживаются поставщиками профилей, включенными в .NET Framework.
- Необходимо управлять сведениями профиля, используя схему базы данных, которая отличается от схемы базы данных, используемой поставщиками, включенными в .NET Framework. Распространенным примером является необходимость интегрировать сведения о профиле с данными пользователя в существующую базу данных SQL Server.

### <a name="required-classes"></a>Обязательные классы

Для реализации поставщика профилей необходимо создать класс, который наследует абстрактный класс System. Web. Profile. Профилепровидер. Абстрактный класс **профилепровидер** , в свою очередь, наследует абстрактный класс System. Configuration. SettingsProvider, который наследует абстрактный класс System. Configuration. Provider. провидербасе. Из-за этой цепочки наследования в дополнение к обязательным элементам класса **профилепровидер** необходимо реализовать необходимые члены классов **SettingsProvider** и **провидербасе** .

В следующих таблицах описываются свойства и методы, которые необходимо реализовать из абстрактных классов **провидербасе**, **SettingsProvider**и **профилепровидер** .

### <a name="providerbase-members"></a>Элементы Провидербасе

| **Член** | **Описание** |
| --- | --- |
| Initialize - метод | Принимает в качестве входных данных имя экземпляра поставщика и NameValueCollection параметров конфигурации. Используется для задания параметров и значений свойств для экземпляра поставщика, включая значения, зависящие от реализации, и параметры, указанные в конфигурации компьютера или файле Web. config. |

### <a name="settingsprovider-members"></a>Элементы SettingsProvider

| **Член** | **Описание** |
| --- | --- |
| Свойство ApplicationName | Имя приложения, которое хранится в каждом профиле. Поставщик профилей использует имя приложения для хранения сведений профиля отдельно для каждого приложения. Это позволяет нескольким ASP.NET приложениям использовать один и тот же источник данных без конфликта, если одно и то же имя пользователя создается в разных приложениях. Кроме того, несколько ASP.NET приложений могут совместно использовать источник данных профиля, указав одно и то же имя приложения. |
| Метод GetPropertyValues | Принимает в качестве входных данных Сеттингсконтекст и объект Сеттингспропертиколлектион. **Сеттингсконтекст** предоставляет сведения о пользователе. Эти сведения можно использовать в качестве первичного ключа для получения сведений о свойствах профиля для пользователя. Используйте объект **сеттингсконтекст** , чтобы получить имя пользователя и проверить, прошел ли пользователь проверку подлинности или анонимность. **Сеттингспропертиколлектион** содержит коллекцию объектов сеттингспроперти. Каждый объект **сеттингспроперти** предоставляет имя и тип свойства, а также дополнительные сведения, такие как значение по умолчанию для свойства и то, доступно ли свойство только для чтения. Метод **GetPropertyValues** заполняет Сеттингспропертивалуеколлектион объектами сеттингспропертивалуе на основе объектов **сеттингспроперти** , предоставленных в качестве входных данных. Значения из источника данных для указанного пользователя присваиваются свойствам PropertyValue для каждого объекта **сеттингспропертивалуе** , и возвращается вся коллекция. При вызове метода также обновляется значение Ластактивитидате для указанного профиля пользователя на текущую дату и время. |
| Метод Сетпропертивалуес | Принимает в качестве входных данных **сеттингсконтекст** и объект **сеттингспропертивалуеколлектион** . **Сеттингсконтекст** предоставляет сведения о пользователе. Эти сведения можно использовать в качестве первичного ключа для получения сведений о свойствах профиля для пользователя. Используйте объект **сеттингсконтекст** , чтобы получить имя пользователя и проверить, прошел ли пользователь проверку подлинности или анонимность. **Сеттингспропертивалуеколлектион** содержит коллекцию объектов **сеттингспропертивалуе** . Каждый объект **сеттингспропертивалуе** предоставляет имя, тип и значение свойства, а также дополнительные сведения, такие как значение по умолчанию для свойства и то, доступно ли свойство только для чтения. Метод **сетпропертивалуес** обновляет значения свойств профиля в источнике данных для указанного пользователя. При вызове метода также обновляются значения **ластактивитидате** и ластупдатеддате для указанного профиля пользователя на текущую дату и время. |

### <a name="profileprovider-members"></a>Элементы Профилепровидер

| **Член** | **Описание** |
| --- | --- |
| Метод Делетепрофилес | Принимает в качестве входных данных строковый массив имен пользователей и удаляет из источника данных все сведения о профиле и значения свойств для указанных имен, в которых имя приложения совпадает со значением свойства **applicationName** . Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакцию и откатить транзакцию и создать исключение в случае сбоя любой операции удаления. |
| Метод Делетепрофилес | Принимает в качестве входных данных коллекцию объектов fileInfo и удаляет из источника данных все сведения о профиле и значения свойств для каждого профиля, в котором имя приложения совпадает со значением свойства **applicationName** . Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакцию и откатить транзакцию и создать исключение в случае сбоя любой операции удаления. |
| Метод Делетеинактивепрофилес | Принимает в качестве входных данных значение Профилеаусентикатионоптион и объект DateTime и удаляет из источника данных все сведения о профиле и значения свойств, в которых Дата последнего действия меньше или равна указанной дате и времени, а имя приложения совпадает со значением свойства **applicationName** . Параметр **профилеаусентикатионоптион** указывает, будут ли удалены только анонимные профили, только профили, прошедшие проверку подлинности или все профили. Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакцию и откатить транзакцию и создать исключение в случае сбоя любой операции удаления. |
| Метод Жеталлпрофилес | Принимает в качестве входных данных значение **профилеаусентикатионоптион** , целое число, указывающее индекс страницы, целое число, указывающее размер страницы, и ссылку на целое число, которое будет равно общему количеству профилей. Возвращает объект Профилеинфоколлектион, содержащий объекты **FileInfo** для всех профилей в источнике данных, в которых имя приложения совпадает со значением свойства **applicationName** . Параметр **профилеаусентикатионоптион** указывает, должны ли возвращаться только анонимные профили, только профили, прошедшие проверку подлинности или все профили. Результаты, возвращаемые методом **жеталлпрофилес** , ограничиваются значениями индекса страницы и размера страницы. Значение размера страницы указывает максимальное число объектов **FileInfo** , возвращаемых в **профилеинфоколлектион**. Значение индекса страницы указывает возвращаемую страницу результатов, где 1 обозначает первую страницу. Параметр для всего записей является выходным параметром (можно использовать **ByRef** в Visual Basic), для которого задано общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы равно 2 с размером страницы 5, то возвращаемый **профилеинфоколлектион** содержит шестой в десятых профилях. При возврате из метода в поле Total Records устанавливается значение 13. |
| Метод Жеталлинактивепрофилес | Принимает в качестве входных данных значение **профилеаусентикатионоптион** , объект **DateTime** , целое число, указывающее индекс страницы, целое число, указывающее размер страницы и ссылку на целое число, которое будет равно общему количеству профилей. Возвращает объект **профилеинфоколлектион** , содержащий объекты **FileInfo** для всех профилей в источнике данных, где Дата последнего действия меньше или равна указанному значению **DateTime** и где имя приложения совпадает со значением свойства **applicationName** . Параметр **профилеаусентикатионоптион** указывает, должны ли возвращаться только анонимные профили, только профили, прошедшие проверку подлинности или все профили. Результаты, возвращаемые методом **жеталлинактивепрофилес** , ограничиваются значениями индекса страницы и размера страницы. Значение размера страницы указывает максимальное число объектов **FileInfo** , возвращаемых в **профилеинфоколлектион**. Значение индекса страницы указывает возвращаемую страницу результатов, где 1 обозначает первую страницу. Параметр для всего записей является выходным параметром (можно использовать **ByRef** в Visual Basic), для которого задано общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы равно 2 с размером страницы 5, то возвращаемый **профилеинфоколлектион** содержит шестой в десятых профилях. При возврате из метода в поле Total Records устанавливается значение 13. |
| Метод Финдпрофилесбюсернаме | Принимает в качестве входных данных значение **профилеаусентикатионоптион** , строку, содержащую имя пользователя, целое число, указывающее индекс страницы, целое число, указывающее размер страницы, и ссылку на целое число, которое будет равно общему количеству профилей. Возвращает **профилеинфоколлектион** , содержащий объекты **FileInfo** для всех профилей в источнике данных, в которых имя пользователя совпадает с указанным именем пользователя, а имя приложения совпадает со значением свойства **applicationName** . Параметр **профилеаусентикатионоптион** указывает, должны ли возвращаться только анонимные профили, только профили, прошедшие проверку подлинности или все профили. Если источник данных поддерживает дополнительные возможности поиска, например подстановочные знаки, можно предоставить более широкие возможности поиска имен пользователей. Результаты, возвращаемые методом **финдпрофилесбюсернаме** , ограничиваются значениями индекса страницы и размера страницы. Значение размера страницы указывает максимальное число объектов **FileInfo** , возвращаемых в **профилеинфоколлектион**. Значение индекса страницы указывает возвращаемую страницу результатов, где 1 обозначает первую страницу. Параметр для всего записей является выходным параметром (можно использовать **ByRef** в Visual Basic), для которого задано общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы равно 2 с размером страницы 5, то возвращаемый **профилеинфоколлектион** содержит шестой в десятых профилях. При возврате из метода в поле Total Records устанавливается значение 13. |
| Метод Финдинактивепрофилесбюсернаме | Принимает в качестве входных данных значение **профилеаусентикатионоптион** , строку, содержащую имя пользователя, объект **DateTime** , целое число, указывающее индекс страницы, целое число, указывающее размер страницы и ссылку на целое число, которое будет равно общему количеству профилей. Возвращает **профилеинфоколлектион** , содержащий объекты **FileInfo** для всех профилей в источнике данных, где имя пользователя совпадает с указанным именем пользователя, где Дата последнего действия меньше или равна указанному значению **DateTime**, а имя приложения совпадает со значением свойства **applicationName** . Параметр **профилеаусентикатионоптион** указывает, должны ли возвращаться только анонимные профили, только профили, прошедшие проверку подлинности или все профили. Если источник данных поддерживает дополнительные возможности поиска, например подстановочные знаки, можно предоставить более широкие возможности поиска имен пользователей. Результаты, возвращаемые методом **финдинактивепрофилесбюсернаме** , ограничиваются значениями индекса страницы и размера страницы. Значение размера страницы указывает максимальное число объектов **FileInfo** , возвращаемых в **профилеинфоколлектион**. Значение индекса страницы указывает возвращаемую страницу результатов, где 1 обозначает первую страницу. Параметр для всего записей является выходным параметром (можно использовать **ByRef** в Visual Basic), для которого задано общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы равно 2 с размером страницы 5, то возвращаемый **профилеинфоколлектион** содержит шестой в десятых профилях. При возврате из метода в поле Total Records устанавливается значение 13. |
| Метод Жетнумберофинактивепрофилес | Принимает в качестве входных данных значение **профилеаусентикатионоптион** и объект **DateTime** и возвращает количество всех профилей в источнике данных, где Дата последнего действия меньше или равна указанному значению **DateTime** и где имя приложения совпадает со значением свойства **applicationName** . Параметр **профилеаусентикатионоптион** указывает, будут ли учитываться только анонимные профили, только профили, прошедшие проверку подлинности или все профили. |

### <a name="applicationname"></a>ApplicationName

Так как поставщики профилей хранят сведения о профилях отдельно для каждого приложения, необходимо убедиться, что схема данных включает имя приложения, а также в том, что запросы и обновления включают в себя имя приложения. Например, следующая команда используется для получения значения свойства из базы данных на основе имени пользователя и того, является ли профиль анонимным, и гарантирует, что значение **applicationName** будет включено в запрос.

[!code-sql[Main](profiles-themes-and-web-parts/samples/sample10.sql)]

## <a name="aspnet-themes"></a>Темы ASP.NET

## <a name="what-are-aspnet-20-themes"></a>Что представляют собой темы ASP.NET 2,0?

Одним из наиболее важных аспектов веб-приложения является согласованный внешний вид и поведение узла. ASP.NET 1. x разработчики обычно используют каскадные таблицы стилей (CSS) для реализации единообразного внешнего вида и поведения. Темы ASP.NET 2,0 значительно улучшают CSS, так как они дают разработчику ASP.NET возможность определять внешний вид ASP.NET серверных элементов управления, а также элементы HTML. Темы ASP.NET можно применять к отдельным элементам управления, определенной веб-странице или всему веб-приложению. Темы используют сочетание CSS-файлов, дополнительный файл обложки и каталог дополнительных изображений, если требуются изображения. Файл обложки управляет внешним видом серверных элементов управления ASP.NET.

## <a name="where-are-themes-stored"></a>Где хранятся темы?

Расположение, в котором хранятся темы, отличается в зависимости от их области действия. Темы, которые могут быть применены к любому приложению, хранятся в следующей папке:

`C:\WINDOWS\Microsoft.NET\Framework\v2.x.xxxxx\ASP.NETClientFiles\Themes\<Theme_Name>`

Тема, относящаяся к конкретному приложению, хранится в каталоге `App\_Themes\<Theme\_Name>` в корне веб-сайта.

> [!NOTE]
> Файл обложки должен изменять только свойства серверного элемента управления, влияющие на внешний вид.

Глобальная тема — это тема, которую можно применить к любому приложению или веб-сайту, работающему на веб-сервере. Эти темы хранятся по умолчанию в каталоге ASP. Нетклиентфилес\семес, который находится в каталоге v2. x. xxxxx. Кроме того, можно переместить файлы темы в папку ASPNET\_Client/System\_Web/[версия]/Семес/[Theme\_name] в корне веб-сайта.

Темы, относящиеся к приложению, могут применяться только к приложениям, в которых находятся файлы. Эти файлы хранятся в каталоге `App\_Themes/<theme\_name>` в корне веб-сайта.

## <a name="the-components-of-a-theme"></a>Компоненты темы

Тема состоит из одного или нескольких файлов CSS, дополнительного файла обложки и папки необязательных изображений. Файлы CSS могут иметь любое требуемое имя (например, Default. CSS или Theme. CSS и т. д.) и должны находиться в корневом каталоге папки Themes. Файлы CSS используются для определения обычных классов и атрибутов CSS для конкретных селекторов. Чтобы применить один из классов CSS к элементу Page, используется свойство **CssClass** .

Файл обложки — это XML-файл, содержащий определения свойств для серверных элементов управления ASP.NET. Приведенный ниже код является примером файла обложки.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample11.aspx)]

На **рис. 1** ниже показана небольшая ASP.NET страница, просмотренная без применения темы. На **рис. 2** показан тот же файл с примененной темой. Цвет фона и цвет текста настраиваются с помощью CSS-файла. Внешний вид кнопки и текстового поля настраивается с помощью файла обложки, приведенного выше.

![Нет темы](profiles-themes-and-web-parts/_static/image1.gif)

**Рис. 1**. отсутствие темы

![Тема применена](profiles-themes-and-web-parts/_static/image2.gif)

**Рис. 2**. применена тема

Приведенный выше файл обложки определяет обложку по умолчанию для всех элементов управления TextBox и кнопок. Это означает, что каждый элемент управления TextBox и элемент управления "Кнопка", вставленные на странице, будут иметь такой внешний вид. Можно также определить обложку, которую можно применить к определенным экземплярам этих элементов управления с помощью свойства **SkinID** элемента управления.

Приведенный ниже код определяет обложку для элемента управления Button. Только элементы управления "Кнопка" с свойством **SkinID** для **гобуттон** будут иметь внешний вид обложки.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample12.aspx)]

Можно использовать только одну обложку по умолчанию для каждого типа серверного элемента управления. Если требуются дополнительные обложки, следует использовать свойство SkinID.

## <a name="applying-themes-to-pages"></a>Применение тем к страницам

Тему можно применить одним из следующих способов.

- В &lt;страницах&gt; файла Web. config
- В директиве @Page страницы
- Программным образом

## <a name="applying-a-theme-in-the-configuration-file"></a>Применение темы в файле конфигурации

Чтобы применить тему в файле конфигурации приложений, используйте следующий синтаксис:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample13.xml)]

Имя темы, указанное здесь, должно совпадать с именем папки Themes. Эта папка может находиться либо в любом из расположений, упомянутых ранее в этом курсе. При попытке применить несуществующую тему произойдет ошибка конфигурации.

## <a name="applying-a-theme-in-the-page-directive"></a>Применение темы в директиве Page

Можно также применить тему в директиве @ Page. Этот метод позволяет использовать тему для конкретной страницы.

Чтобы применить тему в директиве @Page, используйте следующий синтаксис:

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample14.aspx)]

Опять же, указанная здесь тема должна соответствовать папке темы, как упоминалось ранее. При попытке применить несуществующую тему произойдет сбой сборки. Visual Studio также выделит атрибут и уведомит вас о том, что такая тема не существует.

## <a name="applying-a-theme-programmatically"></a>Программное применение темы

Чтобы применить тему программно, необходимо указать свойство **Theme** для страницы на **странице\_** методе инициализации.

Чтобы применить тему программно, используйте следующий синтаксис:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample15.cs)]

Необходимо применить тему в методе прединициализации из-за жизненного цикла страницы. Если применить его после этой точки, тема страницы уже будет применена средой выполнения, а изменение на этом этапе — слишком поздно в жизненном цикле. При применении темы, которая не существует, происходит **HttpException** . Если тема применяется программно, предупреждение о сборке возникает, если для элементов управления сервера задано свойство SkinID. Это предупреждение предназначено для информирования о том, что тема не применена декларативно, и ее можно игнорировать.

## <a name="exercise-1--applying-a-theme"></a>Упражнение 1. Применение темы

В этом упражнении к веб-сайту будет применена тема ASP.NET.

> [!IMPORTANT]
> Если вы используете Microsoft Word для ввода информации в файл обложки, убедитесь, что вы не заменяете обычные кавычки парными. Смарт-кавычки приведут к проблемам с файлами обложки.

1. Создание нового веб-сайта ASP.NET.
2. Щелкните правой кнопкой мыши проект в обозреватель решений и выберите команду Добавить новый элемент.
3. Выберите файл веб-конфигурации из списка файлов и нажмите кнопку Добавить.
4. Щелкните правой кнопкой мыши проект в обозреватель решений и выберите команду Добавить новый элемент.
5. Выберите файл обложки и нажмите кнопку Добавить.
6. Нажмите кнопку Да при появлении запроса на размещение файла в папке App\_Themes.
7. Щелкните правой кнопкой мыши папку Скинфиле в папке App\_Themes в обозреватель решений и выберите команду Добавить новый элемент.
8. Выберите таблицу стилей из списка файлов и нажмите кнопку Добавить. Теперь у вас есть все файлы, необходимые для реализации новой темы. Однако Visual Studio имеет имя папка Themes Скинфиле. Щелкните правой кнопкой мыши эту папку и измените ее имя на Кулсеме.
9. Откройте файл Скинфиле. Skin и добавьте следующий код в конец файла: 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample16.aspx)]
10. Сохраните файл Скинфиле. skin.
11. Откройте таблицу стилей. CSS.
12. Замените весь текст следующим: 

    [!code-css[Main](profiles-themes-and-web-parts/samples/sample17.css)]
13. Сохраните файл StyleSheet. CSS.
14. Откройте страницу Default. aspx.
15. Добавьте элемент управления TextBox и элемент управления "Кнопка".
16. Сохраните страницу. Теперь перейдите на страницу Default. aspx. Он должен отображаться как обычная веб-форма.
17. Откройте файл Web. config.
18. Добавьте следующий тег непосредственно под открывающим тегом `<system.web>`: 

    [!code-xml[Main](profiles-themes-and-web-parts/samples/sample18.xml)]
19. Сохраните файл Web. config. Теперь перейдите на страницу Default. aspx. Он должен отображаться вместе с темой.
20. Откройте страницу Default. aspx в Visual Studio, если она еще не открыта.
21. Нажмите кнопку.
22. Измените свойство **SkinID** на гобуттон. Обратите внимание, что Visual Studio предоставляет раскрывающийся список с допустимыми значениями SkinID для элемента управления Button.
23. Сохраните страницу. Теперь снова просмотрите страницу в браузере. Теперь кнопка должна выглядеть так: «go» и должна быть шире ее внешнего вида.

С помощью свойства **SkinID** можно легко настроить различные обложки для различных экземпляров определенного типа серверного элемента управления.

## <a name="the-stylesheettheme-property"></a>Свойство StyleSheetTheme

До сих пор мы говорили только о применении тем с помощью свойства Theme. При использовании свойства Theme файл обложки переопределит все декларативные параметры серверных элементов управления. Например, в упражнении 1 вы указали SkinID "Гобуттон" для элемента управления "Кнопка" и изменили текст кнопки на "Go". Возможно, вы заметили, что свойство Text кнопки в конструкторе имеет значение "Button", но тема переопределили. Тема всегда будет переопределять все параметры свойств в конструкторе.

Если вы хотите иметь возможность переопределить свойства, определенные в файле обложки темы, свойствами, указанными в конструкторе, можно использовать свойство **StyleSheetTheme** вместо свойства Theme. Свойство StyleSheetTheme совпадает со свойством Theme, за исключением того, что оно не переопределяет все параметры явного свойства, такие как свойство Theme.

Чтобы увидеть это в действии, откройте файл Web. config из проекта в упражнении 1 и измените элемент `<pages>` на следующий:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample19.xml)]

Теперь просмотрите страницу Default. aspx, и вы увидите, что элемент управления "Кнопка" имеет свойство Text "Button". Это обусловлено тем, что параметр явного свойства в конструкторе переопределяет свойство Text, заданное Гобуттон SkinID.

## <a name="overriding-themes"></a>Переопределение тем

Глобальную тему можно переопределить, применив тему к тому же имени в папке App\_Themes (темы) приложения. Тем не менее, тема не применяется в сценарии переопределений true. Если среда выполнения встречает файлы темы в папке App\_Themes, она применит тему, используя эти файлы, и будет игнорировать глобальную тему.

Свойство StyleSheetTheme является переопределяемым и может быть переопределено в коде следующим образом:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample20.cs)]

## <a name="web-parts"></a>веб-части

ASP.NET веб-части — это интегрированный набор элементов управления для создания веб-сайтов, позволяющих конечным пользователям изменять содержимое, внешний вид и поведение веб-страниц непосредственно из браузера. Изменения могут применяться ко всем пользователям сайта или отдельным пользователям. Когда пользователи изменяют страницы и элементы управления, эти параметры можно сохранить, чтобы сохранить личные настройки пользователя в будущих сеансах браузера, а именно в этой функции — Персонализация. Эти веб-части возможности означают, что разработчики могут предоставить конечным пользователям возможность динамического персонализации веб-приложения без вмешательства разработчика или администратора.

Используя набор элементов управления веб-части, разработчик может предоставить конечным пользователям следующие возможности:

- Персонализация содержимого страницы. Пользователи могут добавлять на страницу новые элементы управления веб-части, удалять их, скрывать или сокращать, как обычные окна.
- Настройка макета страницы. Пользователи могут перетаскивать элемент управления веб-части в другую зону на странице или изменять ее внешний вид, свойства и поведение.
- Экспорт и импорт элементов управления. Пользователи могут импортировать или экспортировать веб-части параметры управления для использования на других страницах или сайтах, хранить свойства, внешний вид и даже данные в элементах управления. Это сокращает требования к вводу и настройке данных для конечных пользователей.
- Создание подключений. Пользователи могут устанавливать соединения между элементами управления, чтобы, например, элемент управления диаграммы мог отобразить график для данных в элементе управления биржевых котировок. Пользователи могут персонализировать не только само соединение, но и внешний вид и подробные сведения о том, как элемент управления диаграммы отображает данные.
- Управление настройками уровня сайта и их Персонализация. Полномочные пользователи могут настраивать параметры на уровне сайта, определять, кто имеет доступ к сайту или странице, устанавливать доступ к элементам управления на основе ролей и т. д. Например, пользователь административной роли может задать общий доступ для всех пользователей веб-части, а также запретить пользователям, которые не являются администраторами, персонализировать общий элемент управления.

Обычно вы работаете с веб-части одним из трех способов: создание страниц, использующих элементы управления веб-части, создание отдельных элементов управления веб-части или создание полных, настраиваемых веб-приложений, таких как портал.

## <a name="page-development"></a>Разработка страниц

Разработчики страниц могут использовать средства визуального проектирования, такие как Microsoft Visual Studio 2005, для создания страниц, использующих веб-части. Одним из преимуществ использования такого средства, как Visual Studio, является то, что набор элементов управления веб-части предоставляет функции для создания и настройки веб-части элементов управления в визуальном конструкторе с возможностью перетаскивания. Например, конструктор можно использовать для перетаскивания веб-части зоны или элемента управления редактора веб-части в область конструктора, а затем настраивать элемент управления прямо в конструкторе, используя пользовательский интерфейс, предоставленный набором элементов управления веб-части. Это позволяет ускорить разработку приложений веб-части и сократить объем кода, который необходимо написать.

## <a name="control-development"></a>Разработка элементов управления

Любой существующий элемент управления ASP.NET можно использовать в качестве элемента управления веб-части, включая стандартные элементы управления веб-сервера, пользовательские серверные элементы управления и пользовательские элементы управления. Для максимального программного управления средой можно также создать пользовательские элементы управления веб-части, производные от класса WebPart. Для разработки отдельных веб-части элементов управления обычно можно создать пользовательский элемент управления и использовать его в качестве элемента управления веб-части или разработать пользовательский элемент управления веб-части.

В качестве примера разработки пользовательского элемента управления веб-части можно создать элемент управления для предоставления любых функций, предоставляемых другими серверными элементами управления ASP.NET, которые могут быть полезны для упаковки в качестве настраиваемого элемента управления веб-части: календари, списки, финансовые сведения, Новости, калькуляторы, элементы управления форматированным текстом для обновления содержимого, редактируемые сетки, подключающиеся к базам данных, диаграммы, которые динамически обновляют свои экраны, а также сведения о погоде и командировках. Если вы предоставляете визуальный конструктор с элементом управления, любой разработчик страниц, использующий Visual Studio, может просто перетащить элемент управления в зону веб-части и настроить ее во время разработки без необходимости написания дополнительного кода.

Персонализация является основой функции веб-части. Это позволяет пользователям изменять и настраивать макет, внешний вид и поведение элементов управления веб-части на странице. Персонализированные параметры имеют долгосрочную длину: они сохраняются не только во время текущего сеанса браузера (как и состояние просмотра), но и в долгосрочном хранилище, чтобы параметры пользователя сохранялись для будущих сеансов браузера. Персонализация включена по умолчанию для страниц веб-части.

Компоненты структуры пользовательского интерфейса основываются на персонализации и предоставляют основную структуру и службы, необходимые всем элементам управления веб-части. На каждой веб-части странице требуется один структурный компонент пользовательского интерфейса, который является элементом управления WebPartManager. Хотя это и никогда не отображается, этот элемент управления имеет критическую задачу координирования всех веб-части элементов управления на странице. Например, он отслеживает все отдельные элементы управления веб-части. Он управляет веб-части зонами (регионами, содержащими элементы управления веб-части на странице), а также элементами управления, в которых находятся зоны. Кроме того, он отслеживает и управляет различными режимами экрана, в том числе просмотром, подключением, изменением или режимом каталога, а также изменениями персонализации для всех пользователей или отдельных пользователей. Наконец, он инициирует и отслеживает подключения и обмен данными между элементами управления веб-части.

Вторым видом структурного компонента пользовательского интерфейса является зона. Зоны работают как диспетчеры макетов на странице веб-части. Они содержат и упорядочивают элементы управления, производные от класса Part (элементы управления "часть"), и предоставляют возможность выполнять модульную разметку страниц в горизонтальной или вертикальной ориентации. Зоны также предлагают общие и согласованные элементы пользовательского интерфейса (такие как стиль верхнего и нижнего колонтитула, заголовок, стиль границы, кнопки действий и т. д.) для каждого элемента управления, который они содержат. Эти общие элементы называются хромом элемента управления. Несколько специализированных типов зон используются в различных режимах экрана и с различными элементами управления. Различные типы зон описаны в разделе веб-части важными элементами управления ниже.

Веб-части элементы управления пользовательского интерфейса, которые являются производными от класса **Part** , составляют основной пользовательский интерфейс на веб-части странице. Набор элементов управления веб-части является гибким и включает в себя параметры, позволяющие создавать элементы управления "часть". Помимо создания собственных настраиваемых элементов управления веб-части можно также использовать существующие элементы управления ASP.NET Server, пользовательские элементы управления или пользовательские серверные элементы управления в качестве веб-частиных элементов управления. Основные элементы управления, наиболее часто используемые для создания веб-части страниц, описаны в следующем разделе.

## <a name="web-parts-essential-controls"></a>веб-частиные ключевые элементы управления

Набор элементов управления веб-части является обширным, но некоторые элементы управления являются обязательными, так как они необходимы для работы веб-части, или потому что они являются элементами управления, которые чаще всего используются на страницах веб-части. Когда вы начинаете использовать веб-части и создаете базовые веб-части страницы, полезно ознакомиться с основными элементами управления веб-части, описанными в следующей таблице.

| **веб-части элемент управления** | **Описание** |
| --- | --- |
| SPWebPartManager | Управляет всеми элементами управления веб-части на странице. Для каждой веб-части страницы требуется только один элемент управления **WebPartManager** (и только один). |
| CatalogZone | Содержит элементы управления CatalogPart. Эта зона используется для создания каталога элементов управления веб-части, из которых пользователи могут выбирать элементы управления для добавления на страницу. |
| EditorZone | Содержит элементы управления EditorPart. Используйте эту зону, чтобы разрешить пользователям изменять и персонализировать элементы управления веб-части на странице. |
| Частей | Содержит и предоставляет общий макет для элементов управления WebPart, образующих основной пользовательский интерфейс страницы. Используйте эту зону при создании страниц с элементами управления веб-части. Страницы могут содержать одну или несколько зон. |
| ConnectionsZone | Содержит элементы управления Вебпартконнектион и предоставляет пользовательский интерфейс для управления соединениями. |
| WebPart (GenericWebPart) | Подготавливает к просмотру основной пользовательский интерфейс; Большинство элементов управления пользовательского интерфейса веб-части относятся к этой категории. Для максимального программного управления можно создавать пользовательские элементы управления веб-части, производные от базового элемента управления **WebPart** . Можно также использовать существующие серверные элементы управления, пользовательские элементы управления или пользовательские элементы управления в качестве элементов управления веб-части. Каждый раз, когда любой из этих элементов управления помещается в зону, элемент управления **WebPartManager** автоматически заносит их в элементы управления **GenericWebPart** во время выполнения, чтобы их можно было использовать с веб-частиной функциональностью. |
| CatalogPart | Содержит список доступных элементов управления веб-части, которые пользователи могут добавлять на страницу. |
| вебпартконнектион | Создает соединение между двумя элементами управления веб-части на странице. Соединение определяет один из элементов управления веб-части как поставщик (данных), а другой — как потребитель. |
| EditorPart | Служит базовым классом для специализированных элементов управления редактора. |
| Элементы управления EditorPart (Аппеаранцеедиторпарт, Лайаутедиторпарт, Бехавиоредиторпарт и Пропертигридедиторпарт) | Разрешить пользователям персонализировать различные аспекты веб-части элементов управления пользовательского интерфейса на странице |

## <a name="lab-create-a-web-part-page"></a>Лаборатория: Создание страницы веб-части

В этом лабораторном занятии будет создана страница веб-части, которая будет хранить информацию через Профили ASP.NET.

### <a name="creating-a-simple-page-with-web-parts"></a>Создание простой страницы с веб-части

В этой части пошагового руководства вы создадите страницу, которая использует элементы управления веб-части для отображения статического содержимого. Первым шагом в работе с веб-части является создание страницы с двумя необходимыми структурными элементами. Сначала странице веб-частей требуется элемент управления WebPartManager для трассировки и координации всех элементов управления веб-части. Во-вторых, веб-части странице требуется одна или несколько зон, представляющих собой составные элементы управления, которые содержат веб-часть или другие серверные элементы управления и занимают указанную область страницы.

> [!NOTE]
> Для включения персонализации веб-части не нужно ничего делать. он включен по умолчанию для набора элементов управления веб-части. При первом запуске веб-части страницы на сайте ASP.NET устанавливает поставщика персонализации по умолчанию для хранения параметров персонализации пользователя. Дополнительные сведения о персонализации см. в разделе Общие сведения о персонализации веб-части.

### <a name="to-create-a-page-for-containing-web-parts-controls"></a>Создание страницы, содержащей элементы управления веб-части

1. Закройте страницу по умолчанию и добавьте на сайт новую страницу с именем Вебпартсдемо. aspx.
2. Переключитесь в режим **конструктора** .
3. В меню **вид** убедитесь, что выбраны **Невизуальные элементы управления** и **сведения** для просмотра тегов макета и элементов управления, не имеющих пользовательского интерфейса.
4. Поместите точку вставки перед тегами `<div>` в области конструктора и нажмите клавишу ВВОД, чтобы добавить новую строку. Поместите точку вставки перед символом новой строки, щелкните раскрывающийся список **Формат блока** в меню и выберите пункт **Заголовок 1** . В заголовке добавьте **страницу демонстрации текста веб-части**.
5. На вкладке **WebParts** (веб-части) панели элементов перетащите элемент управления **WebPartManager** на страницу, разместив его сразу после символа новой строки и до тегов `<div>`.   
  
   Элемент управления **WebPartManager** не отображает никаких выходных данных, поэтому он отображается в области конструктора в виде серого прямоугольника.
6. Поместите точку вставки в теги `<div>`.
7. В меню **Макет** выберите пункт **Вставить таблицу**и создайте новую таблицу с одной строкой и тремя столбцами. Нажмите кнопку **Свойства ячейки** , выберите **вверху** в раскрывающемся списке **вертикальное выравнивания** , нажмите кнопку **ОК**, а затем еще раз нажмите кнопку **ОК** , чтобы создать таблицу.
8. Перетащите элемент управления WebPartZone в столбец левой таблицы. Щелкните правой кнопкой мыши элемент управления **WebPartZone** , выберите пункт **свойства**и задайте следующие свойства:   
  
   Идентификатор: Сидебарзоне   
  
   Хеадертекст: Боковая панель
9. Перетащите второй элемент управления **WebPartZone** в столбец средней таблицы и задайте следующие свойства:   
  
   Идентификатор: Маинзоне   
  
   Хеадертекст: основной
10. Сохраните файл.

Теперь страница имеет две отдельные зоны, которыми можно управлять отдельно. Однако ни одна из зон не имеет содержимого, поэтому создание содержимого является следующим шагом. В этом пошаговом руководстве вы работаете с веб-части элементами управления, которые отображают только статическое содержимое.

Макет зоны веб-части задается элементом&gt; &lt;ZoneTemplate. Внутри шаблона зоны можно добавить любой элемент управления ASP.NET, будь то пользовательский элемент управления веб-части, Пользовательский элемент управления или существующий серверный элемент управления. Обратите внимание, что здесь используется элемент управления Label, и к нему просто добавляется статический текст. При помещении обычного серверного элемента управления в зону **WebPartZone** ASP.NET рассматривает элемент управления как элемент управления веб-части во время выполнения, что позволяет веб-части функции элемента управления.

**Создание содержимого для основной зоны**

1. В режиме **конструктора** перетащите элемент управления **Label** со вкладки **Стандартная** панели элементов в область содержимого зоны, свойство **ID** которых имеет значение маинзоне.
2. Переключитесь в представление **исходного кода** . Обратите внимание, что добавлен элемент &lt;ZoneTemplate&gt; для создания оболочки элемента управления **Label** в маинзоне.
3. Добавьте атрибут **Title** в элемент &lt;ASP: Label&gt; и присвойте ему значение Content. Удалите атрибут Text = "Label" из элемента &lt;ASP: Label&gt;. Между открывающим и закрывающим тегами элемента &lt;ASP: Label&gt; добавьте текст, например **Добро пожаловать на мою домашнюю страницу** в паре тегов элементов &lt;H2&gt;. Код должен выглядеть следующим образом. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample21.aspx)]
4. Сохраните файл.

Затем создайте пользовательский элемент управления, который также может быть добавлен на страницу в качестве элемента управления веб-части.

### <a name="to-create-a-user-control"></a>Создание пользовательского элемента управления

1. Добавьте новый пользовательский веб-элемент управления на сайт, чтобы служить элементом управления поиском. Отмените выбор параметра, чтобы **поместить исходный код в отдельный файл**. Добавьте его в тот же каталог, где находится страница Вебпартсдемо. aspx, и назовите его Сеарчусерконтрол. ascx.   
  
    > [!NOTE]
    > Пользовательский элемент управления для этого пошагового руководства не реализует фактические функции поиска; Он используется только для демонстрации функций веб-части.
2. Переключитесь в режим **конструктора** . На вкладке " **стандартные** " панели элементов перетащите элемент управления TextBox на страницу.
3. Поместите точку вставки после только что добавленного текстового поля и нажмите клавишу ВВОД, чтобы добавить новую строку.
4. Перетащите элемент управления Button на страницу в новой строке под только что добавленным текстовым полем.
5. Переключитесь в представление **исходного кода** . Убедитесь, что исходный код для пользовательского элемента управления выглядит как в следующем примере. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample22.aspx)]
6. Сохраните файл и закройте его.

Теперь можно добавить веб-части элементы управления в зону боковой панели. В зону боковой панели добавляются два элемента управления: одна содержит список ссылок, а другая — пользовательский элемент управления, созданный в предыдущей процедуре. Ссылки добавляются в виде стандартного серверного элемента управления **Label** , аналогично тому, как вы создали статический текст для основной зоны. Однако хотя отдельные элементы управления сервера, содержащиеся в пользовательском элементе управления, могут содержаться непосредственно в зоне (например, в элементе управления Label), в данном случае это не так. Вместо этого они являются частью пользовательского элемента управления, созданного в предыдущей процедуре. Это демонстрирует распространенный способ упаковки любых элементов управления и дополнительных функций, которые требуются в пользовательском элементе управления, а затем сослаться на этот элемент управления в зоне в качестве элемента управления веб-части.

Во время выполнения набор элементов управления веб-части заключает оба элемента управления в элементы управления GenericWebPart. Когда элемент управления **GenericWebPart** заключает в оболочку серверный веб-элемент управления, универсальный элемент управления "часть" является родительским элементом управления, и доступ к серверному элементу управления можно получить с помощью свойства чилдконтрол родительского элемента управления. Использование универсальных элементов управления "часть" позволяет стандартным элементам управления веб-сервера иметь то же базовое поведение и атрибуты, что и веб-части элементы управления, производные от класса **WebPart** .

### <a name="to-add-web-parts-controls-to-the-sidebar-zone"></a>Добавление элементов управления веб-части в зону боковой панели

1. Откройте страницу Вебпартсдемо. aspx.
2. Переключитесь в режим **конструктора** .
3. Перетащите созданную вами страницу пользовательского элемента управления Сеарчусерконтрол. ascx из **Обозреватель решений** в зону, свойство **ID** которой имеет значение сидебарзоне, и удалите его.
4. Сохраните страницу Вебпартсдемо. aspx.
5. Переключитесь в представление **исходного кода** .
6. В элементе &lt;ASP: WebPartZone&gt; для Сидебарзоне, прямо над ссылкой на пользовательский элемент управления, добавьте &lt;элемент ASP: Label&gt; с включенными ссылками, как показано в следующем примере. Кроме того, добавьте атрибут **Title** к тегу пользовательского элемента управления со значением **Поиск**, как показано ниже. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample23.aspx)]
7. Сохраните файл и закройте его.

Теперь можно протестировать страницу, перейдя к ней в браузере. На странице отображаются две зоны. На следующем снимке экрана показана страница.

**веб-части демонстрационной странице с двумя зонами**

![Снимок экрана веб-части пошагового руководства по Visual Studio 1](profiles-themes-and-web-parts/_static/image3.gif)

**Рис. 3**. снимок экрана веб-части и пошагового руководства 1

В заголовке каждого элемента управления находится стрелка вниз, предоставляющая доступ к меню команд доступных действий, которые можно выполнять над элементом управления. Щелкните меню команд для одного из элементов управления, а затем щелкните команду **сворачивания** и обратите внимание, что элемент управления является минимальным. В меню команды выберите команду **восстановить**, и элемент управления вернется к нормальному размеру.

### <a name="enabling-users-to-edit-pages-and-change-layout"></a>Предоставление пользователям возможности редактировать страницы и изменять макет

Веб-части предоставляет пользователям возможность изменять макет элементов управления веб-части, перетаскивая их из одной зоны в другую. Помимо предоставления пользователям возможности перемещения элементов управления **веб-частей** из одной зоны в другую, можно разрешить пользователям изменять различные характеристики элементов управления, включая их внешний вид, макет и поведение. Набор элементов управления веб-части предоставляет базовые функции редактирования для элементов управления **WebPart** . Хотя это не будет сделано в этом пошаговом руководстве, можно также создать пользовательские элементы управления редактора, позволяющие пользователям изменять функции элементов управления **WebPart** . Как и при изменении расположения элемента управления **WebPart** , изменение свойств элемента управления полагается на персонализацию ASP.NET, чтобы сохранить изменения, вносимые пользователями.

В этой части пошагового руководства вы добавите возможность для пользователей изменять основные характеристики любого элемента управления **веб-части** на странице. Чтобы включить эти функции, необходимо добавить на страницу еще один пользовательский элемент управления, а также элемент &lt;ASP: EditorZone&gt; и два элемента управления для редактирования.

### <a name="to-create-a-user-control-that-enables-changing-page-layout"></a>Создание пользовательского элемента управления, который включает изменение макета страницы

1. В Visual Studio в меню **файл** выберите подменю **создать** и щелкните параметр **файл** .
2. В диалоговом окне **Добавление нового элемента** выберите **Пользовательский веб-элемент управления**. Назовите новый файл Дисплаймодемену. ascx. Отмените выбор параметра, чтобы **поместить исходный код в отдельный файл**.
3. Нажмите кнопку Добавить, чтобы создать новый элемент управления.
4. Переключитесь в представление **исходного кода** .
5. Удалите весь существующий код в новом файле и вставьте следующий код. В этом коде пользовательского элемента управления используются функции набора элементов управления веб-части, которые позволяют странице изменять режим просмотра или отображения, а также изменять физический внешний вид и макет страницы в определенных режимах отображения. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample24.aspx)]
6. Сохраните файл, щелкнув значок сохранить на панели инструментов или выбрав **сохранить** в меню **файл** .

### <a name="to-enable-users-to-change-the-layout"></a>Предоставление пользователям возможности изменения макета

1. Откройте страницу Вебпартсдемо. aspx и переключитесь в режим **конструктора** .
2. Поместите точку вставки в представлении **конструктора** сразу после элемента управления **WebPartManager** , который вы добавили ранее. Добавьте жесткий возврат после текста, чтобы после элемента управления **WebPartManager** существовала пустая строка. Поместите точку вставки на пустую строку.
3. Перетащите только что созданный пользовательский элемент управления (файл с именем Дисплаймодемену. ascx) на страницу Вебпартсдемо. aspx и поместите его в пустую строку.
4. Перетащите элемент управления EditorZone из раздела **веб-части** области элементов в оставшуюся открытую ячейку таблицы на странице вебпартсдемо. aspx.
5. Из раздела **WebParts (части** ) панели элементов перетащите элемент управления аппеаранцеедиторпарт и элемент управления лайаутедиторпарт в элемент управления **EditorZone** .
6. Переключитесь в представление **исходного кода** . Результирующий код в ячейке таблицы должен выглядеть примерно так, как показано в следующем коде. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample25.aspx)]
7. Сохраните файл Вебпартсдемо. aspx. Вы создали пользовательский элемент управления, который позволяет изменять режимы экрана и изменять макет страницы, а также ссылаться на элемент управления на основной веб-странице.

Теперь можно проверить возможность редактирования страниц и изменения макета.

### <a name="to-test-layout-changes"></a>Проверка изменений макета

1. Загрузите страницу в браузере.
2. Щелкните раскрывающееся меню **режим экрана** и выберите **изменить**. Отобразятся названия зон.
3. Перетащите элемент управления " **Мои ссылки** " на строку заголовка из зоны боковой панели в нижнюю часть основной зоны. Страница должна выглядеть, как на следующем снимке экрана.

### <a name="web-parts-demo-page-with-my-links-control-moved"></a>веб-части демонстрационную страницу с перемещенным элементом управления "Мои ссылки"

![Снимок экрана пошагового руководства веб-части VS 2](profiles-themes-and-web-parts/_static/image4.gif)

**Рис. 4**. снимок экрана пошагового руководства веб-части и 2

1. Щелкните раскрывающееся меню **режим экрана** и выберите **Обзор**. Эта страница обновляется, имена зон исчезают, а элемент управления " **Мои ссылки** " остается там, где вы его размещаете.
2. Чтобы показать, что персонализация работает, закройте браузер, а затем снова загрузите страницу. Внесенные изменения сохраняются для будущих сеансов браузера.
3. В меню **режим просмотра** выберите **изменить**.   
  
   Каждый элемент управления на странице теперь отображается с помощью стрелки вниз в строке заголовка, которая содержит раскрывающееся меню команды.
4. Щелкните стрелку, чтобы отобразить меню команды в элементе управления " **Мои ссылки** ". Щелкните команду **изменить** .   
  
   Появится элемент управления **EditorZone** , отображающий добавленные элементы управления EditorPart.
5. В разделе **вид** элемента управления Правка измените **заголовок** на мое избранное, используйте раскрывающийся список **тип Chrome** , чтобы выбрать **только заголовок**, а затем нажмите кнопку **Применить**. На следующем снимке экрана показана страница в режиме редактирования.

### <a name="web-parts-demo-page-in-edit-mode"></a>веб-части демонстрационная страница в режиме редактирования

![Снимок экрана пошагового руководства веб-части VS 3](profiles-themes-and-web-parts/_static/image5.gif)

**Рис. 5**. снимок экрана веб-части пошагового руководства по Visual Studio 3

1. Откройте меню **режим отображения** и нажмите кнопку **Обзор** , чтобы вернуться в режим обзора.
2. Теперь элемент управления имеет обновленный заголовок без границы, как показано на следующем снимке экрана.

### <a name="edited-web-parts-demo-page"></a>Измененная Демонстрационная Страница веб-части

![Снимок экрана веб-части пошагового руководства по Visual Studio 4](profiles-themes-and-web-parts/_static/image6.gif)

**Рис. 4**. снимок экрана веб-части пошагового руководства по Visual Studio 4

### <a name="adding-web-parts-at-run-time"></a>Добавление веб-части во время выполнения

Можно также разрешить пользователям добавлять элементы управления веб-части на страницу во время выполнения. Для этого настройте на странице каталог веб-части, содержащий список элементов управления веб-части, которые требуется сделать доступными для пользователей.

**Предоставление пользователям возможности добавлять веб-части во время выполнения**

1. Откройте страницу Вебпартсдемо. aspx и переключитесь в режим **конструктора** .
2. На вкладке « **WebParts** » панели элементов перетащите элемент управления CatalogZone в правый столбец таблицы под элементом управления **EditorZone** .   
  
   Оба элемента управления могут находиться в одной ячейке таблицы, так как они не будут отображаться одновременно.
3. На панели Свойства присвойте строке **Add веб-части** свойство хеадертекст элемента управления **CatalogZone** .
4. Из раздела **WebParts (части** ) области элементов перетащите элемент управления декларативекаталогпарт в область содержимого элемента управления **CatalogZone** .
5. Щелкните стрелку в правом верхнем углу элемента управления **декларативекаталогпарт** , чтобы открыть меню задачи, и выберите пункт **изменить шаблоны**.
6. Из **стандартного** раздела панели элементов перетащите элемент управления **FileUpload** и элемент управления **Calendar** в раздел **вебпартстемплате** элемента управления **декларативекаталогпарт** .
7. Переключитесь в представление **исходного кода** . Проверьте исходный код элемента &lt;ASP: CatalogZone&gt;. Обратите внимание, что элемент управления **декларативекаталогпарт** содержит элемент&gt; &lt;вебпартстемплате с двумя вложенными серверными элементами управления, которые можно будет добавить на страницу из каталога.
8. Добавьте свойство **Title** к каждому элементу управления, добавленному в каталог, используя строковое значение, показанное для каждого заголовка в приведенном ниже примере кода. Несмотря на то, что заголовок не является свойством, который обычно можно задать для этих двух серверных элементов управления во время разработки, когда пользователь добавляет эти элементы управления в зону **WebPartZone** из каталога во время выполнения, они упаковываются с помощью элемента управления **GenericWebPart** . Это позволяет им действовать как веб-части элементы управления, чтобы они могли отображать заголовки.   
  
   Код для двух элементов управления, содержащихся в элементе управления **декларативекаталогпарт** , должен выглядеть следующим образом. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample26.aspx)]
9. Сохраните страницу.

Теперь можно протестировать каталог.

### <a name="to-test-the-web-parts-catalog"></a>Тестирование каталога веб-части

1. Загрузите страницу в браузере.
2. Щелкните раскрывающееся меню **режим экрана** и выберите **Catalog (каталог**).   
  
   Отобразится каталог **Add веб-части (добавить** имя).
3. Перетащите элемент управления **My Избранное** из основной зоны обратно в верхнюю часть зоны боковой панели и поместите его сюда.
4. В диалоговом окне **добавление веб-части** выберите оба флажка, а затем в раскрывающемся списке, содержащем доступные зоны, выберите пункт **Main** .
5. Нажмите кнопку **Добавить** в каталоге. Элементы управления добавляются в основную зону. При необходимости можно добавить несколько экземпляров элементов управления из каталога на страницу.   
  
   На следующем снимке экрана показана страница с элементом управления отправка файла и календарем в основной зоне. 

![Элементы управления, добавленные в основную зону из каталога](profiles-themes-and-web-parts/_static/image7.gif)

    **Figure 5**: Controls added to Main zone from the catalog
6. Щелкните раскрывающееся меню **режим экрана** и выберите **Обзор**. Каталог исчезает, и страница обновляется.
7. Закройте браузер. Снова загрузите страницу. Внесенные изменения сохраняются.
