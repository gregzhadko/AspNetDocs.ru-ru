---
uid: web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
title: Профили, темы и веб-частей | Документация Майкрософт
author: microsoft
description: Существуют значительные изменения в конфигурации и инструментарий в среде ASP.NET 2.0. Новый API конфигурации ASP.NET позволяет сделать запрос на Вытягивание изменения конфигурации...
ms.author: riande
ms.date: 02/20/2005
ms.assetid: 92df4051-77c6-492c-bd34-23d24189cea4
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
msc.type: authoredcontent
ms.openlocfilehash: 010adaba61b15ca4421c2d3a4a7590becb53897b
ms.sourcegitcommit: 289e051cc8a90e8f7127e239fda73047bde4de12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/25/2019
ms.locfileid: "58422857"
---
<a name="profiles-themes-and-web-parts"></a>Профили, темы и веб-части
====================
по [Microsoft](https://github.com/microsoft)

> Существуют значительные изменения в конфигурации и инструментарий в среде ASP.NET 2.0. Новый API конфигурации ASP.NET позволяет производить программно, изменения конфигурации. Кроме того, существует много новых параметров конфигурации разрешить для новой конфигурации и инструментирования.


ASP.NET 2.0 – это значительное улучшение в области, персонализированных веб-сайтов. В дополнение к уже распространяется weve функций членства профилей ASP.NET, темы и веб-частей значительно улучшить персонализации в веб-сайтов.

## <a name="aspnet-profiles"></a>Профили ASP.NET

Профили ASP.NET похожи на сеансах. Разница в том, что профиль является постоянным, в то время как сеанс будет прерван, при закрытии браузера. Еще одно существенное отличие между сеансами и профили является то, что профили являются строго типизированными, таким образом обеспечивая IntelliSense во время разработки.

Профиль определяется в файле конфигурации машины или в файл web.config для приложения. (Не удается определить профиль в файле web.config вложенных папок.) Приведенный ниже код определяет профиль, чтобы хранить посетителей веб-узла, сначала имени и фамилии.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample1.xml)]

Тип данных по умолчанию для свойства профиля — System.String. В приведенном выше примере тип данных не был указан. Поэтому свойства FirstName и LastName имеют оба типа String. Как упоминалось ранее, профиль, который свойства являются строго типизированными. Приведенный ниже код добавляет новое свойство для возраста, который относится к типу Int32.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample2.xml)]

Профили обычно используются с проверкой подлинности форм ASP.NET. При использовании в сочетании с формами проверки подлинности, каждый пользователь имеет отдельный профиль, связанный со своим ИД пользователя. Тем не менее, существует также возможность разрешить использование профилей в анонимных приложения с помощью &lt;anonymousIdentification&gt; элемент в файле конфигурации вместе с **allowAnonymous** атрибут как показано ниже:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample3.xml)]

Когда анонимный пользователь просматривает сайт, ASP.NET создает экземпляр **ProfileCommon** для пользователя. Этот профиль использует уникальный идентификатор в файле cookie в браузере для идентификации пользователя в качестве уникальных посетителей. Таким образом можно хранить сведения о профиле для пользователей, просматривающих анонимно.

## <a name="profile-groups"></a>Группы профилей

Существует возможность свойства группы профилей. Свойствами группировки существует возможность имитировать несколько профилей для конкретного приложения.

Следующая конфигурация настраивает свойство FirstName и LastName для двух групп; Покупателей и потенциальных клиентов.

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample4.xml)]

Затем можно настроить свойства в определенной группе следующим образом:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample5.cs)]

## <a name="storing-complex-objects"></a>Хранение сложных объектов

На данный момент мы рассмотрели примеры хранятся простые типы данных в профиле. Существует также возможность хранения сложных типов данных в профиле, указав способ сериализации с помощью **serializeAs** следующим образом:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample6.xml)]

В этом случае тип — PurchaseInvoice. Класс PurchaseInvoice должен быть помечен как сериализуемый и может содержать любое количество свойств. Например, если PurchaseInvoice имеет свойство с именем **NumItemsPurchased**, можно ссылаться на это свойство в коде следующим образом:

[!code-css[Main](profiles-themes-and-web-parts/samples/sample7.css)]

## <a name="profile-inheritance"></a>Профиль наследования

Можно создать профиль для использования в нескольких приложениях. Создав профиль класс, производный от ProfileBase, можно повторно использовать профиль в несколько приложений с помощью **наследует** атрибута, как показано ниже:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample8.xml)]

В данном случае класс **PurchasingProfile** будет выглядеть следующим образом:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample9.cs)]

## <a name="profile-providers"></a>Поставщики профилей

Профили ASP.NET использовать поставщик модели. Поставщик по умолчанию эти сведения хранятся в базе данных SQL Server Express в приложении\_папка данных веб-приложения с помощью поставщика SqlProfileProvider. Если база данных не существует, ASP.NET автоматически создаст ее при попытке сохранить сведения профиля.

Тем не менее в некоторых случаях может потребоваться создать собственного поставщика профиля. Функция профиля ASP.NET позволяет легко использовать различные поставщики.

Создание пользовательского поставщика профилей при:

- Необходимо хранить сведения о профиле в источнике данных, такие как в базе данных FoxPro или базы данных Oracle, который не поддерживается поставщиков профилей, включенный в состав .NET Framework.
- Необходимо управлять информацией профиля с помощью схемы базы данных, которая отличается от схемы базы данных, используемые поставщиками, включенный в состав .NET Framework. Распространенным примером является то, что вы хотите интегрировать данные профиля с данными пользователя в существующей базы данных SQL Server.

### <a name="required-classes"></a>Необходимые классы

Для реализации поставщика профилей, необходимо создать класс, наследующий абстрактный класс System.Web.Profile.ProfileProvider. **Поставщик профиля** абстрактный класс, в свою очередь, наследует System.Configuration.SettingsProvider абстрактный класс, который наследует абстрактный класс System.Configuration.Provider.ProviderBase. Из-за этой цепочки наследования, помимо необходимых членов **поставщик профиля** класса, необходимо реализовать необходимых членов **SettingsProvider** и  **ProviderBase** классы.

В следующих таблицах описаны свойства и методы, которые необходимо реализовать из **ProviderBase**, **SettingsProvider**, и **поставщик профиля** абстрактный классы.

### <a name="providerbase-members"></a>ProviderBase члены

| **Член** | **Описание** |
| --- | --- |
| Initialize - метод | Принимает в качестве входных данных, имя экземпляра поставщика и NameValueCollection параметров конфигурации. Используется для задания параметров и значений свойств для экземпляра поставщика, включая зависящие от реализации значения и параметры, указанные в конфигурации компьютера или в файле Web.config. |

### <a name="settingsprovider-members"></a>SettingsProvider члены

| **Член** | **Описание** |
| --- | --- |
| Свойство ApplicationName | Имя приложения, который хранится вместе с каждым профилем. Поставщик профилей использует имя приложения для хранения сведений профиля отдельно для каждого приложения. Это позволяет нескольким приложениям ASP.NET использовать один и тот же источник данных без конфликтов, если пользователь с одинаковым именем создается в разных приложениях. Кроме того несколько приложений ASP.NET могут совместно использовать источник данных профиля, указав то же имя приложения. |
| Метод GetPropertyValues | Принимает в качестве входных данных SettingsContext и объект SettingsPropertyCollection. **SettingsContext** предоставляет сведения о пользователе. Данные можно использовать в качестве первичного ключа для извлечения сведений профиля пользователя. Используйте **SettingsContext** объекта, чтобы получить имя пользователя и имеет ли пользователь проверку подлинности или анонимные. **SettingsPropertyCollection** содержит коллекцию объектов SettingsProperty. Каждый **SettingsProperty** предоставляет имя и тип свойства, а также дополнительные сведения, например значение по умолчанию для свойства и то, является ли свойство только для чтения. **GetPropertyValues** метод заполняет SettingsPropertyValueCollection SettingsPropertyValue объекты в зависимости от **SettingsProperty** объекты, предоставляемые в качестве входных данных. Значения из источника данных для указанного пользователя присваиваются свойствам PropertyValue для каждого **SettingsPropertyValue** возвращается объект и всей коллекции. Вызов метода также обновляет LastActivityDate значение для указанного профиля пользователя текущую дату и время. |
| Метод SetPropertyValues | Принимает в качестве входных данных **SettingsContext** и **SettingsPropertyValueCollection** объекта. **SettingsContext** предоставляет сведения о пользователе. Данные можно использовать в качестве первичного ключа для извлечения сведений профиля пользователя. Используйте **SettingsContext** объекта, чтобы получить имя пользователя и имеет ли пользователь проверку подлинности или анонимные. **SettingsPropertyValueCollection** содержит коллекцию **SettingsPropertyValue** объектов. Каждый **SettingsPropertyValue** предоставляет имя, тип и значение свойства, а также дополнительные сведения, например значение по умолчанию для свойства и то, является ли свойство только для чтения. **SetPropertyValues** метод обновляет значения свойств в источнике данных для указанного пользователя. Вызов метода также обновляет **LastActivityDate** и LastUpdatedDate значения для указанного профиля пользователя на текущую дату и время. |

### <a name="profileprovider-members"></a>Члены поставщик профиля

| **Член** | **Описание** |
| --- | --- |
| Метод DeleteProfiles | Принимает в качестве входных данных пользователя массив строк имен и удаляет из источника данных все профиля сведения и значения свойств для указанных имен, где имя приложения соответствует **ApplicationName** значение свойства. Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакции, и откат транзакции и создания исключения при сбое любой операции delete. |
| Метод DeleteProfiles | Принимает в качестве входных данных, коллекцию ProfileInfo объектов и удаляет из источника данных все профиля сведения и значения свойств для каждого профиля, где имя приложения соответствует **ApplicationName** значение свойства. Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакцию и откатить транзакцию и создания исключения при сбое любой операции delete. |
| Метод DeleteInactiveProfiles | Принимает в качестве входных данных значение ProfileAuthenticationOption и объект DateTime и удаления данных из данных источника все данные профиля и значения свойств, в которых дата последнего действия меньше или равно указанной даты и времени и в которых имя приложения соответствует **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывает ли только анонимные профили, только профилям с проверкой подлинности, или все профили должны быть удалены. Если источник данных поддерживает транзакции, рекомендуется включить все операции удаления в транзакцию и откатить транзакцию и создания исключения при сбое любой операции delete. |
| Метод GetAllProfiles | Принимает в качестве входных данных **ProfileAuthenticationOption** значение, целое число, указывающее индекс страницы, целое число, указывающее размер страницы и ссылку на целое число, указывающее общее количество профилей. Возвращает ProfileInfoCollection, который содержит **ProfileInfo** объектов для всех профилей в источнике данных, где имя приложения соответствует **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывает ли только анонимные профили, только профилям с проверкой подлинности, или все профили должны быть возвращены. Результаты, возвращенные **GetAllProfiles** метод ограничены индекс страницы и значения размера страницы. Значение размера страницы указывает максимальное количество **ProfileInfo** объекты должны быть возвращены в **ProfileInfoCollection**. Значение индекса страницы указывает, какую страницу результатов, где 1 указывает первую страницу. Параметр общего количества записей является выходным параметром (можно использовать **ByRef** в Visual Basic), имеет значение общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы — 2, а размер страницы равен 5 **ProfileInfoCollection** возвращается содержит с шестого до десятого профилей. Общее число записей значение равно 13, при возврате метода. |
| Метод GetAllInactiveProfiles | Принимает в качестве входных данных **ProfileAuthenticationOption** значение, **DateTime** объект, целое число, указывающее индекс страницы, целое число, указывающее размер страницы и ссылку на целое число, которое будет задано Общее количество профилей. Возвращает **ProfileInfoCollection** , содержащий **ProfileInfo** объектов для всех профилей в источнике данных, в которых дата последнего действия меньше или равно указанному **даты и времени**  и где имя приложения соответствует **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывает ли только анонимные профили, только профилям с проверкой подлинности, или все профили должны быть возвращены. Результаты, возвращенные **GetAllInactiveProfiles** метод ограничены индекс страницы и значения размера страницы. Значение размера страницы указывает максимальное количество **ProfileInfo** объекты должны быть возвращены в **ProfileInfoCollection**. Значение индекса страницы указывает, какую страницу результатов, где 1 указывает первую страницу. Параметр общего количества записей является выходным параметром (можно использовать **ByRef** в Visual Basic), имеет значение общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы — 2, а размер страницы равен 5 **ProfileInfoCollection** возвращается содержит с шестого до десятого профилей. Общее число записей значение равно 13, при возврате метода. |
| Метод FindProfilesByUserName | Принимает в качестве входных данных **ProfileAuthenticationOption** значение, строка, содержащая имя пользователя, целое число, указывающее индекс страницы, целое число, указывающее размер страницы и ссылку на целое число, будет указано значение общего количества профили. Возвращает **ProfileInfoCollection** , содержащий **ProfileInfo** объектов для всех профилей в данных источника, где имя пользователя совпадает с указанным именем пользователя и в которых соответствует имени приложения **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывает ли только анонимные профили, только профилям с проверкой подлинности, или все профили должны быть возвращены. Если источник данных поддерживает дополнительные возможности поиска, такие как символы-шаблоны, можно предоставить расширенные возможности поиска для имен пользователей. Результаты, возвращенные **FindProfilesByUserName** метод ограничены индекс страницы и значения размера страницы. Значение размера страницы указывает максимальное количество **ProfileInfo** объекты должны быть возвращены в **ProfileInfoCollection**. Значение индекса страницы указывает, какую страницу результатов, где 1 указывает первую страницу. Параметр общего количества записей является выходным параметром (можно использовать **ByRef** в Visual Basic), имеет значение общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы — 2, а размер страницы равен 5 **ProfileInfoCollection** возвращается содержит с шестого до десятого профилей. Общее число записей значение равно 13, при возврате метода. |
| Метод FindInactiveProfilesByUserName | Принимает в качестве входных данных **ProfileAuthenticationOption** значение, строка, содержащая имя пользователя, **DateTime** объект, целое число, указывающее индекс страницы, целое число, указывающее размер страницы и ссылка на целое число, указывающее общее количество профилей. Возвращает **ProfileInfoCollection** , содержащий **ProfileInfo** объектов для всех профилей в источнике данных, где имя пользователя совпадает с указанным именем пользователя, где Дата последнего действия меньше или равно указанной **DateTime**, и где имя приложения соответствует **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывает ли только анонимные профили, только профилям с проверкой подлинности, или все профили должны быть возвращены. Если источник данных поддерживает дополнительные возможности поиска, такие как символы-шаблоны, можно предоставить расширенные возможности поиска для имен пользователей. Результаты, возвращенные **FindInactiveProfilesByUserName** метод ограничены индекс страницы и значения размера страницы. Значение размера страницы указывает максимальное количество **ProfileInfo** объекты должны быть возвращены в **ProfileInfoCollection**. Значение индекса страницы указывает, какую страницу результатов, где 1 указывает первую страницу. Параметр общего количества записей является выходным параметром (можно использовать **ByRef** в Visual Basic), имеет значение общее число профилей. Например, если хранилище данных содержит 13 профилей для приложения, а значение индекса страницы — 2, а размер страницы равен 5 **ProfileInfoCollection** возвращается содержит с шестого до десятого профилей. Общее число записей значение равно 13, при возврате метода. |
| Метод GetNumberOfInActiveProfiles | Принимает в качестве входных данных **ProfileAuthenticationOption** значение и **DateTime** объекта и возвращает количество всех профилей в источнике данных, в которых дата последнего действия меньше или равно указанной  **DateTime** и где имя приложения соответствует **ApplicationName** значение свойства. **ProfileAuthenticationOption** параметр указывает ли только анонимные профили, только профилям с проверкой подлинности, или для подсчета всех профилей. |

### <a name="applicationname"></a>ApplicationName

Поскольку поставщики профилей хранят сведения о профиле отдельно для каждого приложения, необходимо убедиться, что схема данных содержит имя приложения, а также что запросов и обновлений также содержать имя приложения. Например, следующая команда используется для получения значения свойства из базы данных на основе имени пользователя и ли профиль является анонимным и гарантирует, что **ApplicationName** значение включается в запрос.

[!code-sql[Main](profiles-themes-and-web-parts/samples/sample10.sql)]

## <a name="aspnet-themes"></a>Темы ASP.NET

## <a name="what-are-aspnet-20-themes"></a>Что такое темы ASP.NET 2.0

Одним из самых важных аспектов веб-приложения является согласованного внешнего вида и поведения по сайту. Обычно разработчики ASP.NET 1.x использовать каскадных таблиц стилей (CSS) для реализации согласованного внешнего вида и поведения. ASP.NET 2.0 темы значительно совершенствующих CSS так, как разработчик ASP.NET предоставляют возможность определить внешний вид серверных элементов управления ASP.NET, а также HTML-элементов. Темы ASP.NET могут применяться для отдельных элементов управления, на конкретную страницу или весь веб-приложения. Темы использовать сочетание файлов CSS, файл обложки необязательно и дополнительный каталог образов, если требуются образы. Файл обложки определяет внешний вид элементов управления сервера ASP.NET.

## <a name="where-are-themes-stored"></a>Где хранятся темы?

Место хранения темы отличается в зависимости от их области. Темы, которые могут применяться к любому приложению, хранятся в следующей папке:

`C:\WINDOWS\Microsoft.NET\Framework\v2.x.xxxxx\ASP.NETClientFiles\Themes\<Theme_Name>`

Темы, относящиеся к конкретному приложению хранится в `App\_Themes\<Theme\_Name>` каталог в корневом каталоге веб-сайта.

> [!NOTE]
> Файл обложки следует изменять только свойства серверного элемента управления, которые влияют на внешний вид.

Глобальная тема является темой, могут применяться к любое приложение или веб-сайт, на веб-сервере. Эти темы хранятся в каталоге ASP.NETClientfiles\Themes внутри v2.x.xxxxx каталог по умолчанию. Кроме того, можно переместить файлы тем в aspnet\_клиента/system\_web / /Themes/ [версия] [темы\_имя] Папка в корне веб-сайт.

Темы, относящиеся к приложению может применяться только к приложению, в которой находятся файлы. Эти файлы хранятся в `App\_Themes/<theme\_name>` каталог в корневом каталоге веб-сайта.

## <a name="the-components-of-a-theme"></a>Компоненты темы

Тема состоит из одного или нескольких файлов CSS, файл обложки необязательно и необязательная папка изображений. CSS-файл может быть любое имя, правильно (т. е. default.css или theme.css т. д.) и должны находиться в корневой папке темы. CSS-файлы используются для определения обычных классов CSS и атрибуты для определенного селекторов. Для применения одного из классов CSS к элементам страницы **CSSClass** используется свойство.

Файл обложки является XML-файл, содержащий определения свойств серверных элементов управления ASP.NET. Код, приведенный ниже приведен пример файла обложки.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample11.aspx)]

**Рис. 1** ниже показан одной небольшой страницы ASP.NET, просмотре без применена тема. **Рис. 2** показан тот же файл с применена тема. Цвет фона и цвет текста настраиваются с помощью CSS-файл. Внешний вид кнопки и текстового поля настраиваются с помощью файла обложки, перечисленных выше.


![Без темы](profiles-themes-and-web-parts/_static/image1.gif)

**Рис. 1**: Без темы


![Применена тема](profiles-themes-and-web-parts/_static/image2.gif)

**Рис. 2**: Применена тема


Файл обложки, перечисленных выше определяет обложку по умолчанию для всех элементов управления TextBox, а также кнопки. Это означает, что каждый элемент управления TextBox и вставленные на страницу управления "Кнопка" будет иметь на этот внешний вид. Можно также определить обложки, которые могут применяться к конкретным экземплярам этих элементов управления, с помощью **SkinID** свойство элемента управления.

Приведенный ниже код определяет обложку для элемента управления Button. Только кнопочные элементы управления с **SkinID** свойство **goButton** займет на внешний вид обложки.

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample12.aspx)]

Может иметь только один обложки по умолчанию для каждого типа элемента управления сервера. Если требуется дополнительный обложки, следует использовать свойство SkinID.

## <a name="applying-themes-to-pages"></a>Применение тем на страницы

Темы можно применять, используя один из следующих методов:

- В &lt;страниц&gt; в файле web.config
- В @Page директиву страницы
- Программным способом

## <a name="applying-a-theme-in-the-configuration-file"></a>Применение темы в файле конфигурации

Чтобы применить тему в файле конфигурации приложения, используйте следующий синтаксис:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample13.xml)]

Имя темы, указанный здесь должно соответствовать имени папки темы. Эта папка может находиться либо в одном из расположений, упомянутых ранее в этом курсе. При попытке применения темы, который не существует, возникнет ошибка конфигурации.

## <a name="applying-a-theme-in-the-page-directive"></a>Применение темы в директиве Page

Можно также применить тему в директиве @ Page. Этот метод позволяет использовать тему для конкретной страницы.

Чтобы применить тему в @Page директива, используйте следующий синтаксис:

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample14.aspx)]

Опять же темы, указанный здесь должно соответствовать папке темы, как было сказано ранее. При попытке применения темы, который не существует, возникает сбой сборки. Visual Studio также будут выделите атрибут и уведомит о том, что тема не существует.

## <a name="applying-a-theme-programmatically"></a>Применение темы программными средствами

Чтобы применить тему программно, необходимо указать **темы** свойство для страницы в **страницы\_PreInit** метод.

Чтобы применить тему программным способом, используйте следующий синтаксис:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample15.cs)]

Это необходимо для применения темы в методе PreInit из-за жизненного цикла страницы. Если применить его после этой точки, темы страницы будет уже были применены средой выполнения и изменения в этот момент еще не поздно в жизненном цикле. Если применить тему, которая не существует, **HttpException** происходит. Когда тема применяется программными средствами, предупреждение сборки произойдет в том случае, если все серверные элементы управления имеют свойство SkinID указан. Это предупреждение предназначено о том, что тема не применяется декларативно, и его можно пропустить.

## <a name="exercise-1--applying-a-theme"></a>Упражнение 1. Применение темы

В этом упражнении вы научитесь применять темы ASP.NET на веб-сайт.

> [!IMPORTANT]
> Если вы используете Microsoft Word для ввода информации в файл обложки, убедитесь, что вы можете не заменить регулярное кавычки парными. Смарт-кавычки приведет к проблемам с файлы обложки.

1. Создайте новый веб-узел ASP.NET.
2. Правой кнопкой мыши проект в обозревателе решений и выберите Add New Item.
3. Выберите файл веб-конфигурации в списке файлов и щелкните "Добавить".
4. Правой кнопкой мыши проект в обозревателе решений и выберите Add New Item.
5. Выберите файл обложки и щелкните "Добавить".
6. Нажмите "Да" при запросе, если вы хотите поместить файл внутри приложения\_папку тем.
7. Правой кнопкой мыши папку SkinFile внутри приложения\_темы папку в обозревателе решений и выберите Add New Item.
8. Выберите таблицу стилей в списке файлов и щелкните "Добавить". Теперь у вас есть все файлы, необходимые для реализации новой темы. Тем не менее Visual Studio с именем вашей папки темы SkinFile. Щелкните правой кнопкой мыши на эту папку и измените имя на CoolTheme.
9. Откройте файл SkinFile.skin и добавьте следующий код в конец файла: 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample16.aspx)]
10. Сохраните файл SkinFile.skin.
11. Откройте StyleSheet.css.
12. Замените весь текст в нем следующее: 

    [!code-css[Main](profiles-themes-and-web-parts/samples/sample17.css)]
13. Сохраните файл StyleSheet.css.
14. Откройте страницу Default.aspx.
15. Добавьте элемент управления TextBox и управления "Кнопка".
16. Сохраните страницу. Теперь перейдите к странице Default.aspx. Он должен отображаться как обычный веб-формы.
17. Откройте файл web.config.
18. Добавьте следующий код непосредственно под открывающей `<system.web>` тега: 

    [!code-xml[Main](profiles-themes-and-web-parts/samples/sample18.xml)]
19. Сохраните файл web.config. Теперь перейдите к странице Default.aspx. Он должен отображаться с примененной темой.
20. Если он не открыт, откройте страницу Default.aspx в Visual Studio.
21. Нажмите кнопку.
22. Изменение **SkinID** свойства goButton. Обратите внимание на то, что Visual Studio предоставляет раскрывающийся список с допустимыми значениями SkinID для управления "Кнопка".
23. Сохраните страницу. Теперь еще раз просмотрите страницу в браузере. Кнопки теперь должно появиться сообщение «перейти» и должен быть шире во внешнем виде.

С помощью **SkinID** свойство, можно легко настроить разные обложки для разных экземпляров определенного типа серверного элемента управления.

## <a name="the-stylesheettheme-property"></a>Свойство StyleSheetTheme

На данный момент мы говорили только об применению тем, с помощью свойства темы. При использовании свойства темы, файл обложки будут переопределять любые декларативной настройки для серверных элементов управления. Например в упражнении 1, вы указали SkinID «goButton» элемента управления Button и, у которого изменились текста кнопки «Перейти». Вы могли заметить было присвоено свойство текста кнопки в конструкторе, а «Кнопка», что темы переопределили. Темы всегда переопределяет все параметры свойств в конструкторе.

Если вы хотите иметь возможность переопределять свойства, определенные в файле обложки темы с помощью свойства заданы в конструкторе, можно использовать **StyleSheetTheme** свойство вместо свойства темы. Свойство StyleSheetTheme совпадает со значением свойства темы за исключением того, что он не переопределяет все параметры явной свойство как свойство темы.

Чтобы увидеть это в действии, откройте файл web.config из проекта в упражнении 1 и измените `<pages>` элемент следующего:

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample19.xml)]

Теперь перейдите к странице Default.aspx, и вы увидите снова имеет «Кнопка» для свойства Text элемента управления Button. Том, что переопределяет свойство Text задается goButton SkinID явные свойства в конструкторе.

## <a name="overriding-themes"></a>Переопределение темы

Глобальные темы можно переопределить с помощью схемы с тем же именем, в приложении\_папку тем приложения. Тем не менее в сценарии значение true, переопределение не применяется тема. Если среда выполнения обнаруживает файлы тем в приложении\_папку тем, он будет применяться темы, с помощью этих файлов и будут игнорировать глобальной темы.

Свойство StyleSheetTheme является переопределяемым и могут переопределяться в коде следующим образом:

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample20.cs)]

## <a name="web-parts"></a>Веб-части

Веб-частей ASP.NET — это интегрированный набор элементов управления для создания веб-сайтов, которые позволяют конечным пользователям изменять содержимое, внешний вид и поведение веб-страниц непосредственно из браузера. Изменения могут применяться ко всем пользователям на сайте или отдельным пользователям. Когда пользователь изменяет страницы и элементы управления, можно сохранить параметры для сохранения личных предпочтений пользователя будущих сеансах, функция персонализации. Эти возможности веб-частей означает, что разработчики могут предоставить конечным пользователям настраивать веб-приложения динамически, без вмешательства разработчику или администратору.

В наборе элементов управления веб-частей как разработчик вы можете включить конечные пользователи могут:

- Настройте содержимое страницы. Пользователей можно добавлять новые элементы управления веб-частей на страницу, удалите их, скрыть их или свести к минимуму их как обычные окна.
- Настройка макета страницы. Пользователей можно перетащить элемент управления веб-частей в другую зону на странице или изменить его внешний вид, свойства и поведение.
- Экспорт и импорт элементов управления. Пользователи могут импортировать или экспортировать параметры элемента управления по веб-частей для использования на других страницах или узлы, сохраняя свойства, внешний вид и даже данные в элементах управления. Это сокращает затраты данных записи и настройки конечным пользователям.
- Создание подключений. Пользователи могут устанавливать подключения между элементами управления, поэтому, например, элемент управления диаграммы может отобразить диаграмму для данных в элементе управления биржевые сводки. Пользователи могут персонализировать не только само подключение, но внешний вид и сведения о том, как элемент управления диаграммы отображает данные.
- Управление и настраивать параметры на уровне сайта. Авторизованные пользователи можно настроить параметры уровня веб-сайта, определения, доступ к сайту или страницы, установить на основе ролей доступ к элементам управления и т. д. Например пользователь в роли администратора может задать элемент управления веб-частей для общей для всех пользователей и пользователи, не являющиеся администраторами, персонализировать общий элемент управления.

Вы обычно работают с веб-частей в одном из трех способов: Создание страниц, использующих веб-части, создание веб-частей или завершенных веб-приложений, таких как портал.

## <a name="page-development"></a>Страница разработки

Разработчики страниц можно использовать средства визуального проектирования, например Microsoft Visual Studio 2005 для создания страниц, использующих веб-частей. Одним из преимуществ с помощью средства, такие как Visual Studio является то, что набор элементов управления веб-частей предоставляет функции и перетаскивать Создание и настройка элементов управления веб-частей в визуальном конструкторе. Например, можно использовать конструктор для зоны веб-частей, или элемент управления редактора веб-частей, перетащите в область конструктора и настройте элемента вправо в конструкторе с помощью пользовательского интерфейса, предоставляемые веб-частей набора элементов управления. Это может ускорить разработку приложений веб-частей и уменьшить объем кода, который необходимо написать.

## <a name="control-development"></a>Разработке элементов управления

Можно использовать любой существующий элемент управления ASP.NET как элемент управления веб-частей, включая стандартные веб-сервера управления, пользовательских серверных элементов управления и пользовательские элементы управления. Для максимального программного управления среды можно также создать пользовательские элементы управления веб-частей, которые являются производными от класса веб-частей. Для отдельных решений веб-частей элемента управления будут обычно создать пользовательский элемент управления и использовать его в качестве веб-части либо разработать пользовательский элемент управления веб-частей.

Например разработки пользовательского элемента управления веб-частей, можно создать элемент управления для предоставления любой из функций, предоставляемых других серверных элементов управления ASP.NET, которые могут пригодиться в пакете управления: календари, списки, финансовой информации Новости, калькуляторы, элементы управления форматированным текстом для обновления сетки содержимого, которые можно редактировать, подключения к базам данных, диаграммы, которые динамически обновлять своими дисплеями или прогноза погоды и информация о поездке. Если вы укажете визуального конструктора с элементом управления, затем любой разработчик, с помощью Visual Studio можно просто перетащить элемент управления в зоне веб-частей и настроить его во время разработки без необходимости написания дополнительного кода.

Персонализация лежит в основе функции веб-частей. Он позволяет пользователям изменять--или персонализации макет, внешний вид и поведение элементов управления веб-частей на странице. Персонализированные параметры: они сохраняются не только в текущем сеансе браузера (например, с состоянием представления), но также в долговременном хранилище, чтобы параметры пользователя сохраняются для следующих сеансов браузера также. Персонализация включена по умолчанию для страниц веб-частей.

Структурных компонентов пользовательского интерфейса используют персонализации и предоставляют базовую структуру и службы, необходимые для всех элементов управления веб-частей. Один компонент структурные пользовательский Интерфейс, необходимый на каждой странице веб-частей является элемент управления WebPartManager. Никогда не отображается этот элемент управления имеет выполнения критической задачи координации всех элементов управления веб-частей на странице. Например он отслеживает все веб-частей. Он управляет веб-части зоны (области, которые содержат элементы управления веб-частей на странице), а какие находятся элементы управления, в какие зоны. Он также отслеживает и управляет различных режимов отображения страницы в которых может находиться, таких как обзор, подключение, изменить или каталога и применения параметров персонализации для всех пользователей или для отдельных пользователей. Наконец он инициирует и отслеживание связей между элементами управления веб-частей.

Второй тип структурных компонентов пользовательского интерфейса — зоны. Зоны в качестве диспетчерами макетов, на веб-странице. Они содержат и упорядочения элементов управления, которые являются производными от класса Part (часть элементов управления) и обеспечивают возможность модульной разметки страницы в горизонтальной или вертикальной ориентации. Зоны также предоставляют единый элементы пользовательского интерфейса (например, стиль верхнего и нижнего колонтитулов, title, стиль границы, кнопки действий и т. д.) для каждого элемента управления, содержащихся в них; Эти общие элементы называются chrome элемента управления. Специализированные типы зон используются в различных режимах и элементов управления. Различные типы зон описаны в следующем разделе Essential управления веб-частей.

Элементы управления веб-частей интерфейса, которые являются производными от **часть** класса, составляющих основной пользовательский Интерфейс на странице веб-частей. В наборе элементов управления веб-частей является гибким и включительно, в параметрах ней можно использовать для создания элементов управления. В дополнение к созданию собственных элементов управления веб-частей, можно также использовать существующие серверные элементы управления ASP.NET, пользовательских элементов управления или пользовательских серверных элементов управления как элементы управления веб-частей. В следующем разделе описаны основные элементы управления, которые чаще всего используются для создания страниц веб-частей.

## <a name="web-parts-essential-controls"></a>Веб-частей, основные элементы управления

В наборе элементов управления веб-частей слишком большой, но некоторые элементы управления необходимы, так как они необходимы для веб-частей для работы, или они являются элементами управления, чаще всего используется на страницах веб-частей. Как приступить к использованию веб-частей и создания основных страницах веб-частей, полезно уметь работать с основные элементы управления веб-частей, описанных в следующей таблице.

| **Веб-частей элемента управления** | **Описание** |
| --- | --- |
| WebPartManager | Управляет всеми элементами управления веб-частей на странице. Один (и только один) **WebPartManager** необходим элемент управления для каждой страницы веб-частей. |
| CatalogZone | Содержит элементы управления CatalogPart. Используйте эту зону для создания каталога элементов управления веб-частей, из которых пользователи могут выбрать элементы управления для добавления на страницу. |
| EditorZone | Содержит элементы управления EditorPart. Используйте эту зону, чтобы пользователи могли изменять и настраивать элементы управления веб-частей на странице. |
| WebPartZone | Содержит и предоставляет общий макет для элементов управления веб-частей, из которых состоит основного пользовательского интерфейса страницы. Используйте эту зону, каждый раз при создании страницы с элементами управления веб-частей. Страницы могут содержать одну или несколько зон. |
| ConnectionsZone | Содержит элементы управления WebPartConnection и предоставляет пользовательский Интерфейс для управления подключениями. |
| Веб-части (GenericWebPart) | Основной пользовательский интерфейс; Большинство элементов управления веб-частей интерфейса попадают в эту категорию. Для максимального программного управления, можно создать пользовательские элементы управления веб-частей, которые являются производными от базового **WebPart** элемента управления. Можно также использовать существующие серверные элементы управления, пользовательские элементы управления или пользовательских элементов управления, как элементы управления веб-частей. Каждый раз, когда любой из этих элементов управления, помещаются в зоне, **WebPartManager** управления автоматически переносит их с помощью **GenericWebPart** элементы управления во время выполнения, таким образом, чтобы их можно использовать с функциональными возможностями веб-частей. |
| CatalogPart | Содержит список доступных элементов управления веб-частей, которые пользователи могут добавлять на страницу. |
| WebPartConnection | Создает подключение между двумя элементами управления веб-частей на странице. Соединение определяет один из элементов управления веб-частей в качестве поставщика (данных), а другой — в качестве получателя. |
| EditorPart | Служит базовым классом для элементов управления специализированный редактор. |
| Элементы управления EditorPart (AppearanceEditorPart, LayoutEditorPart, BehaviorEditorPart и PropertyGridEditorPart) | Разрешить пользователям настраивать различные аспекты управления веб-частей интерфейса на странице |

## <a name="lab-create-a-web-part-page"></a>Лабораторное занятие. Создайте страницу веб-частей

В этой лабораторной работе вы создадите страницу веб-частей, в котором хранятся сведения, с помощью профилей ASP.NET.

### <a name="creating-a-simple-page-with-web-parts"></a>Создание простой страницы с веб-частями

В этой части пошагового руководства создается страница, использующая элементы управления веб-частей для отображения статического содержимого. Первый шаг при работе с веб-частей является создание страницы с двумя обязательными элементами структуры. Во-первых страницы должен элемент управления WebPartManager для отслеживания и координации всех элементов управления веб-частей. Во-вторых веб-странице должен один или несколько зон, которые являются составными элементами управления, которые содержат веб-частей или других серверных элементов управления и занимающие определенную область страницы.

> [!NOTE]
> Не нужно ничего делать для включения персонализации веб-части; он включается по умолчанию для в наборе элементов управления веб-частей. При первом запуске веб-странице на сайте, ASP.NET устанавливает поставщик персонализации по умолчанию для хранения параметров персонализации пользователя. Дополнительные сведения о персонализации см. в разделе Общие сведения о персонализации веб частей.


### <a name="to-create-a-page-for-containing-web-parts-controls"></a>Чтобы создать страницу, содержащую элементы управления веб-частей

1. Закройте страницу по умолчанию и добавьте новую страницу сайта, с именем WebPartsDemo.aspx.
2. Переключиться в режим **разработки** представления.
3. Из **представление** меню, убедитесь, что **Невизуальные элементы управления** и **сведения** параметры выбраны, чтобы можно было видеть теги макета и элементов управления, у которых нет пользовательского интерфейса.
4. Поместите курсор перед `<div>` тегов в области конструктора и нажмите клавишу ВВОД, чтобы добавить новую строку. Поместите курсор перед символ новой строки, нажмите кнопку **формат блока** стрелку раскрывающегося списка элемента управления меню и выберите **заголовок 1** параметр. В заголовке, добавьте текст **страницы демонстрации**.
5. Из **WebParts** вкладки панели элементов перетащите **WebPartManager** на страницу, расположив его сразу после знака новой строки и перед `<div>`теги.   
  
   **WebPartManager** управления не создает никаких выходных данных, поэтому он отображается как серый квадрат в области конструктора.
6. Поместите курсор в пределах `<div>` теги.
7. В **макета** меню, щелкните **вставить таблицу**и создайте новую таблицу, которая содержит одну строку и три столбца. Нажмите кнопку **Cell Properties** кнопку, выберите **верхней** из **вертикальное выравнивание по** стрелку раскрывающегося списка, щелкните **ОК**и нажмите кнопку **ОК** еще раз, чтобы создать таблицу.
8. Перетащите элемент управления WebPartZone в левый столбец таблицы. Щелкните правой кнопкой мыши **WebPartZone** выберите **свойства**и задайте следующие свойства:   
  
   Идентификатор: SidebarZone   
  
   HeaderText: Боковой панели
9. Перетащите второй **WebPartZone** control в средний столбец таблицы и задайте следующие свойства:   
  
   Идентификатор: MainZone   
  
   HeaderText: Главная ветвь
10. Сохраните файл.

Теперь страница имеет две зоны, которыми можно управлять отдельно. Тем не менее у зон имеет любое содержимое, поэтому создание содержимого — следующий шаг. В этом пошаговом руководстве вы работать с элементами управления веб-частей, которые отображают только статическое содержимое.

Макет веб-частей зоны задается &lt;zonetemplate&gt; элемент. В шаблоне зоны можно добавить любой элемент управления ASP.NET, будь то пользовательский элемент управления веб-частей, пользовательский элемент управления или существующего элемента управления сервера. Обратите внимание, что здесь используется элемент управления Label, просто добавляется статический текст. При размещении обычного серверного элемента управления в **WebPartZone** зоны, ASP.NET рассматривает его как элемент управления веб-частей во время выполнения, что дает возможность функции веб-частей на элементе управления.

**Для создания содержимого для основной зоны**

1. В **разработки** Просмотр, перетащите **метка** управления из **стандартный** вкладки панели элементов в область содержимого зоны, **идентификатор** свойство имеет значение MainZone.
2. Переключиться в режим **источника** представления. Обратите внимание, что &lt;zonetemplate&gt; был добавлен элемент программы-оболочки для **метка** элемента управления в MainZone.
3. Добавьте атрибут с именем **title** для &lt;asp: label&gt; элемент и присвойте ему значение к содержимому. Удалите текст = атрибутом «Label» от &lt;asp: label&gt; элемент. Между открывающим и закрывающим тегами &lt;asp: label&gt; элемента, добавьте текст, таких как **приветствует Моя домашняя страница** заключенный в &lt;h2&gt; теги элементов. Код должен выглядеть следующим образом. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample21.aspx)]
4. Сохраните файл.

Создайте пользовательский элемент управления, можно также добавить на страницу, как элемент управления веб-частей.

### <a name="to-create-a-user-control"></a>Создание пользовательского элемента управления

1. Добавьте новый пользовательский элемент управления Web на сайт для использования в качестве элемента управления поиска. Снимите флажок, чтобы **поместить исходный код в отдельном файле**. Добавьте его в том же каталоге, что и страница WebPartsDemo.aspx и назовите его SearchUserControl.ascx.   
  
    > [!NOTE]
    > Пользовательский элемент управления в этом пошаговом руководстве не реализует функциональность поиска; он используется только для демонстрации возможностей веб-частей.
2. Переключиться в режим **разработки** представления. Из **стандартный** вкладки панели элементов перетащите элемент управления TextBox на страницу.
3. Поместите курсор после только что добавленного текстовое поле и нажмите клавишу ВВОД, чтобы добавить новую строку.
4. Перетащите элемент управления на страницу на новой строке под текстовым полем, которое вы только что добавили.
5. Переключиться в режим **источника** представления. Убедитесь, что исходный код для пользовательского элемента управления выглядит как в следующем примере. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample22.aspx)]
6. Сохраните и закройте файл.

Теперь можно добавить элементы управления веб-частей в зону боковой панели. При добавлении двух элементов управления в зону боковой панели, одна из которых содержит список ссылок, другой пользовательский элемент управления, созданный в предыдущей процедуре. Ссылки добавляются в качестве стандарта **метка** серверного элемента управления, подобно тому, как вы создали статический текст основной зоны. Тем не менее хотя отдельные серверные элементы управления, содержащиеся в пользовательский элемент управления, которые могут содержаться непосредственно в зоне (например, элемент управления label), в этом случае они не являются. Вместо этого они являются частью пользовательского элемента управления, созданный в предыдущей процедуре. Это демонстрирует распространенный способ упаковки любых элементов управления и дополнительные функциональные возможности, в пользовательский элемент управления и затем ссылаться на этот элемент управления в зоне, что элемент управления веб-частей.

Во время выполнения в наборе элементов управления веб-частей является оболочкой для обоих элементов управления с помощью элементов управления GenericWebPart. Когда **GenericWebPart** управления создает оболочку для элемента управления, этот универсальный элемент управления является родительским элементом и серверного элемента управления доступны через свойство ChildControl родительского элемента управления. Такое использование элементов управления универсальной части позволяет стандартных серверных элементов управления иметь поведение и атрибуты элементов управления веб-частей, которые являются производными от **WebPart** класса.

### <a name="to-add-web-parts-controls-to-the-sidebar-zone"></a>Для добавления элементов управления веб-частей в зону боковой панели

1. Откройте страницу WebPartsDemo.aspx.
2. Переключиться в режим **разработки** представления.
3. Перетащите пользователя элемента управления страницы вы создали, SearchUserControl.ascx, **обозревателе решений** в зону которого **идентификатор** свойство имеет значение SidebarZone и поместите его там.
4. Сохраните страницу WebPartsDemo.aspx.
5. Переключиться в режим **источника** представления.
6. Внутри &lt;asp: webpartzone&gt; элемент для SidebarZone, непосредственно над ссылку на пользовательский элемент управления, добавления &lt;asp: label&gt; содержится элемент с помощью ссылки, как показано в следующем примере. Кроме того, добавьте **Title** атрибут в теге пользовательского элемента управления со значением **поиска**, как показано. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample23.aspx)]
7. Сохраните и закройте файл.

Теперь можно протестировать страницу, перейдя к нему в браузере. На странице отображаются две зоны. На следующем снимке экрана показана страница.

**Веб-частей демонстрационной страницы с двумя зонами**


![Снимок экрана Web частям VS 1 пошагового руководства:](profiles-themes-and-web-parts/_static/image3.gif)

**Рис. 3**: Снимок экрана Web частям VS 1 пошагового руководства:


В заголовке окна каждого элемента управления отображается стрелка вниз, предоставляющий доступ к меню доступных действий, которые можно выполнять в элементе управления. Щелкните меню команд для одного из элементов управления, а затем нажмите кнопку **свернуть** глагол и обратите внимание, что элемент управления свернут. В меню команд, щелкните **восстановить**, и элемент управления возвращается в обычном размере.

### <a name="enabling-users-to-edit-pages-and-change-layout"></a>Предоставление пользователям возможности редактировать страницы и изменение макета

Веб-частей позволяет пользователям изменять макет элементов управления веб-частей, перетаскивая их из одной зоны в другую. В дополнение к возможности перемещения **WebPart** элементы управления из одной зоны в другую, можно разрешить пользователям редактировать различные свойства элементов, в том числе их внешний вид, макет и поведение. В наборе элементов управления веб-частей обеспечивает базовые функции редактирования для **WebPart** элементов управления. Несмотря на то, что вы не будет сделать в этом пошаговом руководстве, можно также создать пользовательский редактор элементов управления, которые позволяют пользователям редактировать возможности **WebPart** элементов управления. Как и в случае с изменение местоположения **WebPart** элемента управления, редактирование свойств элемента управления зависит от персонализации ASP.NET, чтобы сохранить изменения, внесенные пользователем.

В этой части пошагового руководства вы добавите возможность пользователям редактировать основные характеристики любого **WebPart** управления на этой странице. Чтобы включить эти функции, добавляемые другой пользовательский элемент управления на страницу вместе с &lt;asp: editorzone&gt; элемент и двумя элементами управления.

### <a name="to-create-a-user-control-that-enables-changing-page-layout"></a>Чтобы создать пользовательский элемент управления, который позволяет изменять макет страницы

1. В Visual Studio на **файл** меню, выберите **New** подменю и нажмите кнопку **файл** параметр.
2. В **Добавление нового элемента** диалоговом окне выберите **веб-элемента управления пользователя**. Назовите новый файл DisplayModeMenu.ascx. Снимите флажок, чтобы **поместить исходный код в отдельном файле**.
3. Нажмите кнопку Добавить, чтобы создать новый элемент управления.
4. Переключиться в режим **источника** представления.
5. Удалите весь существующий код в новый файл и вставьте в него следующий код. Этот управляющий код пользователя использует возможности в наборе элементов управления веб-частей, которые позволяют изменять представление или режим отображения страницы, также позволяет изменять внешний вид и макет страницы в определенных режимах отображения. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample24.aspx)]
6. Сохраните файл, нажав кнопку сохранения значок на панели инструментов или выбрав **Сохранить** на **файл** меню.

### <a name="to-enable-users-to-change-the-layout"></a>Чтобы пользователи могли изменить макет

1. Откройте страницу WebPartsDemo.aspx и переключиться в режим **разработки** представления.
2. Поместите курсор в **разработки** сразу после просмотра **WebPartManager** элемента управления, который был добавлен ранее. Добавьте физической вставкой после текста, таким образом, что пустая строка после **WebPartManager** элемента управления. Поместите курсор на пустую строку.
3. Перетащите пользовательский элемент управления, вы только что создали (этот файл имеет имя DisplayModeMenu.ascx) в WebPartsDemo.aspx странице и поместите его на пустую строку.
4. Перетащите элемент управления EditorZone из **WebParts** разделе области элементов в оставшихся ячейку открыть таблицу, на странице WebPartsDemo.aspx.
5. Из **WebParts** разделе панели элементов перетащите appearanceeditorpart-элемент управления и layouteditorpart-элемент управления в **EditorZone** элемента управления.
6. Переключиться в режим **источника** представления. Результирующий код в ячейке таблицы должен выглядеть аналогично следующему коду. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample25.aspx)]
7. Сохраните файл WebPartsDemo.aspx. Вы создали пользовательский элемент управления, позволяющий изменять режим отображения и макета страницы и ссылка на элемент управления на основной веб-странице.

Теперь можно проверить возможность редактировать страницы и изменение макета.

### <a name="to-test-layout-changes"></a>Чтобы проверить изменения макета

1. Загрузите страницу в браузере.
2. Нажмите кнопку **режим отображения** раскрывающееся меню и выберите **изменить**. Отображаются заголовки зон.
3. Перетащите **Мои ссылки** управления за его заголовок из зоны боковой панели в нижней части основной зоны. Этого страница должна выглядеть как на снимке экрана ниже.

### <a name="web-parts-demo-page-with-my-links-control-moved"></a>Веб-Демонстрация частей страницы с элементом управления Мои ссылки перемещены


![Снимок экрана Web частям VS 2 пошагового руководства:](profiles-themes-and-web-parts/_static/image4.gif)

**Рис. 4**: Снимок экрана Web частям VS 2 пошагового руководства:


1. Нажмите кнопку **режим отображения** раскрывающееся меню и выберите **Обзор**. Страница обновится, имена зон исчезнут и **Мои ссылки** управления остается в прежнем месте.
2. Для демонстрации функциональности персонализации, закройте браузер и загрузите страницу. Внесенные изменения сохраняются для следующих сеансов браузера.
3. Из **режим отображения** меню, выберите **изменить**.   
  
   Каждый элемент управления на странице теперь отображается со стрелкой вниз в заголовке окна, который содержит раскрывающееся меню команд.
4. Щелкните стрелку, чтобы отобразить меню команд на **Мои ссылки** элемента управления. Нажмите кнопку **изменить** команды.   
  
   **EditorZone** отображается элемент управления, отображение EditorPart управляет вы добавили.
5. В **внешний вид** раздел элемента управления редактирования, изменение **Title** в Избранное, использовать **рамки** стрелку раскрывающегося списка для выбора **только заголовок**, а затем нажмите кнопку **применить**. На следующем снимке экрана показана страница в режиме редактирования.

### <a name="web-parts-demo-page-in-edit-mode"></a>Веб-частей демонстрационной страницы в режиме правки


![Снимок экрана Web частям VS 3 пошагового руководства:](profiles-themes-and-web-parts/_static/image5.gif)

**Рис. 5**: Снимок экрана Web частям VS 3 пошагового руководства:


1. Нажмите кнопку **режим отображения** меню и выберите **Обзор** для возврата в режим просмотра.
2. Элемент управления теперь имеет обновленный заголовок и без границ, как показано на следующем снимке экрана.

### <a name="edited-web-parts-demo-page"></a>Отредактированную страницу Интернет-демонстрации частей


![Снимок экрана Web частям VS 4 пошагового руководства:](profiles-themes-and-web-parts/_static/image6.gif)

**Рис. 4**: Снимок экрана Web частям VS 4 пошагового руководства:


### <a name="adding-web-parts-at-run-time"></a>Добавление веб-частей во время выполнения

Также можно разрешить пользователям добавлять элементы управления веб-частей на страницу во время выполнения. Для этого нужно настройте страницы с каталогом веб-частей, который содержит список элементов управления веб-частей, которые требуется сделать доступными для пользователей.

**Чтобы разрешить пользователям добавлять веб-частей во время выполнения**

1. Откройте страницу WebPartsDemo.aspx и переключиться в режим **разработки** представления.
2. Из **WebParts** вкладки панели элементов перетащите элемент управления CatalogZone в правом столбце таблицы, ниже **EditorZone** элемента управления.   
  
   Оба элемента управления может быть в той же ячейке таблицы, так как они не отображаются в то же время.
3. В панели «Свойства» присвойте строке **добавить веб-части** свойству HeaderText **CatalogZone** элемента управления.
4. Из **WebParts** разделе панели элементов перетащите DeclarativeCatalogPart-элемент управления в область содержимого **CatalogZone** элемента управления.
5. Щелкните стрелку в правом верхнем углу **DeclarativeCatalogPart** управления для предоставления его меню "задачи", а затем выберите **редактирование шаблонов**.
6. Из **стандартный** панели элементов перетащите **FileUpload** управления и **календаря** управления в **WebPartsTemplate** раздел **DeclarativeCatalogPart** элемента управления.
7. Переключиться в режим **источника** представления. Проверьте исходный код из &lt;asp: catalogzone&gt; элемент. Обратите внимание, что **DeclarativeCatalogPart** элемент управления содержит &lt;webpartstemplate&gt; элемент с двух закрытой серверных элементов управления, которые можно добавить на страницу из каталога.
8. Добавить **Title** свойство для каждого из элементов управления, добавленных в каталог, используя строковое значение, отображаемое для каждого заголовка в следующем примере кода. Несмотря на то, что заголовок не является свойством, которое можно установить на этих двух серверных элементов управления во время разработки, когда пользователь добавляет эти элементы управления на **WebPartZone** зоны из каталога во время выполнения, каждая упаковываются с  **GenericWebPart** элемента управления. Это позволяет им в качестве элементов управления веб-частей, чтобы они могли для заголовков.   
  
   Код для двух элементов управления, содержащихся в **DeclarativeCatalogPart** управления должен выглядеть следующим образом. 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample26.aspx)]
9. Сохраните страницу.

Теперь можно протестировать каталога.

### <a name="to-test-the-web-parts-catalog"></a>Для тестирования веб-части каталога

1. Загрузите страницу в браузере.
2. Нажмите кнопку **режим отображения** раскрывающееся меню и выберите **каталога**.   
  
   Каталог с именем **добавить веб-части** отображается.
3. Перетащите **Мое избранное** управления из основной зоны обратно в верхнюю часть зоны боковой панели и поместите его там.
4. В **добавить веб-части** каталога, выберите оба флажка, а затем выберите **Main** из раскрывающегося списка, который содержит доступных зон.
5. Нажмите кнопку **добавить** в каталоге. Элементы управления добавляются в зону Main. Если требуется, можно добавить несколько экземпляров элемента управления из каталога на страницу.   
  
   На следующем снимке экрана показана страница с элементом управления загрузки файлов и календаря в основной зоны. 

![Элементы управления, добавленные в основную зону из каталога](profiles-themes-and-web-parts/_static/image7.gif)

    **Figure 5**: Controls added to Main zone from the catalog
6. Нажмите кнопку **режим отображения** раскрывающееся меню и выберите **Обзор**. Каталог исчезает, и Страница обновится.
7. Закройте браузер. Загрузите страницу еще раз. Внесенные изменения сохраняются.
