---
uid: web-forms/overview/moving-to-aspnet-20/server-controls
title: Серверные элементы управления | Документация Майкрософт
author: microsoft
description: ASP.NET 2.0 улучшает серверных элементов управления во многих отношениях. В этом модуле рассматриваются некоторые архитектурные изменения способа ASP.NET 2.0 и Visual Studio 200...
ms.author: riande
ms.date: 02/20/2005
ms.assetid: 43f6ac47-76fc-4cf7-8e9f-c18ce673dfd8
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/server-controls
msc.type: authoredcontent
ms.openlocfilehash: c02a633013f061c09141d4f98871848c011a799e
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65116714"
---
# <a name="server-controls"></a>Серверные элементы управления

по [Microsoft](https://github.com/microsoft)

> ASP.NET 2.0 улучшает серверных элементов управления во многих отношениях. В этом модуле рассматриваются некоторые архитектурные изменения как ASP.NET 2.0 и Visual Studio 2005 имеет дело с серверными элементами управления.

ASP.NET 2.0 улучшает серверных элементов управления во многих отношениях. В этом модуле рассматриваются некоторые архитектурные изменения как ASP.NET 2.0 и Visual Studio 2005 имеет дело с серверными элементами управления.

## <a name="view-state"></a>Состояние представления

Основное изменение в состоянии представления в ASP.NET 2.0 это существенное уменьшение размера. Рассмотрим страницу с помощью только календаря на нем. Ниже приведено состояние представления в ASP.NET 1.1.

[!code-css[Main](server-controls/samples/sample1.css)]

Вот состояния представления на странице идентичны в ASP.NET 2.0.

[!code-css[Main](server-controls/samples/sample2.css)]

Это довольно значительное изменение, и рассмотрения, передаваемые состояние представления и обратно по сети, это изменение можно предоставить разработчикам повысить производительность. Уменьшение размера состояния представления является главным образом из-за то, что мы обработать внутренним образом. Помните, что строка в кодировке Base64 находится в состоянии представления. Чтобы лучше понять изменения в состоянии представления в ASP.NET 2.0, давайте взглянем на расшифрованных значений из приведенных выше примерах.

Вот декодировать состояние 1.1 представления:

[!code-css[Main](server-controls/samples/sample3.css)]

Это может выглядеть немного как понятно, но есть здесь шаблон. В ASP.NET 1.x, мы использовать одиночные символы для идентификации типов данных и список значений с помощью &lt; &gt; символов. В примере выше представление состояния «t» представляет три полосы. Триада содержит пару ArrayLists («l» представляет ArrayList). Один из этих ArrayLists содержит Int32 («i») со значением 1, а второй содержит другой Triplet. Триада содержит пару ArrayLists и т. д. Важно помнить, что том, что мы используем Троек, содержащие пары, мы определить типы данных с помощью буквы, и мы используем &lt; и &gt; символов в качестве разделителей.

В ASP.NET 2.0 состояние представления декодированный выглядит немного отличается.

[!code-powershell[Main](server-controls/samples/sample4.ps1)]

Следует заметить, использовавшегося в внешний вид состояния декодированного представления. Это изменение имеет несколько архитектурными. Состояние представления в ASP.NET 1.x использованное LosFormatter для сериализации данных. В версии 2.0 мы используем новый класс ObjectStateFormatter. Этот класс был специально разработан для сериализации и десериализации состояния представления и состояние элемента управления. (Состояние элемента управления будет рассматриваться в следующем разделе.) Существует множество преимуществ, изменив метод, по которому сериализация и десериализация выполняются. Одним из самых значительных является тот факт, что в отличие от LosFormatter, который использует объект TextWriter, ObjectStateFormatter использует BinaryWriter. Это позволяет ASP.NET 2.0 для сохранения состояния представления последовательность байтов, а не строк. Возьмем, например, целое число. В ASP.NET 1.1 целое требуется 4 байта состояния представления. В ASP.NET 2.0 это же число требуется только 1 байт. Другие усовершенствования были внесены уменьшить состояние представления, которые хранятся. Значения даты и времени, например, теперь хранятся с использованием TickCount вместо строки.

Так, как если бы все это мало, был уделить особое внимание тот факт, что одним из наиболее потребителей состояния представления в версии 1.x был DataGrid и схожих элементов управления. Большой недостаток элементов управления, такие как DataGrid, где связано состояние представления — что он часто содержит большое количество повторяющихся сведения. В ASP.NET 1.x, которое просто хранились над и еще раз в результате чего состояния просмотра перегруженными. В ASP.NET 2.0 мы используем новый класс IndexedString для хранения таких данных. Если строка повторяется, мы просто хранить маркер IndexedString и индекс в таблице выполняющихся IndexedString объектов.

## <a name="control-state"></a>Состояние элемента управления

Одной из основных жалобы, которые разработчики были с состоянием представления было размер, он будет добавлен в полезные данные HTTP. Как упоминалось выше, одним из наиболее потребителей состояния представления является элементом управления DataGrid. Чтобы избежать огромные объемы состояния представления, созданные в элемент управления DataGrid, многие разработчики просто состояние представления для этого элемента управления. К сожалению это решение не всегда было вполне приемлемым. Состояние представления в ASP.NET 1.x содержит не только данные, необходимые для правильного функционирования элемента управления. Он также содержит сведения, касающиеся состояние элемента управления пользовательского интерфейса. Это означает, что если вы хотите разрешить для разбиения на страницы на элемент управления DataGrid, следует включить состояние просмотра, даже если не требуется всех данных пользовательского интерфейса, просмотр состояния содержит. Это позволяет отдельных сценарии.

В ASP.NET 2.0 состояние элемента управления решает эту проблему, хорошо через общие сведения о состояния элемента управления. Состояние элемента управления с данными, совершенно необходима для правильной работы элемента управления. В отличие от состояния представления нельзя отключить состояние элемента управления. Таким образом важно тщательно контролируется данные, сохраняемые в состоянии элемента управления.

> [!NOTE]
> Состояние элемента управления сохраняется вместе с состоянием представления в \_ \_VIEWSTATE скрытого поля формы.

В этом видео приведено пошаговое описание состояния представления и состояние элемента управления.

![](server-controls/_static/image1.png)

[Открыть весь экран](server-controls/_static/state1.wmv)

Чтобы серверный элемент управления для чтения и записи для управления состоянием необходимо выполнить три действия.

## <a name="step-1-call-the-registerrequirescontrolstate-method"></a>Шаг 1. Вызовите метод RegisterRequiresControlState

Метод RegisterRequiresControlState сообщает ASP.NET, необходимость элемента управления для сохранения состояния элемента управления. Он принимает один аргумент типа элемента управления, который является элемент управления, который регистрируется.

Важно отметить, что регистрация не сохраняется от запроса. Таким образом этот метод должен вызываться при каждом запросе Если элемент управления для сохранения состояния элемента управления. Рекомендуется, что метод будет вызван в OnInit.

[!code-csharp[Main](server-controls/samples/sample5.cs)]

## <a name="step-2-override-savecontrolstate"></a>Шаг 2. Переопределить SaveControlState

Метод SaveControlState сохраняет изменения состояния для элемента управления с момента последней обратной передачи. Он возвращает объект, представляющий состояние элемента управления.

## <a name="step-3-override-loadcontrolstate"></a>Шаг 3. Переопределить LoadControlState

Метод LoadControlState загружает сохраненное состояние в элемент управления. Этот метод принимает один аргумент типа Object, который содержит сохраненное состояние элемента управления.

## <a name="full-xhtml-compliance"></a>Полный XHTML-совместимость

Любой веб-разработчиков знает важность стандартов в веб-приложениях. Чтобы поддерживать среду разработки на основе стандартов, ASP.NET 2.0 является полностью с XHTML. Таким образом все теги, готовый для просмотра в соответствии со стандартами XHTML в браузерах, поддерживающих HTML 4.0 или более поздней версии.

Определение типа документа в ASP.NET 1.1 был следующим образом:

[!code-html[Main](server-controls/samples/sample6.html)]

В ASP.NET 2.0 определение типа документа по умолчанию выглядит следующим образом:

[!code-html[Main](server-controls/samples/sample7.html)]

При желании можно изменить соответствие XHTML по умолчанию через узел xhtmlConformance в файле конфигурации. Например следующий узел в файле web.config изменится XHTML-совместимость XHTML 1.0 Strict:

[!code-xml[Main](server-controls/samples/sample8.xml)]

При желании можно также настроить ASP.NET для использования устаревших конфигурацию, используемую в ASP.NET 1.x, следующим образом:

[!code-xml[Main](server-controls/samples/sample9.xml)]

## <a name="adaptive-rendering-using-adapters"></a>Подготовка к просмотру с использованием адаптеров адаптивной

В ASP.NET 1.x, файле конфигурации содержится &lt;browserCaps&gt; раздел, в котором заполняется объект HttpBrowserCapabilities. Этот объект может разработчику определить, какое устройство выполняет запрос и отобразить код соответствующим образом. В ASP.NET 2.0 модель улучшена и теперь использует новый класс ControlAdapter. Класс ControlAdapter переопределяет события жизненного цикла элемента управления и управляет отрисовку элементов управления в зависимости от возможностей агента пользователя. Возможности на определенный агент пользователя определяются файл определения браузера (файл с расширением файла с расширением BROWSER), хранящиеся в c:\windows\microsoft.net\framework\v2.0. \* \* \* \*\CONFIG\Browsers папки.

> [!NOTE]
> Класс ControlAdapter является абстрактным классом.

Подобно тому как &lt;browserCaps&gt; разделе в версии 1.x, файл определения браузера используется регулярное выражение выполнить синтаксический анализ строки агента пользователя для идентификации запрашивающим браузером. Он их определяет возможности, определенного для этого агента пользователя. ControlAdapter отображает элемент управления через метод Render. Таким образом Если вы Переопределите метод Render, не следует вызывать отрисовки в базовом классе. Это может привести к визуализации дважды, один раз для адаптера и один раз для самого элемента управления.

## <a name="developing-a-custom-adapter"></a>Разработка пользовательского адаптера

Вы можете разрабатывать собственный пользовательский адаптер путем наследования от ControlAdapter. Кроме того можно наследовать от абстрактного класса PageAdapter в случаях, где требуется адаптер для страницы. Сопоставление элементов управления для пользовательского адаптера можно выполнить посредством &lt;controlAdapters&gt; элемент в файле определения браузера. Например следующий код XML из файла определения браузера сопоставляет элемент управления Menu в класс MenuAdapter:

[!code-html[Main](server-controls/samples/sample10.html)]

С помощью этой модели, становится довольно просто разработчик элемента управления, предназначенную для конкретного устройства или браузера. Это также довольно просто, разработчик может полностью контролировать отображение страниц на каждом устройстве.

## <a name="per-device-rendering"></a>Отрисовки каждого устройства

Свойства серверного элемента управления в ASP.NET 2.0 может быть указанного на уровне отдельного устройства с помощью префикса конкретного браузера. Например приведенный ниже код будет изменить текст подписи, в зависимости от того, какое устройство используется для просмотра страницы.

[!code-aspx[Main](server-controls/samples/sample11.aspx)]

При просмотре страницы, содержащей эту метку из Internet Explorer, метка будет отображать текст, говорим: «Вы подключаетесь из Internet Explorer.» При просмотре страницы из Firefox, метка будет отображать текст «Вы подключаетесь из Firefox.» При просмотре страницы с любого другого устройства будет отображаться «При переходе из неизвестного устройства.» Любое свойство можно задать с помощью специального синтаксиса.

## <a name="setting-focus"></a>Установка фокуса

Разработчики ASP.NET 1.x и ответы о том, как устанавливать исходный фокус на определенный элемент управления. Например на странице входа, будет удобно иметь текстовое поле идентификатора пользователя получить фокус при первой загрузке страницы. В ASP.NET 1.x, это потребовали написания некоторые клиентского скрипта. Несмотря на то, что такого сценария является тривиальной задачей, больше не необходимости в среде ASP.NET 2.0 благодаря метод SetFocus. Метод SetFocus принимает один аргумент, связанным с управлением, который должен попасть фокус. Этот аргумент может быть идентификатор клиента для управления как строка или имя серверного элемента управления как объект элемента управления. Например, чтобы задать исходный фокус в элементе управления TextBox, вызывается txtUserID, при первой загрузке страницы, добавьте следующий код на страницу\_нагрузки:

[!code-csharp[Main](server-controls/samples/sample12.cs)]

--или

[!code-csharp[Main](server-controls/samples/sample13.cs)]

ASP.NET 2.0 использует обработчик Webresource.axd (обсуждалось ранее) для отрисовки клиентской функции, который устанавливает фокус. Имя клиентской функции — WebForm\_AutoFocus, как показано ниже:

[!code-html[Main](server-controls/samples/sample14.html)]

Кроме того можно использовать метод фокуса для элемента управления, устанавливать исходный фокус на этот элемент управления. Метод Focus является производным от класса Control и доступен для всех элементов управления ASP.NET 2.0. Можно также установить фокус на определенный элемент управления, при возникновении ошибки проверки. Который будет рассматриваться в более поздней версии модуля.

## <a name="new-server-controls-in-aspnet-20"></a>Новые серверные элементы управления в ASP.NET 2.0

Ниже приведены новые серверные элементы управления в ASP.NET 2.0. Давайте более подробно на некоторые из них в более поздней версии модулей.

## <a name="imagemap-control"></a>Элемент управления ImageMap

Элемент управления ImageMap позволяет добавить активные области изображения, которое можно инициировать обратной передачи или перейти на URL-адрес. Доступны три типа точек беспроводного доступа; CircleHotSpot RectangleHotSpot и PolygonHotSpot. Горячие точки добавляются с помощью редактора коллекции в Visual Studio, или программно в коде. Для рисования проблемных мест в образ доступен без интерфейса пользователя. Координаты и размер или радиус активной области должны быть указаны декларативно. Имеется также не визуальным представлением активную область в конструкторе. Если активная область настроена для перехода на URL-адрес, URL-адрес задается с помощью свойства NavigateUrl гиперобъекта. В случае отправки обратно гиперобъектов, PostBackValue, свойство позволяет передать строку в обратной передачи, можно получить в коде на стороне сервера.

![Редактор коллекции гиперобъектов в Visual Studio](server-controls/_static/image1.jpg)

**Рис. 1**: Редактор коллекции гиперобъектов в Visual Studio

## <a name="bulletedlist-control"></a>Элемент управления BulletedList

Элемент управления BulletedList является маркированный список, можно легко привязан к данным. Список может быть упорядочен (нумерованные) или два неупорядоченных через свойство BulletStyle. Каждый элемент в списке будет представлен объект ListItem.

![Элемент управления BulletedList в Visual Studio](server-controls/_static/image1.gif)

**Рис. 2**: Элемент управления BulletedList в Visual Studio

## <a name="hiddenfield-control"></a>Элемент управления HiddenField

Элемент управления HiddenField добавляет скрытое поле формы страницу, значение которого доступна в коде на стороне сервера. Значение скрытого поля формы, обычно ожидается остаются неизменными между обратные передачи. Тем не менее существует возможность злонамеренный пользователь может изменить значение предварительного обратную. В этом случае элемент управления HiddenField инициирует событие ValueChanged. Если у вас есть конфиденциальные сведения в элементе управления HiddenField и вы хотите убедиться, что он остается неизменным, событию ValueChanged должна обрабатывать в коде.

## <a name="fileupload-control"></a>Элемента управления fileUpload

Элемента управления FileUpload в ASP.NET 2.0 позволяет передать файлы на веб-сервере с помощью страницы ASP.NET. Этот элемент управления похож на класс HtmlInputFile ASP.NET 1.x, за некоторыми исключениями. В ASP.NET 1.x, он был рекомендован, что свойство PostedFile которого проверяется значение null, чтобы определить, что у вас имеется файл просто. Элемента управления FileUpload в ASP.NET 2.0 добавляет новое свойство HasFile, что можно использовать для той же цели, и более эффективно.

Свойство PostedFile по-прежнему доступна для доступа к объекту HttpPostedFile, но некоторые функции HttpPostedFile теперь доступна по своей природе с помощью элемента управления FileUpload. Например, чтобы сохранить загруженный файл в ASP.NET 1.x, можно вызвать метод SaveAs объекта HttpPostedFile. Использование элемента управления FileUpload в ASP.NET 2.0, будет вызван метод SaveAs на самого элемента управления FileUpload.

Другое значительное изменение в версии 2.0 поведение (и, скорее всего, наиболее значительное изменение) — это больше не требуется для загрузки всего отправленного файла в память перед сохранением. В версии 1.x, любой файл, который был отправлен сохраняется полностью в памяти перед записью на диск. Такая архитектура предотвращает отправку больших файлов.

В ASP.NET 2.0, атрибут requestLengthDiskThreshold элемент httpRuntime следующим образом можно настроить число килобайт хранятся в буфере в памяти перед записью на диск.

**ВАЖНЫЕ**: Документация MSDN (и документации в другом месте) указывает, что это значение задается в байтах (не килобайт) и что значение по умолчанию равно 256. Фактически значение указано в килобайтах, и значение по умолчанию — 80. Когда значение по умолчанию 80 КБ, убедитесь, что буфер не попадут в куче больших объектов.

## <a name="wizard-control"></a>Мастер управления

Это довольно часто возникают разработчиков ASP.NET, стараясь при попытке получить информацию в серии «страниц», с помощью панелей или посредством перемещения между страницами. Гораздо чаще задачей является утомительным и занимает много времени. Новый элемент управления мастера позволяет решить проблемы, позволяя для линейных и нелинейных действия в интерфейсе мастера, пользователи знакомы с. Элемент управления мастер предоставляет формы ввода в ряд шагов. Каждый шаг — определенного типа, указанного в свойстве vlastnost StepType элемента управления. Ниже приведены типы доступных шаг:

| **Тип шага** | **Объяснение** |
| --- | --- |
| Авто | Мастер автоматически определяет тип шага, основываясь на его место в иерархии шаг. |
| Запуск | Первый шаг, часто используется для представления вводной инструкции. |
| Шаг | Обычный шаг. |
| Готово | Последним шагом, обычно используется для представления кнопку, чтобы завершить работу мастера. |
| Завершено | Представляет сообщение о взаимодействии об успехе или неудаче. |

> [!NOTE]
> Мастер управления следит за его состоянием, с помощью состояния элемента управления ASP.NET. Таким образом свойство EnableViewState может быть присвоено значение false, без любой ущерб.

В этом видео приведено пошаговое описание элемента управления Wizard.

![](server-controls/_static/image2.png)

[Открыть весь экран](server-controls/_static/wizard1.wmv)

## <a name="localize-control"></a>Localize-элемент управления

Элемент управления Localize аналогична текстовым элементом управления. Тем не менее, элемент управления Localize имеет **режим** свойство, которое определяет способ отображения разметки, который добавляется к нему. Свойство Mode поддерживает следующие значения:

| **Режим** | **Объяснение** |
| --- | --- |
| Transform | Разметка преобразуется в соответствии с протоколом браузера, выполняющего запрос. |
| Сквозной режим | Разметка будет обработана как-является. |
| Кодирование | Разметка, которая добавляется к элементу управления закодирован при помощи HtmlEncode. |

## <a name="multiview-and-view-controls"></a>MultiView и элементы управления представления

Элемента управления MultiView выступает в качестве контейнера для элементов управления представления, и элементе управления представления выступает в качестве контейнера (как элемент управления Panel) для других элементов управления. Каждое представление в элементе управления MultiView представлен один элемент управления представления. Первый элемент управления представления в режиме MultiView — представление 0, второй — представление 1, и т.д. Путем указания ActiveViewIndex элемента управления MultiView могут переключать представления.

## <a name="substitution-control"></a>Элемент управления Substitution

Элемент управления Substitution используется в сочетании с помощью кэширования ASP.NET. В случаях, когда вы хотите воспользоваться преимуществами кэширования, но у вас есть части страницы, который необходимо обновить для каждого запроса (другими словами, элементы страницы, которые исключаются из кэширования) компонент подстановки предоставляет отличное решение. Элемент управления не отображает никаких выходных данных сама по себе фактически. Вместо этого он привязан к методу в коде на стороне сервера. При запросе страницы вызывается метод и возвращенная разметка отображается вместо элемент управления substitution.

Метод, к которому привязан элемент управления Substitution указываются с помощью **имя_метода** свойство. Этот метод должен удовлетворять следующим критериям:

- Он должен быть метод статического (совместно используется в Visual Basic).
- Он принимает один параметр типа HttpContext.
- Возвращается строка, представляющая разметку, которая должна заменить элемент управления на странице.

Элемент управления Substitution имеет возможность изменять любой другой элемент управления на странице, но он имеет доступа к текущий объект HttpContext через его параметр.

## <a name="gridview-control"></a>Элемент управления GridView

Элемент управления GridView является заменой для элемента управления DataGrid. Этот элемент управления будет рассматриваться более подробно в более поздней версии модуля.

## <a name="detailsview-control"></a>Элемент управления DetailsView

Элемент управления DetailsView обеспечивает возможность отображения одной записи из источника данных, а также изменить или удалить его. Он описан более подробно в более поздней версии модуля.

## <a name="formview-control"></a>Элемент управления FormView

Элемент управления FormView используется для отображения одной записи из источника данных в интерфейсе можно настроить. Он описан более подробно в более поздней версии модуля.

## <a name="accessdatasource-control"></a>Элемент управления AccessDataSource

Элемент управления AccessDataSource используется привязка данных базы данных Access. Он описан более подробно в более поздней версии модуля.

## <a name="objectdatasource-control"></a>Элемент управления ObjectDataSource

Элемент управления ObjectDataSource используется для поддержки трехуровневая архитектура, таким образом, элементы управления могут быть привязаны к среднего уровня бизнес-объект, в отличие от модели двухуровневый где элементы управления привязаны к источнику данных. Обсуждаются более подробно в более поздней версии модуля.

## <a name="xmldatasource-control"></a>Элемент управления XmlDataSource

Элемент управления XmlDataSource используется для привязки данных к источнику данных XML. Он описан более подробно в более поздней версии модуля.

## <a name="sitemapdatasource-control"></a>Элемент управления SiteMapDataSource

Элемент управления SiteMapDataSource обеспечивает привязку данных для элементов управления навигации узла, на основе карты сайта. Обсуждаются более подробно в более поздней версии модуля.

## <a name="sitemappath-control"></a>Элемент управления SiteMapPath

Элемент управления SiteMapPath выводит ряд часто называют адресная строка ссылки навигации. Он описан более подробно в более поздней версии модуля.

## <a name="menu-control"></a>Элемент управления меню

Элемент управления меню отображает динамическое меню, с помощью DHTML. Он описан более подробно в более поздней версии модуля.

## <a name="treeview-control"></a>Элемент управления TreeView

Элемент управления TreeView используется для отображения иерархических древовидным представлением данных. Он описан более подробно в более поздней версии модуля.

## <a name="login-control"></a>Элемент управления Login

Элемент управления Login обеспечивает механизм для входа в веб-сайта. Он описан более подробно в более поздней версии модуля.

## <a name="loginview-control"></a>Элемент управления LoginView

Элемент управления LoginView позволяет отображать различные шаблоны, в зависимости от состояния входа пользователя. Он описан более подробно в более поздней версии модуля.

## <a name="passwordrecovery-control"></a>Элемент управления PasswordRecovery

Управления PasswordRecovery используется для получения забытых паролей пользователями приложения ASP.NET. Он описан более подробно в более поздней версии модуля.

## <a name="loginstatus"></a>LoginStatus

Элемент управления LoginStatus отображает состояние входа пользователя. Он описан более подробно в более поздней версии модуля.

## <a name="loginname"></a>LoginName

Элемент управления LoginName отображает пользователя после регистрируются в приложение ASP.NET. Он описан более подробно в более поздней версии модуля.

## <a name="createuserwizard"></a>CreateUserWizard

CreateUserWizard-это можно настроить мастер, который дает пользователям возможность создавать учетную запись членства ASP.NET для использования в приложении ASP.NET. Он описан более подробно в более поздней версии модуля.

## <a name="changepassword"></a>Изменение пароля

Элемент управления ChangePassword позволяет пользователям изменить свой пароль для приложения ASP.NET. Он описан более подробно в более поздней версии модуля.

## <a name="various-webparts"></a>Различные веб-части

ASP.NET 2.0 поставляется с различных веб-частей. Они рассматриваются подробно в более поздней версии модуля.
