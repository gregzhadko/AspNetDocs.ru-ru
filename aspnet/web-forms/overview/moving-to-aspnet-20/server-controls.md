---
uid: web-forms/overview/moving-to-aspnet-20/server-controls
title: Серверные элементы управления | Документация Майкрософт
author: microsoft
description: ASP.NET 2,0 расширяет серверные элементы управления различными способами. В этом модуле рассматриваются некоторые из архитектурных изменений в ASP.NET 2,0 и Visual Studio 200...
ms.author: riande
ms.date: 02/20/2005
ms.assetid: 43f6ac47-76fc-4cf7-8e9f-c18ce673dfd8
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/server-controls
msc.type: authoredcontent
ms.openlocfilehash: c02a633013f061c09141d4f98871848c011a799e
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78521094"
---
# <a name="server-controls"></a>Серверные элементы управления

по [Майкрософт](https://github.com/microsoft)

> ASP.NET 2,0 расширяет серверные элементы управления различными способами. В этом модуле мы рассмотрим некоторые из архитектурных изменений в способах ASP.NET 2,0 и Visual Studio 2005, работающих с серверными элементами управления.

ASP.NET 2,0 расширяет серверные элементы управления различными способами. В этом модуле мы рассмотрим некоторые из архитектурных изменений в способах ASP.NET 2,0 и Visual Studio 2005, работающих с серверными элементами управления.

## <a name="view-state"></a>Состояние представления

Основное изменение состояния представления в ASP.NET 2,0 — это значительное уменьшение размера. Рассмотрим страницу, на которой есть только элемент управления Calendar. Ниже приведено состояние представления в ASP.NET 1,1.

[!code-css[Main](server-controls/samples/sample1.css)]

Теперь это состояние представления на идентичной странице в ASP.NET 2,0.

[!code-css[Main](server-controls/samples/sample2.css)]

Это довольно существенное изменение, и, учитывая, что состояние представления переносится назад и вперед по сети, это изменение может дать разработчикам значительное повышение производительности. Уменьшение размера состояния представления в основном связано с тем, как он обрабатывается внутренним образом. Помните, что состояние представления является строкой в кодировке Base64. Чтобы лучше понять изменение состояния представления в ASP.NET 2,0, давайте взглянем на декодированные значения из приведенных выше примеров.

Ниже приведено декодированное состояние представления 1,1.

[!code-css[Main](server-controls/samples/sample3.css)]

Это может показаться немного похоже на вам, но здесь есть шаблон. В ASP.NET 1. x мы использовали одиночные символы для обнаружения типов данных и разделенных значений с помощью &lt;&gt; символов. "T" в примере состояния представления выше представляет Triplet. Triplet содержит пару ArrayLists ("l" представляет ArrayList). Один из этих ArrayLists содержит Int32 ("i") со значением 1, а другой — другим Triplet. Triplet содержит пару ArrayLists и т. д. Важно помнить, что мы используем триады, которые содержат пары, определяет типы данных через букву, а также символы &lt; и &gt; в качестве разделителей.

В ASP.NET 2,0 состояние декодированного представления выглядит немного иначе.

[!code-powershell[Main](server-controls/samples/sample4.ps1)]

Следует заметить огромное изменение в внешнем виде декодированного состояния представления. Это изменение имеет несколько архитектурных закрепления. Состояние просмотра в ASP.NET 1. x использовало Лосформаттер для сериализации данных. В 2,0 мы используем новый класс Обжектстатеформаттер. Этот класс был специально разработан для помощи в сериализации и десериализации состояния представления и состояния элемента управления. (Состояние элемента управления будет рассмотрено в следующем разделе.) Существует множество преимуществ, которые получаются путем изменения метода сериализации и десериализации. Одним из наиболее значительных является тот факт, что в отличие от Лосформаттер, использующий TextWriter, Обжектстатеформаттер использует BinaryWriter. Это позволяет ASP.NET 2,0 хранить состояние представления в виде последовательности байтов вместо строк. Возьмем, например, целое число. В ASP.NET 1,1 для целого числа требуется 4 байта состояния представления. В ASP.NET 2,0 для этого же целого числа требуется 1 байт. Были сделаны другие улучшения для уменьшения объема сохраненного состояния представления. Например, значения типа DateTime теперь хранятся с использованием аргумента TickCount вместо строки.

Как если бы все это было недостаточно, особое внимание было оплачено тем, что один из самых крупных потребителей состояния представления в 1. x был элементом DataGrid и аналогичными элементами управления. Главным недостатком таких элементов управления, как DataGrid, где находится состояние представления, является то, что он часто содержит большие объемы повторяющихся данных. В ASP.NET 1. x Повторная информация была просто сохранена и снова, что привело к чрезмерному состоянию представления. В ASP.NET 2,0 мы используем новый класс Индекседстринг для хранения таких данных. Если строка повторяется, мы просто храним маркер для Индекседстринг и индекс в выполняющейся таблице объектов Индекседстринг.

## <a name="control-state"></a>Состояние элемента управления

Одним из основных захватов, которые разработчики имели с состоянием просмотра, был размер, добавленный в полезные данные HTTP. Как упоминалось ранее, одним из самых крупных потребителей состояния представления является элемент управления DataGrid. Чтобы избежать огромного объема состояния представления, создаваемого DataGrid, многие разработчики просто отключили состояние просмотра для этого элемента управления. К сожалению, это решение не всегда было хорошим. Состояние представления в ASP.NET 1. x содержит не только данные, необходимые для правильной работы элемента управления. Он также содержит сведения о состоянии пользовательского интерфейса элемента управления. Это означает, что если вы хотите разрешить разбиение на страницы в DataGrid, необходимо включить состояние представления, даже если вам не нужны все сведения о пользовательском интерфейсе, содержащиеся в состоянии представления. Это сценарий «все или ничего».

В ASP.NET 2,0 контрольное состояние позволяет хорошо решить эту проблему с помощью введения состояния элемента управления. Состояние элемента управления содержит данные, которые абсолютно необходимы для правильной работы элемента управления. В отличие от состояния представления состояние элемента управления не может быть отключено. Поэтому важно тщательно контролировать данные, хранящиеся в состоянии элемента управления.

> [!NOTE]
> Состояние элемента управления сохраняется вместе с состоянием представления в поле \_\_VIEWSTATE скрытая форма.

Это видео представляет собой пошаговое руководство по состоянию представления и состоянию элемента управления.

![](server-controls/_static/image1.png)

[Открыть полноэкранное видео](server-controls/_static/state1.wmv)

Чтобы серверный элемент управления мог выполнять чтение и запись в состояние управления, необходимо выполнить три шага.

## <a name="step-1-call-the-registerrequirescontrolstate-method"></a>Шаг 1. вызов метода Регистеррекуиресконтролстате

Метод Регистеррекуиресконтролстате информирует ASP.NET, что элементу управления необходимо сохранить состояние элемента управления. Он принимает один аргумент типа Control, который является регистрируемым элементом управления.

Важно отметить, что регистрация не сохраняется в запросе на запрос. Поэтому этот метод должен вызываться при каждом запросе, если элемент управления предназначен для сохранения состояния элемента управления. Рекомендуется вызывать метод в OnInit.

[!code-csharp[Main](server-controls/samples/sample5.cs)]

## <a name="step-2-override-savecontrolstate"></a>Шаг 2. Переопределение Савеконтролстате

Метод Савеконтролстате сохраняет изменения состояния элемента управления с момента последней обратной передачи. Он возвращает объект, представляющий состояние элемента управления.

## <a name="step-3-override-loadcontrolstate"></a>Шаг 3. Переопределение Лоадконтролстате

Метод Лоадконтролстате загружает сохраненное состояние в элемент управления. Метод принимает один аргумент типа Object, который содержит сохраненное состояние для элемента управления.

## <a name="full-xhtml-compliance"></a>Полное соответствие XHTML

Любой веб-разработчик знает важность стандартов в веб-приложениях. Чтобы поддерживать среду разработки на основе стандартов, ASP.NET 2,0 полностью совместим с XHTML. Поэтому все теги подготавливаются к просмотру в соответствии со стандартами XHTML в браузерах, поддерживающих HTML 4,0 или более поздней версии.

Определение DOCTYPE в ASP.NET 1,1 имело следующий вид:

[!code-html[Main](server-controls/samples/sample6.html)]

В ASP.NET 2,0 определение DOCTYPE по умолчанию выглядит следующим образом:

[!code-html[Main](server-controls/samples/sample7.html)]

При необходимости можно изменить соответствие XHTML по умолчанию с помощью узла Ксхтмлконформанце в файле конфигурации. Например, следующий узел в файле Web. config изменит совместимость XHTML на XHTML 1,0.

[!code-xml[Main](server-controls/samples/sample8.xml)]

При выборе можно также настроить ASP.NET для использования устаревшей конфигурации, используемой в ASP.NET 1. x, следующим образом.

[!code-xml[Main](server-controls/samples/sample9.xml)]

## <a name="adaptive-rendering-using-adapters"></a>Адаптивная визуализация с помощью адаптеров

В ASP.NET 1. x файл конфигурации содержал раздел &lt;browserCaps&gt;, заполненный объектом Хттпбровсеркапабилитиес. Этот объект позволял разработчику определить, какое устройство выполняет определенный запрос, и визуализировать код соответствующим образом. В ASP.NET 2,0 модель улучшена и теперь использует новый класс ControlAdapter. Класс ControlAdapter переопределяет события в жизненном цикле элемента управления и управляет отрисовкой элементов управления на основе возможностей агента пользователя. Возможности конкретного агента пользователя определяются файлом определения браузера (файлом с расширением BROWSER), хранящимся в файле c:\windows\microsoft.net\Framework\v2.0.\*\*\*\*папку \Конфиг\бровсерс.

> [!NOTE]
> Класс ControlAdapter является абстрактным классом.

Как и в разделе &lt;browserCaps&gt; в 1. x, файл определения браузера использует регулярное выражение для синтаксического анализа строки агента пользователя для определения запрашивающего браузера. Они определяют определенные возможности для этого агента пользователя. ControlAdapter визуализирует элемент управления с помощью метода Render. Поэтому при переопределении метода Render не следует вызывать метод Render для базового класса. Это может привести к тому, что отрисовка будет происходить дважды, один раз для адаптера и один раз для самого элемента управления.

## <a name="developing-a-custom-adapter"></a>Разработка пользовательского адаптера

Вы можете разработать собственный настраиваемый адаптер, наследуя от ControlAdapter. Кроме того, можно наследовать от абстрактного класса Пажеадаптер в случаях, когда для страницы требуется адаптер. Сопоставление элементов управления с настраиваемым адаптером осуществляется с помощью элемента &lt;Контроладаптерс&gt; в файле определения браузера. Например, следующий XML-код из файла определения браузера сопоставляет элемент управления Menu с классом MenuAdapter:

[!code-html[Main](server-controls/samples/sample10.html)]

Используя эту модель, разработчику элемента управления достаточно просто ориентироваться на конкретное устройство или браузер. Разработчику также достаточно просто иметь полный контроль над тем, как страницы подготавливаются к просмотру на каждом устройстве.

## <a name="per-device-rendering"></a>Отрисовка на устройство

Свойства серверного элемента управления в ASP.NET 2,0 можно указать для каждого устройства с помощью префикса для конкретного браузера. Например, приведенный ниже код изменит текст метки в зависимости от того, какое устройство используется для просмотра страницы.

[!code-aspx[Main](server-controls/samples/sample11.aspx)]

При просмотре страницы, содержащей эту метку, из Internet Explorer метка будет отображать текст "вы ведете из браузера Internet Explorer". При просмотре страницы из Firefox в метке отображается текст "вы просматриваете из Firefox". При просмотре страницы с любого другого устройства отображается сообщение «вы ведете обзор с неизвестного устройства». Любое свойство можно указать с помощью этого специального синтаксиса.

## <a name="setting-focus"></a>Установка фокуса

ASP.NET 1. x разработчики часто спрашивают о том, как установить первоначальный фокус на определенный элемент управления. Например, на странице входа полезно, чтобы текстовое поле идентификатор пользователя получило фокус при первой загрузке страницы. В ASP.NET 1. x это необходимо для написания сценария на стороне клиента. Хотя такой сценарий является тривиальной задачей, он больше не нужен в ASP.NET 2,0 благодаря методу SetFocus. Метод SetFocus принимает один аргумент, указывающий на элемент управления, который должен получать фокус. Этот аргумент может быть ИДЕНТИФИКАТОРом клиента элемента управления в виде строки или имени серверного элемента управления как управляющего объекта. Например, чтобы установить начальный фокус на элемент управления TextBox с именем Ткстусерид при первой загрузке страницы, добавьте следующий код на страницу загрузки\_:

[!code-csharp[Main](server-controls/samples/sample12.cs)]

--или

[!code-csharp[Main](server-controls/samples/sample13.cs)]

ASP.NET 2,0 использует обработчик WebClient. axd (обсуждался ранее) для визуализации функции на стороне клиента, которая задает фокус. Имя функции на стороне клиента — это форма\_"автофокус", как показано ниже:

[!code-html[Main](server-controls/samples/sample14.html)]

Кроме того, можно использовать метод Focus для элемента управления, чтобы установить исходный фокус на этот элемент управления. Метод Focus является производным от класса Control и доступен для всех элементов управления ASP.NET 2,0. При возникновении ошибки проверки можно также установить фокус на определенный элемент управления. Это будет рассмотрено в более позднем модуле.

## <a name="new-server-controls-in-aspnet-20"></a>Новые серверные элементы управления в ASP.NET 2,0

Ниже перечислены новые серверные элементы управления в ASP.NET 2,0. Мы подробно рассмотрим некоторые из них в последующих модулях.

## <a name="imagemap-control"></a>Элемент управления Имажемап

Элемент управления Имажемап позволяет добавлять в изображение гиперобъекты, которые могут инициировать обратную передачу или переходить по URL-адресу. Доступны три типа точек доступа. Цирклехотспот, Ректанглехотспот и Полигонхотспот. Гиперобъекты добавляются через редактор коллекций в Visual Studio или программно в коде. Для рисования гиперобъектов на изображении не предусмотрен пользовательский интерфейс. Координаты и размер или радиус гиперобъекта должны быть указаны декларативно. В конструкторе не предусмотрено визуальное представление активной области. Если точка подключения настроена для перехода по URL-адресу, URL-адрес указывается через свойство NavigateUrl активной области. В случае с точки зрения обратной передачи свойство Постбакквалуе позволяет передать строку в обратном ответе, которую можно получить в коде на стороне сервера.

![Редактор коллекции гиперобъектов в Visual Studio](server-controls/_static/image1.jpg)

**Рис. 1**. Редактор коллекции гиперобъектов в Visual Studio

## <a name="bulletedlist-control"></a>Элемент управления маркированного элемента

Элемент управления "маркированный список" является маркированным списком, который можно легко привязать к данным. Список можно упорядочить (нумерованный) или неупорядоченный через свойство Буллетстиле. Каждый элемент в списке представлен объектом ListItem.

![Элемент управления маркированными элементами в Visual Studio](server-controls/_static/image1.gif)

**Рисунок 2**. элемент управления "маркированный" в Visual Studio

## <a name="hiddenfield-control"></a>Элемент управления HiddenField

Элемент управления HiddenField добавляет к странице скрытое поле формы, значение которого доступно в коде на стороне сервера. Значение скрытого поля формы обычно должно оставаться неизменным между обратными передачами. Однако пользователь-злоумышленник может изменить это значение до обратной передачи. В этом случае элемент управления HiddenField вызовет событие ValueChanged. Если у вас есть конфиденциальная информация в элементе управления HiddenField и вы хотите убедиться, что она остается неизменной, следует Обрабатывайте событие ValueChanged в коде.

## <a name="fileupload-control"></a>Элемент управления FileUpload

Элемент управления FileUpload в ASP.NET 2,0 позволяет передавать файлы на веб-сервер через страницу ASP.NET. Этот элемент управления очень похож на класс ASP.NET 1. x HtmlInputFile с некоторыми исключениями. В ASP.NET 1. x было рекомендовано проверять свойство Постедфиле на значение null, чтобы определить, есть ли хороший файл. Элемент управления FileUpload в ASP.NET 2,0 добавляет новое свойство Хасфиле, которое можно использовать для той же цели, и это немного более эффективно.

Свойство Постедфиле по-прежнему доступно для доступа к объекту Хттппостедфиле, но некоторые функции Хттппостедфиле теперь доступны с помощью элемента управления FileUpload. Например, чтобы сохранить загруженный файл в ASP.NET 1. x, вы вызываете метод SaveAs для объекта Хттппостедфиле. Используя элемент управления FileUpload в ASP.NET 2,0, вы бы вызывали метод SaveAs для самого элемента управления FileUpload.

Еще одно важное изменение в поведении 2,0 (и, вероятно, наиболее значимое изменение) заключается в том, что больше не требуется загружать весь загруженный файл в память перед сохранением. В 1. x все отправленные файлы полностью сохраняются в памяти перед записью на диск. Эта архитектура предотвращает отправку больших файлов.

В ASP.NET 2,0 атрибут requestLengthDiskThreshold элемента httpRuntime позволяет указать, сколько килобайтов удерживается в буфере в памяти перед записью на диск.

**Важно!** документация MSDN (и документация в других местах) указывает, что это значение находится в байтах (не в килобайтах) и по умолчанию равно 256. Значение фактически указывается в килобайтах, а значение по умолчанию — 80. Используя значение по умолчанию 80K, мы гарантируете, что буфер не помещается в кучу больших объектов.

## <a name="wizard-control"></a>Элемент управления Wizard

Довольно часто встречаются разработчики ASP.NET, которые пытаются собрать информацию в серии "страниц" с помощью панелей или путем передачи страниц на страницу. Чаще всего это неприятное и занимает много времени. Новый элемент управления Wizard решает проблемы, позволяя выполнять линейные и нелинейные шаги в интерфейсе мастера, с которым пользователи знакомы. Элемент управления мастера предоставляет формы ввода в виде последовательности шагов. Каждый шаг относится к определенному типу, заданному свойством Стептипе элемента управления. Ниже приведены доступные типы шагов.

| **Тип шага** | **Пояснение** |
| --- | --- |
| Auto | Мастер автоматически определяет тип шага в зависимости от его расположения в иерархии шагов. |
| Запуск | Первый шаг, часто используемый для представления вводной инструкции. |
| Шаг | Обычным шагом. |
| Готово | Последний шаг, обычно используемый для представления кнопки для завершения работы мастера. |
| Завершение | Представляет сообщение, которое сообщает об успешном или неуспешном выполнении. |

> [!NOTE]
> Элемент управления мастера отслеживает свое состояние с помощью состояния элемента управления ASP.NET. Таким образом, свойству EnableViewState может быть присвоено значение false без какого бы то ни было негатива.

Это видео представляет собой пошаговое руководство по управлению мастером.

![](server-controls/_static/image2.png)

[Открыть полноэкранное видео](server-controls/_static/wizard1.wmv)

## <a name="localize-control"></a>Локализация элемента управления

Элемент управления Localize аналогичен элементу управления Literal. Однако элемент управления Localize имеет свойство **mode** , которое управляет отображением разметки, добавляемой в нее. Свойство Mode поддерживает следующие значения:

| **Режим** | **Пояснение** |
| --- | --- |
| Преобразование | Разметка преобразуется в соответствии с протоколом браузера, сделавшего запрос. |
| Сылка | Разметка отображается как есть. |
| Кодирование | Разметка, добавляемая в элемент управления, кодируется с помощью HtmlEncode. |

## <a name="multiview-and-view-controls"></a>Элементы управления для просмотра и просмотра

Элемент управления "представление" выступает в качестве контейнера для элементов управления "представление", а элемент управления "представление" выступает в качестве контейнера (подобно элементу управления Panel) для других элементов управления. Каждое представление в элементе управления "Многоэлементный Просмотр" представлено одним элементом управления представлением. Первый элемент управления представления в представлении «многопросмотр» имеет вид 0, второй — представление 1 и т. д. Можно переключать представления, указывая ActiveViewIndex элемента управления для просмотра.

## <a name="substitution-control"></a>Элемент управления Substitution

Элемент управления Substitution используется в сочетании с кэшированием ASP.NET. В случаях, когда требуется использовать кэширование, но есть части страницы, которые необходимо обновить по каждому запросу (иными словами, части страницы, которые исключены из кэширования), компонент подстановки предоставляет отличное решение. Элемент управления на самом деле не отображает никаких выходных данных. Вместо этого он привязывается к методу в коде на стороне сервера. При запросе страницы вызывается метод, и вместо элемента управления Substitution отображается возвращаемая разметка.

Метод, к которому привязан элемент управления Substitution, задается с помощью свойства **MethodName** . Этот метод должен удовлетворять следующим критериям:

- Он должен быть статическим методом (Shared в VB).
- Он принимает один параметр типа HttpContext.
- Он возвращает строку, представляющую разметку, которая должна заменить элемент управления на странице.

Элемент управления Substitution не имеет возможности изменять любой другой элемент управления на странице, но у него есть доступ к текущему HttpContext через его параметр.

## <a name="gridview-control"></a>Элемент управления GridView

Элемент управления GridView является заменой элемента управления DataGrid. Этот элемент управления будет более подробно рассмотрен в более позднем модуле.

## <a name="detailsview-control"></a>Элемент управления DetailsView

Элемент управления DetailsView позволяет отображать одну запись из источника данных, а также редактировать или удалять ее. Он более подробно рассматривается в более позднем модуле.

## <a name="formview-control"></a>Элемент управления FormView

Элемент управления FormView используется для вывода одной записи из источника данных в настраиваемом интерфейсе. Он более подробно рассматривается в более позднем модуле.

## <a name="accessdatasource-control"></a>Элемент управления AccessDataSource

Элемент управления AccessDataSource используется для привязки данных к базе данных Access. Он более подробно рассматривается в более позднем модуле.

## <a name="objectdatasource-control"></a>Элемент управления ObjectDataSource

Элемент управления ObjectDataSource используется для поддержки трехуровневой архитектуры, чтобы элементы управления могли быть привязаны к бизнес-объекту среднего уровня, а не к модели с двумя уровнями, где элементы управления привязаны непосредственно к источнику данных. Он будет обсуждаться более подробно в более позднем модуле.

## <a name="xmldatasource-control"></a>Элемент управления XmlDataSource

Элемент управления XmlDataSource используется для привязки данных к источнику данных XML. Он более подробно рассматривается в более позднем модуле.

## <a name="sitemapdatasource-control"></a>Элемент управления SiteMapDataSource

Элемент управления SiteMapDataSource обеспечивает привязку данных для элементов управления навигацией сайта на основе схемы узла. Он будет обсуждаться более подробно в более позднем модуле.

## <a name="sitemappath-control"></a>Элемент управления SiteMapPath

Элемент управления SiteMapPath отображает ряд навигационных ссылок, обычно называемых навигатором. Он более подробно рассматривается в более позднем модуле.

## <a name="menu-control"></a>Элемент управления меню

Элемент управления Menu отображает динамические меню с помощью DHTML. Он более подробно рассматривается в более позднем модуле.

## <a name="treeview-control"></a>Элемент управления TreeView

Элемент управления TreeView используется для отображения иерархического представления данных в виде дерева. Он более подробно рассматривается в более позднем модуле.

## <a name="login-control"></a>Элемент управления Login

Элемент управления Login предоставляет механизм для входа на веб-сайт. Он более подробно рассматривается в более позднем модуле.

## <a name="loginview-control"></a>Элемент управления LoginView

Элемент управления LoginView позволяет отображать различные шаблоны на основе состояния имени входа пользователя. Он более подробно рассматривается в более позднем модуле.

## <a name="passwordrecovery-control"></a>Элемент управления Пассвордрековери

Элемент управления Пассвордрековери используется для извлечения забытых паролей пользователями приложения ASP.NET. Он более подробно рассматривается в более позднем модуле.

## <a name="loginstatus"></a>LoginStatus

Элемент управления LoginStatus отображает состояние входа пользователя. Он более подробно рассматривается в более позднем модуле.

## <a name="loginname"></a>LoginName

Элемент управления LoginName отображает имя пользователя после входа в приложение ASP.NET. Он более подробно рассматривается в более позднем модуле.

## <a name="createuserwizard"></a>CreateUserWizard

CreateUserWizard — это настраиваемый мастер, который дает пользователям возможность создать учетную запись членства ASP.NET для использования в приложении ASP.NET. Он более подробно рассматривается в более позднем модуле.

## <a name="changepassword"></a>Пароля

Элемент управления ChangePassword позволяет пользователям изменять свой пароль для приложения ASP.NET. Он более подробно рассматривается в более позднем модуле.

## <a name="various-webparts"></a>Различные WebParts

ASP.NET 2,0 поставляется с различными веб-части. Эти сведения будут подробно рассмотрены в более позднем модуле.
