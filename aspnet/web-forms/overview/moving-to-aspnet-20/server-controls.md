---
uid: web-forms/overview/moving-to-aspnet-20/server-controls
title: Управление серверами (ru) Документы Майкрософт
author: rick-anderson
description: ASP.NET 2.0 во многом повышает управление сервером. В этом модуле мы рассмотрим некоторые архитектурные изменения в пути ASP.NET 2.0 и Visual Studio 200...
ms.author: riande
ms.date: 02/20/2005
ms.assetid: 43f6ac47-76fc-4cf7-8e9f-c18ce673dfd8
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/server-controls
msc.type: authoredcontent
ms.openlocfilehash: 7109f10e87abfadf1e7e08795cf9d3d6bf5df122
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2020
ms.locfileid: "81543747"
---
# <a name="server-controls"></a>Серверные элементы управления

[корпорацией Майкрософт](https://github.com/microsoft)

> ASP.NET 2.0 во многом повышает управление сервером. В этом модуле мы рассмотрим некоторые архитектурные изменения в том, как ASP.NET 2.0 и Visual Studio 2005 сделок с серверным управлением.

ASP.NET 2.0 во многом повышает управление сервером. В этом модуле мы рассмотрим некоторые архитектурные изменения в том, как ASP.NET 2.0 и Visual Studio 2005 сделок с серверным управлением.

## <a name="view-state"></a>Состояние просмотра

Первичное изменение состояния представления в ASP.NET 2.0 является резким уменьшением размера. Рассмотрим страницу с только элементом управления календарем на ней. Вот состояние представления в ASP.NET 1.1.

[!code-css[Main](server-controls/samples/sample1.css)]

Теперь вот состояние представления на идентичной странице в ASP.NET 2.0.

[!code-css[Main](server-controls/samples/sample2.css)]

Это довольно значительное изменение, и учитывая, что состояние представления переносится туда и обратно по проводу, это изменение может дать разработчикам значительное увеличение производительности. Уменьшение размера состояния представления во многом обусловлено тем, как мы с ним справляемся внутренне. Помните, что состояние представления является закодированной строкой Base64. Чтобы лучше понять изменение состояния представления в ASP.NET 2.0, давайте рассмотрим декодированные значения из приведенных выше примеров.

Вот состояние 1.1 расшифровано:

[!code-css[Main](server-controls/samples/sample3.css)]

Это может выглядеть немного как тарабарщина, но здесь есть закономерность. В ASP.NET 1.x мы использовали отдельные символы для определения типов &lt; &gt; данных и разграниченных значений с помощью символов. "t" в приведенной выше примере состояния представления представляет собой Triplet. Тройка содержит пару ArrayLists ("l" представляет ArrayList.) Один из этих ArrayLists содержит Int32 ("i") со значением 1, а другой содержит другой Triplet. Тройка содержит пару ArrayLists и т.д. Важно помнить, что мы используем Triplets, которые содержат пары, мы идентифицируем типы &lt; &gt; данных через букву, и мы используем и символы в качестве делимитеров.

В ASP.NET 2.0 состояние декодированного представления выглядит несколько иначе.

[!code-powershell[Main](server-controls/samples/sample4.ps1)]

Вы должны заметить огромные изменения во внешнем виде состояния декодированного представления. Это изменение имеет несколько архитектурных основ. Просмотр состояния в ASP.NET 1.x использовал LosFormatter для сериализации данных. В 2.0 мы используем новый класс ObjectStateFormatter. Этот класс был специально разработан, чтобы помочь в сериализации и десериализации состояния представления и управления. (Состояние управления будет рассмотрено в следующем разделе.) Есть много преимуществ, полученных путем изменения метода, с помощью которого сериализация и десериализация происходят. Одним из наиболее драматичных является тот факт, что в отличие от LosFormatter, который использует TextWriter, ObjectStateFormatter использует BinaryWriter. Это позволяет ASP.NET 2.0 для хранения состояния представления серии байтов вместо строк. Возьмем, к примеру, бесхопорок. В ASP.NET 1.1, integer требуется 4 байт состояния представления. В ASP.NET 2.0, что же integer требует только 1 байт. Были сделаны другие усовершенствования для уменьшения состояния представления, которое хранится. Значения DateTime, например, теперь хранятся с помощью TickCount вместо строки.

Как будто все это было недостаточно, особое внимание было уделено тому факту, что одним из величайших потребителей состояния зрения в 1.x был DataGrid и аналогичные элементы управления. Основным недостатком элементов управления, таких как DataGrid, где речь идет о состоянии представления, является то, что он часто содержит большие объемы повторяющейся информации. В ASP.NET 1.x, что повторная информация просто хранится снова и снова, что приводит к раздутому состоянию представления. В ASP.NET 2.0 мы используем новый класс IndexedString для хранения таких данных. Если строка повторяется, мы просто храним маркер для IndexedString и индекс в таблице, работая на объектах IndexedString.

## <a name="control-state"></a>Состояние управления

Одним из основных проблем, которые разработчики имели с состоянием представления, был размер, который он добавил к полезной нагрузке HTTP. Как упоминалось ранее, одним из крупнейших потребителей состояния представления является контроль DataGrid. Чтобы избежать огромного количества состояния представления, генерируемого DataGrid, многие разработчики просто отключили состояние представления для этого элемента управления. К сожалению, это решение не всегда было хорошим. Состояние просмотра в ASP.NET 1.x содержит не только данные, необходимые для правильной функциональности элемента управления. В нем также содержится информация о состоянии системы управления. Это означает, что если вы хотите разрешить pagination на DataGrid, вы должны включить состояние представления, даже если вам не нужна вся информация о доступе к доступу, содержащаяся в состоянии представления. Это сценарий «все или ничего».

В ASP.NET 2.0, государство управления решает эту проблему хорошо через введение государства контроля. Состояние управления содержит данные, которые абсолютно необходимы для правильной функциональности элемента управления. В отличие от состояния представления, состояние управления не может быть отключено. Поэтому важно тщательно контролировать данные, хранящиеся в состоянии контроля.

> [!NOTE]
> Состояние управления сохраняется вместе с состоянием представления в поле скрытой \_ \_формы VIEWSTATE.

Это видео представляет собой пошаговое пошаговое состояние представления и состояние управления.

![](server-controls/_static/image1.png)

[Открытое полноэкранное видео](server-controls/_static/state1.wmv)

Для того, чтобы управление сервером считывалось и записывалось для управления состоянием, необходимо сделать три шага.

## <a name="step-1-call-the-registerrequirescontrolstate-method"></a>Шаг 1: Вызов RegisterRequiresControlState Метод

Метод RegisterRequiresControlState информирует ASP.NET, что элемент управления должен сохраняться в состоянии контроля. Требуется один аргумент управления типом, который является контролем, который регистрируется.

Важно отметить, что регистрация не сохраняется от запроса к запросу. Таким образом, этот метод должен вызываться по каждому запросу, если элемент управления должен сохраняться в состоянии управления. Рекомендуется, чтобы метод был вызван в OnInit.

[!code-csharp[Main](server-controls/samples/sample5.cs)]

## <a name="step-2-override-savecontrolstate"></a>Шаг 2: Переопределить Состояние Управления Сохранением

Метод SaveControlState сохраняет изменения состояния управления для элемента управления после последнего возврата публикации. Он возвращает объект, представляющий состояние элемента управления.

## <a name="step-3-override-loadcontrolstate"></a>Шаг 3: Переопределить положение о контроле нагрузки

Метод LoadControlState загружает сохраненное состояние в элемент управления. Метод использует один аргумент объекта типа, который удерживает сохраненное состояние для элемента управления.

## <a name="full-xhtml-compliance"></a>Полное соответствие XHTML

Любой веб-разработчик знает о важности стандартов в веб-приложениях. Для поддержания среды разработки, основанной на стандартах, ASP.NET 2.0 полностью соответствует требованиям XHTML. Таким образом, все теги отображаются в соответствии со стандартами XHTML в браузерах, которые поддерживают HTML 4.0 или больше.

Определение DOCTYPE в ASP.NET 1.1 было следующим образом:

[!code-html[Main](server-controls/samples/sample6.html)]

В ASP.NET 2.0 определение DOCTYPE по умолчанию таково:

[!code-html[Main](server-controls/samples/sample7.html)]

Если вы выберете, вы можете изменить соответствие XHTML по умолчанию через узло xhtmlConformance в файле конфигурации. Например, следующий узел в файле web.config изменит соответствие XHTML на XHTML 1.0 Strict:

[!code-xml[Main](server-controls/samples/sample8.xml)]

Если вы выберете, вы также можете настроить ASP.NET использовать устаревшую конфигурацию, используемую в ASP.NET 1.x следующим образом:

[!code-xml[Main](server-controls/samples/sample9.xml)]

## <a name="adaptive-rendering-using-adapters"></a>Адаптивное рендеринг с помощью адаптеров

В ASP.NET 1.x файл конфигурации содержал раздел &lt;browserCaps,&gt; который населен объектом HttpBrowserCapabilities. Этот объект позволил разработчику определить, какое устройство делает конкретный запрос, и рендерзировать код соответствующим образом. В ASP.NET 2.0 модель улучшилась и теперь использует новый класс ControlAdapter. Класс ControlAdapter переопределяет события в жизненном цикле управления и контролирует визуализацию элементов управления на основе возможностей агента пользователя. Возможности конкретного агента пользователя определяются файлом определения браузера (файл с расширением файла .browser), хранящимся в c: 'windows.net'framework'v2.0. \* \*Папка \*для \*браузеров.

> [!NOTE]
> Класс ControlAdapter является абстрактным классом.

Как и &lt;раздел&gt; browserCaps в 1.x, файл определения браузера использует обычное выражение для разбора строки агента пользователя для идентификации запрашивающего браузера. Это их определяет конкретные возможности для этого агента пользователя. ControlAdapter предоставляет элемент управления с помощью метода Render. Поэтому, если вы переопределяете метод Render, не следует вызывать Render в базовом классе. Это может привести к тому, что визуализация произойдет дважды, один раз для адаптера и один раз для самого элемента управления.

## <a name="developing-a-custom-adapter"></a>Разработка пользовательского адаптера

Вы можете разработать свой собственный адаптер, наследовав от ControlAdapter. Кроме того, вы можете наследовать от абстрактного класса PageAdapter в тех случаях, когда адаптер необходим для страницы. Отображение элементов управления в пользовательском адаптере осуществляется с помощью элемента &lt;controlAdapters&gt; в файле определения браузера. Например, следующий XML из файла определения браузера отображает элемент управления меню в класс MenuAdapter:

[!code-html[Main](server-controls/samples/sample10.html)]

Используя эту модель, разработчику управления становится довольно легко настроить таргетинг на определенное устройство или браузер. Кроме того, разработчику довольно просто иметь полный контроль над тем, как отображают страницы на каждом устройстве.

## <a name="per-device-rendering"></a>Рендеринг на устройстве

Свойства управления сервером в ASP.NET 2.0 могут быть указаны на устройство с помощью приставки для браузера. Например, приведенный ниже код изменяет текст метки в зависимости от того, какое устройство используется для просмотра страницы.

[!code-aspx[Main](server-controls/samples/sample11.aspx)]

Когда страница, содержащая эту метку, просматривается из Internet Explorer, на этикетке будет отображаться текст с надписью "Вы просматриваете Internet Explorer". Когда страница просматривается из Firefox, на этикетке будет отображаться текст "Вы просматриваете от Firefox". Когда страница просматривается с любого другого устройства, она будет отображать "Вы просматриваете с неизвестного устройства". Любое свойство может быть указано с помощью этого специального синтаксиса.

## <a name="setting-focus"></a>Установка фокусировки

ASP.NET 1.x разработчики часто задавались вопросом о том, как настроить первоначальный фокус на определенном элементе управления. Например, на странице входа полезно, чтобы текстовый ящик User ID был фокусироваться при первой загрузке страницы. В ASP.NET 1.x для этого требовалось написать сценарий на стороне клиента. Несмотря на то, что такой скрипт является тривиальной задачей, он больше не нужен в ASP.NET 2.0 благодаря методу SetFocus. Метод SetFocus использует один аргумент, указывающий на элемент управления, который должен получить фокус. Этот аргумент может быть либо идентификатором клиента элемента управления в виде строки, либо именем управления сервером как объекта управления. Например, чтобы установить начальный фокус на элемент управления TextBox, который называется txtUserID при первой загрузке страницы, добавьте следующий код в Page\_Load:

[!code-csharp[Main](server-controls/samples/sample12.cs)]

-- или

[!code-csharp[Main](server-controls/samples/sample13.cs)]

ASP.NET 2.0 использует обработчик Webresource.axd (обсуждался ранее) для визуализации функции клиентской стороны, которая устанавливает фокус. Название функции клиента стороне WebForm\_AutoFocus, как показано здесь:

[!code-html[Main](server-controls/samples/sample14.html)]

Кроме того, можно использовать метод Focus для управления, чтобы установить начальный фокус на этом элементе управления. Метод Фокуса происходит от класса управления и доступен для всех ASP.NET 2.0 элементов управления. Также можно настроить фокус на определенный элемент управления при возникновении ошибки проверки. Это будет рассмотрено в более позднем модуле.

## <a name="new-server-controls-in-aspnet-20"></a>Новые управления серверами в ASP.NET 2.0

Ниже приведены новые элементы управления сервером в ASP.NET 2.0. Мы будем входить в более подробноо ею в более поздних модулях.

## <a name="imagemap-control"></a>Управление ImageMap

Управление ImageMap позволяет добавлять точки доступа к изображению, которое может инициировать публикацию назад или перейти к URL-. Доступны три типа горячих точек; CircleHotSpot, RectangleHotSpot и PolygonHotSpot. Горячие точки добавляются через редактор коллекции в Visual Studio или программно в коде. Отсутствует пользовательский интерфейс для рисования горячих точек на изображении. Координаты и размер или радиус точки доступа должны быть определены декларативно. Существует также нет визуального представления точки доступа в дизайнера. Если точка доступа настроена для навигации по URL, URL-адрес указывается через свойство NavigateUrl точки доступа. В случае обратной точки доступа post свойство PostBackValue позволяет передавать строку в задней строке, которую можно получить в коде сервера.

![Редактор коллекции HotSpot в визуальной студии](server-controls/_static/image1.jpg)

**Рисунок 1**: Редактор коллекции HotSpot в визуальной студии

## <a name="bulletedlist-control"></a>Управление пулевым листом

Элемент управления BulletedList — это список пуль, который легко связан данными. Список можно заказать (пронумерованный) или не заказанный через свойство BulletStyle. Каждый элемент в списке представлен объектом ListItem.

![Управление пулевым испугом в визуальной студии](server-controls/_static/image1.gif)

**Рисунок 2**: BulletedList управления в визуальной студии

## <a name="hiddenfield-control"></a>Контроль скрытными полями

Контроль HiddenField добавляет на страницу скрытое поле формы, значение которого доступно в коде на стороне сервера. Значение поля скрытой формы, как правило, останется неизменным между спинками столба. Тем не менее, вредоносный пользователь может изменить значение до публикации обратно. Если это произойдет, контроль HiddenField повысит событие ValueChanged. Если у вас есть конфиденциальная информация в управлении HiddenField и вы хотите убедиться, что она остается неизменной, вы должны обрабатывать событие ValueChanged в коде.

## <a name="fileupload-control"></a>Управление файламиUpload

Управление FileUpload в ASP.NET 2.0 позволяет загружать файлы на веб-сервер через ASP.NET страницу. Этот элемент управления очень похож на ASP.NET 1.x HtmlInputFile класса с некоторыми исключениями. В ASP.NET 1.x, было рекомендовано, чтобы свойство PostedFile было проверено на нулевой, чтобы определить, есть ли у вас хороший файл. Управление FileUpload в ASP.NET 2.0 добавляет новое свойство HasFile, которое можно использовать для той же цели, и это немного более эффективно.

Свойство PostedFile по-прежнему доступно для доступа к объекту HttpPostedFile, но некоторые функциональные возможности HttpPostedFile теперь доступны по своей сути с управлением FileUpload. Например, чтобы сохранить загруженный файл в ASP.NET 1.x, вы называете метод SaveAs на объекте HttpPostedFile. Используя элемент управления FileUpload в ASP.NET 2.0, вы вызовете метод SaveAs на самом управлении FileUpload.

Другим существенным изменением в поведении 2.0 (и, вероятно, наиболее значительным изменением) является то, что больше нет необходимости загружать весь загруженный файл в память, прежде чем сохранить его. В 1.x любой загружаемый файл сохраняется полностью в памяти до того, как он будет записан на диск. Эта архитектура предотвращает загрузку больших файлов.

В ASP.NET 2.0 атрибут запросаLengthDiskThreshold элемента httpRuntime позволяет настроить, сколько килобайт удерживается в буфере памяти до того, как они будут записаны на диск.

**IMPORTANT**: ДОКУМЕНТАЦИя MSDN (и документация в другом месте) указывает, что это значение находится в байтах (не килобайтах) и что значение по умолчанию составляет 256. Значение фактически указывается в килобайтах, а значение по умолчанию составляет 80. Имея значение по умолчанию 80K, мы гарантируем, что буфер не окажется на большой куче объекта.

## <a name="wizard-control"></a>Управление мастером

Довольно часто сталкиваются ASP.NET разработчики пытаются собрать информацию в серии "страниц" с помощью панелей или путем передачи со страницы на страницу. Чаще всего, усилия разочарование один и занимает много времени. Новый элемент управления Мастера решает проблемы, позволяя линейные и нелинейные шаги в интерфейсе мастера, с которыми пользователи знакомы. Управление Мастера представляет входные формы в серии шагов. Каждый шаг имеет определенный тип, указанный свойством StepType элемента управления. Доступные типы шагов:

| **Тип шага** | **Объяснение** |
| --- | --- |
| Авто | Мастер автоматически определяет тип шага на основе его положения в иерархии шага. |
| Запуск | Первый шаг, часто используется для представления вступительного заявления. |
| Шаг | Нормальный шаг. |
| Готово | Последний шаг, как правило, используется для представления кнопки, чтобы закончить мастера. |
| Завершение | Представляет сообщение, сообщая об успехе или неудаче. |

> [!NOTE]
> Управление Мастера отслеживает его состояние, используя ASP.NET состояние управления. Таким образом, свойство EnableViewState может быть установлено ложным без какого-либо ущерба.

Это видео является пошаговой частью управления Мастера.

![](server-controls/_static/image2.png)

[Открытое полноэкранное видео](server-controls/_static/wizard1.wmv)

## <a name="localize-control"></a>Локализация управления

Управление локализацией похоже на литеральное управление. Однако элемент управления локализации имеет свойство **режима,** которое контролирует, как добавляется разметка к ней. Свойство «Режим» поддерживает следующие значения:

| **Режим** | **Объяснение** |
| --- | --- |
| Преобразование | Разметка преобразуется в соответствии с протоколом браузера, делающих запрос. |
| Прохождения | Разметка отображается как есть. |
| Кодирование | Разметка, добавленная в элемент управления, кодируется с помощью HtmlEncode. |

## <a name="multiview-and-view-controls"></a>Мультипросмотр и управление просмотром

Элемент управления MultiView выполняет функции контейнера для элементов управления представления, а управление представлением — как контейнер (как элемент управления панелью) для других элементов управления. Каждое представление в элементе управления MultiView представлено одним элементом управления представления. Первый элемент управления представления в MultiView — это вид 0, второй — вид 1 и т.д. Вы можете переключать представления, указывая ActiveViewIndex управления MultiView.

## <a name="substitution-control"></a>Контроль замещения

Контроль замены используется в сочетании с ASP.NET кэшированием. В тех случаях, когда вы хотите воспользоваться кэшированием, но у вас есть части страницы, которые должны быть обновлены по каждому запросу (другими словами, части страницы, которые не могут быть кэширования), компонент Замены обеспечивает отличное решение. Элемент управления фактически не предоставляет какой-либо вывод сам по себе. Вместо этого он связан с методом в коде сервера. При запросе страницы метод вызывается и возвращается разметка нанесется вместо элемента управления замены.

Метод, к которому привязан контроль замещения, определяется через свойство **MethodName.** Этот метод должен соответствовать следующим критериям:

- Это должен быть статический (общий в VB) метод.
- Он принимает один параметр типа HttpContext.
- Он возвращает строку, представляющую разметку, которая должна заменить элемент управления на странице.

Контроль замены не имеет возможности изменять любой другой элемент управления на странице, но он имеет доступ к текущему HttpContext через его параметр.

## <a name="gridview-control"></a>Контроль GridView

Контроль GridView является заменой управления DataGrid. Этот элемент управления будет рассмотрен более подробно в более позднем модуле.

## <a name="detailsview-control"></a>ДеталиПросмотр управления

Контроль DatasView позволяет отображать одну запись из источника данных и отсеивать или удалять ее. Она более подробно описана в более позднем модуле.

## <a name="formview-control"></a>Управление FormView

Элемент управления FormView используется для отображения одной записи из источника данных в настраиваемом интерфейсе. Она более подробно описана в более позднем модуле.

## <a name="accessdatasource-control"></a>Контроль доступаКДатаИсточник

Контроль AccessDataSource используется для связывания данных базой данных Access. Она более подробно описана в более позднем модуле.

## <a name="objectdatasource-control"></a>Элемента управления ObjectDataSource

Элемент управления ObjectDataSource используется для поддержки трехуровневой архитектуры, так что элементы управления могут быть связаны с данными бизнес-объектом среднего уровня, в отличие от двухуровневой модели, где элементы управления связаны непосредственно с источником данных. Он будет подробно рассмотрен в более позднем модуле.

## <a name="xmldatasource-control"></a>XmlDataИсточник управления

Контроль XmlDataSource используется для привязки данных к источнику данных XML. Она более подробно описана в более позднем модуле.

## <a name="sitemapdatasource-control"></a>Управление SiteMapDataSource

Контроль SiteMapDataSource обеспечивает привязку данных к управлению навигацией сайта на основе карты сайта. Он будет подробно рассмотрен в более позднем модуле.

## <a name="sitemappath-control"></a>Управление SiteMapPath

Управление SiteMapPath отображает ряд навигационных ссылок, обычно называемых панировочными сухарями. Она более подробно описана в более позднем модуле.

## <a name="menu-control"></a>Элемент управления меню

Элемент управления меню отображает динамическое меню с помощью DHTML. Она более подробно описана в более позднем модуле.

## <a name="treeview-control"></a>Элемент управления TreeView

Элемент управления TreeView используется для отображения иерархического представления данных о дереве. Она более подробно описана в более позднем модуле.

## <a name="login-control"></a>Управление логином

Управление логином обеспечивает механизм входа на веб-узел. Она более подробно описана в более позднем модуле.

## <a name="loginview-control"></a>Элемент управления LoginView

Управление LoginView позволяет отображать различные шаблоны на основе статуса входа пользователя. Она более подробно описана в более позднем модуле.

## <a name="passwordrecovery-control"></a>Управление паролейRecovery

Контроль PasswordRecovery используется для получения забытых паролей пользователями ASP.NET приложения. Она более подробно описана в более позднем модуле.

## <a name="loginstatus"></a>LoginStatus

Элемент управления LoginStatus отображает статус входа пользователя. Она более подробно описана в более позднем модуле.

## <a name="loginname"></a>LoginName

Управление LoginName отображает имя пользователя после входа в ASP.NET приложение. Она более подробно описана в более позднем модуле.

## <a name="createuserwizard"></a>СоздатьUserWizard

CreateUserWizard — это настраиваемый мастер, который дает пользователям возможность создавать учетную запись ASP.NET членства для использования в ASP.NET приложении. Она более подробно описана в более позднем модуле.

## <a name="changepassword"></a>ChangePassword;

Контроль ChangePassword позволяет пользователям менять свой пароль для ASP.NET приложения. Она более подробно описана в более позднем модуле.

## <a name="various-webparts"></a>Различные WebParts

ASP.NET 2.0 корабли с различными web-частими. Они будут подробно рассмотрены в более позднем модуле.
