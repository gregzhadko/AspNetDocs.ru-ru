---
uid: web-forms/overview/data-access/introduction/creating-a-business-logic-layer-vb
title: Создание уровня бизнес-логики (Visual Basic) | Документация Майкрософт
author: rick-anderson
description: В этом руководстве мы рассмотрим централизовать бизнес-правилам в слой бизнес-логики (BLL), выступающем в качестве посредника при обмене данными между t...
ms.author: riande
ms.date: 03/31/2010
ms.assetid: 142e5181-29ce-4bb9-907b-2a0becf7928b
msc.legacyurl: /web-forms/overview/data-access/introduction/creating-a-business-logic-layer-vb
msc.type: authoredcontent
ms.openlocfilehash: 63efa46410e821947c6b0ee4ecd0c790fbf793e3
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59380097"
---
# <a name="creating-a-business-logic-layer-vb"></a>Создание уровня бизнес-логики (VB)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачайте пример приложения](http://download.microsoft.com/download/5/d/7/5d7571fc-d0b7-4798-ad4a-c976c02363ce/ASPNET_Data_Tutorial_2_VB.exe) или [скачать PDF](creating-a-business-logic-layer-vb/_static/datatutorial02vb1.pdf)

> В этом руководстве будет показано, как централизовать бизнес-правилам в слой бизнес-логики (BLL), выступающем в качестве посредника при обмене данными между слоем представления и слоем DAL.


## <a name="introduction"></a>Вступление

Уровень доступа к данным (DAL) создан в [руководства по использованию](creating-a-data-access-layer-vb.md) четко разделяет данные доступа логики от логики представления. Тем не менее хотя DAL четко отделяет сведения о данных доступа от слоя представления, любой бизнес-правила, которые могут применяться не реализуется. Например, для нашего приложения мы может потребоваться запретить `CategoryID` или `SupplierID` поля `Products` таблицы, если для `Discontinued` поле имеет значение 1 или нам может понадобиться принудительное применение правил старшинства, запрещающих ситуации, в котором Сотрудник управляется человек, который был принят на работу позже него. Другим распространенным сценарием является авторизации может быть только пользователи в определенной роли, могут удалять продукты или можно изменить `UnitPrice` значение.

В этом руководстве будет показано, как для централизации этих бизнес-правил в слой бизнес-логики (BLL), выступающем в качестве посредника при обмене данными между слоем представления и слоем DAL. В реальном приложении слой бизнес-ЛОГИКИ должен быть реализован как отдельный проект библиотеки классов; Однако этих руководствах мы реализуем BLL как ряд классов в наших `App_Code` папки для упрощения структуры проекта. Рис. 1 показаны связи архитектуры между слоя представления, BLL и DAL.


![BLL отделяет слой представления от уровня доступа к данным и налагает бизнес-правила](creating-a-business-logic-layer-vb/_static/image1.png)

**Рис. 1**: BLL отделяет слой представления от уровня доступа к данным и налагает бизнес-правила


Вместо создания отдальных классов для реализации наших [бизнес-логики](http://en.wikipedia.org/wiki/Business_logic), мы может поместить эту логику непосредственно в типизированном наборе DataSet с частичными классами. Пример создания и расширения Typed DataSet вернитесь в первом учебном курсе.

## <a name="step-1-creating-the-bll-classes"></a>Шаг 1. Создание классов BLL

Наш слой BLL будет состоять из четырех классов, по одному для каждого адаптера TableAdapter в слое DAL; Каждый из этих классов BLL будет содержать методы извлечения, вставки, обновления и удаления из соответствующего TableAdapter в слое DAL, применяющие соответствующие бизнес-правила.

Для большей четкости разделения классов, связанных с DAL и BLL, создадим две вложенные папки в `App_Code` папке `DAL` и `BLL`. Просто щелкните правой кнопкой мыши `App_Code` папку в обозревателе решений и выберите новую папку. После создания этих двух папок переместите типизированный набор DataSet, созданный в первом руководстве в `DAL` во вложенную папку.

Создайте четыре файла классов BLL во `BLL` во вложенную папку. Для этого щелкните правой кнопкой мыши `BLL` во вложенную папку, выберите команду Добавить новый элемент и выберите шаблон класса. Присвойте имя этим четырем классам `ProductsBLL`, `CategoriesBLL`, `SuppliersBLL`, и `EmployeesBLL`.


![Добавьте четыре новых класса в папку App_Code](creating-a-business-logic-layer-vb/_static/image2.png)

**Рис. 2**: Добавьте четыре новых класса в `App_Code` папки


Далее добавим методы к каждому из классов, чтобы просто перенести методы, определенные для TableAdapters из первого руководства. Пока эти методы будут просто вызываться непосредственно из DAL; впоследствии мы вернемся Добавление любые необходимые бизнес-логики.

> [!NOTE]
> Если вы используете Visual Studio Standard Edition или более поздней версии (то есть вы *не* с помощью Visual Web Developer), существует возможность проектировать классы визуально с помощью [конструктор классов](https://msdn.microsoft.com/library/default.asp?url=/library/dv_vstechart/html/clssdsgnr.asp). Ссылаться на [блог конструктор класса](https://blogs.msdn.com/classdesigner/default.aspx) Дополнительные сведения об этой новой возможности в Visual Studio.


Для `ProductsBLL` придется добавить целых семь методов:

- `GetProducts()` Возвращает все продукты
- `GetProductByProductID(productID)` Возвращает продукт с указанным Идентификатором продукта
- `GetProductsByCategoryID(categoryID)` Возвращает все продукты указанной категории
- `GetProductsBySupplier(supplierID)` Возвращает все продукты указанного поставщика
- `AddProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued)` Вставляет новый продукт в базе данных с использованием значений переданное; Возвращает `ProductID` значение вновь вставленной записи
- `UpdateProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued, productID)` обновляет существующий продукт в базе данных, используя переданные значения; Возвращает `True` Если точности одна строка была обновлена, `False` в противном случае
- `DeleteProduct(productID)` Удаляет указанный продукт из базы данных

ProductsBLL.vb


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample1.vb)]

Методы, которые просто возвращают данные `GetProducts`, `GetProductByProductID`, `GetProductsByCategoryID`, и `GetProductBySuppliersID` являются крайне простыми, так как они напрямую обращаются к слою методу DAL. Хотя в некоторых сценариях может быть бизнес-правила, которые должны быть реализованы на этом уровне (например, правила авторизации на основе текущего пользователя или роли, к которой принадлежит пользователь), мы просто оставим эти методы, как-является. Для этих методов выберите слой BLL будет выступать в качестве прокси-сервера, через который слой представления получает доступ к данным из уровня доступа к данным.

`AddProduct` И `UpdateProduct` методов и принимают в качестве параметров значения различных полей продукта и добавляют новый продукт или обновляет существующий, соответственно. Поскольку многие из `Product` столбцы таблицы могут принимать `NULL` значения (`CategoryID`, `SupplierID`, и `UnitPrice`, некоторые), для тех входных параметров `AddProduct` и `UpdateProduct` , сопоставленные с таким столбцам, используются [обнуляемые типы](https://msdn.microsoft.com/library/1t3y8s4s(v=vs.80).aspx). Обнуляемые типы не знакомы с .NET 2.0 и дают возможность указать, для, указывающее, является ли тип значения должен, вместо этого быть `Nothing`. Ссылаться на [Пол Вик](http://www.panopticoncentral.net/)на запись в блоге [правда об обнуляемый типах и VB](http://www.panopticoncentral.net/archive/2004/06/04/1180.aspx) и технической документации по [Nullable](https://msdn.microsoft.com/library/b3h38hb0%28VS.80%29.aspx) структура Дополнительные сведения.

Все три метода возвращают логическое значение, указывающее, был ли строки вставки, обновления или удалить, так как операция может не привести к над соответствующей строкой. Например, если разработчик страницы вызывает `DeleteProduct` передавая `ProductID` для несуществующего продукта, `DELETE` обращенное к базе данных не оказывает влияния и, следовательно, `DeleteProduct` метод возвратит `False`.

Обратите внимание, что при добавлении нового продукта или обновляется существующая мы берем в продукт новых или измененных значений полей как список скалярных выражений, в отличие от принятия `ProductsRow` экземпляра. Такой подход был выбран, так как `ProductsRow` класс является производным `DataRow` класс, который не имеет конструктора по умолчанию без параметров. Для создания нового экземпляра `ProductsRow` экземпляра, необходимо сначала создать `ProductsDataTable` и затем вызвать его `NewProductRow()` метода (который мы делаем в `AddProduct`). Этот недостаток начинает себя проявлять при обращении ко вставке и обновлению продуктов с помощью элемента управления ObjectDataSource. Короче говоря ObjectDataSource пытается создать экземпляр входных параметров. Если метод BLL ожидает `ProductsRow` экземпляра, ObjectDataSource пытается создать его, но завершиться ошибкой из-за отсутствия конструктора без параметров по умолчанию. Дополнительные сведения по этой проблеме см. в следующих двух форумах по ASP.NET: [Обновление элементов управления ObjectDataSource с помощью строго типизированных наборов данных](https://forums.asp.net/1098630/ShowPost.aspx), и [проблема с ObjectDataSource и строго типизированный набор DataSet](https://forums.asp.net/1048212/ShowPost.aspx).

Далее, в обоих `AddProduct` и `UpdateProduct`, код создает `ProductsRow` экземпляра и заполняется только что переданными значениями. При присвоении значений объектам DataColumn класса DataRow возможны различные проверки на уровне полей. Таким образом Вставка вручную переданных значений обратно в строку DataRow облегчает обеспечение допустимости данных, передаваемые в метод BLL. К сожалению, строго типизированные классы DataRow, созданные Visual Studio не используют обнуляемые типы. Скорее чтобы указать, что конкретный объект DataColumn в DataRow должен соответствовать `NULL` базы данных необходимо использовать `SetColumnNameNull()` метод.

В `UpdateProduct` сначала загружается обновляемый продукт с помощью `GetProductByProductID(productID)`. Хотя это может показаться необязательным обращением к базе данных, этот дополнительный проход, будет доказана осмысленность в следующих учебных пособиях, исследующих оптимистичный параллелизм. Оптимистическая блокировка — это метод, чтобы убедиться, что случайно двух пользователей, которые одновременно работают над теми же данными не перезаписать изменения друг друга. Захват записи целиком также упрощает создание методов обновления в BLL, изменяющих только подмножество столбцов DataRow. При изучении `SuppliersBLL` класс, мы рассмотрим такой пример.

Наконец, обратите внимание, что `ProductsBLL` класс имеет [к нему атрибут DataObject](https://msdn.microsoft.com/library/system.componentmodel.dataobjectattribute.aspx) применения к нему ( `[System.ComponentModel.DataObject]` непосредственно предшествующий оператору класса поблизости верхней части файла) и методы имеют [ Атрибуты DataObjectMethodAttribute](https://msdn.microsoft.com/library/system.componentmodel.dataobjectmethodattribute.aspx). `DataObject` Атрибут помечает класс как объект, подходящий для привязки к [элемента управления ObjectDataSource](https://msdn.microsoft.com/library/9a4kyhcx.aspx), тогда как `DataObjectMethodAttribute` указывает назначение метода. Как мы увидим в последующих руководствах, элемент управления ObjectDataSource ASP.NET 2.0 облегчает декларативный доступ к данным из класса. Для облегчения фильтрации списка возможных классов для привязки к в мастере ObjectDataSource, по умолчанию только классы, помеченные как `DataObjects` отображаются в раскрывающемся списке мастера. `ProductsBLL` Класс будет работать точно так же без этих атрибутов, но их добавление облегчает работу в мастере ObjectDataSource.

## <a name="adding-the-other-classes"></a>Добавление других классов

С помощью `ProductsBLL` полный класс, по-прежнему необходимо добавить классы для работы с категориями, поставщиками и сотрудниками. Уделите минуту, чтобы создать следующие классы и методы, с использованием концепции из приведенного выше примера.

- **CategoriesBLL.cs**

    - `GetCategories()`
    - `GetCategoryByCategoryID(categoryID)`
- **SuppliersBLL.cs**

    - `GetSuppliers()`
    - `GetSupplierBySupplierID(supplierID)`
    - `GetSuppliersByCountry(country)`
    - `UpdateSupplierAddress(supplierID, address, city, country)`
- **EmployeesBLL.cs**

    - `GetEmployees()`
    - `GetEmployeeByEmployeeID(employeeID)`
    - `GetEmployeesByManager(managerID)`

Достоин упоминания метод является `SuppliersBLL` класса `UpdateSupplierAddress` метод. Этот метод предоставляет интерфейс для обновления только сведения о адрес поставщика. На внутреннем уровне этот метод считывает в `SupplierDataRow` для указанного `supplierID` (с помощью `GetSupplierBySupplierID`), задает его свойства, связанные с адресом и затем вызывается метод `SupplierDataTable` `Update` метод. `UpdateSupplierAddress` Метод следующим образом:


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample2.vb)]

См. в этой статье загрузки для Завершенная реализация классов BLL.

## <a name="step-2-accessing-the-typed-datasets-through-the-bll-classes"></a>Шаг 2. Доступ к типизированным наборам данных посредством классов BLL

В первом учебном курсе были рассмотрены примеры работы непосредственно с типизированный набор DataSet, программными средствами, но с добавлением наши классы BLL, уровень представления предназначен для работы с BLL вместо этого. В `AllProducts.aspx` пример из руководства по использованию `ProductsTableAdapter` использовался для привязки списка продуктов к GridView, как показано в следующем коде:


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample3.vb)]

Для использования нового BLL классы, все, которые необходимо изменить — первая часть кода просто заменить `ProductsTableAdapter` со `ProductBLL` объекта:


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample4.vb)]

Классы BLL может осуществляться с помощью элемента управления ObjectDataSource также декларативно (что может типизированный набор DataSet). Здесь мы рассмотрим ObjectDataSource более подробно в следующих руководствах.


[![Список продуктов, отображаемый в GridView](creating-a-business-logic-layer-vb/_static/image4.png)](creating-a-business-logic-layer-vb/_static/image3.png)

**Рис. 3**: Список продуктов, отображаемый в элементе управления GridView ([Просмотр полноразмерного изображения](creating-a-business-logic-layer-vb/_static/image5.png))


## <a name="step-3-adding-field-level-validation-to-the-datarow-classes"></a>Шаг 3. Добавление проверки на уровне полей к классам DataRow

Проверки на уровне полей являются проверками, которые относятся к значениям свойств бизнес-объектов, при вставке или обновлении. Включают несколько правил проверки на уровне полей для продуктов:

- `ProductName` Должна превышать 40 символов длиной
- `QuantityPerUnit` Должна превышать 20 символов длиной
- `ProductID`, `ProductName`, И `Discontinued` поля являются обязательными, но все остальные поля являются необязательными
- `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, И `ReorderLevel` поля должны быть больше или равно нулю

Эти правила могут и должны быть выражены на уровне базы данных. Ограничение символов на `ProductName` и `QuantityPerUnit` поля регистрируются по типам данных тех столбцов `Products` таблицы (`nvarchar(40)` и `nvarchar(20)`, соответственно). Являются ли поля обязательные и необязательные выражается посредством допустимости для столбца таблицы базы данных позволяет `NULL` s. Четыре [проверочные ограничения](https://msdn.microsoft.com/library/ms188258.aspx) существует, убедитесь, что только значения больше или равно нулю могут выполнять его в `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, или `ReorderLevel` столбцов.

Помимо обязательного выполнения этих правил в базе данных они должны также обязательно выполняться на уровне объекта DataSet. На самом деле длина поля и является ли значение обязательного уже определены для каждого объекта DataTable набора DataColumns объекта. Чтобы просмотреть существующие проверки уровня полей автоматически, перейдите в конструктор DataSet, выберите поле из одного из DataTable, а затем выберите окно "Свойства". Как показано на рис. 4, `QuantityPerUnit` DataColumn в `ProductsDataTable` имеет максимальную длину 20 символов и допускает `NULL` значения. Если для свойства `ProductsDataRow` `QuantityPerUnit` строковое значение длиннее 20 символов `ArgumentException` будет создано.


[![DataColumn обеспечивает базовую проверку на уровне полей](creating-a-business-logic-layer-vb/_static/image7.png)](creating-a-business-logic-layer-vb/_static/image6.png)

**Рис. 4**: DataColumn обеспечивает базовую на уровне полей проверку ([Просмотр полноразмерного изображения](creating-a-business-logic-layer-vb/_static/image8.png))


К сожалению, мы не может указать проверяются границы, например `UnitPrice` значение должно быть больше или равно нулю, в окне «Свойства». Для обеспечения этого типа проверки на уровне полей необходимо создать обработчик событий для объекта DataTable [ColumnChanging](https://msdn.microsoft.com/library/system.data.datatable.columnchanging%28VS.80%29.aspx) событий. Как упоминалось в [предыдущем учебном курсе](creating-a-data-access-layer-vb.md), объекты DataSet, DataTables и DataRow, создаваемые типизированный набор DataSet можно расширить посредством использования частичных классов. С помощью этой методики, мы можем создать `ColumnChanging` обработчик событий для `ProductsDataTable` класса. Начните с создания класса в `App_Code` папку с именем `ProductsDataTable.ColumnChanging.vb`.


[![Добавьте новый класс в папку App_Code](creating-a-business-logic-layer-vb/_static/image10.png)](creating-a-business-logic-layer-vb/_static/image9.png)

**Рис. 5**: Добавьте новый класс к `App_Code` папку ([Просмотр полноразмерного изображения](creating-a-business-logic-layer-vb/_static/image11.png))


Создайте обработчик событий для `ColumnChanging` событие, которое гарантирует, что `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, и `ReorderLevel` значения столбцов (в противном случае `NULL`) больше или равно нулю. Если любой из таких столбцов выходит за пределы диапазона, возникает исключение `ArgumentException`.

ProductsDataTable.ColumnChanging.vb


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample5.vb)]

## <a name="step-4-adding-custom-business-rules-to-the-blls-classes"></a>Шаг 4. Добавление пользовательских бизнес-правил к классам BLL

Помимо проверки на уровне полей могут существовать высокого уровня пользовательских бизнес-правил, которые включают в себя различные объекты или концепции которые невозможно выразить на уровне столбца, такие как:

- Если продукт снят с производства, его `UnitPrice` не может быть обновлен
- Страна проживания сотрудников должна совпадать с именем страной проживания их руководителя
- Продукт не может прекратить в случае, если это единственный продукт, предоставляемый данным поставщиком

Классы BLL должны содержать проверки, обеспечивающие соблюдение бизнес-правил приложения. Эти проверки можно добавить непосредственно в методы, к которым они применяются.

Представьте себе, что наши бизнес-правила требуют, что продукт не может быть помечена неподдерживаемые Если это единственный продукт данного производителя. То есть если продукта *X* единственный продукт, приобретавшимся у поставщика *Y*, нельзя помечать *X* как снятые с продажи; Если, тем не менее, поставщик *Y*поставлял три продукта, *объект*, *B*, и *C*, можно помечать любые и все их них как более не поддерживается. Странное бизнес-правило, но бизнес-правила и здравый смысл не всегда совпадают!

Для принудительного применения этого бизнес-правила в `UpdateProducts` может начинаться с проверки, если метод `Discontinued` было присвоено `True` и, таким образом, мы вызовем `GetProductsBySupplierID` чтобы определить, сколько продуктов было приобретено у этого поставщика продуктов. Если только один продукт приобретается у этого поставщика, мы выдаем `ApplicationException`.


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample6.vb)]

## <a name="responding-to-validation-errors-in-the-presentation-tier"></a>Реакция на ошибки проверки в слое представления

При обращении к BLL из слоя представления мы можно решить, следует ли пытаться обрабатывать все исключения, которые могут возникнуть, или позволить им обнаружиться ASP.NET (который создает событие `HttpApplication`в `Error` событий). Для обработки исключения при работе со слоем BLL программно, мы используем [попробуйте... Catch](https://msdn.microsoft.com/library/fk6t46tz%28VS.80%29.aspx) блока, как показано в следующем примере:


[!code-vb[Main](creating-a-business-logic-layer-vb/samples/sample7.vb)]

Как мы увидим в последующих учебных курсах, обработка исключений, которые поднимаются из BLL при использовании данных веб-элемент управления для вставки, обновления или удаления данных могут обрабатываться непосредственно в обработчике событий вместо необходимости включать код в `Try...Catch` блоков.

## <a name="summary"></a>Сводка

Приложение с хорошо продуманной архитектурой состоит из различных слоев, каждый из которых заключена конкретная роль. В первом руководстве этой серии статей мы создали слой доступа к данным, использование типизированных наборов DataSet; в этом руководстве мы создали слой бизнес-логики как ряд классов в нашем приложении `App_Code` вызов DAL папку. BLL реализует логику на уровне полей и бизнес уровня для нашего приложения. Кроме создания отдельного слоя BLL, как мы делали это в этом руководстве, другим вариантом является расширение методов элемента управления TableAdapter посредством использования частичных классов. Тем не менее при использовании этого метода позволяет переопределять существующие методы, ни разделять слои DAL и BLL так же четко, как подход, использованный в этой статье.

DAL и BLL мы можем приступить к слоя представления. В [следующему руководству](master-pages-and-site-navigation-vb.md) мы ненадолго отвлечемся из статьи о доступе к данным и определения согласованного макета страницы для использования на протяжении всего руководства.

Счастливого вам программирования!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP.NET и основатель веб- [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Microsoft с 1998 года. Скотт — независимый консультант, преподаватель и автор. Его последняя книга — [ *Sams Teach ASP.NET 2.0 in 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Ним можно связаться по адресу [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Особая благодарность

В этой серии руководств пособий рецензировалась многими компетентными редакторами. (Liz Shulok), Деннис Patterson, Карлос Сантос и (Hilton giesenow), стали Лиз Шалок в этом руководстве. Хотите поработать с моих последующих статей для MSDN? Если Да, напишите мне [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](creating-a-data-access-layer-vb.md)
> [Вперед](master-pages-and-site-navigation-vb.md)
