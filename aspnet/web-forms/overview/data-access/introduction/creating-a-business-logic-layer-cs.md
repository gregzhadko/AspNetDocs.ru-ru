---
uid: web-forms/overview/data-access/introduction/creating-a-business-logic-layer-cs
title: Создание уровня бизнес-логикиC#() | Документация Майкрософт
author: rick-anderson
description: В этом учебнике мы посмотрим, как централизовать бизнес-правила на уровне бизнес-логики (BLL), который служит посредником для обмена данными между t...
ms.author: riande
ms.date: 03/31/2010
ms.assetid: 85554606-47cb-4e4f-9848-eed9da579056
msc.legacyurl: /web-forms/overview/data-access/introduction/creating-a-business-logic-layer-cs
msc.type: authoredcontent
ms.openlocfilehash: df96f3e7422a0537bf1b003a33fe8d71a671ac33
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2019
ms.locfileid: "74586205"
---
# <a name="creating-a-business-logic-layer-c"></a>Создание уровня бизнес-логики (C#)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачивание примера приложения](https://download.microsoft.com/download/4/6/3/463cf87c-4724-4cbc-b7b5-3f866f43ba50/ASPNET_Data_Tutorial_2_CS.exe) или [Загрузка PDF-файла](creating-a-business-logic-layer-cs/_static/datatutorial02cs1.pdf)

> В этом учебнике мы посмотрим, как централизовать бизнес-правила на уровне бизнес-логики (BLL), который служит посредником для обмена данными между уровнем представления и DAL.

## <a name="introduction"></a>Введение

Уровень доступа к данным (DAL), созданный в [первом учебнике](creating-a-data-access-layer-cs.md) , четко отделяет логику доступа к данным от логики представления. Однако, хотя DAL четко отделяет сведения о доступе к данным от уровня представления, он не применяет никаких бизнес-правил, которые могут применяться. Например, для нашего приложения мы можем запретить изменение полей `CategoryID` или `SupplierID` таблицы `Products`, если для поля `Discontinued` задано значение 1, или же можно применить правила стажа, запрещая ситуации, в которых сотрудник управляется кем-то, кто его нанимает. Другой распространенный сценарий — авторизация, возможно, только пользователи определенной роли могут удалять продукты или изменять `UnitPrice` значение.

В этом учебнике мы посмотрим, как централизовать эти бизнес-правила в слое бизнес-логики (BLL), который служит посредником для обмена данными между уровнем представления и DAL. В реальных приложениях слой BLL должен быть реализован в виде отдельного проекта библиотеки классов. Однако в этих учебных курсах мы реализуем слой BLL как набор классов в папке `App_Code`, чтобы упростить структуру проекта. На рис. 1 показаны архитектурные отношения между уровнем представления, BLL и DAL.

![Слой BLL отделяет уровень представления от уровня доступа к данным и накладывает бизнес-правила.](creating-a-business-logic-layer-cs/_static/image1.png)

**Рис. 1**. слой BLL отделяет уровень представления от уровня доступа к данным и накладывает бизнес-правила

## <a name="step-1-creating-the-bll-classes"></a>Шаг 1. Создание классов BLL

Наш слой BLL будет состоять из четырех классов — по одному для каждого адаптера таблицы в DAL; Каждый из этих классов BLL будет иметь методы для извлечения, вставки, обновления и удаления из соответствующего TableAdapter в DAL, применяя соответствующие бизнес-правила.

Для более четкого разделения классов, связанных с DAL и BLL, давайте создадим две вложенные папки в папке `App_Code`, `DAL` и `BLL`. Просто щелкните правой кнопкой мыши папку `App_Code` в обозреватель решений и выберите пункт Создать папку. После создания этих двух папок переместите типизированный набор данных, созданный в первом учебнике, в подпапку `DAL`.

Затем создайте четыре файла класса BLL во вложенной папке `BLL`. Для этого щелкните подпапку `BLL` правой кнопкой мыши, выберите пункт Добавить новый элемент и выберите шаблон класса. Назовите четыре класса `ProductsBLL`, `CategoriesBLL`, `SuppliersBLL`и `EmployeesBLL`.

![Добавление четырех новых классов в папку App_Code](creating-a-business-logic-layer-cs/_static/image2.png)

**Рис. 2**. добавление четырех новых классов в папку `App_Code`

Теперь добавим методы к каждому из классов, чтобы просто создать оболочку для методов, определенных для адаптеров таблиц TableAdapter, из первого руководства. Сейчас эти методы просто вызываются непосредственно в DAL; Позже мы вернемся к добавлению любой необходимой бизнес-логики.

> [!NOTE]
> Если вы используете Visual Studio Standard Edition или более поздней версии (то есть *не* используете Visual Web Developer), при необходимости можно спроектировать классы визуально с помощью [конструктор классов](https://msdn.microsoft.com/library/default.asp?url=/library/dv_vstechart/html/clssdsgnr.asp). Дополнительные сведения об этой новой функции в Visual Studio см. в [блоге конструктор классов](https://blogs.msdn.com/classdesigner/default.aspx) .

Для класса `ProductsBLL` нужно добавить всего семь методов:

- `GetProducts()` возвращает все продукты
- `GetProductByProductID(productID)` возвращает продукт с указанным ИДЕНТИФИКАТОРом продукта
- `GetProductsByCategoryID(categoryID)` возвращает все продукты из указанной категории
- `GetProductsBySupplier(supplierID)` возвращает все продукты указанного поставщика
- `AddProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued)` вставляет новый продукт в базу данных, используя переданные значения; Возвращает `ProductID` значение вновь вставленной записи
- `UpdateProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued, productID)` обновляет существующий продукт в базе данных, используя переданные значения; Возвращает `true`, если была обновлена ровно одна строка, `false` в противном случае
- `DeleteProduct(productID)` удаляет указанный продукт из базы данных

ProductsBLL.cs

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample1.cs)]

Методы, которые просто возвращают данные `GetProducts`, `GetProductByProductID`, `GetProductsByCategoryID`и `GetProductBySuppliersID`, довольно просты, так как они просто вызывают DAL. Хотя в некоторых сценариях могут существовать бизнес-правила, которые необходимо реализовать на этом уровне (например, правила авторизации на основе вошедшего в систему пользователя или роль, к которой принадлежит пользователь), мы просто оставляем эти методы как есть. Для этих методов BLL выступает в качестве прокси-сервера, через который уровень представления данных обращается к базовым данным уровня доступа к данным.

Методы `AddProduct` и `UpdateProduct` принимают в качестве параметров значения для различных полей продукта и добавляют новый продукт или обновляют существующий, соответственно. Так как многие столбцы `Product`ной таблицы могут принимать `NULL` значения (`CategoryID`, `SupplierID`и `UnitPrice`, для нескольких имен), эти входные параметры для `AddProduct` и `UpdateProduct`, которые сопоставляются с такими столбцами, используют [типы, допускающие значение NULL](https://msdn.microsoft.com/library/1t3y8s4s(v=vs.80).aspx). Типы, допускающие значение null, являются новыми для .NET 2,0 и предоставляют метод для указания того, следует ли `null`тип значения. В C# качестве типа значения можно пометить как тип, допускающий значение null, добавив `?` после типа (например, `int? x;`). Дополнительные сведения см. в разделе [типы Nullable](https://msdn.microsoft.com/library/1t3y8s4s.aspx) в [ C# руководстве по программированию](https://msdn.microsoft.com/library/67ef8sbd%28VS.80%29.aspx) .

Все три метода возвращают логическое значение, указывающее, была ли строка вставлена, обновлена или удалена, так как операция может не привести к затронутой строке. Например, если разработчик страницы вызывает `DeleteProduct` передачи `ProductID` несуществующему продукту, инструкция `DELETE`, выданная базе данных, не будет оказывать влияния, поэтому метод `DeleteProduct` возвратит `false`.

Обратите внимание, что при добавлении нового продукта или обновлении существующего можно использовать новые или измененные значения полей продукта в виде списка скаляров, а не принимать `ProductsRow` экземпляр. Этот подход был выбран, поскольку класс `ProductsRow` является производным от класса ADO.NET `DataRow`, у которого нет конструктора без параметров по умолчанию. Чтобы создать новый экземпляр `ProductsRow`, сначала необходимо создать экземпляр `ProductsDataTable`, а затем вызвать его метод `NewProductRow()` (который мы делаем в `AddProduct`). Этот недостаток отменяет свой заголовок, когда мы переключим вставку и обновление продуктов с помощью ObjectDataSource. Вкратце, элемент управления ObjectDataSource попытается создать экземпляр входных параметров. Если метод BLL принимает экземпляр `ProductsRow`, то ObjectDataSource попытается создать его, но при этом произойдет сбой из-за отсутствия конструктора без параметров по умолчанию. Дополнительные сведения об этой проблеме см. в следующих двух сообщениях форумов ASP.NET: [Обновление ObjectDataSource с помощью строго типизированных наборов](https://forums.asp.net/1098630/ShowPost.aspx) [данных и проблема с ObjectDataSource и строго типизированным набором DataSet](https://forums.asp.net/1048212/ShowPost.aspx).

Затем в `AddProduct` и `UpdateProduct`код создает экземпляр `ProductsRow` и заполняет его только что переданными значениями. При назначении значений столбцам данных DataRow могут возникать различные проверки на уровне полей. Таким образом, ручное помещение переданных значений обратно в DataRow позволяет гарантировать, что данные передаются в метод BLL. К сожалению, строго типизированные классы DataRow, создаваемые Visual Studio, не используют типы, допускающие значение null. Вместо этого, чтобы указать, что определенный DataColumn в DataRow должен соответствовать `NULL` значению базы данных, необходимо использовать метод `SetColumnNameNull()`.

В `UpdateProduct` мы сначала загружаем в продукт для обновления с помощью `GetProductByProductID(productID)`. Хотя это может показаться ненужным обращением к базе данных, это дополнительное путешествие будет оправдано в будущих руководствах, иссвященных оптимистичному параллелизму. Оптимистичный параллелизм — это способ убедиться, что два пользователя, которые одновременно работают с одними и теми же данными, не перезапишут изменения, внесенные другими пользователями. При извлечении всей записи также упрощается создание в BLL методов обновления, которые изменяют только подмножество столбцов DataRow. При рассмотрении класса `SuppliersBLL` мы увидим такой пример.

Наконец, обратите внимание, что к классу `ProductsBLL` применен [атрибут DataObject](https://msdn.microsoft.com/library/system.componentmodel.dataobjectattribute.aspx) (синтаксис `[System.ComponentModel.DataObject]` прямо перед оператором Class в верхней части файла), а методы имеют [атрибуты датаобжектмесодаттрибуте](https://msdn.microsoft.com/library/system.componentmodel.dataobjectmethodattribute.aspx). Атрибут `DataObject` помечает класс как объект, подходящий для привязки к [элементу управления ObjectDataSource](https://msdn.microsoft.com/library/9a4kyhcx.aspx), в то время как `DataObjectMethodAttribute` указывает назначение метода. Как мы увидим в следующих учебных курсах, ObjectDataSource ASP.NET 2.0 упрощает декларативный доступ к данным из класса. Чтобы помочь фильтровать список возможных классов для привязки в мастере ObjectDataSource, по умолчанию в раскрывающемся списке мастера отображаются только те классы, которые помечены как `DataObjects`. Класс `ProductsBLL` будет работать точно так же, как и эти атрибуты, но их добавление упрощает работу в мастере ObjectDataSource.

## <a name="adding-the-other-classes"></a>Добавление других классов

По завершении класса `ProductsBLL` нам по-прежнему нужно добавить классы для работы с категориями, поставщиками и сотрудниками. Уделите время созданию следующих классов и методов с помощью концепций из приведенного выше примера:

- **CategoriesBLL.cs**

    - `GetCategories()`
    - `GetCategoryByCategoryID(categoryID)`
- **SuppliersBLL.cs**

    - `GetSuppliers()`
    - `GetSupplierBySupplierID(supplierID)`
    - `GetSuppliersByCountry(country)`
    - `UpdateSupplierAddress(supplierID, address, city, country)`
- **EmployeesBLL.cs**

    - `GetEmployees()`
    - `GetEmployeeByEmployeeID(employeeID)`
    - `GetEmployeesByManager(managerID)`

Один из методов стоит отметить как метод `UpdateSupplierAddress` `SuppliersBLL` класса. Этот метод предоставляет интерфейс для обновления только сведений об адресе поставщика. На внутреннем уровне этот метод считывает объект `SupplierDataRow` для указанного `supplierID` (используя `GetSupplierBySupplierID`), устанавливает связанные с адресом свойства, а затем вызывает метод `Update` `SupplierDataTable`. Ниже приведен метод `UpdateSupplierAddress`.

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample2.cs)]

Сведения о завершении реализации классов BLL см. в статье загрузка этой статьи.

## <a name="step-2-accessing-the-typed-datasets-through-the-bll-classes"></a>Шаг 2. доступ к типизированным наборам данных с помощью классов BLL

В первом учебном курсе мы увидели примеры работы непосредственно с типизированным набором данных программным способом, но с добавлением наших классов BLL уровень представления должен работать с BLL. В `AllProducts.aspx` примере из первого руководства `ProductsTableAdapter` использовалась для привязки списка продуктов к GridView, как показано в следующем коде:

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample3.cs)]

Чтобы использовать новые классы BLL, все, что нужно изменить, — это первая строка кода, просто заменяющая объект `ProductsTableAdapter` объектом `ProductBLL`:

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample4.cs)]

Доступ к классам BLL также можно получить декларативно (как и типизированный набор данных) с помощью ObjectDataSource. Мы будем обсуждать ObjectDataSource более подробно в следующих руководствах.

[![список продуктов отображается в элементе управления GridView](creating-a-business-logic-layer-cs/_static/image4.png)](creating-a-business-logic-layer-cs/_static/image3.png)

**Рис. 3**. список продуктов отображается в элементе управления GridView ([щелкните, чтобы просмотреть изображение с полным размером](creating-a-business-logic-layer-cs/_static/image5.png))

## <a name="step-3-adding-field-level-validation-to-the-datarow-classes"></a>Шаг 3. Добавление проверки на уровне полей в классы DataRow

Проверка на уровне полей — это проверки, относящиеся к значениям свойств бизнес-объектов при вставке или обновлении. Некоторые правила проверки на уровне полей для продуктов включают:

- Длина поля `ProductName` не должна превышать 40 символов.
- Длина поля `QuantityPerUnit` не должна превышать 20 символов
- Поля `ProductID`, `ProductName`и `Discontinued` являются обязательными, но все остальные поля являются необязательными.
- Поля `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`и `ReorderLevel` должны быть больше или равны нулю

Эти правила можно и выражать на уровне базы данных. Ограничение на количество символов в полях `ProductName` и `QuantityPerUnit` захватывается типами данных этих столбцов в `Products` таблице (`nvarchar(40)` и `nvarchar(20)`соответственно). Указывает, являются ли поля обязательными и необязательными, выражаются, если столбец таблицы базы данных допускает `NULL` s. Существуют четыре [проверочных ограничения](https://msdn.microsoft.com/library/ms188258.aspx) , которые гарантируют, что только значения, которые больше или равны нулю, могут быть в столбцах `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`или `ReorderLevel`.

Помимо применения этих правил к базе данных, они также должны быть принудительно применены на уровне набора данных. На самом деле, длина поля и то, является ли значение обязательным или необязательным, уже захвачено для каждого набора столбцов DataTable. Чтобы просмотреть существующую проверку на уровне полей, перейдите в конструктор наборов данных, выберите поле из одной из таблиц DataTable, а затем перейдите к окно свойств. Как показано на рис. 4, `QuantityPerUnit` столбец данных в `ProductsDataTable` имеет максимальную длину 20 символов и допускает значения `NULL`. Если при попытке задать для свойства `QuantityPerUnit` `ProductsDataRow`строковое значение длиннее 20 символов, будет выдано `ArgumentException`.

[![столбец DataColumn обеспечивает базовую проверку на уровне полей](creating-a-business-logic-layer-cs/_static/image7.png)](creating-a-business-logic-layer-cs/_static/image6.png)

**Рис. 4**. параметр DataColumn обеспечивает базовую проверку на уровне полей ([щелкните, чтобы просмотреть изображение с полным размером](creating-a-business-logic-layer-cs/_static/image8.png))

К сожалению, невозможно указать проверки границ, например значение `UnitPrice` должно быть больше или равно нулю через окно свойств. Чтобы обеспечить такой тип проверки на уровне полей, необходимо создать обработчик событий для события [ColumnChanging](https://msdn.microsoft.com/library/system.data.datatable.columnchanging%28VS.80%29.aspx) DataTable. Как упоминалось в [предыдущем руководстве](creating-a-data-access-layer-cs.md), объекты DataSet, DataTables и DataRow, созданные типизированным набором данных, можно расширить с помощью разделяемых классов. Используя этот прием, можно создать обработчик событий `ColumnChanging` для класса `ProductsDataTable`. Начните с создания класса в папке `App_Code` с именем `ProductsDataTable.ColumnChanging.cs`.

[![добавить новый класс в папку App_Code](creating-a-business-logic-layer-cs/_static/image10.png)](creating-a-business-logic-layer-cs/_static/image9.png)

**Рис. 5**. Добавление нового класса в папку `App_Code` ([щелкните, чтобы просмотреть изображение с полным размером](creating-a-business-logic-layer-cs/_static/image11.png))

Затем создайте обработчик событий для события `ColumnChanging`, которое гарантирует, что значения столбцов `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`и `ReorderLevel` (если не `NULL`) больше или равны нулю. Если какой-либо из этих столбцов выходит за пределы диапазона, вызовите `ArgumentException`.

ProductsDataTable.ColumnChanging.cs

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample5.cs)]

## <a name="step-4-adding-custom-business-rules-to-the-blls-classes"></a>Шаг 4. Добавление настраиваемых бизнес-правил в классы BLL

Помимо проверки на уровне полей, могут существовать настраиваемые бизнес-правила высокого уровня, использующие различные сущности или понятия, не вычисляемые на уровне одного столбца, например:

- Если продукт прекращен, его `UnitPrice` невозможно обновить
- Страна проживания сотрудника должна совпадать со страной проживания своего руководителя
- Невозможно прекратить работу продукта, если он является единственным продуктом, предоставленным поставщиком

Классы BLL должны содержать проверки, гарантирующие соблюдение бизнес-правил приложения. Эти проверки можно добавить непосредственно в методы, к которым они применяются.

Представьте, что наши бизнес-правила определяют, что продукт не может быть помечен как неподдерживаемый, если он был единственным продуктом от данного поставщика. То есть, если продукт *x* был единственным продуктом, приобретенным у поставщика *Y*, мы не можем помечать *X* как снятое. Однако если бы поставщик *Y* представил нам три продукта: *A*, *B*и *C*, можно пометить все и все эти данные как снятые. Нерегулярное бизнес-правило, но бизнес-правила и распространенный смысл не всегда согласованы!

Чтобы применить это бизнес-правило в `UpdateProducts` методе, мы начнем с того, что для `Discontinued` было установлено значение `true` и, если да, мы вызываем `GetProductsBySupplierID`, чтобы определить, сколько продуктов было приобретено у этого поставщика продукта. Если у этого поставщика приобретен только один продукт, мы выдаем `ApplicationException`.

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample6.cs)]

## <a name="responding-to-validation-errors-in-the-presentation-tier"></a>Реагирование на ошибки проверки на уровне представления

При вызове BLL из уровня представления можно решить, следует ли попытаться обрабатывать любые исключения, которые могут быть вызваны, или позволить им подASP.NETся, что приведет к появлению события `Error` `HttpApplication`). Чтобы обрабатывалось исключение при программной работе с BLL, можно использовать метод [try... блок catch](https://msdn.microsoft.com/library/0yd65esw.aspx) , как показано в следующем примере:

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample7.cs)]

Как мы увидим в следующих учебных курсах, обработка исключений, которые поднимаются от BLL при использовании веб-элемента управления данными для вставки, обновления или удаления данных, может обрабатываться непосредственно в обработчике событий, в отличие от необходимости заключения кода в блоки `try...catch`.

## <a name="summary"></a>Сводка

Хорошо спроектированное приложение создается на различных уровнях, каждый из которых инкапсулирует определенную роль. В первом учебнике этой серии статей мы создали уровень доступа к данным с помощью типизированных наборов данных. в этом учебнике мы создали уровень бизнес-логики в виде серии классов в папке `App_Code` приложения, которая вызывает DAL. В BLL для нашего приложения реализуется логика на уровне полей и бизнес-уровня. Помимо создания отдельного слоя BLL, как мы делали в этом учебнике, другой вариант — расширить методы TableAdapter с помощью разделяемых классов. Однако использование этой методики не позволяет переопределять существующие методы и не разделять DAL и BLL в соответствии с подходом, который мы сделали в этой статье.

Теперь, когда DAL и BLL завершены, мы готовы начать работу на нашем уровне представления. В [следующем учебном курсе](master-pages-and-site-navigation-cs.md) мы предоставим краткий обзор разделов, посвященных доступу к данным, и определим единообразный макет страницы для использования в рамках руководства.

Поздравляем с программированием!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP. NET и основатель [4GuysFromRolla.com](http://www.4guysfromrolla.com), работал с веб-технологиями Майкрософт с 1998. Скотт работает как независимый консультант, преподаватель и модуль записи. Его последняя книга — [*Sams обучать себя ASP.NET 2,0 за 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Он доступен по адресу [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти по адресу [http://ScottOnWriting.NET](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Специальная благодарность

Эта серия руководств была рассмотрена многими полезными рецензентами. Потенциальные рецензенты для этого руководства: основными рецензентами, Деннис Patterson, Карлос Сантос и Хилтон Гизнау. Хотите ознакомиться с моими будущими статьями MSDN? Если это так, расположите строку в [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](creating-a-data-access-layer-cs.md)
> [Вперед](master-pages-and-site-navigation-cs.md)
