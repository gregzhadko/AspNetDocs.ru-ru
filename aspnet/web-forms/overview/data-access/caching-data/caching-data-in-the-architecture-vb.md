---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
title: Кэширование данных в архитектуре (VB) | Документация Майкрософт
author: rick-anderson
description: В предыдущем учебном курсе мы узнали, как применять кэширование на уровне представления. В этом учебнике мы рассмотрите, как воспользоваться преимуществами нашего многоуровневого арчитекту...
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 5e189dd7-f4f9-4f28-9b3a-6cb7d392e9c7
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-vb
msc.type: authoredcontent
ms.openlocfilehash: dc991a205fa7e61f604bc0f26e9b24b3faefd3d3
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78443592"
---
# <a name="caching-data-in-the-architecture-vb"></a>Кэширование данных в архитектуре (VB)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачивание примера приложения](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_VB.exe) или [Загрузка PDF-файла](caching-data-in-the-architecture-vb/_static/datatutorial59vb1.pdf)

> В предыдущем учебном курсе мы узнали, как применять кэширование на уровне представления. В этом учебнике мы рассмотрите, как использовать преимущества нашей многоуровневой архитектуры для кэширования данных на уровне бизнес-логики. Это делается путем расширения архитектуры для включения слоя кэширования.

## <a name="introduction"></a>Введение

Как было показано в предыдущем руководстве, кэширование данных ObjectDataSource не так просто, как установка нескольких свойств. К сожалению, элемент управления ObjectDataSource применяет кэширование на уровне представления, что тесно прикрепляет политики кэширования со страницей ASP.NET. Одна из причин создания многоуровневой архитектуры заключается в том, чтобы обеспечить разрыв таких взаимосвязей. Уровень бизнес-логики, например, разделяет бизнес-логику со страниц ASP.NET, а уровень доступа к данным разделяет сведения о доступе к данным. Такое разделение бизнес-логики и сведений о доступе к данным является предпочтительным, в части, поскольку оно делает систему более удобочитаемой, более удобной для сопровождения и более гибкой. Кроме того, это позволяет разработчикам, работающим на уровне представления, получить знания о предметной области и отделить данные, которые не должны быть знакомы с подробными сведениями о базе данных, чтобы выполнить свою работу. Отделение политики кэширования от уровня представления презентаций обеспечивает аналогичные преимущества.

В этом учебнике мы дополнять нашу архитектуру, включив в нее *слой кэширования* (или CL для краткого), в котором применяется наша политика кэширования. Уровень кэширования будет включать класс `ProductsCL`, который предоставляет доступ к сведениям о продукте с помощью таких методов, как `GetProducts()`, `GetProductsByCategoryID(categoryID)`и т. д., которые при вызове будут сначала пытаться получить данные из кэша. Если кэш пуст, эти методы вызывают соответствующий метод `ProductsBLL` в BLL, который, в свою очередь, получит данные из DAL. Методы `ProductsCL` кэшируют данные, полученные из BLL, перед их возвратом.

Как показано на рис. 1, среда CL находится между уровнями представления и бизнес-логики.

![Уровень кэширования (CL) — это еще один уровень в нашей архитектуре](caching-data-in-the-architecture-vb/_static/image1.png)

**Рис. 1**. слой кэширования (CL) — это еще один уровень в нашей архитектуре

## <a name="step-1-creating-the-caching-layer-classes"></a>Шаг 1. Создание классов уровня кэширования

В этом учебнике мы создадим очень простую версию CL с одним классом `ProductsCL`, который содержит всего несколько методов. Создание полного слоя кэширования для всего приложения потребует создания классов `CategoriesCL`, `EmployeesCL`и `SuppliersCL` и предоставления метода в этих классах уровней кэширования для каждого метода доступа к данным или изменения в BLL. Как и в случае с BLL и DAL, уровень кэширования в идеале должен быть реализован как отдельный проект библиотеки классов. Однако мы будем реализовывать его как класс в папке `App_Code`.

Чтобы более четко отделить классы CL от классов DAL и BLL, давайте создадим новую вложенную папку в папке `App_Code`. Щелкните правой кнопкой мыши папку `App_Code` в обозреватель решений, выберите пункт Создать папку и назовите новую папку `CL`. После создания этой папки добавьте в нее новый класс с именем `ProductsCL.vb`.

![Добавьте новую папку с именем CL и класс с именем Продуктскл. vb.](caching-data-in-the-architecture-vb/_static/image2.png)

**Рис. 2**. Добавление новой папки с именем `CL` и класса с именем `ProductsCL.vb`

Класс `ProductsCL` должен включать тот же набор методов доступа к данным и изменения, что и в соответствующем классе уровня бизнес-логики (`ProductsBLL`). Вместо того, чтобы создавать все эти методы, давайте просто создадим пару, чтобы получить представление о шаблонах, используемых в CL. В частности, мы добавим методы `GetProducts()` и `GetProductsByCategoryID(categoryID)` на шаге 3 и `UpdateProduct`ую перегрузку на шаге 4. В свободное время можно добавить оставшиеся методы `ProductsCL` и классы `CategoriesCL`, `EmployeesCL`и `SuppliersCL`.

## <a name="step-2-reading-and-writing-to-the-data-cache"></a>Шаг 2. чтение и запись в кэш данных

Функция кэширования ObjectDataSource, рассмотренная в предыдущем руководстве, внутренне использует кэш данных ASP.NET для хранения данных, полученных из BLL. Доступ к кэшу данных также можно получить программным путем из классов ASP.NET страниц кода программной части или из классов в архитектуре веб-приложений. Для чтения и записи в кэш данных из класса кода программной части ASP.NET страницы используйте следующий шаблон:

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample1.vb)]

Метод [`Cache` классов](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) [`Insert`](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) имеет ряд перегрузок. `Cache("key") = value` и `Cache.Insert(key, value)` являются синонимами и добавляют элемент в кэш с помощью указанного ключа без определенного срока действия. Как правило, мы хотим указать срок действия при добавлении элемента в кэш либо в качестве зависимости, истечения срока действия на основе времени, либо в обоих случаях. Используйте один из других перегрузок метода `Insert`, чтобы предоставить сведения об истечении срока действия зависимости или времени.

Методы уровня кэширования должны сначала проверить, находятся ли запрошенные данные в кэше, и, если да, вернуть их отсюда. Если запрошенные данные отсутствуют в кэше, необходимо вызвать соответствующий метод BLL. Возвращаемое значение должно кэшироваться, а затем возвращаться, как показано на следующей схеме последовательностей.

![Методы уровня кэширования возвращают данные из кэша, если они доступны](caching-data-in-the-architecture-vb/_static/image3.png)

**Рис. 3**. методы уровня кэширования возвращают данные из кэша, если они доступны

Последовательность, показанная на рис. 3, реализована в классах CL в следующем формате:

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample2.vb)]

Здесь *Type* — это тип данных, хранящихся в кэше `Northwind.ProductsDataTable`, например, если *ключ* — это ключ, однозначно определяющий элемент кэша. Если элемент с указанным *ключом* отсутствует в кэше, то *экземпляр* будет `Nothing`, а данные будут получены из соответствующего метода BLL и добавлены в кэш. По достижении времени `Return instance` *экземпляр* содержит ссылку на данные из кэша или из слоя BLL.

При доступе к данным из кэша обязательно используйте приведенный выше шаблон. Следующий шаблон, на первый взгляд, выглядит эквивалентным, содержит незаметное различие, которое порождает состояние гонки. Трудно выполнить отладку, так как они раскрывают их случайным путем и трудно воспроизвести.

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample3.vb)]

Разница во втором, неверный фрагмент кода заключается в том, что вместо сохранения ссылки на кэшированный элемент в локальной переменной доступ к кэшу данных осуществляется непосредственно в условном операторе *и* в `Return`. Представьте, что при достижении этого кода `Cache("key")` не `Nothing`, но перед тем, как будет достигнута инструкция `Return`, система происключает *ключ* из кэша. В этом редких случаях код возвратит `Nothing`, а не объект ожидаемого типа.

> [!NOTE]
> Кэш данных является потокобезопасным, поэтому вам не нужно синхронизировать доступ к потоку для простого чтения или записи. Однако, если необходимо выполнить несколько операций с данными в кэше, которые должны быть атомарными, вы несете ответственность за реализацию блокировки или какого-либо другого механизма обеспечения безопасности потоков. Дополнительные сведения см. в разделе [синхронизация доступа к кэшу ASP.NET](http://www.ddj.com/184406369) .

Элемент можно программно удалить из кэша данных с помощью [метода`Remove`](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) следующим образом:

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample4.vb)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a>Шаг 3. Возврат сведений о продукте из класса`ProductsCL`

В этом руководстве мы рассмотрим реализацию двух методов возврата сведений о продукте из класса `ProductsCL`: `GetProducts()` и `GetProductsByCategoryID(categoryID)`. Как и в случае с классом `ProductsBL` на уровне бизнес-логики, метод `GetProducts()` в CL возвращает сведения обо всех продуктах как объект `Northwind.ProductsDataTable`, а `GetProductsByCategoryID(categoryID)` возвращает все продукты из указанной категории.

В следующем коде показана часть методов класса `ProductsCL`:

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample5.vb)]

Сначала обратите внимание на атрибуты `DataObject` и `DataObjectMethodAttribute`, применяемые к классу и методам. Эти атрибуты предоставляют сведения в мастере ObjectDataSource s, указывающие, какие классы и методы должны отображаться в шагах мастера. Поскольку доступ к классам и методам CL осуществляется из элемента управления ObjectDataSource на уровне представления, я добавил эти атрибуты для улучшения работы во время разработки. См. Руководство по [созданию уровня бизнес-логики](../introduction/creating-a-business-logic-layer-vb.md) для более подробного описания этих атрибутов и их последствий.

В методах `GetProducts()` и `GetProductsByCategoryID(categoryID)` данные, возвращаемые методом `GetCacheItem(key)`, назначаются локальной переменной. Метод `GetCacheItem(key)`, который мы рассмотрим вскоре, возвращает определенный элемент из кэша на основе указанного *ключа*. Если такие данные не найдены в кэше, они извлекаются из соответствующего метода `ProductsBLL` класса, а затем добавляются в кэш с помощью метода `AddCacheItem(key, value)`.

Методы `GetCacheItem(key)` и `AddCacheItem(key, value)` интерфейсом с кэшем данных, считывающими и записывающими значения соответственно. Метод `GetCacheItem(key)` является более простым из двух. Он просто возвращает значение из класса Cache, используя переданный *ключ*:

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample6.vb)]

`GetCacheItem(key)` не использует значение *ключа* , как указано, а вызывает метод `GetCacheKey(key)`, который возвращает *ключ* , добавленный в начале продуктскаче-. `MasterCacheKeyArray`, содержащий строку Продуктскаче, также используется методом `AddCacheItem(key, value)`, как будет видно мгновенно.

Из класса кода программной части ASP.NET Page можно получить доступ к кэшу данных с помощью свойства `Page` класса [`Cache`](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)и допустить синтаксис, подобный `Cache("key") = value`, как описано на шаге 2. Из класса в архитектуре доступ к кэшу данных можно получить с помощью `HttpRuntime.Cache` или `HttpContext.Current.Cache`. Запись блога [Питер Джонсон](https://weblogs.asp.net/pjohnson/default.aspx) [httpRuntime. Cache и HttpContext. Current. Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) замещает небольшое преимущество в производительности при использовании `HttpRuntime` вместо `HttpContext.Current`; Следовательно, `ProductsCL` использует `HttpRuntime`.

> [!NOTE]
> Если архитектура реализуется с помощью проектов библиотеки классов, необходимо добавить ссылку на `System.Web` сборку, чтобы использовать классы [`HttpRuntime`](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) и [`HttpContext`](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) .

Если элемент не найден в кэше, методы `ProductsCL` класса s получают данные из слоя BLL и добавляют их в кэш с помощью метода `AddCacheItem(key, value)`. Чтобы добавить *значение* в кэш, можно использовать следующий код, который использует время истечения 60 секунды.

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample7.vb)]

`DateTime.Now.AddSeconds(CacheDuration)` указывает время истечения срока действия в 60 секунд в будущем, в то время как [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) указывает на отсутствие скользящего срока действия. Хотя эта перегрузка метода `Insert` имеет входные параметры как для абсолютного, так и для скользящего срока действия, можно предоставить только одно из двух. При попытке указать и абсолютное время, и интервал времени метод `Insert` вызовет исключение `ArgumentException`.

> [!NOTE]
> Эта реализация метода `AddCacheItem(key, value)` в настоящее время имеет несколько недостатков. Мы будем решать и преодолеть эти проблемы на шаге 4.

## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a>Шаг 4. непроверяемый кэш при изменении данных с помощью архитектуры

Наряду с методами получения данных, уровень кэширования должен предоставлять те же методы, что и BLL для вставки, обновления и удаления данных. Методы изменения данных в CL s не изменяют кэшированные данные, а вызывают соответствующий метод изменения данных BLL, а затем делают кэш недействительным. Как было показано в предыдущем учебном курсе, это то же поведение, которое элемент ObjectDataSource применяет при включении функций кэширования, а также при вызове методов `Insert`, `Update`или `Delete`.

Следующая перегрузка `UpdateProduct` показывает, как реализовать методы изменения данных в CL:

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample8.vb)]

Вызывается соответствующий метод уровня бизнес-логики модификации данных, но до возврата ответа необходимо сделать кэш недействительным. К сожалению, аннулирование кэша не является простым, поскольку `ProductsCL` классов `GetProducts()` и методы `GetProductsByCategoryID(categoryID)` каждый из них добавляют элементы в кэш с разными ключами, а метод `GetProductsByCategoryID(categoryID)` добавляет отдельный элемент кэша для каждого уникального *CategoryID*.

При непроверке кэша необходимо удалить *все* элементы, которые могли быть добавлены классом `ProductsCL`. Это можно сделать, связав *зависимость кэша* с каждым элементом, добавленным в кэш в методе `AddCacheItem(key, value)`. Как правило, зависимость кэша может быть другим элементом в кэше, файлом в файловой системе или данными из базы данных Microsoft SQL Server. При изменении или удалении зависимости из кэша элементы кэша, с которыми он связан, автоматически удаляются из кэша. В этом руководстве мы хотим создать дополнительный элемент в кэше, который служит зависимостью кэша для всех элементов, добавленных с помощью класса `ProductsCL`. Таким образом, все эти элементы можно удалить из кэша, просто удалив зависимость кэша.

Добавим метод `AddCacheItem(key, value)`, чтобы каждый элемент, добавленный в кэш с помощью этого метода, был связан с единственной зависимостью кэша:

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample9.vb)]

`MasterCacheKeyArray` — это массив строк, содержащий одно значение Продуктскаче. Сначала элемент кэша добавляется в кэш и ему присваивается текущая дата и время. Если элемент кэша уже существует, он обновляется. Далее создается зависимость кэша. Конструктор [`CacheDependency` класса](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s имеет ряд перегрузок, но в нем используется два входных массива `String`. Первый указывает набор файлов, которые будут использоваться в качестве зависимостей. Поскольку мы не будем использовать зависимости на основе файлов, для первого входного параметра используется значение `Nothing`. Второй входной параметр задает набор ключей кэша для использования в качестве зависимостей. Здесь мы указываем одну зависимость, `MasterCacheKeyArray`. Затем `CacheDependency` передается в метод `Insert`.

С этим изменением в `AddCacheItem(key, value)`недействительность кэша сводится к удалению зависимости.

[!code-vb[Main](caching-data-in-the-architecture-vb/samples/sample10.vb)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a>Шаг 5. вызов слоя кэширования из уровня представления

Классы и методы уровня кэширования можно использовать для работы с данными с помощью методов, которые мы проверили в рамках этих руководств. Чтобы продемонстрировать работу с кэшированными данными, сохраните изменения в классе `ProductsCL`, а затем откройте страницу `FromTheArchitecture.aspx` в папке `Caching` и добавьте GridView. Из смарт-тега GridView s создайте новый элемент ObjectDataSource. В первом шаге мастера вы увидите класс `ProductsCL` в качестве одного из вариантов из раскрывающегося списка.

[![класс Продуктскл включен в раскрывающийся список бизнес-объектов](caching-data-in-the-architecture-vb/_static/image5.png)](caching-data-in-the-architecture-vb/_static/image4.png)

**Рис. 4**. класс `ProductsCL` входит в раскрывающийся список бизнес-объектов ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-in-the-architecture-vb/_static/image6.png))

После выбора `ProductsCL`нажмите кнопку Далее. Раскрывающийся список на вкладке Выбор содержит два элемента: `GetProducts()` и `GetProductsByCategoryID(categoryID)`, а вкладка обновление имеет единственную `UpdateProduct` перегрузку. Выберите метод `GetProducts()` на вкладке "выбор" и метод `UpdateProducts` на вкладке "обновление" и нажмите кнопку "Готово".

[![методы класса Продуктскл перечислены в раскрывающихся списках.](caching-data-in-the-architecture-vb/_static/image8.png)](caching-data-in-the-architecture-vb/_static/image7.png)

**Рис. 5**. методы `ProductsCL` классов перечислены в раскрывающихся списках ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-in-the-architecture-vb/_static/image9.png)).

После завершения работы мастера Visual Studio задаст свойству `OldValuesParameterFormatString` ObjectDataSource s значение `original_{0}` и добавить соответствующие поля в GridView. Снова задайте для свойства `OldValuesParameterFormatString` значение по умолчанию, `{0}`и настройте GridView для поддержки разбиения по страницам, сортировки и редактирования. Поскольку перегрузка `UploadProducts`, используемая модулем CL, принимает только измененное имя и цену продукта, ограничьте GridView таким образом, чтобы только эти поля были доступны для изменения.

В предыдущем учебном курсе мы определили GridView для включения полей `ProductName`, `CategoryName`и `UnitPrice` полей. Вы можете реплицировать форматирование и структуру. в этом случае декларативная разметка GridView и ObjectDataSource s должна выглядеть следующим образом:

[!code-aspx[Main](caching-data-in-the-architecture-vb/samples/sample11.aspx)]

На этом этапе у нас есть страница, использующая уровень кэширования. Чтобы увидеть, как выполняется кэширование, установите точки останова в `ProductsCL` классов `GetProducts()` и методах `UpdateProduct`. Откройте страницу в браузере и пошаговым кодом при сортировке и разбиении на страницы, чтобы просмотреть данные, извлеченные из кэша. Затем обновите запись и обратите внимание, что кэш становится недействительным и, следовательно, извлекается из BLL при повторной привязке данных к GridView.

> [!NOTE]
> Уровень кэширования, указанный в загружаемом файле, прилагаемом к этой статье, не является полным. Он содержит только один класс, `ProductsCL`, который всего лишь несколько методов. Более того, только одна страница ASP.NET использует CL (`~/Caching/FromTheArchitecture.aspx`) все остальные по-прежнему ссылаются на BLL напрямую. Если вы планируете использовать в приложении CL-компилятор, все вызовы из уровня представления должны переключиться на CL, что потребует, чтобы классы и методы CL-компилятора сосмотрели эти классы и методы в BLL, который в настоящее время используется уровнем представления данных.

## <a name="summary"></a>Сводка

Хотя кэширование можно применять на уровне представления с ASP.NET 2,0 s SqlDataSource и элементами управления ObjectDataSource, в идеале обязанности кэширования будут делегированы на отдельный слой в архитектуре. В этом руководстве мы создали слой кэширования, который находится между уровнем представления и уровнем бизнес-логики. Уровень кэширования должен предоставлять тот же набор классов и методов, которые существуют в BLL и вызываются из уровня представления данных.

Примеры уровней кэширования, рассмотренные в этом и предыдущих руководствах, демонстрирующие *перезагрузку*. При использовании реактивной загрузки данные загружаются в кэш только при запросе данных и отсутствии данных в кэше. Данные также можно *заранее загрузить* в кэш — метод, который загружает данные в кэш до того, как он действительно нужен. В следующем учебном курсе мы рассмотрим пример упреждающего загрузки, когда мы рассмотрим, как хранить статические значения в кэше при запуске приложения.

Поздравляем с программированием!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP. NET и основатель [4GuysFromRolla.com](http://www.4guysfromrolla.com), работал с веб-технологиями Майкрософт с 1998. Скотт работает как независимый консультант, преподаватель и модуль записи. Его последняя книга — [*Sams обучать себя ASP.NET 2,0 за 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Он доступен по адресу [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти по адресу [http://ScottOnWriting.NET](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Специальная благодарность

Эта серия руководств была рассмотрена многими полезными рецензентами. Специалист по интересу для этого руководства был Терезой Мерфи. Хотите ознакомиться с моими будущими статьями MSDN? Если это так, расположите строку в [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](caching-data-with-the-objectdatasource-vb.md)
> [Вперед](caching-data-at-application-startup-vb.md)
