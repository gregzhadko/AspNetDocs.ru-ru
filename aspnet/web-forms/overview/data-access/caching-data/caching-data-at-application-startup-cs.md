---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
title: Кэширование данных при запуске приложенияC#() | Документация Майкрософт
author: rick-anderson
description: В любом веб-приложении будут часто использоваться некоторые данные, и некоторые данные будут использоваться редко. Мы можем улучшить производительность нашего ASP.NET приложения b...
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 22ca8efa-7cd1-45a7-b9ce-ce6eb3b3ff95
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
msc.type: authoredcontent
ms.openlocfilehash: a0b55b0df1b7843120de284891e16178df23fabe
ms.sourcegitcommit: fe5c7512383a9b0a05d321ff10d3cca1611556f0
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/05/2019
ms.locfileid: "70386561"
---
# <a name="caching-data-at-application-startup-c"></a>Кэширование данных при запуске приложения (C#)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Загрузить PDF-файл](caching-data-at-application-startup-cs/_static/datatutorial60cs1.pdf)

> В любом веб-приложении будут часто использоваться некоторые данные, и некоторые данные будут использоваться редко. Мы можем улучшить производительность нашего приложения ASP.NET, заранее загрузив часто используемые данные — методику, называемую кэшированием. В этом руководстве демонстрируется один из подходов к профилактической загрузке, который заключается в загрузке данных в кэш при запуске приложения.

## <a name="introduction"></a>Вступление

Два предыдущих руководства Просмотрели кэширование данных на уровнях представления и кэширования. При [кэшировании данных с помощью ObjectDataSource](caching-data-with-the-objectdatasource-cs.md)мы рассматривали использование функций кэширования ObjectDataSource для кэширования данных на уровне представления. [Кэширование данных в архитектуре](caching-data-in-the-architecture-cs.md) , изучая кэширование на новом отдельном уровне кэширования. В обоих учебниках используются *реактивные загрузки* при работе с кэшем данных. При использовании реактивной загрузки каждый раз, когда данные запрашиваются, система сначала проверяет, находится ли он в кэше. В противном случае он извлекает данные из исходного источника, например базы данных, а затем сохраняет их в кэше. Основное преимущество реактивной загрузки заключается в простоте реализации. Один из его недостатков — это неравномерное снижение производительности между запросами. Представьте себе страницу, которая использует уровень кэширования из предыдущего руководства для вывода сведений о продукте. При первом посещении этой страницы или посещении в первый раз после исключения кэшированных данных из-за ограничений памяти или истечения указанного срока действия данные должны быть получены из базы данных. Поэтому эти запросы пользователей будут занимать больше времени, чем запросы пользователей, которые могут обслуживаться кэшем.

*Упреждающее Загрузка* предоставляет альтернативную стратегию управления кэшем, которая позволяет сгладить производительность запросов, загружая кэшированные данные до того, как они понадобятся. Как правило, упреждающее Загрузка использует некоторый процесс, который либо периодически проверяет, либо уведомляется при обновлении базовых данных. Затем этот процесс обновляет кэш, чтобы он оставался в актуальном виде. Упреждающее Загрузка особенно полезна, если базовые данные поступают из медленного подключения к базе данных, веб-службы или некоторого другого источника данных с низкой скоростью. Но этот подход к профилактической загрузке сложнее реализовать, так как он требует создания, управления и развертывания процесса для проверки изменений и обновления кэша.

Еще одна разновидность упреждающего загрузки и тип, который мы будем изучать в этом руководстве, загружают данные в кэш при запуске приложения. Этот подход особенно полезен для кэширования статических данных, например записей в таблицах подстановки базы данных.

> [!NOTE]
> Более подробные сведения о различиях между упреждающим и переупреждающим загрузкой, а также списками достоинств, недостатков и рекомендаций по реализации см. в разделе [Управление содержимым кэша](https://msdn.microsoft.com/library/ms978503.aspx) в [руководстве по архитектуре кэширования для .NET. Приложения платформы](https://msdn.microsoft.com/library/ms978498.aspx).

## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a>Шаг 1. Определение данных для кэширования при запуске приложения

Примеры кэширования с использованием реактивной загрузки, которые мы рассматривали в предыдущих двух учебниках, хорошо подходят для данных, которые могут периодически изменяться и не занимают ексорбитантли времени для создания. Но если кэшированные данные никогда не изменяются, срок действия, используемый функцией реактивной загрузки, является избыточным. Аналогично, если кэшированные данные занимают слишком много времени для создания, то эти пользователи, чьи запросы находят пустой кэш, должны превращаться длительное время ожидания, пока извлекаются базовые данные. Рассмотрите возможность кэширования статических данных и данных, которые создаются очень долго во время запуска приложения.

Хотя базы данных имеют множество динамических, часто изменяемых значений, большинство из них также имеют адекватный объем статических данных. Например, практически все модели данных имеют один или несколько столбцов, содержащих определенное значение из фиксированного набора вариантов. Таблица базы данных может содержать столбец, набор значений которого может быть английским, испанский, французский, Русский, японский и т. д. `PrimaryLanguage` `Patients` Зачастую эти типы столбцов реализуются с помощью *таблиц подстановки*. Вместо того чтобы хранить строку на английском или французском языке `Patients` в таблице, создается вторая таблица, которая, как правило, содержит два столбца — уникальный идентификатор и строковое описание — с записью для каждого возможного значения. `PrimaryLanguage` Столбец`Patients` в таблице хранит соответствующий уникальный идентификатор в таблице уточняющих запросов. На рис. 1 в пациентах Джон Петров основной язык — английский, а ED Джонсон — русский.

![Таблица Languages — это таблица уточняющих запросов, используемая таблицей пациентов](caching-data-at-application-startup-cs/_static/image1.png)

**Рис. 1**. Таблица является таблицей подстановки, используемой `Patients` таблицей `Languages`

Пользовательский интерфейс для редактирования или создания нового пациента должен включать раскрывающийся список допустимых языков, заполненных записями в `Languages` таблице. Без кэширования при каждом посещении этого интерфейса система должна запрашивать `Languages` таблицу. Это непроизводительна и не требуется, так как значения таблицы подстановки изменяются очень редко, если когда-либо.

Мы можем кэшировать `Languages` данные с помощью тех же методов реактивной загрузки, которые были проверены в предыдущих руководствах. Однако при реактивной загрузке используется срок действия, основанный на времени, который не требуется для статических данных таблицы подстановки. Хотя кэширование с использованием реактивной загрузки было бы лучше, чем кэширование, лучшим подходом будет Предварительная загрузка данных таблицы подстановки в кэш при запуске приложения.

В этом учебнике будет рассмотрено кэширование данных таблицы подстановок и других статических сведений.

## <a name="step-2-examining-the-different-ways-to-cache-data"></a>Шаг 2. Анализ различных способов кэширования данных

Данные можно программно кэшировать в приложении ASP.NET, используя различные подходы. Мы уже видели, как использовать кэш данных в предыдущих руководствах. Кроме того, объекты можно программно кэшировать, используя *статические члены* или *состояние приложения*.

При работе с классом, как правило, для доступа к его членам сначала необходимо создать экземпляр класса. Например, чтобы вызвать метод из одного из классов на уровне бизнес-логики, необходимо сначала создать экземпляр класса:

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample1.cs)]

Прежде чем можно будет вызвать *SomeMethod* или работать с *сомепроперти*, сначала необходимо создать экземпляр `new` класса с помощью ключевого слова. *SomeMethod* и *сомепроперти* связаны с определенным экземпляром. Время существования этих элементов связано со временем существования связанного объекта. *Статические члены*, с другой стороны, являются переменными, свойствами и методами, которые являются общими для *всех* экземпляров класса и, следовательно, имеют время существования, пока класс. Статические члены обозначаются ключевым `static`словом.

Кроме статических элементов, данные можно кэшировать с помощью состояния приложения. Каждое приложение ASP.NET поддерживает коллекцию "имя-значение", которая является общей для всех пользователей и страниц приложения. Доступ к этой коллекции можно получить с [ `HttpContext` ](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)помощью [ `Application` свойства](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)класса и использовать из класса кода программной части страницы ASP.NET следующим образом:

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample2.cs)]

Кэш данных предоставляет более богатый API для кэширования данных, предоставляя механизмы для истечения срока действия, основанного на времени и зависимости, приоритеты элементов кэша и т. д. При использовании статических членов и состояния приложения такие функции должны добавляться разработчиком страницы вручную. При кэшировании данных при запуске приложения в течение времени существования приложения, однако, преимущества кэша данных затеи. В этом учебнике мы рассмотрим код, который использует все три метода кэширования статических данных.

## <a name="step-3-caching-thesupplierstable-data"></a>Шаг 3. Кэширование`Suppliers`данных таблицы

Таблицы базы данных Northwind, которые мы реализовали в качестве даты, не включают традиционные таблицы подстановки. Четыре таблицы данных, реализованные в DAL, являются таблицами модели, значения которых не являются статическими. Вместо того чтобы тратить время на добавление новой таблицы данных к слою DAL, а затем к новому классу и методам BLL, в этом руководстве мы просто предположим, что `Suppliers` данные таблицы являются статическими. Поэтому мы можем кэшировать эти данные при запуске приложения.

Чтобы начать, создайте `StaticCache.cs` `CL` в папке новый класс с именем.

![Создание класса StaticCache.cs в папке CL](caching-data-at-application-startup-cs/_static/image2.png)

**Рис. 2**. `StaticCache.cs` Создание класса`CL` в папке

Нам нужно добавить метод, который загружает данные при запуске в соответствующее хранилище кэша, а также методы, возвращающие данные из этого кэша.

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample3.cs)]

Приведенный выше код использует статическую переменную `suppliers`-член, для хранения результатов `SuppliersBLL` из `GetSuppliers()` метода класса, который вызывается из `LoadStaticCache()` метода. `LoadStaticCache()` Метод предназначен для вызова во время запуска приложения. После загрузки этих данных при запуске приложения любая страница, которая должна работать с данными поставщика, может вызвать `StaticCache` `GetSuppliers()` метод класса. Поэтому вызов базы данных для получения поставщиков происходит только один раз при запуске приложения.

Вместо использования статической переменной-члена в качестве хранилища кэша можно было бы использовать состояние приложения или кэш данных. В следующем коде показан класс для использования состояния приложения.

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample4.cs)]

В `LoadStaticCache()`данные о поставщике хранятся в *ключе*переменной приложения. Он возвращается в качестве соответствующего типа (`Northwind.SuppliersDataTable`) из. `GetSuppliers()` Хотя доступ к состоянию приложения можно получить в классах кода программной части страниц `Application["key"]`ASP.NET, используя, в архитектуре `HttpContext.Current.Application["key"]` , которую необходимо использовать для получения `HttpContext`текущего.

Аналогичным образом кэш данных можно использовать в качестве хранилища кэша, как показано в следующем коде:

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample5.cs)]

Чтобы добавить элемент в кэш данных без истечения времени действия, используйте `System.Web.Caching.Cache.NoAbsoluteExpiration` значения и `System.Web.Caching.Cache.NoSlidingExpiration` в качестве входных параметров. Была выбрана конкретная перегрузка `Insert` метода кэша данных, чтобы можно было указать *приоритет* элемента кэша. Приоритет используется для определения элементов, которые нужно очистить из кэша, если объем доступной памяти невелик. Здесь мы используем приоритет `NotRemovable`, который гарантирует, что этот элемент кэша не будет очищен.

> [!NOTE]
> В скачивании этого учебника реализуется класс, `StaticCache` использующий метод статической переменной члена. Код для методов состояния приложения и кэша данных доступен в комментариях в файле класса.

## <a name="step-4-executing-code-at-application-startup"></a>Шаг 4. Исполнение кода при запуске приложения

Чтобы выполнить код при первом запуске веб-приложения, необходимо создать специальный файл с именем `Global.asax`. Этот файл может содержать обработчики событий для событий приложения, сеанса и уровня запроса, и здесь можно добавить код, который будет выполняться при каждом запуске приложения.

`Global.asax` Добавьте файл в корневой каталог веб-приложения, щелкнув правой кнопкой мыши имя проекта веб-сайта в Обозреватель решений Visual Studio и выбрав пункт Добавить новый элемент. В диалоговом окне Добавление нового элемента выберите тип элемента глобальный класс приложения и нажмите кнопку Добавить.

> [!NOTE]
> Если у вас уже есть `Global.asax` файл в проекте, тип элемента глобальный класс приложения не будет отображаться в диалоговом окне Добавление нового элемента.

[![Добавление файла Global. asax в корневой каталог веб-приложения](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)

**Рис. 3**. Добавьте файл в корневой каталог веб-приложения ([щелкните, чтобы просмотреть изображение с полным размером)](caching-data-at-application-startup-cs/_static/image5.png) `Global.asax`

Шаблон файла `Global.asax` по умолчанию включает пять методов в тег на стороне `<script>` сервера:

- **`Application_Start`** выполняется при первом запуске веб-приложения
- **`Application_End`** выполняется при завершении работы приложения
- **`Application_Error`** выполняется всякий раз, когда необработанное исключение достигает приложения
- **`Session_Start`** выполняется при создании нового сеанса
- **`Session_End`** выполняется при истечении срока действия или прекращении сеанса

Обработчик `Application_Start` событий вызывается только один раз во время жизненного цикла приложения. Приложение запускается при первом запросе ресурса ASP.NET из приложения и продолжит работу до перезапуска приложения, что может произойти путем изменения содержимого `/Bin` папки, изменения `Global.asax`, изменения содержимое папки или `Web.config` изменение файла, помимо прочего, приводит к другим причинам. `App_Code` Дополнительные сведения о жизненном цикле приложения см. в статье [Обзор жизненного цикла приложения ASP.NET](https://msdn.microsoft.com/library/ms178473.aspx) .

В этих руководствах нам нужно только добавить код в `Application_Start` метод, поэтому вы можете удалить другие. В `Application_Start` `LoadStaticCache()` просто`StaticCache` вызовите метод класса, который будет загружать и кэшировать сведения о поставщике:

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample6.aspx)]

Вот и все! При запуске `LoadStaticCache()` приложения метод захватит сведения о поставщике из BLL и сохранит его в статической переменной-члене (или `StaticCache` в любом хранилище кэша, которое вы завершили с помощью в классе). Чтобы проверить это поведение, установите точку останова в `Application_Start` методе и запустите приложение. Обратите внимание, что точка останова достигается при запуске приложения. Однако последующие запросы не приводят `Application_Start` к выполнению метода.

[![Использование точки останова для проверки выполнения обработчика событий Application_Start](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)

**Рис. 4**. Использование точки останова для проверки `Application_Start` выполнения обработчика событий ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-at-application-startup-cs/_static/image8.png))

> [!NOTE]
> Если вы не достигли `Application_Start` точки останова при первом запуске отладки, это связано с тем, что приложение уже запущено. Принудительно перезапустите приложение, изменив `Global.asax` файлы `Web.config` или, а затем повторите попытку. Чтобы быстро перезапустить приложение, можно просто добавить (или удалить) пустую строку в конце одного из этих файлов.

## <a name="step-5-displaying-the-cached-data"></a>Шаг 5. Отображение кэшированных данных

На этом этапе `StaticCache` класс имеет версию данных поставщика, кэшированную при запуске приложения, доступ к которому можно получить `GetSuppliers()` с помощью метода. Для работы с этими данными на уровне представления данных можно использовать ObjectDataSource или программно вызвать `StaticCache` `GetSuppliers()` метод класса из класса кода программной части страницы ASP.NET. Рассмотрим использование элементов управления ObjectDataSource и GridView для отображения кэшированных сведений о поставщике.

Для начала откройте `AtApplicationStartup.aspx` страницу `Caching` в папке. Перетащите элемент GridView из области элементов в конструктор, установив для `ID` `Suppliers`его свойства значение. Затем в смарт-теге GridView выберите Создание нового элемента ObjectDataSource с именем `SuppliersCachedDataSource`. Настройте ObjectDataSource для использования `StaticCache` `GetSuppliers()` метода класса.

[![Настройка ObjectDataSource для использования класса Статиккаче](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)

**Рис. 5**. Настройка ObjectDataSource для использования `StaticCache` класса ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-at-application-startup-cs/_static/image11.png))

[![Получение кэшированных данных о поставщике с помощью метода-поставщика ()](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)

**Рис. 6**. Использование метода для получения кэшированных данных поставщика ([щелкните, чтобы просмотреть изображение с полным размером)](caching-data-at-application-startup-cs/_static/image14.png) `GetSuppliers()`

После завершения работы мастера Visual Studio автоматически добавит BoundFields для каждого поля данных в `SuppliersDataTable`. Декларативная разметка GridView и ObjectDataSource должна выглядеть следующим образом:

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample7.aspx)]

На рис. 7 показана страница при просмотре в браузере. Выходные данные те же, что были извлечены из `SuppliersBLL` класса BLL, но `StaticCache` использование класса возвращает данные поставщика в кэше при запуске приложения. Чтобы проверить это поведение, можно задать `StaticCache` точки останова в `GetSuppliers()` методе класса.

[![Кэшированные данные поставщика отображаются в элементе управления GridView](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)

**Рис. 7**. Кэшированные данные поставщика отображаются в элементе управления GridView ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-at-application-startup-cs/_static/image17.png)).

## <a name="summary"></a>Сводка

Большинство моделей данных содержат достаточное количество статических данных, которые обычно реализуются в виде таблиц подстановки. Поскольку эти сведения являются статическими, нет причин постоянного доступа к базе данных каждый раз, когда необходимо отобразить эту информацию. Более того, из-за статической природы при кэшировании данных нет необходимости в истечении срока действия. В этом учебнике мы увидели, как взять такие данные и кэшировать их в кэше данных, состоянии приложения и через статическую переменную-член. Эта информация кэшируется при запуске приложения и остается в кэше в течение всего времени существования приложения.

В этом руководстве и двух прошлых уроках мы Просмотрели кэширование данных в течение времени существования приложения, а также истечение срока действия с учетом времени. Однако при кэшировании данных базы данных срок действия, основанный на времени, может быть менее идеальным. Вместо периодического сброса кэша было бы оптимальным только выключать кэшированный элемент при изменении базовых данных базы данных. Этот идеальный вариант можно реализовать с помощью зависимостей кэша SQL, которые мы рассмотрим в следующем руководстве.

Поздравляем с программированием!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP. NET и основатель [4GuysFromRolla.com](http://www.4guysfromrolla.com), работал с веб-технологиями Майкрософт с 1998. Скотт работает как независимый консультант, преподаватель и модуль записи. Его последняя книга — [*Sams обучать себя ASP.NET 2,0 за 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Он доступен по адресу [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти по адресу [http://ScottOnWriting.NET](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Специальная благодарность

Эта серия руководств была рассмотрена многими полезными рецензентами. Потенциальным рецензентам для этого учебника были Терезой Мерфи и Зак Jones. Хотите ознакомиться с моими будущими статьями MSDN? Если это так, удалите строку в [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](caching-data-in-the-architecture-cs.md)
> [Вперед](using-sql-cache-dependencies-cs.md)
