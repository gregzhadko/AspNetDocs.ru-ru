---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-vb
title: Кэширование данных при запуске приложения (Visual Basic) | Документация Майкрософт
author: rick-anderson
description: В любой веб-приложении некоторые данные будут часто использоваться, и некоторые данные будут использоваться редко. Мы может повысить производительность приложения в наших ASP.NET...
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 84afe4ac-cc53-4f2e-a867-27eaf692c2df
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-vb
msc.type: authoredcontent
ms.openlocfilehash: 58c4654691084b9574283c03c77398cb43f6751a
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59393474"
---
# <a name="caching-data-at-application-startup-vb"></a>Кэширование данных при запуске приложения (VB)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачать PDF](caching-data-at-application-startup-vb/_static/datatutorial60vb1.pdf)

> В любой веб-приложении некоторые данные будут часто использоваться, и некоторые данные будут использоваться редко. Мы может повысить производительность приложения ASP.NET, часто используемые данные, подход, называемый загружая заранее. Этот учебник демонстрирует один из способов упреждающего загрузки, которая является загрузка данных в кэш при запуске приложения.


## <a name="introduction"></a>Вступление

Два предыдущих руководствах рассмотрели кэширования данных в представления и слои кэширования. В [кэширование данных с помощью ObjectDataSource](caching-data-with-the-objectdatasource-vb.md), мы рассмотрели применение s ObjectDataSource, функций для кэширования данных на уровне представления данных кэширования. [Кэширование данных в архитектуре](caching-data-in-the-architecture-vb.md) проверить кэширование в новый, отдельный уровень кэширования. Оба этих учебниках используется *реактивного загрузки* при работе с кэшем данных. При загрузке реактивное, каждый раз, запрашиваются данные, система сначала проверяет его s в кэше. В противном случае он извлекает данные из исходного источника, например базы данных, а затем сохраняет его в кэше. Главным преимуществом режима реактивного загрузка является его Простота реализации. Одна из его недостатки — своей ненадежности всех запросов. Представьте себе страницы, использующей уровень кэширования из предыдущего учебника для отображения сведений о продукте. Когда эта страница посещен впервые или посещен впервые после кэшированных данных исключен из-за нехватки памяти или достигнут указанный срок действия, необходимо получить данные из базы данных. Таким образом эти запросы пользователей потребуется больше времени, чем запросы пользователей, которые могут обрабатываться кэшем.

*Упреждающая загрузка* предоставляет стратегию управления альтернативные кэша, позволяет сгладить производительность запросов путем загрузки необходимых кэшированных данных перед его. Как правило упреждающая загрузка использует какой-либо процесс, который периодически проверяет или получает уведомление, когда была обновление базовых данных. Затем этот процесс обновляет кэш, чтобы обеспечить актуальность. Упреждающая загрузка — это особенно полезно в том случае, если базовые данные поступают из подключения к базе данных медленно, веб-службы или другого источника данных, особенно низкой производительностью. Но этот подход, чтобы упреждающая загрузка сложнее, так как требует создания, управления и развертывания процесса для проверки изменений и обновления кэша.

Иная разновидность упреждающая загрузка, а тип, в этом руководстве мы будем изучать загружает данные в кэш при запуске приложения. Этот подход особенно полезен для кэширования статических данных, таких как записи в таблицах базы данных поиска.

> [!NOTE]
> Более подробно рассмотрим различия между проактивное и реактивное загрузки, а также список преимуществ, недостатков и рекомендации по реализации, см. в разделе [управление содержимое кэша](https://msdn.microsoft.com/library/ms978503.aspx) раздел [ Кэширование руководство по архитектуре для приложений .NET Framework](https://msdn.microsoft.com/library/ms978498.aspx).


## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a>Шаг 1. Определить, какие данные кэша при запуске приложения

Примеры кэширования, с помощью реактивного загрузки было рассмотрено в предыдущих двух учебных правильно работали с данных, периодически могут измениться и не принимает exorbitantly длинное для создания. Но если кэшированные данные не изменяются, истечения срока действия, используемые реактивного загрузка является излишним. Аналогично Если кэширование данных занимает очень много времени для создания, затем этих пользователей, которых запросы поиска, очищать кэш будет придется сталкиваться с длинными Подождите, пока базовые данные извлекаются. Рассмотрите возможность кэширования статических данных и данных, который принимает слишком долго для создания при запуске приложения.

Баз данных, имеют много динамической, часто изменяющиеся значения, большинство имеется значительный объем статических данных. Например практически все модели данных имеют один или несколько столбцов, содержащих определенное значение из фиксированного набора вариантов. Объект `Patients` таблица базы данных может иметь `PrimaryLanguage` столбца, может быть, набор значений, английский, испанский, французский, русский, японский и т. д. Очень часто этих типов столбцов реализуются с помощью *таблиц подстановки*. Вместо того чтобы хранить строки английский или французский в `Patients` , во второй таблице созданная таблица имеет, как правило, два столбца — это уникальный идентификатор и строковое описание — с помощью записи для каждого возможного значения. `PrimaryLanguage` Столбца в `Patients` таблица содержит соответствующий уникальный идентификатор в таблице уточняющих запросов. На рис. 1 пациента John Doe s основной язык является английский, а Джонсон Ed s — русский.


![Таблица языков является используемое таблицы подстановки таблицей пациентов](caching-data-at-application-startup-vb/_static/image1.png)

**Рис. 1**: `Languages` Таблица — поиск таблицы используется `Patients` таблицы


Пользовательский интерфейс для редактирования или создания нового пациента будет включать стрелку раскрывающегося списка допустимых языков, взят из записей в `Languages` таблицы. Без кэширования, каждый раз, этот интерфейс является посещен система должна запрос `Languages` таблицы. Это дополнительными издержками и ненужных с момента появления значения таблицы подстановки изменения в очень редких случаях, если когда-либо.

Мы можете кэшировать `Languages` данных, используя те же способы реактивного загрузки, проверяются в предыдущих учебных курсах. Тем не менее, реактивные загрузка использует срок действия по времени, которое не требуется для статических Уточняющий запрос таблицы данных. Во время кэширования с помощью реактивных загрузки будет лучше, чем отсутствие кэширования, наилучший подход будет заранее загрузить данные таблицы подстановки в кэш при запуске приложения.

В этом руководстве мы рассмотрим как данные таблицы подстановки кэша и другие статические данные.

## <a name="step-2-examining-the-different-ways-to-cache-data"></a>Шаг 2. Изучение различных способов кэширования данных

Данные могут кэшироваться программным способом в приложении ASP.NET, используя различные подходы. Мы ve уже видели, как использовать кэш данных в предыдущих учебных курсах. Кроме того, объекты можно программным способом кэшировать с помощью *статические члены* или *состояние приложения*.

При работе с классом, обычно необходимо сначала создать экземпляр класса можно получить доступ к его члены. Например чтобы вызвать метод от одного из классов в наш бизнес-логики, необходимо сначала создать экземпляр класса:


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample1.vb)]

Прежде чем мы можно вызвать *SomeMethod* или работать с *SomeProperty*, необходимо сначала создать экземпляр класса с помощью `New` ключевое слово. *SomeMethod* и *SomeProperty* связаны с конкретным экземпляром. Время существования этих членов привязывается к времени существования их связанного объекта. *Статические члены*, с другой стороны, являются переменные, свойства и методы, которые являются общими для *все* экземпляры класса и, следовательно, имеют срок существования условии, что класс. Статические члены отмечены ключевым словом `Shared`.

В дополнение к статические члены данные могут быть кэшированы с помощью состояния приложения. Каждое приложение ASP.NET поддерживает коллекцию имя/значение, s, общих для всех пользователей и страницы приложения. Эта коллекция может осуществляться с использованием [ `HttpContext` класс](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) s [ `Application` свойство](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)и использования из кода класса страницы s ASP.NET следующим образом:


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample2.vb)]

Кэш данных предоставляет гораздо более широкие API для кэширования данных, предоставляя механизмы кэше на основе времени и зависимостей, приоритеты элемента кэша и т. д. Статические члены и состояния приложения такие функции, необходимо вручную добавить разработчиком страницы. При кэшировании данных при запуске приложения в течение времени существования приложения, тем не менее, данные кэша s преимущества заключаются в комбинированного. В этом руководстве мы рассмотрим код, который использует все три метода для кэширования статических данных.

## <a name="step-3-caching-thesupplierstable-data"></a>Шаг 3. Кэширование`Suppliers`данные таблицы

Базы данных Northwind, таблицы базы данных мы ve, реализованные для даты не включают все таблицы подстановки традиционных. Четыре DataTables в DAL реализован все таблицы модели, значения которых не являются статическими. Вместо того чтобы тратить время, чтобы добавить новую таблицу данных DAL, а затем новый класс и методы в BLL, для этого учебника просто позволить s притвориться, `Suppliers` таблицы s данные являются статическими. Таким образом мы может кэшировать эти данные при запуске приложения.

Чтобы начать, создайте новый класс с именем `StaticCache.cs` в `CL` папку.


![Создайте класс StaticCache.vb в папке CL](caching-data-at-application-startup-vb/_static/image2.png)

**Рис. 2**: Создание `StaticCache.vb` в класс `CL` папки


Нам нужно добавить метод, который загружает данные во время запуска в хранилище соответствующие кэша, а также методы, возвращающие данные из этого кэша.


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample3.vb)]

Приведенный выше код использует статическую переменную-член, `suppliers`, для хранения результатов из `SuppliersBLL` класс s `GetSuppliers()` метод, который вызывается из `LoadStaticCache()` метод. `LoadStaticCache()` Метод предназначен для вызова во время запуска приложения s. После этого данные были загружены при запуске приложения, можно вызвать любой страницы, для работы с поставщиком данных `StaticCache` класс s `GetSuppliers()` метод. Таким образом вызов к базе данных для получения поставщиков происходит только один раз, при запуске приложения.

Вместо того чтобы, используя статическую переменную-член в качестве хранилища кэша, можно было бы также использовать состояние приложения или в кэше данных. В следующем коде показано класс retooled использовать состояние приложения:


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample4.vb)]

В `LoadStaticCache()`, сведения о поставщиках хранятся в переменную приложения *ключ*. Он s возвращаются в виде соответствующего типа (`Northwind.SuppliersDataTable`) из `GetSuppliers()`. Хотя состояние приложения может осуществляться в классы фонового кода страницы ASP.NET с использованием `Application("key")`, в архитектуре, необходимо использовать `HttpContext.Current.Application("key")` для получения текущего `HttpContext`.

Аналогичным образом кэш данных можно использовать как хранилище кэша, как показано в следующем коде:


[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample5.vb)]

Чтобы добавить элемент в кэш данных и без срока действия по времени, используйте `System.Web.Caching.Cache.NoAbsoluteExpiration` и `System.Web.Caching.Cache.NoSlidingExpiration` значения как входные параметры. Данная конкретная перегрузка кэш данных s `Insert` был выбран метод, чтобы мы могли указать *приоритет* элемента кэша. Приоритет используется, чтобы определить, какие элементы нужно удалить из кэша, когда не хватает доступной памяти. Здесь мы используем приоритет `NotRemovable`, которое гарантирует, что не очистки для этого элемента кэша.

> [!NOTE]
> Реализует этот учебник s загружаемый `StaticCache` класса подходе переменной статического члена. Код для методов кэша состояния и данных приложения находится в комментарии в файле класса.


## <a name="step-4-executing-code-at-application-startup"></a>Шаг 4. Выполнение кода при запуске приложения

Чтобы выполнить код при первом запуске веб-приложения, необходимо создать специальный файл с именем `Global.asax`. Этот файл может содержать обработчики событий для приложения-, сеанс- и события на уровне запроса, который здесь где можно добавить код, который будет выполняться при каждом запуске приложения.

Добавить `Global.asax` файл web s корневом каталоге приложения, щелкнув имя проекта веб-сайта в Visual Studio s обозревателе решений и выбрав Add New Item. В диалоговом окне Add New Item выберите тип элемента глобальный класс приложения и нажмите кнопку «Добавить».

> [!NOTE]
> Если у вас уже есть `Global.asax` файл в проекте, глобальный класс приложения, тип элемента не будет отображаться в диалоговом окне Добавление нового элемента.


[![Aдд файле Global.asax, чтобы ваш веб-приложение s корневой каталог](caching-data-at-application-startup-vb/_static/image4.png)](caching-data-at-application-startup-vb/_static/image3.png)

**Рис. 3**: Добавить `Global.asax` файл на свой веб-приложение s корневой каталог ([Просмотр полноразмерного изображения](caching-data-at-application-startup-vb/_static/image5.png))


Значение по умолчанию `Global.asax` шаблона файла включает пять методов на стороне сервера `<script>` тега:

- **`Application_Start`** выполняется при первом запуске веб-приложения
- **`Application_End`** выполняется, когда приложение завершает работу
- **`Application_Error`** выполняется всегда, когда необработанное исключение достигает приложения
- **`Session_Start`** выполняется при создании нового сеанса
- **`Session_End`** выполняется, когда сеанс истек срок действия или прерван

`Application_Start` Обработчик событий вызывается только один раз во время жизненного цикла приложения s. Приложение запускается в первый раз ресурса ASP.NET запрашивается из приложения и продолжает выполняться до перезапуска приложения, которой может произойти, если изменение содержимого `/Bin` папки, изменение `Global.asax`, изменение содержимое в `App_Code` папку или изменив `Web.config` файл другими причинами. Ссылаться на [Общие сведения о жизненном цикле приложения ASP.NET](https://msdn.microsoft.com/library/ms178473.aspx) для более подробный рассказ о жизненном цикле приложения.

Для этих учебников необходимо только добавить код, чтобы `Application_Start` метод, поэтому можно удалить остальные. В `Application_Start`, просто вызовите `StaticCache` класс s `LoadStaticCache()` метод, который будет загружен и кэширование сведений о поставщике:


[!code-aspx[Main](caching-data-at-application-startup-vb/samples/sample6.aspx)]

Все, что s — его! При запуске приложения `LoadStaticCache()` метод получения сведений о поставщике из BLL и сохраните его в статическую переменную-член (или любой кэш хранить вы в итоге в `StaticCache` класса). Чтобы проверить это, установите точку останова в `Application_Start` метод и запустите приложение. Обратите внимание на то, что точка останова достигается при запуске приложения. Последующие запросы, но не вызывают `Application_Start` для выполнения метода.


[![USE точку останова, чтобы убедитесь, что обработчик событий Application_Start выполняемой](caching-data-at-application-startup-vb/_static/image7.png)](caching-data-at-application-startup-vb/_static/image6.png)

**Рис. 4**: Использовать точку останова, чтобы проверить, `Application_Start` обработчик событий — выполняемой ([Просмотр полноразмерного изображения](caching-data-at-application-startup-vb/_static/image8.png))


> [!NOTE]
> Если не достигнуто `Application_Start` точки останова, при первом запуске отладки, это, поскольку приложение уже запущена. Принудительно применить для перезапуска, изменив вашей `Global.asax` или `Web.config` файлы, а затем повторите попытку. Можно просто добавить (или удалить) пустую строку в конце один из этих файлов, чтобы быстро перезапустить приложение.


## <a name="step-5-displaying-the-cached-data"></a>Шаг 5. Отображение всех кэшированных данных

На этом этапе `StaticCache` класс имеет версию поставщика данных, кэшированных при запуске приложения, который можно получить с помощью его `GetSuppliers()` метод. Для работы с этими данными от слоя представления, можно использовать элемент управления ObjectDataSource или программный вызов `StaticCache` класс s `GetSuppliers()` метод из класса фонового кода страницы s ASP.NET. Позвольте расскажем об использовании элементов управления ObjectDataSource и GridView для отображения сведений о поставщике кэшированных s.

Сначала откройте `AtApplicationStartup.aspx` странице в `Caching` папку. Перетащите элемент управления GridView с панели элементов в конструктор, установив его `ID` свойства `Suppliers`. Затем из GridView s смарт-тега выберите Создание нового источника ObjectDataSource с именем `SuppliersCachedDataSource`. Настройка ObjectDataSource на использование `StaticCache` класс s `GetSuppliers()` метод.


[![CНастройка ObjectDataSource на использование класса StaticCache](caching-data-at-application-startup-vb/_static/image10.png)](caching-data-at-application-startup-vb/_static/image9.png)

**Рис. 5**: Настройка ObjectDataSource на использование `StaticCache` класс ([Просмотр полноразмерного изображения](caching-data-at-application-startup-vb/_static/image11.png))


[![USE GetSuppliers() метод для извлечения данных кэшируются поставщика](caching-data-at-application-startup-vb/_static/image13.png)](caching-data-at-application-startup-vb/_static/image12.png)

**Рис. 6**: Используйте `GetSuppliers()` метод для извлечения данных кэшируются поставщика ([Просмотр полноразмерного изображения](caching-data-at-application-startup-vb/_static/image14.png))


После завершения работы мастера, Visual Studio автоматически добавит полей BoundField для каждого из полей данных в `SuppliersDataTable`. GridView и ObjectDataSource s декларативной разметке должен выглядеть следующим образом:


[!code-aspx[Main](caching-data-at-application-startup-vb/samples/sample7.aspx)]

Рис. 7 показана страница в обозревателе. Результат будет тем же мы здесь данные из BLL s `SuppliersBLL` класс, но с помощью `StaticCache` класс возвращает данные поставщика в виде кэшированных при запуске приложения. Можно установить точки останова `StaticCache` класс s `GetSuppliers()` способ проверить это.


[![Tон кэшированных поставщика данных отображается в элементе управления GridView](caching-data-at-application-startup-vb/_static/image16.png)](caching-data-at-application-startup-vb/_static/image15.png)

**Рис. 7**: Кэшированные данные поставщиков отображается в элементе управления GridView ([Просмотр полноразмерного изображения](caching-data-at-application-startup-vb/_static/image17.png))


## <a name="summary"></a>Сводка

Большинство каждая модель данных содержит детальный статические данные, обычно реализуется в виде таблицы подстановки. Так как эта информация является статическим, там s нет необходимости постоянно обращаться к базе данных каждый раз, эти данные должны отображаться. Кроме того, из-за статического характера, при кэшировании данных здесь s не требуется также указать срок действия. В этом учебнике мы рассмотрели такие данные и кэшировать его в кэш данных, состояние приложения и через статическую переменную-член. Эта информация кэшируется при запуске приложения и остается в кэше на протяжении всего времени существования приложения s.

В этом руководстве и последние два мы рассмотрели ve кэширования данных в течение жизненного цикла приложения s, а также с помощью кэше на основе времени. При кэшировании данных базы данных, однако может быть идеальным по времени окончания срока действия. Вместо того, чтобы периодически очистить кэш, будет оптимальным решением удалить кэшированный элемент только при изменении основной базы данных. Это идеальный вариант — за счет использования зависимостей кэша SQL, которые мы рассмотрим в нашем следующем учебном курсе.

Счастливого вам программирования!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP.NET и основатель веб- [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Microsoft с 1998 года. Скотт — независимый консультант, преподаватель и автор. Его последняя книга — [ *Sams Teach ASP.NET 2.0 in 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Ним можно связаться по адресу [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Особая благодарность

В этой серии руководств пособий рецензировалась многими компетентными редакторами. Терезой Мерфи и Зак Джонс, стали Лиз Шалок в этом руководстве. Хотите поработать с моих последующих статей для MSDN? Если Да, напишите мне [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](caching-data-in-the-architecture-vb.md)
> [Вперед](using-sql-cache-dependencies-vb.md)
