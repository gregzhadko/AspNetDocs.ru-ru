---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-vb
title: Кэширование данных при запуске приложения (VB) | Документация Майкрософт
author: rick-anderson
description: В любом веб-приложении будут часто использоваться некоторые данные, и некоторые данные будут использоваться редко. Мы можем улучшить производительность нашего ASP.NET приложения b...
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 84afe4ac-cc53-4f2e-a867-27eaf692c2df
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-vb
msc.type: authoredcontent
ms.openlocfilehash: 6c07b565329ab17496d2436f4c35bc4507694ed8
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78465744"
---
# <a name="caching-data-at-application-startup-vb"></a>Кэширование данных при запуске приложения (VB)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачать в формате PDF](caching-data-at-application-startup-vb/_static/datatutorial60vb1.pdf)

> В любом веб-приложении будут часто использоваться некоторые данные, и некоторые данные будут использоваться редко. Мы можем улучшить производительность нашего приложения ASP.NET, заранее загрузив часто используемые данные — методику, известную как. В этом руководстве демонстрируется один из подходов к профилактической загрузке, который заключается в загрузке данных в кэш при запуске приложения.

## <a name="introduction"></a>Введение

Два предыдущих руководства Просмотрели кэширование данных на уровнях представления и кэширования. При [кэшировании данных с помощью ObjectDataSource](caching-data-with-the-objectdatasource-vb.md)мы рассматривали использование функций кэширования ObjectDataSource для кэширования данных на уровне представления. [Кэширование данных в архитектуре](caching-data-in-the-architecture-vb.md) , изучая кэширование на новом отдельном уровне кэширования. В обоих учебниках используются *реактивные загрузки* при работе с кэшем данных. При использовании реактивной загрузки каждый раз, когда данные запрашиваются, система сначала проверяет, есть ли они в кэше. В противном случае он извлекает данные из исходного источника, например базы данных, а затем сохраняет их в кэше. Основное преимущество реактивной загрузки заключается в простоте реализации. Один из его недостатков — это неравномерное снижение производительности между запросами. Представьте себе страницу, которая использует уровень кэширования из предыдущего руководства для вывода сведений о продукте. При первом посещении этой страницы или посещении в первый раз после исключения кэшированных данных из-за ограничений памяти или истечения указанного срока действия данные должны быть получены из базы данных. Поэтому эти запросы пользователей будут занимать больше времени, чем запросы пользователей, которые могут обслуживаться кэшем.

*Упреждающее Загрузка* предоставляет альтернативную стратегию управления кэшем, которая позволяет сгладить производительность запросов, загружая кэшированные данные до того, как они понадобятся. Как правило, упреждающее Загрузка использует некоторый процесс, который либо периодически проверяет, либо уведомляется при обновлении базовых данных. Затем этот процесс обновляет кэш, чтобы он оставался в актуальном виде. Упреждающее Загрузка особенно полезна, если базовые данные поступают из медленного подключения к базе данных, веб-службы или некоторого другого источника данных с низкой скоростью. Но этот подход к профилактической загрузке сложнее реализовать, так как он требует создания, управления и развертывания процесса для проверки изменений и обновления кэша.

Еще одна разновидность упреждающего загрузки и тип, который мы будем изучать в этом руководстве, загружают данные в кэш при запуске приложения. Этот подход особенно полезен для кэширования статических данных, например записей в таблицах подстановки базы данных.

> [!NOTE]
> Более подробные сведения о различиях между упреждающим и переупреждающим загрузкой, а также списками достоинств, недостатков и рекомендаций по реализации см. в разделе [Управление содержимым кэша](https://msdn.microsoft.com/library/ms978503.aspx) в [руководстве по архитектуре кэширования для .NET Framework приложений](https://msdn.microsoft.com/library/ms978498.aspx).

## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a>Шаг 1. Определение данных для кэширования при запуске приложения

Примеры кэширования с использованием реактивной загрузки, которые мы рассматривали в предыдущих двух учебниках, хорошо подходят для данных, которые могут периодически изменяться и не занимают ексорбитантли времени для создания. Но если кэшированные данные никогда не изменяются, срок действия, используемый функцией реактивной загрузки, является избыточным. Аналогично, если кэшированные данные занимают слишком много времени для создания, то эти пользователи, чьи запросы находят пустой кэш, должны превращаться длительное время ожидания, пока извлекаются базовые данные. Рассмотрите возможность кэширования статических данных и данных, которые создаются очень долго во время запуска приложения.

Хотя базы данных имеют множество динамических, часто изменяемых значений, большинство из них также имеют адекватный объем статических данных. Например, практически все модели данных имеют один или несколько столбцов, содержащих определенное значение из фиксированного набора вариантов. Таблица базы данных `Patients` может иметь `PrimaryLanguage` столбец, набор значений которого может быть английским, испанский, французский, Русский, японский и т. д. Зачастую эти типы столбцов реализуются с помощью *таблиц подстановки*. Вместо того чтобы хранить строку на английском или французском языке в таблице `Patients`, создается вторая таблица, которая, как правило, содержит два столбца — уникальный идентификатор и строковое описание — с записью для каждого возможного значения. Столбец `PrimaryLanguage` в таблице `Patients` сохраняет соответствующий уникальный идентификатор в таблице уточняющих запросов. На рис. 1, Сергей Петров, главный язык — английский, а ED Джонсон s — русский.

![Таблица Languages — это таблица уточняющих запросов, используемая таблицей пациентов](caching-data-at-application-startup-vb/_static/image1.png)

**Рис. 1**. Таблица `Languages` является таблицей подстановки, используемой `Patients` таблицей

Пользовательский интерфейс для редактирования или создания нового пациента должен включать раскрывающийся список допустимых языков, заполненных записями в таблице `Languages`. Без кэширования при каждом посещении этого интерфейса система должна запрашивать таблицу `Languages`. Это непроизводительна и не требуется, так как значения таблицы подстановки изменяются очень редко, если когда-либо.

Можно кэшировать данные `Languages`, используя те же методы реактивной загрузки, которые были проверены в предыдущих руководствах. Однако при реактивной загрузке используется срок действия, основанный на времени, который не требуется для статических данных таблицы подстановки. Хотя кэширование с использованием реактивной загрузки было бы лучше, чем кэширование, лучшим подходом будет Предварительная загрузка данных таблицы подстановки в кэш при запуске приложения.

В этом учебнике будет рассмотрено кэширование данных таблицы подстановок и других статических сведений.

## <a name="step-2-examining-the-different-ways-to-cache-data"></a>Шаг 2. изучение различных способов кэширования данных

Данные можно программно кэшировать в приложении ASP.NET, используя различные подходы. Мы уже видели, как использовать кэш данных в предыдущих руководствах. Кроме того, объекты можно программно кэшировать, используя *статические члены* или *состояние приложения*.

При работе с классом, как правило, для доступа к его членам сначала необходимо создать экземпляр класса. Например, чтобы вызвать метод из одного из классов на уровне бизнес-логики, необходимо сначала создать экземпляр класса:

[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample1.vb)]

Прежде чем можно будет вызвать *SomeMethod* или работать с *сомепроперти*, сначала необходимо создать экземпляр класса с помощью ключевого слова `New`. *SomeMethod* и *сомепроперти* связаны с определенным экземпляром. Время существования этих элементов связано со временем существования связанного объекта. *Статические члены*, с другой стороны, являются переменными, свойствами и методами, которые являются общими для *всех* экземпляров класса и, следовательно, имеют время существования, пока класс. Статические элементы обозначаются ключевым словом `Shared`.

Кроме статических элементов, данные можно кэшировать с помощью состояния приложения. Каждое приложение ASP.NET поддерживает коллекцию "имя-значение", которая совместно используется всеми пользователями и страницами приложения. Доступ к этой коллекции можно получить с помощью свойства [`HttpContext` класса](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) [`Application`](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)и использовать из класса кода программной части ASP.NET Page s следующим образом:

[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample2.vb)]

Кэш данных предоставляет более богатый API для кэширования данных, предоставляя механизмы для истечения срока действия, основанного на времени и зависимости, приоритеты элементов кэша и т. д. При использовании статических членов и состояния приложения такие функции должны добавляться разработчиком страницы вручную. Однако при выполнении кэширования данных при запуске приложения в течение времени существования приложения преимущество кэша данных затеи. В этом учебнике мы рассмотрим код, который использует все три метода кэширования статических данных.

## <a name="step-3-caching-thesupplierstable-data"></a>Шаг 3. кэширование`Suppliers`данных таблицы

Таблицы базы данных Northwind, которые мы реализовали в качестве даты, не включают традиционные таблицы подстановки. Четыре таблицы данных, реализованные в DAL, являются таблицами модели, значения которых не являются статическими. Вместо того, чтобы тратить время на добавление новой таблицы данных в DAL, а затем новый класс и методы для BLL, для этого учебника можно просто предубедиться, что данные `Suppliers` таблицы s являются статическими. Поэтому мы можем кэшировать эти данные при запуске приложения.

Для начала создайте новый класс с именем `StaticCache.cs` в папке `CL`.

![Создание класса Статиккаче. vb в папке CL](caching-data-at-application-startup-vb/_static/image2.png)

**Рис. 2**. создание класса `StaticCache.vb` в папке `CL`

Нам нужно добавить метод, который загружает данные при запуске в соответствующее хранилище кэша, а также методы, возвращающие данные из этого кэша.

[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample3.vb)]

В приведенном выше коде используется статическая переменная-член `suppliers`для хранения результатов метода `SuppliersBLL` класса s `GetSuppliers()`, который вызывается из метода `LoadStaticCache()`. Метод `LoadStaticCache()` предназначен для вызова во время запуска приложения. После загрузки этих данных при запуске приложения любая страница, которая должна работать с данными поставщика, может вызвать метод `StaticCache` класса `GetSuppliers()`. Поэтому вызов базы данных для получения поставщиков происходит только один раз при запуске приложения.

Вместо использования статической переменной-члена в качестве хранилища кэша можно было бы использовать состояние приложения или кэш данных. В следующем коде показан класс для использования состояния приложения.

[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample4.vb)]

В `LoadStaticCache()`сведения о поставщике хранятся в *ключе*переменной приложения. Он возвращается в качестве соответствующего типа (`Northwind.SuppliersDataTable`) из `GetSuppliers()`. Хотя доступ к состоянию приложения можно получить в классах кода программной части страниц ASP.NET с помощью `Application("key")`, в архитектуре для получения текущей `HttpContext`необходимо использовать `HttpContext.Current.Application("key")`.

Аналогичным образом кэш данных можно использовать в качестве хранилища кэша, как показано в следующем коде:

[!code-vb[Main](caching-data-at-application-startup-vb/samples/sample5.vb)]

Чтобы добавить элемент в кэш данных без истечения времени действия, используйте значения `System.Web.Caching.Cache.NoAbsoluteExpiration` и `System.Web.Caching.Cache.NoSlidingExpiration` в качестве входных параметров. Была выбрана конкретная перегрузка метода `Insert` кэша данных, чтобы можно было указать *приоритет* элемента кэша. Приоритет используется для определения элементов, которые нужно очистить из кэша, если объем доступной памяти невелик. Здесь используется приоритет `NotRemovable`, который гарантирует, что этот элемент кэша не будет очищен.

> [!NOTE]
> В этом руководстве по скачиванию класс `StaticCache` реализуется с помощью статического переменного члена. Код для методов состояния приложения и кэша данных доступен в комментариях в файле класса.

## <a name="step-4-executing-code-at-application-startup"></a>Шаг 4. исполнение кода при запуске приложения

Чтобы выполнить код при первом запуске веб-приложения, необходимо создать специальный файл с именем `Global.asax`. Этот файл может содержать обработчики событий для событий приложения, сеанса и уровня запроса, и здесь можно добавить код, который будет выполняться при каждом запуске приложения.

Добавьте файл `Global.asax` в корневой каталог веб-приложения, щелкнув правой кнопкой мыши имя проекта веб-сайта в Visual Studio s обозреватель решений и выбрав пункт Добавить новый элемент. В диалоговом окне Добавление нового элемента выберите тип элемента глобальный класс приложения и нажмите кнопку Добавить.

> [!NOTE]
> Если в проекте уже имеется файл `Global.asax`, то тип элемента глобальный класс приложения не будет отображаться в диалоговом окне Добавление нового элемента.

[![добавить файл Global. asax в корневой каталог веб-приложения](caching-data-at-application-startup-vb/_static/image4.png)](caching-data-at-application-startup-vb/_static/image3.png)

**Рис. 3**. добавление файла `Global.asax` в корневой каталог веб-приложения ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-at-application-startup-vb/_static/image5.png))

Шаблон файла `Global.asax` по умолчанию включает пять методов в теге `<script>` на стороне сервера:

- **`Application_Start`** выполняется при первом запуске веб-приложения
- **`Application_End`** выполняется при завершении работы приложения
- **`Application_Error`** выполняется всякий раз, когда необработанное исключение достигает приложения
- **`Session_Start`** выполняется при создании нового сеанса
- **`Session_End`** запускается по истечении срока действия или прекращения сеанса

Обработчик событий `Application_Start` вызывается только один раз во время жизненного цикла приложения. Приложение запускается при первом запросе ресурса ASP.NET из приложения и продолжит работу до перезапуска приложения, что может произойти путем изменения содержимого папки `/Bin`, изменения `Global.asax`, изменения содержимого в папке `App_Code` или изменения файла `Web.config`, помимо прочего. Дополнительные сведения о жизненном цикле приложения см. в статье [Обзор жизненного цикла приложения ASP.NET](https://msdn.microsoft.com/library/ms178473.aspx) .

В этих руководствах нам нужно только добавить код в метод `Application_Start`, поэтому вы можете удалить другие. В `Application_Start`просто вызовите метод `StaticCache` класса s `LoadStaticCache()`, который будет загружать и кэшировать сведения о поставщике:

[!code-aspx[Main](caching-data-at-application-startup-vb/samples/sample6.aspx)]

Вот и все! При запуске приложения метод `LoadStaticCache()` извлекает сведения о поставщике из BLL и сохраняет их в статической переменной-члене (или в любом хранилище кэша, которое вы закончили использовать в классе `StaticCache`). Чтобы проверить это поведение, установите точку останова в методе `Application_Start` и запустите приложение. Обратите внимание, что точка останова достигается при запуске приложения. Однако последующие запросы не приводят к выполнению метода `Application_Start`.

[![использовать точку останова для проверки выполнения обработчика событий Application_Start](caching-data-at-application-startup-vb/_static/image7.png)](caching-data-at-application-startup-vb/_static/image6.png)

**Рис. 4**. Использование точки останова для проверки выполнения обработчика событий `Application_Start` ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-at-application-startup-vb/_static/image8.png))

> [!NOTE]
> Если вы не достигли точки останова `Application_Start` при первом запуске отладки, это связано с тем, что приложение уже запущено. Принудительно перезапустите приложение, изменив `Global.asax` или `Web.config` файлы, а затем повторите попытку. Чтобы быстро перезапустить приложение, можно просто добавить (или удалить) пустую строку в конце одного из этих файлов.

## <a name="step-5-displaying-the-cached-data"></a>Шаг 5. Отображение кэшированных данных

На этом этапе класс `StaticCache` имеет версию данных поставщика, кэшируемых при запуске приложения, доступ к которым можно получить с помощью метода `GetSuppliers()`. Для работы с этими данными на уровне представления данных можно использовать ObjectDataSource или программно вызвать метод `StaticCache` класса `GetSuppliers()` из класса кода программной части Page s. Давайте рассмотрим использование элементов управления ObjectDataSource и GridView для отображения кэшированных сведений о поставщике.

Для начала откройте страницу `AtApplicationStartup.aspx` в папке `Caching`. Перетащите элемент GridView с панели инструментов в конструктор, установив для его свойства `ID` значение `Suppliers`. Затем в смарт-теге GridView s выберите Создание нового ObjectDataSource с именем `SuppliersCachedDataSource`. Настройте ObjectDataSource для использования метода `GetSuppliers()` `StaticCache` классов.

[![настроить ObjectDataSource для использования класса Статиккаче](caching-data-at-application-startup-vb/_static/image10.png)](caching-data-at-application-startup-vb/_static/image9.png)

**Рис. 5**. Настройка ObjectDataSource для использования класса `StaticCache` ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-at-application-startup-vb/_static/image11.png))

[![использования метода "поставщики ()" для получения кэшированных данных поставщика](caching-data-at-application-startup-vb/_static/image13.png)](caching-data-at-application-startup-vb/_static/image12.png)

**Рис. 6**. использование метода `GetSuppliers()` для получения кэшированных данных поставщика ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-at-application-startup-vb/_static/image14.png))

После завершения работы мастера Visual Studio автоматически добавит BoundFields для каждого поля данных в `SuppliersDataTable`. Декларативная разметка GridView и ObjectDataSource должна выглядеть следующим образом:

[!code-aspx[Main](caching-data-at-application-startup-vb/samples/sample7.aspx)]

На рис. 7 показана страница при просмотре в браузере. Выходные данные те же, что были извлечены из класса BLL `SuppliersBLL`, но использование класса `StaticCache` возвращает данные поставщика в кэше при запуске приложения. Вы можете задать точки останова в методе `StaticCache` классов `GetSuppliers()`, чтобы проверить это поведение.

[![кэшированные данные поставщика отображаются в элементе управления GridView](caching-data-at-application-startup-vb/_static/image16.png)](caching-data-at-application-startup-vb/_static/image15.png)

**Рис. 7**. кэшированные данные поставщика отображаются в элементе управления GridView ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-at-application-startup-vb/_static/image17.png))

## <a name="summary"></a>Сводка

Большинство моделей данных содержат достаточное количество статических данных, которые обычно реализуются в виде таблиц подстановки. Поскольку эти сведения являются статическими, нет причин постоянного доступа к базе данных каждый раз, когда необходимо отобразить эту информацию. Более того, из-за статической природы при кэшировании данных нет необходимости в истечении срока действия. В этом учебнике мы увидели, как взять такие данные и кэшировать их в кэше данных, состоянии приложения и через статическую переменную-член. Эта информация кэшируется при запуске приложения и остается в кэше в течение всего времени существования приложения.

В этом руководстве и двух прошлых уроках мы Просмотрели кэширование данных в течение времени существования приложения, а также истечения срока действия, основанного на времени. Однако при кэшировании данных базы данных срок действия, основанный на времени, может быть менее идеальным. Вместо периодического сброса кэша было бы оптимальным только выключать кэшированный элемент при изменении базовых данных базы данных. Этот идеальный вариант можно реализовать с помощью зависимостей кэша SQL, которые мы рассмотрим в следующем руководстве.

Поздравляем с программированием!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP. NET и основатель [4GuysFromRolla.com](http://www.4guysfromrolla.com), работал с веб-технологиями Майкрософт с 1998. Скотт работает как независимый консультант, преподаватель и модуль записи. Его последняя книга — [*Sams обучать себя ASP.NET 2,0 за 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Он доступен по адресу [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти по адресу [http://ScottOnWriting.NET](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Специальная благодарность

Эта серия руководств была рассмотрена многими полезными рецензентами. Потенциальным рецензентам для этого учебника были Терезой Мерфи и Зак Jones. Хотите ознакомиться с моими будущими статьями MSDN? Если это так, расположите строку в [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](caching-data-in-the-architecture-vb.md)
> [Вперед](using-sql-cache-dependencies-vb.md)
