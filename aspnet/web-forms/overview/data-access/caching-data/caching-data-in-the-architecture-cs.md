---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
title: Кэширование данных в архитектуре (C#) | Документация Майкрософт
author: rick-anderson
description: В предыдущем учебном курсе мы показали, как для применения кэширования на уровне представления. В этом руководстве мы узнаем, как пользоваться преимуществами наших многоуровневой архитектуре систем обеспечения...
ms.author: riande
ms.date: 05/30/2007
ms.assetid: d29a7c41-0628-4a23-9dfc-bfea9c6c1054
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
msc.type: authoredcontent
ms.openlocfilehash: 7637e23678af80ae037292fd3f89ef74167c8242
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59419253"
---
# <a name="caching-data-in-the-architecture-c"></a>Кэширование данных в архитектуре (C#)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачайте пример приложения](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe) или [скачать PDF](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)

> В предыдущем учебном курсе мы показали, как для применения кэширования на уровне представления. В этом руководстве мы узнаем, как пользоваться преимуществами наших многоуровневая архитектура для кэширования данных на уровне бизнес-логики. Это делается путем расширения архитектуры, чтобы включить кэширование слой.


## <a name="introduction"></a>Вступление

Как мы видели в предыдущем учебном курсе, кэширование данных s ObjectDataSource нужно просто, как и настройка нескольких свойств. К сожалению элемент управления ObjectDataSource применяется кэширование на уровне представления, которая жестко связывает политики кэширования с помощью страницы ASP.NET. Одной из причин для создания многоуровневой архитектуры является возможность таких связей не работает. Уровня бизнес-логики, к примеру, отделяет бизнес-логики на страницах ASP.NET, пока данные доступа отделяет уровень доступа к данным. Это разделение бизнес логику и данные, сведения о доступе является предпочтительным, отчасти потому, что он делает систему более удобочитаемым, более простого в сопровождении и более гибким, чтобы изменить. Он также позволяет знания о предметной области и разделение труда, разработчику, работающему над t уровень представления данных должны быть ознакомьтесь со сведениями базы данных s, чтобы сделать свою работу. Отделение политику кэширования от слоя представления предлагает аналогичные преимущества в отношении.

В этом руководстве мы расширим архитектуру для включения *уровень кэширования* (или CL для краткости), использует наши политику кэширования. Уровень кэширования будет включать `ProductsCL` класс, который предоставляет доступ к сведениям продукта с помощью методов, например `GetProducts()`, `GetProductsByCategoryID(categoryID)`, и т. д., что, при вызове будет первой попытке получения данных из кэша. Если кэш пуст, эти методы будут вызывать соответствующий `ProductsBLL` в BLL, который в свою очередь будет получать данные из слоя DAL. `ProductsCL` Методы кэширования данных, полученных из BLL, перед его возвратом.

Как показано на рис. 1, CL находится между презентацией и уровни бизнес-логики.


![Уровень кэширования (CL) — еще один уровень в архитектуре наш](caching-data-in-the-architecture-cs/_static/image1.png)

**Рис. 1**: Уровень кэширования (CL) — еще один уровень в архитектуре наш


## <a name="step-1-creating-the-caching-layer-classes"></a>Шаг 1. Создание слоя классы кэширования

В этом руководстве мы создадим очень простой CL с отдельным классом `ProductsCL` , имеет лишь небольшое число методов. Создание полного уровня кэширования, для всего приложения требуется создание `CategoriesCL`, `EmployeesCL`, и `SuppliersCL` классы и предоставление метода в этих классах, кэширование слой для каждого метода доступа или изменения данных в BLL. Как и в BLL и DAL, уровень кэширования в идеале должен быть реализован как отдельный проект библиотеки классов; Тем не менее, мы будем реализовывать как класс в `App_Code` папку.

Чтобы дополнительные четко отдельных CL классы от классов DAL и BLL, s позволяют создать новую вложенную папку в `App_Code` папку. Щелкните правой кнопкой мыши `App_Code` папку в обозревателе решений, выберите новую папку и назовите папку `CL`. После создания этой папки, добавьте к нему новый класс с именем `ProductsCL.cs`.


![Добавить новую папку с именем CL и класс с именем ProductsCL.cs](caching-data-in-the-architecture-cs/_static/image2.png)

**Рис. 2**: Добавьте новую папку с именем `CL` и класс с именем `ProductsCL.cs`


`ProductsCL` Должен включать тот же набор методов доступа и изменения данных, обнаруженных в его соответствующий класс уровня бизнес-логики (`ProductsBLL`). Вместо создания все эти методы только сборки let s несколько здесь, чтобы понять закономерности используемые CL. В частности, мы добавим `GetProducts()` и `GetProductsByCategoryID(categoryID)` методы на шаге 3 и `UpdateProduct` перегрузки на шаге 4. Вы можете добавить оставшиеся `ProductsCL` методы и `CategoriesCL`, `EmployeesCL`, и `SuppliersCL` классы в свободное время.

## <a name="step-2-reading-and-writing-to-the-data-cache"></a>Шаг 2. Чтение и запись в кэше данных

Элемент управления ObjectDataSource, рассмотренные в предыдущем учебном курсе внутри функции кэширования использует кэш данных для хранения данных, полученных из BLL. Кэш данных также возможен программно из классы фонового кода страницы ASP.NET или классы в архитектуру s веб-приложения. Для чтения и записи в кэш данных из s класс фонового кода страницы ASP.NET, используйте следующий шаблон:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample1.cs)]

[ `Cache` Класс](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [ `Insert` метод](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) имеет несколько перегрузок. `Cache["key"] = value` и `Cache.Insert(key, value)` являются синонимами и как добавить элемент в кэш, используя указанный ключ без определенного истечения срока действия. Как правило необходимо указать срок действия при добавлении элемента в кэш, либо в качестве зависимости и по времени окончания срока действия. Используйте один из других `Insert` перегрузок метода s для предоставления сведений зависимостей или на основе времени окончания срока действия.

Кэширование слой, на который s методы должны сначала проверьте, если запрошенные данные в кэше и если да, вернуть его оттуда. Если запрошенные данные не в кэше, соответствующий метод BLL необходимо вызвать. Его возвращаемое значение следует кэшировать и затем возвращается, как показано на следующей схеме.


![Методы s кэширование уровень возвращает данные из кэша, если оно доступно s](caching-data-in-the-architecture-cs/_static/image3.png)

**Рис. 3**: Методы s кэширование уровень возвращает данные из кэша, если оно доступно s


Последовательность, изображенный на рис. 3 выполняется в классах CL, в следующем формате:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample2.cs)]

Здесь *тип* — это тип данных, хранящихся в кэше `Northwind.ProductsDataTable`, например сетям *ключ* — ключ, который однозначно определяет элемент кэша. Если элемент с указанным *ключ* не в кэше, то *экземпляр* будет `null` и данные, полученные из соответствующего метода BLL и добавляются в кэш. К моменту `return instance` достижении *экземпляр* содержит ссылку на данные, либо из кэша или извлекается из BLL.

Убедитесь, что выше шаблон при доступе к данным из кэша. Следующий шаблон, который на первый взгляд выглядит эквивалент содержит небольшая разница, который представляет состояние гонки. Гонки, сложно отладку, так как они обнаруживать себя нерегулярно и трудно воспроизвести.


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample3.cs)]

Разность в этом втором фрагменте неверный код является то, что, а не хранить ссылку на кэшированный элемент в локальной переменной, кэш данных осуществляется непосредственно в условном операторе *и* в `return`. Представим, что при достижении этого кода `Cache["key"]` отличается от`null`, но перед `return` к оператору, система исключает *ключ* из кэша. В этом редком случае возвратит код `null` преимущества, а не объект ожидаемого типа.

> [!NOTE]
> Кэш данных является потокобезопасным, поэтому вам не требуется t для синхронизации доступа потоке для простых операций чтения или записи. Тем не менее если необходимо выполнить несколько операций с данными в кэше, должны быть атомарными, вы несете ответственность за реализацию блокировку или другой механизм для обеспечения потокобезопасности. См. в разделе [синхронизации доступа к кэшу ASP.NET](http://www.ddj.com/184406369) Дополнительные сведения.


Элемент может быть программно исключена из кэша данных, используя [ `Remove` метод](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) следующим образом:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample4.cs)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a>Шаг 3. Возвращает сведения о продукте из`ProductsCL`класса

Для этого руководства позволяют реализовать два метода для возвращения сведения о продукте из s `ProductsCL` класса: `GetProducts()` и `GetProductsByCategoryID(categoryID)`. Как с помощью `ProductsBL` класса на уровне бизнес-логики, `GetProducts()` метод в CL возвращает сведения обо всех продуктов, как `Northwind.ProductsDataTable` объекта, хотя `GetProductsByCategoryID(categoryID)` возвращает все продукты из указанной категории.

В следующем коде показано часть методов в `ProductsCL` класса:


[!code-vb[Main](caching-data-in-the-architecture-cs/samples/sample5.vb)]

Во-первых, обратите внимание, `DataObject` и `DataObjectMethodAttribute` атрибутов, примененных к классу и методы. Эти атрибуты предоставляют сведения о мастере s ObjectDataSource, указывающее, какие классы и методы должны отображаться на шагах s. Поскольку CL классы и методы будут получать доступ из элемента ObjectDataSource на уровне представления данных, я добавил эти атрибуты для улучшения работы во время разработки. Вернуться к [Создание слой бизнес-логики](../introduction/creating-a-business-logic-layer-cs.md) учебника более подробное описание этих атрибутов и их воздействие.

В `GetProducts()` и `GetProductsByCategoryID(categoryID)` методы, данные, возвращенные из `GetCacheItem(key)` метод назначается локальной переменной. `GetCacheItem(key)` Метод, который будет рассмотрен чуть ниже, возвращает определенный элемент из кэша на основе указанного *ключ*. Если такие данные не найдены в кэше, он извлекается из соответствующего `ProductsBLL` метод класса, а затем добавляется в кэш с помощью `AddCacheItem(key, value)` метод.

`GetCacheItem(key)` И `AddCacheItem(key, value)` методы интерфейса с помощью кэша данных, чтение и запись значений, соответственно. `GetCacheItem(key)` Метод проще двух. Он просто возвращает значение из класса кэша с помощью переданного *ключ*:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample6.cs)]

`GetCacheItem(key)` не используйте *ключ* значение, как указано, а вызовы `GetCacheKey(key)` метод, возвращающий *ключ* с ProductsCache - префиксом. `MasterCacheKeyArray`, Который содержит строку ProductsCache, также используется процедурой `AddCacheItem(key, value)` метод, как мы увидим моментально.

Из кода класса страницы s ASP.NET, кэш данных может осуществляться с использованием `Page` класс s [ `Cache` свойство](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)и позволяет использовать синтаксис, как `Cache["key"] = value`, как описано в шаге 2. От класса в архитектуре, кэш данных может осуществляться с помощью `HttpRuntime.Cache` или `HttpContext.Current.Cache`. [Питер Джонсон](https://weblogs.asp.net/pjohnson/default.aspx)на запись в блоге [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) заметки о небольшое повышение производительности с помощью `HttpRuntime` вместо `HttpContext.Current`; следовательно, `ProductsCL` использует `HttpRuntime`.

> [!NOTE]
> Если вашей архитектуры реализуется с помощью проектов библиотек классов, то необходимо будет добавить ссылку на `System.Web` сборки, чтобы использовать [HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) и [HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) классы.


Если элемент не найден в кэше, `ProductsCL` методы класса s получить данные из BLL и добавьте его в кэш с помощью `AddCacheItem(key, value)` метод. Чтобы добавить *значение* в кэш мы используем следующий код, который использует 60 секунд времени окончания срока действия:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample7.cs)]

`DateTime.Now.AddSeconds(CacheDuration)` Указывает на основе времени окончания срока действия 60 секунд в будущем while [ `System.Web.Caching.Cache.NoSlidingExpiration` ](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) указывает, выполняется ли s не скользящий срок действия. При этом `Insert` перегрузку метода имеет входные параметры для обоих абсолютного и скользящего срока действия, можно предоставить только один из двух. Если вы попытаетесь указать абсолютное время и промежуток времени, `Insert` метод вызывает исключение `ArgumentException` исключение.

> [!NOTE]
> Эта реализация `AddCacheItem(key, value)` метод в настоящее время имеет некоторые недостатки. Мы будем адрес и преодолеть эти проблемы на шаге 4.


## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a>Шаг 4. Нарушение при данные кэша — изменены через архитектура

А также методы получения данных уровень кэширования должен предоставить те же методы в BLL для вставки, обновления и удаления данных. Способы изменения данных CL s не изменяйте кэшированных данных, но вместо этого вызовите метод соответствующего изменения данных BLL s и затем делают кэш недействительным. Как мы видели в предыдущем учебном курсе, это то же поведение, элемент управления ObjectDataSource применяется при включении его функции кэширования и его `Insert`, `Update`, или `Delete` методы вызываются.

Следующие `UpdateProduct` перегрузка показано, как реализовать методы изменения данных в CL:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample8.cs)]

Вызывается метод уровня бизнес-логики изменения соответствующих данных, но до возвращения ответа, нам нужно делают кэш недействительным. К сожалению, аннулирования кэша не просто потому что `ProductsCL` класс s `GetProducts()` и `GetProductsByCategoryID(categoryID)` методы добавляют элементы в кэш с разными ключами и `GetProductsByCategoryID(categoryID)` метод добавляет элемент разного кэша для каждого уникального *categoryID*.

При аннулирования кэша, необходимо удалить *все* элементов, которые могут быть добавлены с `ProductsCL` класса. Это можно сделать путем связывания *зависимости кэша* с каждого элемента, добавляемого в кэш в `AddCacheItem(key, value)` метод. В общем случае зависимость кэша может быть другой элемент в кэше, файл в файловой системе, или данные из базы данных Microsoft SQL Server. При изменении зависимости или удаляется из кэша, связанного с ним элементы автоматически вытесняются из кэша. В этом руководстве мы хотим создать еще один элемент в кэше, который выступает в качестве зависимость кэша для всех элементов, добавленных с помощью `ProductsCL` класса. Таким образом, все эти элементы могут быть удалены из кэша, просто удалив зависимость кэша.

Обновления позволяют s `AddCacheItem(key, value)` метод таким образом, чтобы добавить каждый элемент в кэш через этот метод связан с зависимостью от кэша:


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample9.cs)]

`MasterCacheKeyArray` является массивом строк, содержащий одно значение, ProductsCache. Во-первых элемент кэша добавляется в кэш и назначено текущую дату и время. Если элемент кэша уже существует, она обновляется. Затем создается зависимость кэша. [ `CacheDependency` Класс](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s конструктор имеет несколько перегрузок, но использованному в здесь ожидает, что два `string` массива входных данных. Первый из них указывает набор файлов для использования в качестве зависимости. Так как мы кое нежелательно использовать файловые зависимые компоненты значение `null` используется в качестве первого входного параметра. Второй входной параметр указывает набор ключей кэша для использования в качестве зависимости. Здесь мы указываем наших одна зависимость `MasterCacheKeyArray`. `CacheDependency` Потом передается `Insert` метод.

Этого изменения для `AddCacheItem(key, value)`, invaliding осуществляется простым устраняя зависимость кэша.


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample10.cs)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a>Шаг 5. Вызов из уровня представления данных уровень кэширования

Кэширование слоя s классы и методы можно использовать для работы с данными с использованием методик, мы ve проверяется в данных учебных курсах. Для иллюстрации работы с кэшированными данными, сохранить изменения в `ProductsCL` класса, а затем откройте `FromTheArchitecture.aspx` странице в `Caching` папку и добавьте элемент управления GridView. Смарт-теге GridView s создайте новый ObjectDataSource. На первом шаге мастера s вы должны увидеть `ProductsCL` классов как один из вариантов в раскрывающемся списке.


[![Tон ProductsCL класс включается в раскрывающемся списке объекта бизнеса](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)

**Рис. 4**: `ProductsCL` Класс включен в раскрывающемся списке объекта бизнеса ([Просмотр полноразмерного изображения](caching-data-in-the-architecture-cs/_static/image6.png))


После выбора `ProductsCL`, нажмите кнопку Далее. Стрелку раскрывающегося списка на вкладке "ВЫБЕРИТЕ" имеет два элемента - `GetProducts()` и `GetProductsByCategoryID(categoryID)` и вкладку обновление имеет единственный аргумент `UpdateProduct` перегрузки. Выберите `GetProducts()` метод на вкладке SELECT и `UpdateProducts` метод на вкладке обновления и нажмите кнопку Готово.


[![Tон, в раскрывающемся списке указаны перечислены методы класса ProductsCL s](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)

**Рис. 5**: `ProductsCL` Методы класса s, перечислены в раскрывающемся списке указаны ([Просмотр полноразмерного изображения](caching-data-in-the-architecture-cs/_static/image9.png))


По завершении работы мастера Visual Studio установит ObjectDataSource s `OldValuesParameterFormatString` свойства `original_{0}` и добавьте соответствующие поля к GridView. Изменение `OldValuesParameterFormatString` свойства к значению по умолчанию, `{0}`и настроить для поддержки разбиения по страницам, сортировки и редактирования GridView. Так как `UploadProducts` перегруженный метод, используемый с CL принимает только измененный s имя и цену продукта, ограничить GridView, таким образом, чтобы только эти поля являются изменяемыми.

В предыдущем учебном курсе мы определили GridView для включения полей для `ProductName`, `CategoryName`, и `UnitPrice` поля. Вы можете реплицировать этот форматирование и структуру, в этом случае ваш GridView и ObjectDataSource s декларативной разметка должна выглядеть следующим образом:


[!code-aspx[Main](caching-data-in-the-architecture-cs/samples/sample11.aspx)]

На этом этапе у нас есть страница, использующая уровень кэширования. Чтобы просмотреть кэш в действии, установите точки останова в `ProductsCL` класс s `GetProducts()` и `UpdateProduct` методы. Посетите страницу в браузере и пошагово выполнить код, при сортировке и разбиение по страницам, чтобы просмотреть данные извлечены из кэша. Затем обновить запись и обратите внимание, что кэш становится недействительным, и, следовательно, он извлекается из BLL при привязываются к GridView.

> [!NOTE]
> Уровень кэширования, в файле, прилагающемся к этой статье не завершена. Он содержит только один класс `ProductsCL`, который только спортивные небольшое число методов. Кроме того, только одной страницы ASP.NET использует CL (`~/Caching/FromTheArchitecture.aspx`) все остальные по-прежнему ссылающихся BLL напрямую. Если вы планируете использовать CL в приложении, все вызовы от слоя представления должно передаваться CL, что может требовать CL s классы и методы рассматриваются эти классы и методы в BLL, в настоящий момент используется уровень представления данных.


## <a name="summary"></a>Сводка

Хотя кэширование может применяться на уровень представления данных с помощью ASP.NET 2.0 s SqlDataSource и ObjectDataSource элементы управления, в идеале кэширование обязанности бы делегировать отдельный уровень в архитектуре. В этом руководстве мы создали это кэширование слой, который находится между слоем представления и бизнес-логику. Уровень кэширования должен предоставить тот же набор классов и методов, которые существуют в BLL и вызываются из уровня представления данных.

Примеры кэширования слой, мы изучили в этом и предыдущем учебных возникала *реактивного загрузки*. Реактивное загрузка, данные загружаются в кэш только в том случае, когда выполняется запрос для данных и данных отсутствует в кэше. Данные также могут быть *заранее загрузить* в кэш, методика, загружает данные в кэш, прежде чем он фактически требуется. В следующем учебном курсе мы рассмотрим пример упреждающего загрузки, когда мы рассмотрим, как для хранения статических значений в кэш при запуске приложения.

Счастливого вам программирования!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP.NET и основатель веб- [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Microsoft с 1998 года. Скотт — независимый консультант, преподаватель и автор. Его последняя книга — [ *Sams Teach ASP.NET 2.0 in 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Ним можно связаться по адресу [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Особая благодарность

В этой серии руководств пособий рецензировалась многими компетентными редакторами. Основной рецензент этого учебного был Murph Терезой. Хотите поработать с моих последующих статей для MSDN? Если Да, напишите мне [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](caching-data-with-the-objectdatasource-cs.md)
> [Вперед](caching-data-at-application-startup-cs.md)
