---
uid: web-forms/overview/data-access/caching-data/caching-data-with-the-objectdatasource-cs
title: Кэширование данных с помощью ObjectDataSourceC#() | Документация Майкрософт
author: rick-anderson
description: Кэширование может означать разницу между медленным и быстрым веб-приложением. Этот учебник является первым из четырех, в котором подробно рассматривается кэширование в ASP.NET...
ms.author: riande
ms.date: 05/30/2007
ms.assetid: bd87413c-8160-4520-a8a2-43b555c4183a
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-with-the-objectdatasource-cs
msc.type: authoredcontent
ms.openlocfilehash: c9883314d6153b9816d9bad2a281ab3c0a816448
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78420660"
---
# <a name="caching-data-with-the-objectdatasource-c"></a>Кэширование данных с помощью ObjectDataSource (C#)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачивание примера приложения](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_58_CS.exe) или [Загрузка PDF-файла](caching-data-with-the-objectdatasource-cs/_static/datatutorial58cs1.pdf)

> Кэширование может означать разницу между медленным и быстрым веб-приложением. Этот учебник является первым из четырех, в котором подробно рассматривается кэширование в ASP.NET. Изучите основные понятия кэширования и способ применения кэширования к слою представления данных с помощью элемента управления ObjectDataSource.

## <a name="introduction"></a>Введение

В компьютерных образах *кэширование* — это процесс получения данных или сведений, которые требуют больших затрат на получение и хранение их копии в расположении, доступном для быстрого доступа. Для приложений, управляемых данными, крупные и сложные запросы обычно потребляют большую часть времени выполнения приложения. Таким же показателем производительности приложения можно часто улучшить, сохраняя результаты ресурсоемких запросов к базе данных в памяти приложения.

ASP.NET 2,0 предлагает разнообразные варианты кэширования. Вся разметка, отображаемая веб-страницей или пользовательским элементом управления, может быть кэширована с помощью *кэширования вывода*. Элементы управления ObjectDataSource и SqlDataSource также предоставляют возможности кэширования, тем самым позволяя кэшировать данные на уровне элемента управления. И ASP.NET *кэш данных* предоставляют богатый API кэширования, позволяющий разработчикам страниц программно кэшировать объекты. В этом руководстве и следующих трех мы рассмотрим использование функций кэширования ObjectDataSource и кэша данных. Мы также рассмотрим, как кэшировать данные на уровне приложения при запуске и как обновлять кэшированные данные с помощью зависимостей кэша SQL. В этих руководствах не рассматривается кэширование вывода. Подробный обзор кэширования выходных данных см. [в разделе Кэширование вывода в ASP.NET 2,0](http://aspnet.4guysfromrolla.com/articles/121306-1.aspx).

Кэширование может применяться в любом месте архитектуры, от уровня доступа к данным до уровня представления. В этом учебнике мы рассмотрим применение кэширования к слою представления с помощью элемента управления ObjectDataSource. В следующем учебном курсе мы рассмотрим кэширование данных на уровне бизнес-логики.

## <a name="key-caching-concepts"></a>Основные понятия кэширования ключей

Кэширование может значительно повысить общую производительность и масштабируемость приложения, используя данные, требующие дорогостоящего создания и хранения его копии в расположении, которое может быть более эффективно к использованию. Так как кэш хранит только копию фактических базовых данных, он может устареть или *устареть*при изменении базовых данных. Для борьбы с этим разработчик страницы может указать критерии, по которым элемент кэша будет *удален* из кэша, используя один из следующих способов.

- **Критерий на основе времени** . элемент может быть добавлен в кэш для абсолютной или скользящей длительности. Например, разработчик страницы может указать длительность, скажем, 60 секунд. При абсолютной длительности кэшированный элемент выдается через 60 секунд после добавления в кэш, независимо от частоты доступа к нему. При скользящей длительности кэшированный элемент удаляется 60 секунд после последнего доступа.
- **Критерии на основе зависимости** . зависимость может быть связана с элементом при добавлении в кэш. При изменении зависимости элементов он удаляется из кэша. Зависимость может быть файлом, другим элементом кэша или сочетанием этих двух. ASP.NET 2,0 также разрешает зависимости кэша SQL, позволяющие разработчикам добавлять элементы в кэш и удалять их при изменении базовых данных базы данных. Мы рассмотрим зависимости кэша SQL в предстоящем руководстве [Использование зависимостей кэша SQL](using-sql-cache-dependencies-cs.md) .

Независимо от указанного критерия вытеснений, элемент в кэше может быть *очищен* до выполнения условий, основанных на времени или зависимости. Если в кэше достигнута емкость, существующие элементы необходимо удалить, прежде чем новые можно будет добавить. Следовательно, при программной работе с кэшированными данными крайне важно, чтобы всегда предполагалось, что кэшированные данные могут отсутствовать. Мы рассмотрим шаблон, который будет использоваться при программном доступе к данным из кэша в следующем руководстве, *кэшировании данных в архитектуре*.

Кэширование предоставляет экономичные средства для сжатие большей производительности приложения. Как [Андрей роговов](http://aspadvice.com/blogs/ssmith/) в статье [ASP.NET Caching: методы и](https://msdn.microsoft.com/library/aa478965.aspx)рекомендации:

Кэширование может быть хорошим способом обеспечить достаточную производительность, не требуя массового времени и анализа. Память является недорогой, поэтому, если вы можете получить необходимую производительность путем кэширования выходных данных в течение 30 секунд, вместо того, чтобы тратить день или неделю, пытаясь оптимизировать код или базу данных, выполните решение кэширования (при условии, что 30-секундные старые данные имеют значение ОК) и переходите к. В конечном итоге, плохое проектирование, вероятно, будет перехватывать вас, поэтому, конечно же, следует попытаться правильно разработать приложения. Но если вы просто хотите получить достаточную производительность уже сегодня, кэширование может быть отличным [подходом], покупая время на более позднюю дату, когда вы захотите это сделать.

Несмотря на то, что кэширование позволяет повысить производительность аппреЦиабле, оно неприменимо во всех ситуациях, например в приложениях, использующих данные в режиме реального времени, часто обновляемые, или когда неприемлемые устаревшие данные не допускают. Но для большинства приложений следует использовать кэширование. Дополнительные сведения о кэшировании в ASP.NET 2,0 см. в разделе [кэширование для производительности](https://quickstarts.asp.net/QuickStartv20/aspnet/doc/caching/default.aspx) статьи [краткие руководства ASP.NET 2,0](https://quickstarts.asp.net/QuickStartv20/aspnet/).

## <a name="step-1-creating-the-caching-web-pages"></a>Шаг 1. Создание веб-страниц кэширования

Прежде чем начать изучение функций кэширования ObjectDataSource, давайте сначала создадим страницы ASP.NET в нашем проекте веб-сайта, которые понадобятся вам в рамках этого руководства и следующих трех. Для начала добавьте новую папку с именем `Caching`. Затем добавьте в эту папку следующие страницы ASP.NET, чтобы связать каждую страницу с главной страницей `Site.master`:

- `Default.aspx`
- `ObjectDataSource.aspx`
- `FromTheArchitecture.aspx`
- `AtApplicationStartup.aspx`
- `SqlCacheDependencies.aspx`

![Добавление страниц ASP.NET для руководств, связанных с кэшированием](caching-data-with-the-objectdatasource-cs/_static/image1.png)

**Рис. 1**. добавление страниц ASP.NET для руководств, связанных с кэшированием

Как и в других папках, `Default.aspx` в папке `Caching` будут перечислены учебники в разделе. Вспомним, что `SectionLevelTutorialListing.ascx` пользовательский элемент управления предоставляет эти функции. Таким образом, добавьте этот пользовательский элемент управления в `Default.aspx`, перетащив его из обозреватель решений на страницу s представление конструирования.

[![рис. 2. Добавление пользовательского элемента управления SectionLevelTutorialListing. ascx в Default. aspx](caching-data-with-the-objectdatasource-cs/_static/image3.png)](caching-data-with-the-objectdatasource-cs/_static/image2.png)

**Рис. 2**. рисунок 2. Добавление `SectionLevelTutorialListing.ascx` пользовательского элемента управления в `Default.aspx` ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-with-the-objectdatasource-cs/_static/image4.png))

Наконец, добавьте эти страницы в качестве записей в файл `Web.sitemap`. В частности, добавьте следующую разметку после работы с двоичными данными `<siteMapNode>`:

[!code-xml[Main](caching-data-with-the-objectdatasource-cs/samples/sample1.xml)]

После обновления `Web.sitemap`просмотрите веб-сайт учебников в браузере. Меню слева теперь содержит элементы руководства по кэшированию.

![На карте веб-узла теперь есть записи для учебников по кэшированию.](caching-data-with-the-objectdatasource-cs/_static/image5.png)

**Рис. 3**. схема узла теперь включает в себя записи для учебников по кэшированию

## <a name="step-2-displaying-a-list-of-products-in-a-web-page"></a>Шаг 2. Отображение списка продуктов на веб-странице

В этом учебнике рассматривается использование встроенных функций кэширования элемента управления ObjectDataSource. Тем не менее, прежде чем можно будет взглянуть на эти функции, нам сначала нужна страница для работы. Давайте создадим веб-страницу, использующую GridView для вывода списка сведений о продукте, полученных ObjectDataSource из класса `ProductsBLL`.

Для начала откройте страницу `ObjectDataSource.aspx` в папке `Caching`. Перетащите элемент GridView с панели инструментов в конструктор, задайте для его свойства `ID` значение `Products`, а в смарт-теге выберите привязку к новому элементу управления ObjectDataSource с именем `ProductsDataSource`. Настройте ObjectDataSource для работы с классом `ProductsBLL`.

[![настроить ObjectDataSource для использования класса ProductsBLL](caching-data-with-the-objectdatasource-cs/_static/image7.png)](caching-data-with-the-objectdatasource-cs/_static/image6.png)

**Рис. 4**. Настройка ObjectDataSource для использования класса `ProductsBLL` ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-with-the-objectdatasource-cs/_static/image8.png))

Для этой страницы давайте создадим редактируемый элемент GridView, чтобы мы могли проверить, что происходит при изменении данных, кэшированных в ObjectDataSource, с помощью интерфейса GridView s. Оставьте в раскрывающемся списке вкладки выбор значение по умолчанию `GetProducts()`, но измените выбранный элемент на вкладке обновление на перегрузку `UpdateProduct`, которая принимает в качестве входных параметров `productName`, `unitPrice`и `productID`.

[![установить в раскрывающемся списке вкладки обновления соответствующую перегрузку UpdateProduct](caching-data-with-the-objectdatasource-cs/_static/image10.png)](caching-data-with-the-objectdatasource-cs/_static/image9.png)

**Рис. 5**. Установка в раскрывающемся списке вкладки обновления соответствующей перегрузки `UpdateProduct` ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-with-the-objectdatasource-cs/_static/image11.png))

Наконец, задайте для раскрывающихся списков на вкладках Вставка и удаление значение (нет) и нажмите кнопку Готово. После завершения работы мастера настройки источника данных Visual Studio устанавливает свойство `OldValuesParameterFormatString` ObjectDataSource s в значение `original_{0}`. Как обсуждалось в [обзоре руководства по вставке, обновлению и удалению данных](../editing-inserting-and-deleting-data/an-overview-of-inserting-updating-and-deleting-data-cs.md) , это свойство необходимо удалить из декларативного синтаксиса или вернуться к значению по умолчанию, `{0}`, чтобы наш рабочий процесс обновления не выйдет ошибку.

Кроме того, по завершении работы мастера Visual Studio добавляет поле в GridView для каждого поля данных продукта. Удалите все, кроме `ProductName`, `CategoryName`и `UnitPrice` BoundFields. Затем обновите свойства `HeaderText` каждого из этих BoundFields, чтобы они соответствовали продукту, категории и цене соответственно. Так как поле `ProductName` является обязательным, преобразуйте BoundField в TemplateField и добавьте RequiredFieldValidator в `EditItemTemplate`. Аналогичным образом преобразуйте `UnitPrice` BoundField в TemplateField и добавьте объект CompareValidator, чтобы гарантировать, что значение, вводимых пользователем, является допустимым значением валюты, которое больше или равно нулю. В дополнение к этим изменениям можно выполнить любые Aesthetic изменения, такие как выровняйте `UnitPrice` значение по правому краю, или указав форматирование текста `UnitPrice` в его интерфейсах, предназначенных только для чтения и редактирования.

Сделайте элемент GridView редактируемым, установив флажок Включить редактирование в смарт-теге GridView s. Также установите флажки Включить разбиение по страницам и включить сортировку.

> [!NOTE]
> Требуется проверить, как настроить интерфейс редактирования GridView s? Если это так, ознакомьтесь с руководством по [настройке интерфейса изменения данных](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-cs.md) .

[![включить поддержку GridView для редактирования, сортировки и разбиения на страницы](caching-data-with-the-objectdatasource-cs/_static/image13.png)](caching-data-with-the-objectdatasource-cs/_static/image12.png)

**Рис. 6**. Включение поддержки GridView для редактирования, сортировки и разбиения на страницы ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-with-the-objectdatasource-cs/_static/image14.png))

После внесения этих изменений в GridView декларативная разметка GridView и ObjectDataSource s должна выглядеть следующим образом:

[!code-aspx[Main](caching-data-with-the-objectdatasource-cs/samples/sample2.aspx)]

Как показано на рис. 7, редактируемый элемент управления GridView перечисляет имя, категорию и цену каждого из продуктов в базе данных. Уделите время для тестирования функциональности страниц. отсортируйте результаты, проведите их на страницы и измените запись.

[![названия, категории и цены каждого продукта перечислены в виде редактируемого элемента управления GridView с возможностью сортировки.](caching-data-with-the-objectdatasource-cs/_static/image16.png)](caching-data-with-the-objectdatasource-cs/_static/image15.png)

**Рис. 7**. название, Категория и цена каждого продукта перечислены в изменяемом элементе управления GridView ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-with-the-objectdatasource-cs/_static/image17.png)).

## <a name="step-3-examining-when-the-objectdatasource-is-requesting-data"></a>Шаг 3. Проверка того, когда ObjectDataSource запрашивает данные

`Products` GridView извлекает свои данные для вывода, вызывая метод `Select` `ProductsDataSource` ObjectDataSource. Этот элемент управления ObjectDataSource создает экземпляр `ProductsBLL` класса уровня бизнес-логики и вызывает его метод `GetProducts()`, который, в свою очередь, вызывает метод доступа к данным уровня `ProductsTableAdapter` s `GetProducts()`. Метод DAL подключается к базе данных Northwind и выдает настроенный запрос `SELECT`. Затем эти данные возвращаются в DAL, который упаковывает в `NorthwindDataTable`. Объект DataTable возвращается к BLL, который возвращает его в элемент управления ObjectDataSource, который возвращает его в GridView. Затем GridView создает объект `GridViewRow` для каждого `DataRow` в таблице данных, и каждый из `GridViewRow` в конечном итоге подготавливается к просмотру в формате HTML, который возвращается клиенту и отображается в браузере посетителя.

Эта последовательность событий возникает каждый раз, когда GridView необходимо привязать к его базовым данным. Это происходит при первом посещении страницы, при переходе с одной страницы данных на другую, при сортировке GridView или при изменении данных GridView с помощью встроенных интерфейсов редактирования или удаления. Если состояние представления GridView s отключено, GridView будет повторно привязано к каждой обратной передаче. GridView также можно явно связать с данными, вызвав его метод `DataBind()`.

Чтобы полностью оценить частоту, с которой данные извлекаются из базы данных, можно отобразить сообщение, указывающее, когда данные извлекаются повторно. Добавьте веб-элемент управления Label над элементом GridView с именем `ODSEvents`. Очистите свойство `Text` и задайте для его свойства `EnableViewState` значение `false`. Под меткой добавьте веб-элемент управления Button и задайте для его свойства `Text` значение обратная передача.

[![добавить метку и кнопку на страницу над GridView](caching-data-with-the-objectdatasource-cs/_static/image19.png)](caching-data-with-the-objectdatasource-cs/_static/image18.png)

**Рис. 8**. Добавление метки и кнопки на страницу над элементом управления GridView ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-with-the-objectdatasource-cs/_static/image20.png))

Во время рабочего процесса доступа к данным событие ObjectDataSource `Selecting` срабатывает перед созданием базового объекта и вызовом его настроенного метода. Создайте обработчик событий для этого события и добавьте следующий код:

[!code-csharp[Main](caching-data-with-the-objectdatasource-cs/samples/sample3.cs)]

Каждый раз, когда ObjectDataSource выполняет запрос к архитектуре данных, в метке отображается событие выбора текста.

Посетите эту страницу в браузере. При первом посещении страницы отображается событие выбора текста, которое срабатывает. Нажмите кнопку обратная передача и обратите внимание на то, что текст исчезнет (при условии, что для свойства `EnableViewState` GridView s установлено значение `true`, значение по умолчанию). Это вызвано тем, что при обратной передаче GridView восстанавливается из состояния представления и, следовательно, не превращается в ObjectDataSource для своих данных. При сортировке, разбиении по страницам или редактировании данных GridView выполняет повторную привязку к своему источнику данных, поэтому выводится сообщение о том, что выбранное событие выдается.

[![при повторной привязке элемента управления GridView к его источнику данных отображается выбранное событие.](caching-data-with-the-objectdatasource-cs/_static/image22.png)](caching-data-with-the-objectdatasource-cs/_static/image21.png)

**Рис. 9**. при повторной привязке элемента управления GridView к его источнику данных отображается выбор запущенного события ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-with-the-objectdatasource-cs/_static/image23.png))

[![нажатии кнопки обратной передачи приведет к повторному созданию элемента управления GridView из его состояния просмотра.](caching-data-with-the-objectdatasource-cs/_static/image25.png)](caching-data-with-the-objectdatasource-cs/_static/image24.png)

**Рис. 10**. нажатие кнопки обратной передачи приводит к восстановлению элемента управления GridView из состояния просмотра ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-with-the-objectdatasource-cs/_static/image26.png))

Может показаться, что непроизводительна извлекать данные базы данных каждый раз, когда данные передаются по страницам или сортируются. В конце концов, поскольку мы воспользуемся подкачкой по умолчанию, ObjectDataSource извлек все записи при отображении первой страницы. Даже если GridView не обеспечивает поддержку сортировки и разбиения по страницам, данные должны извлекаться из базы данных при первом посещении страницы любым пользователем (и при каждой обратной передаче, если состояние представления отключено). Но если GridView отображает одни и те же данные для всех пользователей, эти дополнительные запросы к базе данных являются избыточными. Почему не кэшировать результаты, возвращенные методом `GetProducts()`, и привязать GridView к этим кэшированным результатам?

## <a name="step-4-caching-the-data-using-the-objectdatasource"></a>Шаг 4. кэширование данных с помощью ObjectDataSource

Путем простого задания нескольких свойств ObjectDataSource можно настроить на автоматическое кэширование извлеченных данных в кэш данных ASP.NET. В следующем списке перечислены свойства элемента управления ObjectDataSource, относящиеся к кэшу:

- Для включения кэширования [енаблекачинг](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.enablecaching.aspx) необходимо задать значение `true`. Значение по умолчанию — `false`.
- [Качедуратион](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.cacheduration.aspx) время в секундах, в течение которого кэшируются данные. Значение по умолчанию равно 0. Элемент управления ObjectDataSource будет кэшировать данные только в том случае, если `EnableCaching` `true` и для `CacheDuration` задано значение больше нуля.
- Для [качикспиратионполици](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.cacheexpirationpolicy.aspx) можно задать значение `Absolute` или `Sliding`. Если `Absolute`, ObjectDataSource кэширует извлеченные данные в течение `CacheDuration` секунд; Если `Sliding`, срок действия данных истекает только после того, как к нему не выполнялся доступ в течение `CacheDuration` секунд. Значение по умолчанию — `Absolute`.
- [Качекэйдепенденци](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.cachekeydependency.aspx) используйте это свойство, чтобы связать записи кэша ObjectDataSource s с существующей зависимостью кэша. Записи данных ObjectDataSource s можно преждевременно исключить из кэша, истечения срока действия связанных с ним `CacheKeyDependency`. Это свойство чаще всего используется для связывания зависимости кэша SQL с кэшем ObjectDataSource s. раздел, который мы рассмотрим в будущем [с помощью руководства по зависимостям кэша SQL](using-sql-cache-dependencies-cs.md) .

Давайте настроим `ProductsDataSource` ObjectDataSource, чтобы кэшировать данные в течение 30 секунд на абсолютном масштабе. Задайте свойству `EnableCaching` ObjectDataSource s значение `true`, а для свойства `CacheDuration` значение 30. Оставьте для свойства `CacheExpirationPolicy` значение по умолчанию `Absolute`.

[![настроить ObjectDataSource на кэширование данных в течение 30 секунд](caching-data-with-the-objectdatasource-cs/_static/image28.png)](caching-data-with-the-objectdatasource-cs/_static/image27.png)

**Рис. 11**. Настройка ObjectDataSource для кэширования данных в течение 30 секунд ([щелкните, чтобы просмотреть изображение с полным размером](caching-data-with-the-objectdatasource-cs/_static/image29.png))

Сохраните изменения и снова перейдите на эту страницу в браузере. При первом посещении страницы будет отображаться текст, порожденный нажатием кнопки, так как изначально данные не находятся в кэше. Однако последующие обратные передачи, активируемые нажатием кнопки обратной передачи, сортировки, разбиения на страницы или нажатия кнопки "Изменить" или "Отмена", *не* отображают вызываемый текст события. Это обусловлено тем, что событие `Selecting` срабатывает только тогда, когда ObjectDataSource получает свои данные из базового объекта. событие `Selecting` не срабатывает, если данные извлекаются из кэша данных.

Через 30 секунд данные будут исключены из кэша. Данные также будут исключены из кэша, если вызываются методы ObjectDataSource `Insert`, `Update`или `Delete`. Следовательно, после прохождения 30 секунд или нажатия кнопки "Обновить", сортировки, разбиения на страницы или нажатия кнопки "Изменить" или "Отмена" элемент управления ObjectDataSource будет получать свои данные из базового объекта, отображая событие выбора, которое создает текст при срабатывании события `Selecting`. Возвращенные результаты помещаются обратно в кэш данных.

> [!NOTE]
> Если вы видите, что выбираемое событие часто выносит текст, даже если предполагается, что ObjectDataSource работает с кэшированными данными, это может быть связано с ограничениями памяти. Если недостаточно свободной памяти, то данные, добавляемые в кэш ObjectDataSource, могут быть очищены. Если элемент управления ObjectDataSource неправильно кэширует данные или кэширует данные только в кэше, закройте некоторые приложения, чтобы освободить память, и повторите попытку.

На рис. 12 показан рабочий процесс кэширования ObjectDataSource. Когда на экране появляется отображаемый текст события, это связано с тем, что данные не находятся в кэше и пришлось бы извлечь из базового объекта. Однако, если этот текст отсутствует, так как данные были доступны из кэша. Когда данные возвращаются из кэша, нет вызова к базовому объекту и, следовательно, запросы к базе данных не выполняются.

![Элемент управления ObjectDataSource сохраняет и извлекает свои данные из кэша данных.](caching-data-with-the-objectdatasource-cs/_static/image30.png)

**Рис. 12**. элемент управления ObjectDataSource сохраняет и извлекает свои данные из кэша данных

Каждое приложение ASP.NET имеет собственный экземпляр кэша данных, который совместно используется всеми страницами и посетителями. Это означает, что данные, хранящиеся в кэше данных ObjectDataSource, также являются общими для всех пользователей, посещающих страницу. Чтобы проверить это, откройте страницу `ObjectDataSource.aspx` в браузере. При первом посещении страницы появится сообщение о том, что при выборе события выводится текст (при условии, что данные, добавленные в кэш предыдущими тестами, теперь были исключены). Откройте второй экземпляр браузера и скопируйте и вставьте URL-адрес из первого экземпляра браузера во второй. Во втором экземпляре браузера отображаемый текст не отображается, так как он использует те же кэшированные данные, что и первый.

При вставке извлеченных данных в кэш ObjectDataSource использует значение ключа кэша, включающее в себя следующие значения свойств `CacheDuration` и `CacheExpirationPolicy`. Тип базового бизнес-объекта, используемого ObjectDataSource, который задается с помощью [свойства`TypeName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.typename.aspx) (в этом примере`ProductsBLL`); значение свойства `SelectMethod`, а также имя и значения параметров в коллекции `SelectParameters`; и значения его свойств `StartRowIndex` и `MaximumRows`, которые используются при реализации [пользовательского разбиения по страницам.](../paging-and-sorting/paging-and-sorting-report-data-cs.md)

Создание значения ключа кэша как сочетание этих свойств обеспечивает уникальность записи кэша при изменении этих значений. Например, в прошлых учебных курсах мы рассматривали использование `ProductsBLL` класса s `GetProductsByCategoryID(categoryID)`, который возвращает все продукты для указанной категории. Один пользователь может перейти на страницу и просмотреть напитки, у которых есть `CategoryID` 1. Если элемент управления ObjectDataSource кэширует свои результаты без учета значений `SelectParameters`, когда другой пользователь поступил на страницу для просмотра «специи», пока в кэше есть продукты напитков, они d видят кэшированные продукты напитков, а не «специи». Изменяя ключ кэша с помощью этих свойств, которые включают значения `SelectParameters`, ObjectDataSource поддерживает отдельную запись кэша для напитков и «специи».

## <a name="stale-data-concerns"></a>Проблемы с устаревшими данными

Элемент управления ObjectDataSource автоматически удаляет свои элементы из кэша, когда вызывается любой из методов `Insert`, `Update`или `Delete`. Это помогает защититься от устаревших данных путем очистки записей кэша при изменении данных на странице. Однако элемент ObjectDataSource, использующий кэширование, может по-прежнему отображать устаревшие данные. В самом простом случае это может быть связано с тем, что данные изменяются непосредственно в базе данных. Возможно, администратор базы данных запустил бы сценарий, изменяющий некоторые записи в базе данных.

Этот сценарий также может unfold более слабым способом. Хотя элемент ObjectDataSource удаляет свои элементы из кэша при вызове одного из его методов модификации данных, удаленные кэшированные элементы относятся к конкретному сочетанию значений свойств ObjectDataSource (`CacheDuration`, `TypeName`, `SelectMethod`и т. д.). Если у вас есть два элемента ObjectDataSource, которые используют разные `SelectMethods` или `SelectParameters`, но по-прежнему могут обновлять одни и те же данные, то один элемент ObjectDataSource может обновить строку и сделать свои записи кэша недействительными, но соответствующая строка второго элемента ObjectDataSource по-прежнему будет обрабатываться из кэшированного. Я рекомендую создавать страницы для отображения этих функций. Создайте страницу, отображающую редактируемый элемент управления GridView, который извлекает свои данные из ObjectDataSource, использующего кэширование, и настраивается для получения данных из метода `ProductsBLL` класса s `GetProducts()`. Добавьте еще один изменяемый элемент управления GridView и ObjectDataSource на эту страницу (или другой), но для второго элемента ObjectDataSource он использует метод `GetProductsByCategoryID(categoryID)`. Поскольку два элемента ObjectDataSource `SelectMethod` свойства различаются, все они имеют свои собственные кэшированные значения. Если вы изменяете продукт в одной сетке, при следующей привязке данных к другой сетке (с помощью разбиения по страницам, сортировки и т. д.) она по-прежнему будет обслуживать старые кэшированные данные и не отражает изменения, внесенные из другой сетки.

Коротко говоря, использование времени истекает только в том случае, если вы готовы иметь возможность использовать устаревшие данные и используете более короткий срок действия для сценариев, в которых важна актуальность данных. Если устаревшие данные неприемлемы, отказаться от Caching или используют зависимости кэша SQL (при условии, что это данные базы данных, для которых выполняется повторное кэширование). В следующем учебнике мы рассмотрим зависимости кэша SQL.

## <a name="summary"></a>Сводка

В этом учебнике мы рассмотрели встроенные возможности кэширования ObjectDataSource. Просто задав несколько свойств, можно указать ObjectDataSource кэшировать результаты, возвращенные из указанного `SelectMethod`, в кэш данных ASP.NET. Свойства `CacheDuration` и `CacheExpirationPolicy` указывают длительность кэширования элемента и то, является ли он абсолютным или скользящим истечением срока действия. Свойство `CacheKeyDependency` связывает все записи кэша ObjectDataSource s с существующей зависимостью кэша. Это можно использовать для исключения записей ObjectDataSource из кэша до истечения срока действия, основанного на времени, и обычно используется с зависимостями кэша SQL.

Так как ObjectDataSource просто кэширует свои значения в кэш данных, можно программно реплицировать встроенные функции ObjectDataSources. Не имеет смысла делать это на уровне представления, так как ObjectDataSource предлагает эту функцию без рамки, но мы можем реализовать возможности кэширования на отдельном уровне архитектуры. Чтобы сделать это, необходимо повторить ту же логику, которая используется ObjectDataSource. Мы рассмотрим, как программно работать с кэшем данных из архитектуры в нашем следующем руководстве.

Поздравляем с программированием!

## <a name="further-reading"></a>Дополнительные материалы

Дополнительные сведения о разделах, обсуждаемых в этом руководстве, см. в следующих ресурсах:

- [ASP.NET Caching: методы и рекомендации](https://msdn.microsoft.com/library/aa478965.aspx)
- [Инструкции по архитектуре кэширования для приложений .NET Framework](https://msdn.microsoft.com/library/ee817645.aspx)
- [Кэширование выходных данных в ASP.NET 2,0](http://aspnet.4guysfromrolla.com/articles/121306-1.aspx)

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP. NET и основатель [4GuysFromRolla.com](http://www.4guysfromrolla.com), работал с веб-технологиями Майкрософт с 1998. Скотт работает как независимый консультант, преподаватель и модуль записи. Его последняя книга — [*Sams обучать себя ASP.NET 2,0 за 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Он доступен по адресу [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти по адресу [http://ScottOnWriting.NET](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Специальная благодарность

Эта серия руководств была рассмотрена многими полезными рецензентами. Специалист по интересу для этого руководства был Терезой Мерфи. Хотите ознакомиться с моими будущими статьями MSDN? Если это так, расположите строку в [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Дальше](caching-data-in-the-architecture-cs.md)
