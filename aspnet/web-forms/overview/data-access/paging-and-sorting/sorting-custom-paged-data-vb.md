---
uid: web-forms/overview/data-access/paging-and-sorting/sorting-custom-paged-data-vb
title: Упорядочение нестандартно разбитых по страницам данных (Visual Basic) | Документация Майкрософт
author: rick-anderson
description: В предыдущем учебном курсе мы показали, как реализовать пользовательское разбиение по страницам при представлении данных на веб-страницы. В этом руководстве показано, как расширить предшествующий...
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 4823a186-caaf-4116-a318-c7ff4d955ddc
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/sorting-custom-paged-data-vb
msc.type: authoredcontent
ms.openlocfilehash: 4c0d015c7d0a294464a3c22dd14a1ad98fbf3235
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65131374"
---
# <a name="sorting-custom-paged-data-vb"></a>Упорядочение нестандартно разбитых по страницам данных (VB)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачайте пример приложения](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_26_VB.exe) или [скачать PDF](sorting-custom-paged-data-vb/_static/datatutorial26vb1.pdf)

> В предыдущем учебном курсе мы показали, как реализовать пользовательское разбиение по страницам при представлении данных на веб-страницы. В этом руководстве показано, как расширить предшествующий пример для включения поддержки упорядочения пользовательское разбиение по страницам.

## <a name="introduction"></a>Вступление

По сравнению с разбиением страниц по умолчанию, нестандартное разбиение может улучшить производительность разбиения данных несколько порядков, делая пользовательское разбиение по страницам де-факто является выбор реализации разбиение по страницам, если разбивка на страницы больших объемов данных. Применение нестандартного разбиения требует больше усилий, чем разбиения по умолчанию, тем не менее, особенно в том случае, если добавление сортировки в наборе. В этом руководстве мы расширим пример с предыдущим для включения поддержки упорядочения *и* пользовательское разбиение по страницам.

> [!NOTE]
> Так как этот учебник основан на предыдущий, перед началом Отвлекитесь и скопируйте декларативный синтаксис внутри `<asp:Content>` элемент из предыдущего учебника s веб-страницы (`EfficientPaging.aspx`) и вставьте его между `<asp:Content>` элемент в `SortParameter.aspx` страницы. Вернитесь к шагу 1 из [Добавление проверяющих элементов управления для редактирования и вставки интерфейсы](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) учебника более подробный рассказ о репликации функций одной страницы ASP.NET на другой.

## <a name="step-1-reexamining-the-custom-paging-technique"></a>Шаг 1. Уточнение метод пользовательского разбиения по страницам

Для пользовательского разбиения по страницам для правильной работы, нужно реализовать некоторые приемы, которые можно эффективно взять определенное подмножество записей, заданных параметров индекс первой строки и максимальное число строк. Существует множество методов, которые можно использовать для достижения этой цели. В предыдущем учебном курсе мы рассмотрели относящееся к элементу управления с помощью Microsoft SQL Server 2005 s новый `ROW_NUMBER()` ранжирующей функции. Короче говоря `ROW_NUMBER()` Ранжирующая функция назначает номер строки для каждой строки, возвращаемые запросом, которая ранжирована определенным способом упорядочения. Путем возвращения определенного раздела нумерованных результатов затем получается соответствующее подмножество записей. Следующий запрос показывает, как использовать этот прием для возвращения продуктов, пронумерованных с 11 до 20 при ранжировании результатов по алфавиту по `ProductName`:

[!code-sql[Main](sorting-custom-paged-data-vb/samples/sample1.sql)]

Этот прием эффективен для разбиения на страницы, используя определенный порядок сортировки (`ProductName` сортируются в алфавитном порядке, в данном случае), но запрос необходимо изменить, чтобы показать результаты, упорядоченные другим выражением для упорядочения. В идеале, можно переписать приведенный выше запрос для использования параметра в `OVER` предложение, следующим образом:

[!code-sql[Main](sorting-custom-paged-data-vb/samples/sample2.sql)]

Увы, параметризованные предложения `ORDER BY` не допускаются. Вместо этого необходимо создать хранимую процедуру, которая принимает `@sortExpression` входного параметра, но использующую один из следующих действий:

- Создание жестко запросов для каждого из выражений сортировки, которые могут использоваться; затем с помощью `IF/ELSE` инструкции T-SQL, чтобы определить, какой запрос выполнять.
- Используйте `CASE` для предоставления динамических выражений `ORDER BY` на основе выражений `@sortExpressio` n входной параметр; см. в разделе используется раздел динамически результаты запросов сортировки [The Power SQL `CASE` инструкций](http://www.4guysfromrolla.com/webtech/102704-1.shtml) Для получения дополнительных сведений.
- Создание высокопроизводительных соответствующий запрос как строку в хранимой процедуре и затем использовать [ `sp_executesql` системной хранимой процедуры](https://msdn.microsoft.com/library/ms188001.aspx) для исполнения динамического запроса.

Каждый из этих обходных путей имеет недостатки. Первый вариант не настолько удобен в поддержке чем другие два, его необходимо создать запрос для каждого возможного выражения упорядочения. Таким образом Если позже вы решите добавить новый, сортируемого поля GridView также необходимо будет вернуться назад и обновить хранимую процедуру. У второго подхода есть некоторое тонкости, вызывающие приведена устранить проблемы с производительностью при сортировке столбцов без строк базы данных, а также страдает от тех же проблем как первая. И третий вариант, который использует динамический код SQL, сопровождается риском атаки введения SQL, если злоумышленник может исполнить хранимую процедуру, передавая значения входных параметров по своему выбору.

Хотя ни один из этих подходов не идеален, я думаю, что третий вариант является наилучшим является третий. С помощью динамического SQL он обеспечивает уровень гибкости, чем два других — нет. Кроме того атака введения SQL может произойти, только если злоумышленник может исполнить хранимую процедуру, передавая входные параметры собственный. Поскольку DAL используются параметризованные запросы, ADO.NET защитит параметры, отправляемые базе данных с помощью архитектуры, это означает, что уязвимость к атаке введения SQL существует, только если злоумышленник может напрямую выполнить хранимую процедуру.

Чтобы реализовать эту функциональность, создайте новую хранимую процедуру в базе данных "Борей" с именем `GetProductsPagedAndSorted`. Эта хранимая процедура должна принимать три параметра: `@sortExpression`, входной параметр типа `nvarchar(100`), указывающий, как должны сортироваться результаты и подставляемый прямо после `ORDER BY` текста в `OVER` предложение; и `@startRowIndex` и `@maximumRows`, же два целочисленных входных параметра из `GetProductsPaged` хранимой процедуры, которые проверяются в предыдущем учебном курсе. Создание `GetProductsPagedAndSorted` хранимой процедуры с помощью следующего сценария:

[!code-sql[Main](sorting-custom-paged-data-vb/samples/sample3.sql)]

Хранимая процедура начинается с обеспечения указания значения для `@sortExpression` был указан параметр. Если он отсутствует, результаты ранжируются по `ProductID`. Далее создается динамический запрос SQL. Обратите внимание на то, что динамический запрос SQL здесь несколько отличается от предыдущих запросов, использовавшихся для получения всех строк из таблицы Products. В предыдущих примерах были получены каждой категории связанных продуктов s s и поставщика имен s, с помощью вложенного запроса. Это было сделано в [создание уровня доступа к данным](../introduction/creating-a-data-access-layer-vb.md) руководства и заместило использование `JOIN` s поскольку TableAdapter не может автоматически создавать связанные вставки, обновления и удаления для таких методов запросы. `GetProductsPagedAndSorted` Хранимой процедуры, тем не менее, необходимо использовать `JOIN` s результаты могут быть упорядочены по имени категории или поставщику.

Этот динамический запрос создается путем сцепления частей статического запроса и `@sortExpression`, `@startRowIndex`, и `@maximumRows` параметров. Так как `@startRowIndex` и `@maximumRows` являются целочисленными параметрами, они должны быть преобразованы в nvarchars правильно сцепления. После создания этого динамического запроса SQL он выполняется посредством `sp_executesql`.

Отвлекитесь и тестированию этой хранимой процедуры с различными значениями для `@sortExpression`, `@startRowIndex`, и `@maximumRows` параметров. В обозревателе сервера щелкните правой кнопкой мыши имя хранимой процедуры и выберите команду выполнить. Откроется диалоговое окно выполнение хранимой процедуры, в котором можно ввести входные параметры (см. рис. 1). Чтобы отсортировать результаты по имени категории, используйте CategoryName для `@sortExpression` значение параметра; Чтобы сортировать по названию компании поставщика s, используйте CompanyName. После предоставления значений параметров, нажмите кнопку "ОК". Результаты отображаются в окне вывода. Рис. 2 показаны результаты при возвращении продуктов, ранжированных от 11 до 20 при упорядочении по цене `UnitPrice` в порядке убывания.

![Попробуйте вводить различные значения для хранимой процедуры s трех входных параметров](sorting-custom-paged-data-vb/_static/image1.png)

**Рис. 1**: Попробуйте вводить различные значения для хранимой процедуры s трех входных параметров

[![Хранимая процедура s результаты отображаются в окне вывода](sorting-custom-paged-data-vb/_static/image3.png)](sorting-custom-paged-data-vb/_static/image2.png)

**Рис. 2**: Хранимая процедура s результаты отображаются в окне вывода ([Просмотр полноразмерного изображения](sorting-custom-paged-data-vb/_static/image4.png))

> [!NOTE]
> При ранжировании результатов по заданному `ORDER BY` столбца в `OVER` предложение, SQL Server должен отсортировать результаты. Это — это Быстрая операция, если имеется кластеризованный индекс для соответствующих столбцов, результаты сортируются по или если имеется покрытия индекса, но может быть более затратным, в противном случае. Чтобы повысить производительность, достаточно больших запросов, можно добавить некластеризованный индекс для столбца, по которому результаты упорядочиваются по. Ссылаться на [Ранжирующие функции и производительности в SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) для получения дополнительных сведений.

## <a name="step-2-augmenting-the-data-access-and-business-logic-layers"></a>Шаг 2. Расширение доступа к данным и уровни бизнес-логики

С помощью `GetProductsPagedAndSorted` хранимая процедура, созданная, следующим этапом является для предоставления способа исполнения этой хранимой процедуры через архитектуру приложения. Это влечет за собой Добавление соответствующего метода к DAL и BLL. Позвольте s начните с добавления метода к DAL. Откройте `Northwind.xsd` типизированный набор DataSet, щелкните правой кнопкой мыши `ProductsTableAdapter`и выберите вариант Добавить запрос в контекстном меню. Как это делалось в предыдущем учебном курсе мы хотим настроить этот новый метод DAL на использование существующей хранимой процедуры - `GetProductsPagedAndSorted`, в данном случае. Для начала, указывающее, что требуется новый метод TableAdapter для использования существующей хранимой процедуры.

![Выберите использование существующей хранимой процедуры](sorting-custom-paged-data-vb/_static/image5.png)

**Рис. 3**: Выберите использование существующей хранимой процедуры

Чтобы указать хранимую процедуру для использования, выберите `GetProductsPagedAndSorted` хранимую процедуру из раскрывающегося списка на следующем экране.

![Использовать GetProductsPagedAndSorted хранимой процедуры](sorting-custom-paged-data-vb/_static/image6.png)

**Рис. 4**: Использовать GetProductsPagedAndSorted хранимой процедуры

Эта хранимая процедура возвращает набор записей, так как его результаты таким образом, на следующем экране, указывают на то что он возвращает табличные данные.

![Указывает, что хранимая процедура возвращает табличные данные](sorting-custom-paged-data-vb/_static/image7.png)

**Рис. 5**: Указывает, что хранимая процедура возвращает табличные данные

Наконец, создайте методы DAL, использующие оба заполнения таблицы данных и возвращать шаблоны объекта DataTable, назвав методы `FillPagedAndSorted` и `GetProductsPagedAndSorted`, соответственно.

![Выберите названия методов](sorting-custom-paged-data-vb/_static/image8.png)

**Рис. 6**: Выберите названия методов

Теперь, мы ve расширенных DAL, мы будет готов к BLL. Откройте `ProductsBLL` и добавьте новый метод `GetProductsPagedAndSorted`. Этот метод должен принимать три параметра `sortExpression`, `startRowIndex`, и `maximumRows` и должен напрямую обращаются к слою в DAL s `GetProductsPagedAndSorted` метода, следующим образом:

[!code-vb[Main](sorting-custom-paged-data-vb/samples/sample4.vb)]

## <a name="step-3-configuring-the-objectdatasource-to-pass-in-the-sortexpression-parameter"></a>Шаг 3. Настройка элемента ObjectDataSource для передачи параметра SortExpression

Дополнив DAL и BLL включением методов, использующих `GetProductsPagedAndSorted` хранимой процедуры, все, остается является настройка ObjectDataSource в `SortParameter.aspx` страницы использовать новый метод BLL и передавать `SortExpression` на основе параметра столбец, который пользователь хочет отсортировать результаты по.

Сначала измените ObjectDataSource s `SelectMethod` из `GetProductsPaged` для `GetProductsPagedAndSorted`. Это можно сделать с помощью мастера настройки источника данных из окна свойств или напрямую через декларативный синтаксис. Далее нам нужно указать значение для ObjectDataSource s [ `SortParameterName` свойство](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.sortparametername.aspx). Если это свойство имеет значение, ObjectDataSource пытается передать принадлежащее GridView s `SortExpression` свойства `SelectMethod`. В частности, элемент управления ObjectDataSource ищет входной параметр, имя которого равно значению `SortParameterName` свойство. С момента BLL s `GetProductsPagedAndSorted` метод имеет входной параметр выражения сортировки, с именем `sortExpression`, набор ObjectDataSource s `SortExpression` свойства sortExpression.

После внесения этих двух изменений, декларативный синтаксис s ObjectDataSource должен выглядеть следующим образом:

[!code-aspx[Main](sorting-custom-paged-data-vb/samples/sample5.aspx)]

> [!NOTE]
> Как в предыдущем учебном курсе, убедитесь, что элемент управления ObjectDataSource не *не* включают sortExpression "," startRowIndex "или" maximumRows входных параметров в коллекции SelectParameters.

Чтобы включить сортировку в GridView, просто установите флажок Включить сортировку в GridView s смарт-тег, который задает GridView s `AllowSorting` свойства `true` и текст заголовка для каждого столбца отобразится как LinkButton. Когда конечный пользователь щелкает один из заголовков элементов управления LinkButton, обратная передача и происходит следующее:

1. Обновления GridView его [ `SortExpression` свойство](https://msdn.microsoft.com/library/system.web.ui.webcontrols.gridview.sortexpression.aspx) значению `SortExpression` была нажата, ссылку на заголовок поля
2. Элемент управления ObjectDataSource вызывает BLL s `GetProductsPagedAndSorted` , передавая принадлежащее GridView s `SortExpression` свойство в качестве значения для метода s `sortExpression` входного параметра (вместе с необходимым `startRowIndex` и `maximumRows` значений входных параметров)
3. BLL вызывает принадлежащий DAL s `GetProductsPagedAndSorted` метод
4. DAL исполняет хранимую процедуру `GetProductsPagedAndSorted` хранимую процедуру, передав в `@sortExpression` параметра (вместе с `@startRowIndex` и `@maximumRows` значений входных параметров)
5. Хранимая процедура возвращает соответствующее подмножество данных уровню BLL, который возвращает его к элементу ObjectDataSource; Эти данные затем привязать к GridView, в код HTML и отправляются конечному пользователю

Рис. 7 показана первая страница результатов при сортировке по `UnitPrice` в порядке возрастания.

[![Результаты сортируются по UnitPrice](sorting-custom-paged-data-vb/_static/image10.png)](sorting-custom-paged-data-vb/_static/image9.png)

**Рис. 7**: Результаты сортируются по UnitPrice ([Просмотр полноразмерного изображения](sorting-custom-paged-data-vb/_static/image11.png))

Хотя текущая реализация может верно упорядочивать результаты по имени продукта, имя категории, количество за единицу и цена за единицу, попытка упорядочить результаты по поставщику именем приводит к исключению среды выполнения (см. рис. 8).

![Попытка упорядочить результаты по имени поставщика приводит следующее исключение среды выполнения](sorting-custom-paged-data-vb/_static/image12.png)

**Рис. 8**: Попытка упорядочить результаты по имени поставщика приводит следующее исключение среды выполнения

Это исключение возникает, так как `SortExpression` из GridView s `SupplierName` BoundField присваивается `SupplierName`. Тем не менее, имя поставщика s в `Suppliers` таблицы на самом деле называется `CompanyName` использовалось это имя столбца как `SupplierName`. Тем не менее `OVER` используемое функцией `ROW_NUMBER()` функция этот псевдоним нельзя использовать и необходимо использовать действительное имя столбца. Таким образом, изменить `SupplierName` BoundField s `SortExpression` из SupplierName на CompanyName (см. рис. 9). Как показано на рис. 10, после этого изменения результаты можно упорядочить по поставщику.

![Измените SortExpression s SupplierName BoundField CompanyName](sorting-custom-paged-data-vb/_static/image13.png)

**Рис. 9**: Измените SortExpression s SupplierName BoundField CompanyName

[![Теперь результаты можно сортировать по поставщикам](sorting-custom-paged-data-vb/_static/image15.png)](sorting-custom-paged-data-vb/_static/image14.png)

**Рис. 10**: Результаты теперь могут быть отсортированы по поставщикам ([Просмотр полноразмерного изображения](sorting-custom-paged-data-vb/_static/image16.png))

## <a name="summary"></a>Сводка

Пользовательская реализация разбиения на страницы, которую мы изучили в предыдущем учебном курсе необходимо указать что заказ, по которому были результаты сортировки во время разработки. Короче говоря это означало, что пользовательская реализация разбиения на страницы, которую мы применили может, в то же время предоставляет возможности упорядочения. В этом руководстве мы позволяют обойти это ограничение, расширив хранимую процедуру из первого для включения `@sortExpression` входного параметра, по которому может быть упорядочены результаты.

После создания этой хранимой процедуры и создания новых методов в DAL и BLL, мы были возможность реализовать GridView, предоставляются как сортировка и пользовательское разбиение по страницам путем настройки ObjectDataSource для передачи в GridView s текущий `SortExpression` принадлежащему BLL `SelectMethod`.

Счастливого вам программирования!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP.NET и основатель веб- [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Microsoft с 1998 года. Скотт — независимый консультант, преподаватель и автор. Его последняя книга — [ *Sams Teach ASP.NET 2.0 in 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Ним можно связаться по адресу [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Особая благодарность

В этой серии руководств пособий рецензировалась многими компетентными редакторами. Основной рецензент этого учебного Карлос Сантос. Хотите поработать с моих последующих статей для MSDN? Если Да, напишите мне [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](efficiently-paging-through-large-amounts-of-data-vb.md)
> [Вперед](creating-a-customized-sorting-user-interface-vb.md)
