---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
title: Эффективное разбиение больших объемов данных (C#) | Документация Майкрософт
author: rick-anderson
description: Возможности разбиения по страницам по умолчанию элемента управления представления данных не подходит при работе с большими объемами данных, таких как его retriev базового элемента управления источника данных...
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 59c01998-9326-4ecb-9392-cb9615962140
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
msc.type: authoredcontent
ms.openlocfilehash: 21f37dc1ffbcb7e8e15e4bed261b68ffc0388c21
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59388430"
---
# <a name="efficiently-paging-through-large-amounts-of-data-c"></a>Эффективное разбиение на страницы больших объемов данных (C#)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачайте пример приложения](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe) или [скачать PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)

> Возможности разбиения по страницам по умолчанию элемента управления представления данных неудобны при работе с большими объемами данных, поскольку его базового элемента управления источника данных получает все записи, несмотря на то, что отображается только подмножество данных. В такой ситуации нужно включить пользовательское разбиение по страницам.


## <a name="introduction"></a>Вступление

Как мы уже говорили в предыдущем учебном курсе, разбиение по страницам можно реализовать одним из двух способов:

- **Разбиение по страницам по умолчанию** можно реализовать, просто установить этот флажок Enable Paging в данных веб-элемента управления s смарт-теге; тем не менее, при просмотре страницы данных, ObjectDataSource извлекает *все* записей, даже Однако только их подмножество, отображаются на странице
- **Пользовательское разбиение по страницам** повышает производительность по умолчанию разбиение по страницам путем извлечения только тех записей из базы данных, которые должны отображаться на странице данных, запрошенный пользователем; тем не менее, пользовательское разбиение по страницам включает в себя немного больше усилий для реализации чем разбиения по страницам по умолчанию

Из-за простоту реализации достаточно лишь установить флажок и которые производится Готово. разбиение по страницам по умолчанию очень привлекательным вариантом. Его н/д ve подход, предполагающий получение всех записей, однако упрощает это вряд ли будет применяться вариант при работе с большими объемами данных или на сайтах с много пользователей одновременно. В такой ситуации нужно включить пользовательское разбиение по страницам, чтобы обеспечить время реакции системы.

Задача пользовательское разбиение по страницам является возможность написать запрос, возвращающий точного набора записей, необходимых для определенной страницы данных. К счастью Microsoft SQL Server 2005 имеется новый метод для ранжирование результатов, который позволит нам необходимо написать запрос, возвращающий нужное подмножество записей. В этом руководстве будет показано, как использовать это новое ключевое слово SQL Server 2005 реализовать пользовательское разбиение по страницам в элементе управления GridView. Хотя пользовательский интерфейс для пользовательского разбиения по страницам по умолчанию, переход от одной страницы к другой идентично значению, пользовательское разбиение по страницам можно несколько раз быстрее, чем разбиения по страницам по умолчанию.

> [!NOTE]
> Выигрыш в производительности, пользовательское разбиение по страницам зависит от общего числа записей, разбиваемых по страницам и нагрузки, возлагаемой на сервере базы данных. В конце этого руководства мы рассмотрим некоторые численные показатели, демонстрирующие эффективность пользовательского разбиения по страницам.


## <a name="step-1-understanding-the-custom-paging-process"></a>Шаг 1. Для понимания процесса пользовательского разбиения по страницам

Если разбиение по страницам данных, точное записей, отображаемых на странице зависят от страницы от запрашиваемых данных и число записей, отображаемых на каждой странице. Например представьте, что мы хотели бы постраничного просмотра списка из 81 продуктов, по 10 продуктов на странице. При просмотре первой страницы, d необходимо продуктов от 1 до 10. При просмотре на второй странице мы d заинтересовать продуктов 11 до 20 и т. д.

Существует три переменные, которые определяют, какие записи должны быть получены и способ отображения интерфейса разбиения по страницам.

- **Индекса первой строки** индекс первой строки в странице данных для отображения; этот индекс может рассчитываться путем умножения индекс страницы записей, отображаемых на одной странице и прибавить 1. Например, если разбиение по страницам записей 10 одновременно, для первой страницы (с индексом 0), индекс первой строки равно 0 \* 10 + 1 или 1; для второй страницы (с индексом 1), индекс первой строки-1 \* 10 + 1 , или 11.
- **Максимальное число строк** максимальное число записей, отображаемых на одной странице. Эта переменная называется максимальное число строк, так как для последней страницы может быть меньше записей, возвращаемых размер страницы. Например при разбиение по страницам записей из 81 наименования продуктов 10 на одну страницу, девятый и последняя страница будет отображаться только одна запись. Ни одна из страниц, покажет записей больше, чем значение максимальное число строк.
- **Общего числа записей** общее число записей, разбиваемых по страницам. Во время этой переменной является t необходимую для определения того, что записей на данной странице, он определяют интерфейс разбиения по страницам. Например если из 81 наименования продуктов, разбиваемых по страницам, интерфейс разбиения по страницам будет отображаться общее число страниц 9 в Интерфейс разбиения по страницам.

С разбиением на страницы по умолчанию, индекс первой строки вычисляется как произведение индекса страницы и размера страницы плюс один, тогда как максимальное число строк — это просто размер страницы. Так как при разбиении по умолчанию запрашиваются все записи из базы данных при подготовке к просмотру любой из страниц данных, индекс для каждой строки известен, переход к строке индекс первой строки тривиальной задачей. Кроме того, легко доступны, так как он общего числа записей s просто число записей в таблице DataTable (или любой объект используется для хранения результатов базы данных).

Учитывая переменные индекс первой строки и максимальное число строк, пользовательская реализация разбиения по страницам должны возвращать только точные подмножества записей, начиная с индекс первой строки до максимальное число строк, количество записей после этого. Пользовательское разбиение по страницам решить две задачи.

- Нам необходимо найти эффективный способ связывания индекса строки с каждой строкой в все данные, разбиваемых по страницам, чтобы получать записи по указанному индексу строки, запуск
- Необходимо указать общее количество записей, разбиваемых по страницам

В следующих двух шагах мы изучим сценарий SQL, необходимые для ответа на эти две задачи. Помимо сценария SQL необходимо также реализовать методы DAL и BLL.

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a>Шаг 2. Возвращает общее число записей, разбиваемых по страницам

Перед тем как получить точные подмножества записей для отображаемой странице, позвольте s сначала посмотрим, как вернуть общее число записей, разбиваемых по страницам. Эти сведения необходимы для правильной настройки пользовательского интерфейса разбиения по страницам. Общее число записей, возвращенных в результате запроса SQL можно получить с помощью [ `COUNT` Агрегатная функция](https://msdn.microsoft.com/library/ms175997.aspx). Например, чтобы определить общее число записей в `Products` таблицы, можно использовать следующий запрос:


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample1.sql)]

Позвольте s Добавление метода к DAL, возвращающий данную информацию. В частности, мы создадим метод DAL с именем `TotalNumberOfProducts()` , выполняющего `SELECT` инструкции, показанный выше.

Сначала откройте `Northwind.xsd` файл типизированного набора DataSet в `App_Code/DAL` папку. После этого щелкните правой кнопкой мыши `ProductsTableAdapter` в конструкторе и выберите Добавить запрос. Как мы видели в предыдущих руководствах ve это позволит нам для добавления нового метода к DAL, при вызове будет выполняться на определенной инструкции SQL или хранимую процедуру. Как и в предыдущем курсе метода TableAdapter, в нашем решили использовать специальный оператор SQL.


![Использовать специальный оператор SQL](efficiently-paging-through-large-amounts-of-data-cs/_static/image1.png)

**Рис. 1**: Использовать специальный оператор SQL


На следующем экране можно указать тип создаваемого запроса. Так как этот запрос будет возвращать одно скалярное значение общее число записей в `Products` таблицы выберите `SELECT` возвращающий одной значение параметра.


![Запрос, используйте инструкцию SELECT, возвращающей одиночное значение](efficiently-paging-through-large-amounts-of-data-cs/_static/image2.png)

**Рис. 2**: Запрос, используйте инструкцию SELECT, возвращающей одиночное значение


После выбора типа запроса, нужно ввести запрос.


![Использование SELECT COUNT(*) FROM запроса продукта](efficiently-paging-through-large-amounts-of-data-cs/_static/image3.png)

**Рис. 3**: ВЫБЕРИТЕ СЧЕТЧИК использования (\*) FROM запроса продукта


Наконец укажите имя для метода. В качестве s упомянутых выше, позволяют использовать `TotalNumberOfProducts`.


![Присвойте имя TotalNumberOfProducts DAL метод](efficiently-paging-through-large-amounts-of-data-cs/_static/image4.png)

**Рис. 4**: Присвойте имя TotalNumberOfProducts DAL метод


После нажатия кнопки Готово, мастер добавит `TotalNumberOfProducts` метода к DAL. Возвращение скалярных методы DAL возвращают значения обнуляемых типов, на случай, если результат запроса SQL `NULL`. Наши `COUNT` запрос, тем не менее, всегда будет возвращать отличного`NULL` значением; тем не менее метод DAL не вернет обнуляемое целое.

Помимо метода DAL нам понадобиться метод на уровне BLL. Откройте `ProductsBLL` и добавьте `TotalNumberOfProducts` метод, который просто вызывает DAL s `TotalNumberOfProducts` метод:


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample2.cs)]

DAL s `TotalNumberOfProducts` метод возвращает значение типа обнуляемого целого; тем не менее, мы ve создан `ProductsBLL` класс s `TotalNumberOfProducts` метода, которые возвращает обычное целочисленное значение. Таким образом, необходимо иметь `ProductsBLL` класс s `TotalNumberOfProducts` метод возвращать значимую часть обнуляемого целого, возвращенный DAL s `TotalNumberOfProducts` метод. Вызов `GetValueOrDefault()` возвращает значение типа обнуляемого целого, если он существует; Если обнуляемого целого, которое является `null`, тем не менее, он возвращает целочисленное значение по умолчанию 0.

## <a name="step-3-returning-the-precise-subset-of-records"></a>Шаг 3. Возврат точного подмножества записей

DAL следующей задачей является создание методов в DAL и BLL, которые принимают индекс первой строки и переменные максимальное число строк, речь выше и возвращающие соответствующие записи. Перед этим, позволяющие s сначала посмотрим сценарий SQL. Нам является то, что нам необходимо найти эффективный способ присваивания индекса каждой строке полного набора записей, разбиваемых по страницам, чтобы получить только те записи, начиная с индекс первой строки (до записи максимальное число записей).

Это не является сложной задачей, если уже существует столбец в таблице базы данных, который служит в качестве индекса строки. На первый взгляд может показаться `Products` таблицы s `ProductID` поля, поскольку первый продукт имеет `ProductID` 1, второго — 2 и т. д. Тем не менее удаление продукта из списка в последовательности возникает пропуск, этот подход.

Существует два общих способа присвоения эффективный способ связывания индекса строки с данными для постраничного просмотра, тем самым позволяя нужного подмножества записей, которые требуется извлечь.

- **С помощью SQL Server 2005 s `ROW_NUMBER()` ключевое слово** знакомы с SQL Server 2005, `ROW_NUMBER()` ключевое слово связывает ранжирования с возвращаемых записей в определенном порядке. Присвоенные номера можно использовать в качестве индекса строки для каждой строки.
- **С помощью табличную переменную и `SET ROWCOUNT`**  s SQL Server [ `SET ROWCOUNT` инструкции](https://msdn.microsoft.com/library/ms188774.aspx) может использоваться для указания запроса должны быть обработаны; количество записей [табличные переменные](http://www.sqlteam.com/item.asp?ItemID=9454) локальные переменные T-SQL, которые могут содержать табличные данные, они похожи на [временные таблицы](http://www.sqlteam.com/item.asp?ItemID=2029). Этот подход работает одинаково хорошо с Microsoft SQL Server 2005 и SQL Server 2000 (тогда как `ROW_NUMBER()` подход работает только с SQL Server 2005).  
  
  Идея заключается в том, чтобы создать табличную переменную со `IDENTITY` и столбцами для первичных ключей таблицы, данные которых является, разбиваемых по страницам. После этого содержимое таблицы, данные которого разбиваемых выводится в табличную переменную, тем самым связав последовательные индексы всем строкам (через `IDENTITY` столбец) для каждой записи в таблице. После заполнения этой табличной переменной `SELECT` оператором в табличную переменную, присоединенных к исходной таблице, можно выполнить, чтобы извлечь определенной записи. `SET ROWCOUNT` Оператор используется для ограничения числа записей, которые должны быть записаны в табличную переменную.  
  
  Этот подход s эффективность зависит от номеров запрашиваемых страниц, как `SET ROWCOUNT` значение присваивается значение индекс первой строки, а также максимальное число строк. При работе с небольшими номерами страниц, таких как первый несколько страниц данных этот подход очень эффективен. Тем не менее он демонстрирует производительность разбиения на страницы в стиле по умолчанию при загрузке страницы в конце.

В этом руководстве реализуется с помощью пользовательского разбиения по страницам `ROW_NUMBER()` ключевое слово. Дополнительные сведения об использовании табличной переменной и `SET ROWCOUNT` методика, см. в разделе [более эффективным методом для разбиения на страницы через больших результирующих наборов](http://www.4guysfromrolla.com/webtech/042606-1.shtml).

`ROW_NUMBER()` Ключевое слово ранжирования связанные с каждой записи возвращается номер, используя следующий синтаксис:


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample3.sql)]

`ROW_NUMBER()` Возвращает числовое значение, указывающее ранг для каждой записи в соответствии с указанным порядком. Например чтобы узнать номер для каждого продукта, упорядочены от самого дорого к самому дешевому, можно использовать следующий запрос:


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample4.sql)]

Рис. 5 показан этот запрос s результаты при выполнении в окне запросов в Visual Studio. Обратите внимание, что продукты упорядочены по цене, а также указан порядковый номер для каждой строки.


![Порядковый номер включается для каждой записи возвращаются](efficiently-paging-through-large-amounts-of-data-cs/_static/image5.png)

**Рис. 5**: Порядковый номер включается для каждой записи возвращаются


> [!NOTE]
> `ROW_NUMBER()` лишь один из многих новых функций ранжирования доступна в SQL Server 2005. Более глубокое обсуждение `ROW_NUMBER()`, а также других функциях ранжирования, чтение [возвращение ранжированные результаты с помощью Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).


При ранжировании результатов по заданному `ORDER BY` столбца в `OVER` предложение (`UnitPrice`, в приведенном выше примере), SQL Server должен отсортировать результаты. Это — это Быстрая операция, если имеется кластеризованный индекс для соответствующих столбцов, результаты сортируются по, или если имеется покрытия индекса, но может быть более затратным, в противном случае. Чтобы повысить производительность, достаточно больших запросов, рассмотрите возможность добавления некластеризованный индекс для столбца, по которому упорядочиваются результаты. См. в разделе [Ранжирующие функции и производительности в SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) для более подробно изучить рекомендации по производительности.

Возвращаемые сведения о рангах `ROW_NUMBER()` нельзя использовать непосредственно в `WHERE` предложение. Тем не менее, можно использовать производную таблицу для возвращения `ROW_NUMBER()` результат, который затем может встречаться в `WHERE` предложение. Например, следующий запрос использует производную таблицу для возврата столбцов ProductName и UnitPrice, вместе с `ROW_NUMBER()` результат, а затем используется `WHERE` предложение, для которых номера цен лежат только возвращения продуктов — от 11 до 20:


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample5.sql)]

Распространения этой концепции немного дальше, мы используем этот подход, чтобы получить страницу данных для заданных нужные значения индекс первой строки и максимальное число строк:


[!code-html[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample6.html)]

> [!NOTE]
> Как мы увидим далее в этом руководстве *`StartRowIndex`* предоставляемые ObjectDataSource индексируется начиная с нуля, тогда как `ROW_NUMBER()` значение, возвращенное SQL Server 2005, начинаются с 1. Таким образом `WHERE` возвращает записи где `PriceRank` строго больше, чем *`StartRowIndex`* и меньше или равно *`StartRowIndex`*  +  *`MaximumRows`*.


Теперь, мы ve, рассматриваются как `ROW_NUMBER()` может быть используется для получения определенной страницы данных, учитывая значения индекс первой строки и максимальное число строк, теперь нам нужно реализовать эту логику в виде методов DAL и BLL.

При создании такого метода нужно определить порядок, по которому ранжирования результатов; Пусть продукты сортируются по имени в алфавитном порядке s. Это означает, что с реализацию пользовательского разбиения по страницам в этом руководстве мы невозможна для создания пользовательского разбитого на страницы отчета, чем можно было бы отсортировать. В следующем учебном курсе Однако мы увидим как можно предоставить подобные функции.

В предыдущем разделе мы создали метод DAL в виде специальной инструкции SQL. К сожалению, синтаксический анализатор T-SQL в Visual Studio, используемый t Мастер TableAdapter как `OVER` синтаксис, используемый `ROW_NUMBER()` функции. Таким образом необходимо создать этот метод DAL как хранимую процедуру. Выберите в обозревателе сервера из меню "Вид" (или нажмите сочетание клавиш Ctrl + Alt + S) и разверните `NORTHWND.MDF` узла. Чтобы добавить новую хранимую процедуру, щелкните правой кнопкой мыши на узел хранимых процедур и выберите команду Добавить новую хранимую процедуру (см. рис. 6).


![Добавить новую хранимую процедуру для продуктов по страницам](efficiently-paging-through-large-amounts-of-data-cs/_static/image6.png)

**Рис. 6**: Добавить новую хранимую процедуру для продуктов по страницам


Эта хранимая процедура должна принимать два целочисленных параметра - `@startRowIndex` и `@maximumRows` и использовать `ROW_NUMBER()` отсортированную по `ProductName` поле, возвращает только те строки, больше чем `@startRowIndex` и меньше или равным `@startRowIndex`  +  `@maximumRow` s. Введите приведенный ниже сценарий в новой хранимой процедуры и щелкните значок сохранения, чтобы добавить хранимую процедуру в базу данных.


[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample7.sql)]

После создания хранимой процедуры, Отвлекитесь и протестировать его. Щелкните правой кнопкой мыши `GetProductsPaged` хранимой процедуры в обозревателе сервера укажите имя и параметра инструкции Execute. Visual Studio появится приглашение для ввода параметров, `@startRowIndex` и `@maximumRow` s (см. рис. 7). Попробуйте вводить различные значения и проанализировать результаты.


![Введите значение для @startRowIndex и @maximumRows параметров](efficiently-paging-through-large-amounts-of-data-cs/_static/image7.png)

<strong>Рис. 7</strong>: Введите значение для @startRowIndex и @maximumRows параметров


После выбора этих входных значений параметров, результаты появятся в окне вывода. Рис. 8 показаны результаты, если для обоих `@startRowIndex` и `@maximumRows` параметров.


[![Tон записей, отобразятся в второй страницы данных возвращаются](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)

**Рис. 8**: Возвращаются записи, будет отображаться в данные из второй страницы ([Просмотр полноразмерного изображения](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))


С этим хранимая процедура, созданная, и мы будет готов для создания `ProductsTableAdapter` метод. Откройте `Northwind.xsd` типизированный набор DataSet, щелкните правой кнопкой мыши в `ProductsTableAdapter`и выберите пункт Добавить запрос. Вместо создания запроса с помощью инструкции SQL ad-hoc, создайте его с помощью существующей хранимой процедуры.


![Создание метода DAL с использованием существующей хранимой процедуры](efficiently-paging-through-large-amounts-of-data-cs/_static/image11.png)

**Рис. 9**: Создание метода DAL с использованием существующей хранимой процедуры


Далее мы приглашение выбрать нужную хранимую процедуру. Выбрать `GetProductsPaged` хранимую процедуру из раскрывающегося списка.


![Выберите GetProductsPaged хранимую процедуру из раскрывающегося списка](efficiently-paging-through-large-amounts-of-data-cs/_static/image12.png)

**Рис. 10**: Выберите GetProductsPaged хранимую процедуру из раскрывающегося списка


Следующем экране вы вида данных возвращается хранимой процедурой: табличные данные, одно значение или нет значения. Так как `GetProductsPaged` хранимая процедура может возвращать несколько записей, указывают, что он возвращает табличные данные.


![Указывает, что хранимая процедура возвращает табличные данные](efficiently-paging-through-large-amounts-of-data-cs/_static/image13.png)

**Рис. 11**: Указывает, что хранимая процедура возвращает табличные данные


И наконец укажите имена методов, для создания. Как и в предыдущих учебных курсах, продолжим и создание методов с помощью обоих заполнения таблицы DataTable и вернуть таблицу данных. Назовем первый метод `FillPaged` , а второй `GetProductsPaged`.


![Имя методы FillPaged и GetProductsPaged](efficiently-paging-through-large-amounts-of-data-cs/_static/image14.png)

**Рис. 12**: Имя методы FillPaged и GetProductsPaged


Кроме того для создания метода DAL, возвращающего нужную страницу продуктов, мы также необходимо предоставить подобные функции в BLL. Как и метод DAL s BLL метода GetProductsPaged необходимо принять два набора входных данных целое число для указания индекс первой строки и максимальное число строк и должен возвращать только те записи, которые попадают в указанный диапазон. Создайте в классе, так что просто вызывает метод вниз в DAL s метода GetProductsPaged класса ProductsBLL:


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample8.cs)]

Вы можете использовать любое имя для входных параметров метода s BLL, но, как мы скоро увидим, что решили использовать `startRowIndex` и `maximumRows` избавляет нас от лишних работу при настройке нового ObjectDataSource для использования этого метода.

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a>Шаг 4. Настройка ObjectDataSource на использование пользовательского разбиения по страницам

С помощью методов BLL и DAL для доступа к определенному подмножеству данных мы будет готов для создания элемента управления GridView управлять этой страницы через его базовой записи, с помощью пользовательского разбиения по страницам. Сначала откройте `EfficientPaging.aspx` странице в `PagingAndSorting` папки, добавьте элемент управления GridView на страницу и настроить его для использования нового элемента управления ObjectDataSource. В предыдущих курсах мы часто настраивали элемент управления ObjectDataSource, который настроен для использования `ProductsBLL` класс s `GetProducts` метод. На этот раз тем не менее, мы хотим использовать `GetProductsPaged` метод вместо этого после `GetProducts` возвращает *все* продуктов в базе данных в то время как `GetProductsPaged` возвращает определенного подмножества записей.


![Настройте элемент ObjectDataSource для использования метода GetProductsPaged класса ProductsBLL s](efficiently-paging-through-large-amounts-of-data-cs/_static/image15.png)

**Рис. 13**: Настройте элемент ObjectDataSource для использования метода GetProductsPaged класса ProductsBLL s


С момента мы повторно создание только для чтения элемента управления GridView Отвлекитесь и задайте метод стрелку раскрывающегося списка в инструкции INSERT, UPDATE и удаление вкладок (нет).

После этого мастер ObjectDataSource запрашивает источники `GetProductsPaged` метод s `startRowIndex` и `maximumRows` входных значений параметров. Эти входные параметры фактически устанавливается с GridView автоматически, просто оставьте исходный набор нет и нажмите кнопку Готово.


![Оставьте источники входного параметра, как None](efficiently-paging-through-large-amounts-of-data-cs/_static/image16.png)

**Рис. 14**: Оставьте источники входного параметра, как None


После завершения работы мастера ObjectDataSource GridView будет содержать BoundField или CheckBoxField для каждого из полей данных продукта. Вы можете настроить внешний вид s GridView по своему усмотрению. Я решил ve отображения только `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, и `UnitPrice` полей BoundField. Кроме того настройте поддержку разбиения по страницам, установив флажок Включить разбиение по страницам в его смарт-теге GridView. После внесения этих изменений декларативная разметка GridView и элемент управления ObjectDataSource должен выглядеть следующим образом:


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample9.aspx)]

Если зайти на страницу через обозреватель, однако GridView именно не должен быть найден.


![— GridView не отображается](efficiently-paging-through-large-amounts-of-data-cs/_static/image17.png)

**Рис. 15**: — GridView не отображается


GridView отсутствует, так как элемент управления ObjectDataSource используется 0 как значения для обоих `GetProductsPaged` `startRowIndex` и `maximumRows` входных параметров. Следовательно, результирующий запрос SQL не возвращает ни одной записи и поэтому GridView не отображается.

Чтобы исправить это, необходимо настроить ObjectDataSource на использование пользовательского разбиения по страницам. Это можно сделать следующим образом:

1. **Набор ObjectDataSource s `EnablePaging` свойства `true`**  это значит, что элемент управления ObjectDataSource, его необходимо передать в `SelectMethod` два дополнительных параметра: один для указания индекс первой строки ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)) и для указания максимального числа строк ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).
2. **Набор ObjectDataSource s `StartRowIndexParameterName` и `MaximumRowsParameterName` свойства соответствующим образом** `StartRowIndexParameterName` и `MaximumRowsParameterName` обозначают имена параметров, передаваемых в `SelectMethod` для пользовательского разбиения по страницам. По умолчанию эти параметры имеют имена `startIndexRow` и `maximumRows`, поэтому, при создании `GetProductsPaged` метод в BLL, мы использовали такие значения входных параметров. Если вы решили использовать другие имена для BLL s `GetProductsPaged` метода, такого как `startIndex` и `maxRows`, для примера, вам потребовалось бы значение ObjectDataSource s `StartRowIndexParameterName` и `MaximumRowsParameterName` свойства соответствующим образом (например, startIndex для `StartRowIndexParameterName` и maxRows для `MaximumRowsParameterName`).
3. **Набор ObjectDataSource s [ `SelectCountMethod` свойство](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) имя метода, который возвращает общее число из записи выполняется, разбитых на страницы через (`TotalNumberOfProducts`)** помните, что `ProductsBLL` класс s `TotalNumberOfProducts`метод возвращает общее число записей, разбиваемых по страницам с помощью метода DAL, который выполняет `SELECT COUNT(*) FROM Products` запроса. Эти сведения необходимы элементом ObjectDataSource, чтобы правильно отображения интерфейса разбиения по страницам.
4. **Удалить `startRowIndex` и `maximumRows` `<asp:Parameter>` элементы из s декларативная разметка ObjectDataSource** при настройке элемента управления ObjectDataSource в мастере, Visual Studio автоматически добавляет два `<asp:Parameter>` элементов для `GetProductsPaged` метод s входных параметров. Установив `EnablePaging` для `true`, эти параметры будут переданы автоматически; Если оставить их в декларативном синтаксисе, элемент управления ObjectDataSource будет пытаться передать *четыре* параметров `GetProductsPaged` метод и два параметра `TotalNumberOfProducts` метод. Если вы забыли удалить эти `<asp:Parameter>` элементов, при просмотре страницы в обозревателе, вы получите сообщение об ошибке, например: *ObjectDataSource 'ObjectDataSource1' не удалось найти неуниверсальный метод «TotalNumberOfProducts» с параметрами: startRowIndex maximumRows*.

После внесения этих изменений декларативный синтаксис s ObjectDataSource должен выглядеть следующим образом:


[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample10.aspx)]

Обратите внимание, что `EnablePaging` и `SelectCountMethod` заданы свойства и `<asp:Parameter>` элементы будут удалены. Рис. 16 показан снимок экрана окна свойств после внесения этих изменений.


![Чтобы использовать пользовательское разбиение по страницам, настройте элемент управления ObjectDataSource](efficiently-paging-through-large-amounts-of-data-cs/_static/image18.png)

**Рис. 16**: Чтобы использовать пользовательское разбиение по страницам, настройте элемент управления ObjectDataSource


После внесения этих изменений, посетите эту страницу через обозреватель. Вы должны увидеть 10 продуктов в списке, представлены в алфавитном порядке. Отвлекитесь и пошаговое выполнение на одной странице данных за раз. Пока нет никакой разницы с точки зрения конечного пользователя s между стандартным и пользовательское разбиение по страницам, пользовательское разбиение гораздо более эффективно по страницам больших объемов данных, так как он получает только те записи, которые должны отображаться для данной страницы.


[![Tу него данные, упорядоченные по s имя продукта, является, разбитых на страницы с помощью пользовательского разбиения по страницам](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)

**Рис. 17**: К данным, упорядоченный по продукту — имя, является, разбитых на страницы с помощью пользовательского разбиения по страницам ([Просмотр полноразмерного изображения](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))


> [!NOTE]
> При пользовательском разбиении страница подсчета значение, возвращенное ObjectDataSource s `SelectCountMethod` хранится в GridView состояние представления s. Другие переменные GridView `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` коллекции и т. д., хранятся в *состояние элемента управления*, которое сохраняется вне зависимости от значения параметра GridView s `EnableViewState` свойство. Так как `PageCount` значение сохраняется во время обратной передачи, с помощью состояния представления, при использовании интерфейса разбиения по страницам, со ссылкой, чтобы перейти к последней странице, крайне важно включенное состояние представления s GridView. (Если в интерфейсе разбиения по страницам не поддерживает прямую ссылку к последней странице, вы можете отключить состояние представления.)


Щелкнув ссылки на последнюю страницу вызывает обратную передачу и указывает, что для обновления GridView его `PageIndex` свойство. При нажатии ссылки на последнюю страницу GridView назначает его `PageIndex` одно значение меньшее, чем `PageCount` свойство. В отключенном состоянии представления `PageCount` теряется при обратных передач и `PageIndex` вместо присваивается максимальное целое значение. Затем GridView пытается определить начальный индекс строки путем перемножения `PageSize` и `PageCount` свойства. В результате `OverflowException` так, как продукт превышает размер целочисленное значение максимально допустимого.

## <a name="implement-custom-paging-and-sorting"></a>Реализация пользовательского разбиения по страницам и сортировка

Текущей реализацией пользовательского разбиения по страницам требует, что заказ, по которому страницам данных определяется статически при создании `GetProductsPaged` хранимой процедуры. Тем не менее вы записали, смарт-тега GridView s содержит флажок Включить сортировку, помимо возможности включить разбиение по страницам. К сожалению Если включить поддержку сортировки к GridView с текущей реализацией пользовательского разбиения по страницам будут отсортированы только записи на текущей просматриваемой странице данных. Например при настройке GridView для разбиения по страницам, а затем, при просмотре первой страницы данных, отсортировать по названию продукта в убывающем порядке, в его обратный порядок продуктов на странице 1. Как показано на рис. 18, продукт Carnarvon Tigers стал первым продуктом при сортировке в обратном алфавитном порядке, который пропускает 71 другие продукты, полученные после Carnarvon Tigers, в алфавитном порядке; в сортировке, считаются только те записи, на первой странице.


[![Oчтение данных, показанный на текущей странице сортируется](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)

**Рис. 18**: Сортируются только данные отображаются на текущей странице ([Просмотр полноразмерного изображения](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))


В сортировке участвуют только к текущей странице данных, поскольку сортировка происходит после получения данных из BLL s `GetProductsPaged` метод и этот метод возвращает только записи одной страницы. Для правильной сортировки необходимо передать выражение сортировки `GetProductsPaged` метод таким образом, чтобы упорядочить данные до возврата нужной страницы данных. Узнаете, как это сделать в нашем следующем учебном курсе.

## <a name="implementing-custom-paging-and-deleting"></a>Реализация пользовательского разбиения по страницам и удаления

Если необходимо включить функцию удаления в элементе управления GridView, данные которых отображаются с помощью настраиваемых способов разбиения по страницам, можно найти, при удалении последней записи на последней странице GridView исчезает вместо того чтобы надлежащим образом уменьшить GridView s `PageIndex`. Чтобы воспроизвести эту ситуацию, включите поддержку удаления в только что только что созданной. Перейдите на последнюю страницу (страница 9), где должен отображаться один продукт, так как мы разбиение по страницам из 81 наименования продуктов, 10 продуктов за раз. Удалите этот продукт.

После удаления последнего продукта GridView *следует* автоматически перейти на страницу восьмой, и этот механизм корректно работает с разбиением на страницы по умолчанию. С помощью пользовательского разбиения по страницам, однако после удаления последнего продукта на последней странице GridView просто исчезает с экрана вообще. Точная Причина *почему* это происходит, выходит за рамки данного учебника, см. в разделе [Удаление последней записи на последней странице из GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) низкоуровневые сведения относительно источника эту проблему. Таким образом он s из-за следующие действия, выполняемые с GridView при нажатии кнопки Delete:

1. Удалить запись
2. Получение записей для отображения для указанного `PageIndex` и `PageSize`
3. Проверка того, что `PageIndex` не превышает количество страниц данных в источнике данных; Если функция автоматически уменьшить GridView s `PageIndex` свойство
4. Связывание соответствующей страницы данных к GridView с помощью записей, полученных на шаге 2

Проблема вытекает из того, что `PageIndex` используется, когда получение записей, отображаемых по-прежнему `PageIndex` последней страницы, последняя запись которой была удалена. Таким образом, на шаге 2 *не* записи возвращаются в том случае, поскольку на последней странице данных больше не содержит какие-либо записи. Затем, на шаге 3 GridView осознает, что его `PageIndex` больше, чем общее число страниц в источнике данных (с момента мы ve удалена последняя запись последней страницы) и таким образом уменьшает его `PageIndex` свойство. На шаге 4 GridView пытается выполнить привязку к данным, полученным на шаге 2; Тем не менее на шаге 2, возвращено ни одной записи, поэтому в результате чего пустой GridView. С разбиением на страницы по умолчанию, область t проблема, так как на шаге 2 *все* записи из источника данных.

Чтобы устранить эту проблему у нас есть два варианта. Первый — для создания обработчика событий для GridView s `RowDeleted` обработчик событий, который определяет, сколько записей, отображаемых на странице, которая была удалена. Если была только одна запись, а затем эта запись должна была последней и необходимо уменьшить GridView s `PageIndex`. Само собой, требуется только обновление `PageIndex` Если операция удаления прошла успешна, который можно определить с помощью гарантий, что `e.Exception` свойство `null`.

Этот подход работает, поскольку он обновляет `PageIndex` после шага 1, но перед шаг 2. Поэтому на этапе 2 возвращается правильный набор записей. Для этого используйте код, аналогичный следующему:


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample11.cs)]

Второе решение — создать обработчик событий для ObjectDataSource s `RowDeleted` событий и задать `AffectedRows` свойства со значением 1. После удаления записи на шаге 1 (но до получения данных на шаге 2), обновляет GridView его `PageIndex` свойства, если одну или несколько строк, затронутых операцией. Тем не менее `AffectedRows` свойство не задано, элемент управления ObjectDataSource, и поэтому этот шаг пропускается. Это действие выполняется один из способов является установка вручную `AffectedRows` свойства, если операция удаления завершилась успешно. Это можно сделать с помощью следующего кода:


[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample12.cs)]

Код обоих этих обработчиков можно найти в классе фонового кода `EfficientPaging.aspx` пример.

## <a name="comparing-the-performance-of-default-and-custom-paging"></a>Сравнение производительности стандартного и пользовательского разбиения по страницам

Так как пользовательское разбиение по страницам только отображаемые записи, тогда как разбиение по страницам по умолчанию возвращает *все* записей для каждой страницы отображается, его s снимите, что пользовательское разбиение по страницам является более эффективным, чем разбиения по страницам по умолчанию. Но насколько эффективнее пользовательское разбиение по страницам? Какого рода выигрыш в производительности можно увидеть путем перемещения от одного вида разбиения к другому?

К сожалению, возникли s нет одного универсального все ответить здесь. Выигрыш в производительности зависит от ряда факторов, главные два число записей, разбиваемых по страницам и нагрузки уделено базы данных каналов сервера и обмен данными между веб-сервер и сервер базы данных. Для небольших таблиц, состоящих из нескольких десятков записей разница в производительности можно пренебречь. Для больших таблиц с сотен и тысяч строк однако разница в производительности может стать существенной.

Статьи, [пользовательского разбиения по страницам в ASP.NET 2.0 с SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), несколько тестов, я сравнил различия в производительности между этих двух способов разбиения по страницам таблицы базы данных с помощью 50 000 записей. В этих тестах я сравнил время выполнения запроса на уровне SQL Server (с помощью [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) и на странице ASP.NET с помощью [возможности трассировки ASP.NET s](https://msdn.microsoft.com/library/y13fw6we.aspx). Имейте в виду, что эти тесты выполнялись на моем рабочем компьютере с одним активным пользователем и таким образом нельзя назвать научными и они не демонстрируют шаблонов нагрузки типичный веб-сайт. Тем не менее, они позволяют показать относительную разницу между временем выполнения для по умолчанию и пользовательское разбиение по страницам при работе с достаточно большими объемами данных.


|  | **Средняя Длительность (в секундах)** | **Число чтений** |
| --- | --- | --- |
| **По умолчанию разбиение на страницы SQL Profiler** | 1.411 | 383 |
| **Пользовательского разбиения по страницам SQL Profiler** | 0.002 | 29 |
| **Трассировка ASP.NET разбиение по страницам по умолчанию** | 2.379 | *Н/Д* |
| **Пользовательского разбиения по страницам ASP.NET трассировки** | 0.029 | *Н/Д* |


Как вы видите, получения отдельной страницы данных в среднем требуется 354 меньше операций чтения и завершена за долю времени. На странице ASP.NET, пользовательские страницы был подготавливать к просмотру в близко к 1/100<sup>th</sup> времени уходит при разбиении по умолчанию. См. в разделе [моей статье](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) Дополнительные сведения о этих результатов, а также код и базу данных можно загрузить для воспроизведения этих тестов в своей среде.

## <a name="summary"></a>Сводка

Разбиение по страницам по умолчанию очень просто в реализации достаточно лишь установить флажок Включить разбиение по страницам данных Web управления s смарт-тега, но за эту простоту приходится расплачиваться производительностью. С разбиением на страницы по умолчанию, когда пользователь запрашивает все страницы данных *все* записи, несмотря на то, что лишь небольшая часть из них могут отображаться. Чтобы избавиться от этой лишней, ObjectDataSource предлагает альтернативные разбиение по страницам параметр пользовательское разбиение по страницам.

Хотя пользовательское разбиение позволяет повысить разбиение по страницам s проблем с производительностью, путем извлечения только тех записей, которые должны отображаться, по умолчанию он s больше усилий для реализации пользовательского разбиения по страницам. Во-первых запрос должен быть написан, правильно (и эффективно), отслеживать обращения к определенной нужного подмножества записей. Это можно сделать несколькими способами; было рассмотрено в этом учебнике – используют новые для SQL Server 2005 s `ROW_NUMBER()` позволяет ранжировать результаты, а затем запрашивали только результаты, индекс которых лежит в пределах указанного диапазона. Кроме того нам нужно реализовать средства, позволяющие определить общее число записей, разбиваемых по страницам. После создания этих методов DAL и BLL, необходимо также настроить элемент управления ObjectDataSource, чтобы определить, сколько всего записей разбиваемых по страницам и корректно передавать значения индекс первой строки и максимальное число строк в BLL.

При реализации пользовательского разбиения по страницам требуется несколько этапов и практически не сложнее, чем разбиения по страницам по умолчанию, пользовательское разбиение по страницам при приложить достаточно большими объемами данных. Как изучить результаты, пользовательское разбиение по страницам может сэкономить секунды время визуализации страницы ASP.NET и сделать более светлым нагрузку на сервер базы данных одну или несколько порядков.

Счастливого вам программирования!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP.NET и основатель веб- [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Microsoft с 1998 года. Скотт — независимый консультант, преподаватель и автор. Его последняя книга — [ *Sams Teach ASP.NET 2.0 in 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Ним можно связаться по адресу [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).

> [!div class="step-by-step"]
> [Назад](paging-and-sorting-report-data-cs.md)
> [Вперед](sorting-custom-paged-data-cs.md)
