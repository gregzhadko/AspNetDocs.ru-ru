---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
title: Эффективное разбиение больших объемов данных (Visual Basic) | Документация Майкрософт
author: rick-anderson
description: Возможности разбиения по страницам по умолчанию элемента управления представления данных не подходит при работе с большими объемами данных, таких как его retriev базового элемента управления источника данных...
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 3e20e64a-8808-4b49-88d6-014e2629d56f
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
msc.type: authoredcontent
ms.openlocfilehash: dd1fd089bc4faa18fb2e8112b2820788c1f25ceb
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65130967"
---
# <a name="efficiently-paging-through-large-amounts-of-data-vb"></a><span data-ttu-id="4c263-103">Эффективное разбиение на страницы больших объемов данных (VB)</span><span class="sxs-lookup"><span data-stu-id="4c263-103">Efficiently Paging Through Large Amounts of Data (VB)</span></span>

<span data-ttu-id="4c263-104">по [Скотт Митчелл](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="4c263-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="4c263-105">[Скачайте пример приложения](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) или [скачать PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="4c263-105">[Download Sample App](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span></span>

> <span data-ttu-id="4c263-106">Возможности разбиения по страницам по умолчанию элемента управления представления данных неудобны при работе с большими объемами данных, поскольку его базового элемента управления источника данных получает все записи, несмотря на то, что отображается только подмножество данных.</span><span class="sxs-lookup"><span data-stu-id="4c263-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="4c263-107">В такой ситуации нужно включить пользовательское разбиение по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-107">In such circumstances, we must turn to custom paging.</span></span>

## <a name="introduction"></a><span data-ttu-id="4c263-108">Вступление</span><span class="sxs-lookup"><span data-stu-id="4c263-108">Introduction</span></span>

<span data-ttu-id="4c263-109">Как мы уже говорили в предыдущем учебном курсе, разбиение по страницам можно реализовать одним из двух способов:</span><span class="sxs-lookup"><span data-stu-id="4c263-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="4c263-110">**Разбиение по страницам по умолчанию** можно реализовать, просто установить этот флажок Enable Paging в данных веб-элемента управления s смарт-теге; тем не менее, при просмотре страницы данных, ObjectDataSource извлекает *все* записей, даже Однако только их подмножество, отображаются на странице</span><span class="sxs-lookup"><span data-stu-id="4c263-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="4c263-111">**Пользовательское разбиение по страницам** повышает производительность по умолчанию разбиение по страницам путем извлечения только тех записей из базы данных, которые должны отображаться на странице данных, запрошенный пользователем; тем не менее, пользовательское разбиение по страницам включает в себя немного больше усилий для реализации чем разбиения по страницам по умолчанию</span><span class="sxs-lookup"><span data-stu-id="4c263-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="4c263-112">Из-за простоту реализации достаточно лишь установить флажок и которые производится Готово.</span><span class="sxs-lookup"><span data-stu-id="4c263-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="4c263-113">разбиение по страницам по умолчанию очень привлекательным вариантом.</span><span class="sxs-lookup"><span data-stu-id="4c263-113">default paging is an attractive option.</span></span> <span data-ttu-id="4c263-114">Его н/д ve подход, предполагающий получение всех записей, однако упрощает это вряд ли будет применяться вариант при работе с большими объемами данных или на сайтах с много пользователей одновременно.</span><span class="sxs-lookup"><span data-stu-id="4c263-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="4c263-115">В такой ситуации нужно включить пользовательское разбиение по страницам, чтобы обеспечить время реакции системы.</span><span class="sxs-lookup"><span data-stu-id="4c263-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="4c263-116">Задача пользовательское разбиение по страницам является возможность написать запрос, возвращающий точного набора записей, необходимых для определенной страницы данных.</span><span class="sxs-lookup"><span data-stu-id="4c263-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="4c263-117">К счастью Microsoft SQL Server 2005 имеется новый метод для ранжирование результатов, который позволит нам необходимо написать запрос, возвращающий нужное подмножество записей.</span><span class="sxs-lookup"><span data-stu-id="4c263-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="4c263-118">В этом руководстве будет показано, как использовать это новое ключевое слово SQL Server 2005 реализовать пользовательское разбиение по страницам в элементе управления GridView.</span><span class="sxs-lookup"><span data-stu-id="4c263-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="4c263-119">Хотя пользовательский интерфейс для пользовательского разбиения по страницам по умолчанию, переход от одной страницы к другой идентично значению, пользовательское разбиение по страницам можно несколько раз быстрее, чем разбиения по страницам по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4c263-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="4c263-120">Выигрыш в производительности, пользовательское разбиение по страницам зависит от общего числа записей, разбиваемых по страницам и нагрузки, возлагаемой на сервере базы данных.</span><span class="sxs-lookup"><span data-stu-id="4c263-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="4c263-121">В конце этого руководства мы рассмотрим некоторые численные показатели, демонстрирующие эффективность пользовательского разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>

## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="4c263-122">Шаг 1. Для понимания процесса пользовательского разбиения по страницам</span><span class="sxs-lookup"><span data-stu-id="4c263-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="4c263-123">Если разбиение по страницам данных, точное записей, отображаемых на странице зависят от страницы от запрашиваемых данных и число записей, отображаемых на каждой странице.</span><span class="sxs-lookup"><span data-stu-id="4c263-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="4c263-124">Например представьте, что мы хотели бы постраничного просмотра списка из 81 продуктов, по 10 продуктов на странице.</span><span class="sxs-lookup"><span data-stu-id="4c263-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="4c263-125">При просмотре первой страницы, d необходимо продуктов от 1 до 10. При просмотре на второй странице мы d заинтересовать продуктов 11 до 20 и т. д.</span><span class="sxs-lookup"><span data-stu-id="4c263-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="4c263-126">Существует три переменные, которые определяют, какие записи должны быть получены и способ отображения интерфейса разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="4c263-127">**Индекса первой строки** индекс первой строки в странице данных для отображения; этот индекс может рассчитываться путем умножения индекс страницы записей, отображаемых на одной странице и прибавить 1.</span><span class="sxs-lookup"><span data-stu-id="4c263-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="4c263-128">Например, если разбиение по страницам записей 10 одновременно, для первой страницы (с индексом 0), индекс первой строки равно 0 \* 10 + 1 или 1; для второй страницы (с индексом 1), индекс первой строки-1 \* 10 + 1 , или 11.</span><span class="sxs-lookup"><span data-stu-id="4c263-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="4c263-129">**Максимальное число строк** максимальное число записей, отображаемых на одной странице.</span><span class="sxs-lookup"><span data-stu-id="4c263-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="4c263-130">Эта переменная называется максимальное число строк, так как для последней страницы может быть меньше записей, возвращаемых размер страницы.</span><span class="sxs-lookup"><span data-stu-id="4c263-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="4c263-131">Например при разбиение по страницам записей из 81 наименования продуктов 10 на одну страницу, девятый и последняя страница будет отображаться только одна запись.</span><span class="sxs-lookup"><span data-stu-id="4c263-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="4c263-132">Ни одна из страниц, покажет записей больше, чем значение максимальное число строк.</span><span class="sxs-lookup"><span data-stu-id="4c263-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="4c263-133">**Общего числа записей** общее число записей, разбиваемых по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="4c263-134">Во время этой переменной является t необходимую для определения того, что записей на данной странице, он определяют интерфейс разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="4c263-135">Например если из 81 наименования продуктов, разбиваемых по страницам, интерфейс разбиения по страницам будет отображаться общее число страниц 9 в Интерфейс разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="4c263-136">С разбиением на страницы по умолчанию, индекс первой строки вычисляется как произведение индекса страницы и размера страницы плюс один, тогда как максимальное число строк — это просто размер страницы.</span><span class="sxs-lookup"><span data-stu-id="4c263-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="4c263-137">Так как при разбиении по умолчанию запрашиваются все записи из базы данных при подготовке к просмотру любой из страниц данных, индекс для каждой строки известен, переход к строке индекс первой строки тривиальной задачей.</span><span class="sxs-lookup"><span data-stu-id="4c263-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="4c263-138">Кроме того, легко доступны, так как он общего числа записей s просто число записей в таблице DataTable (или любой объект используется для хранения результатов базы данных).</span><span class="sxs-lookup"><span data-stu-id="4c263-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="4c263-139">Учитывая переменные индекс первой строки и максимальное число строк, пользовательская реализация разбиения по страницам должны возвращать только точные подмножества записей, начиная с индекс первой строки до максимальное число строк, количество записей после этого.</span><span class="sxs-lookup"><span data-stu-id="4c263-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="4c263-140">Пользовательское разбиение по страницам решить две задачи.</span><span class="sxs-lookup"><span data-stu-id="4c263-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="4c263-141">Нам необходимо найти эффективный способ связывания индекса строки с каждой строкой в все данные, разбиваемых по страницам, чтобы получать записи по указанному индексу строки, запуск</span><span class="sxs-lookup"><span data-stu-id="4c263-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="4c263-142">Необходимо указать общее количество записей, разбиваемых по страницам</span><span class="sxs-lookup"><span data-stu-id="4c263-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="4c263-143">В следующих двух шагах мы изучим сценарий SQL, необходимые для ответа на эти две задачи.</span><span class="sxs-lookup"><span data-stu-id="4c263-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="4c263-144">Помимо сценария SQL необходимо также реализовать методы DAL и BLL.</span><span class="sxs-lookup"><span data-stu-id="4c263-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="4c263-145">Шаг 2. Возвращает общее число записей, разбиваемых по страницам</span><span class="sxs-lookup"><span data-stu-id="4c263-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="4c263-146">Перед тем как получить точные подмножества записей для отображаемой странице, позвольте s сначала посмотрим, как вернуть общее число записей, разбиваемых по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="4c263-147">Эти сведения необходимы для правильной настройки пользовательского интерфейса разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="4c263-148">Общее число записей, возвращенных в результате запроса SQL можно получить с помощью [ `COUNT` Агрегатная функция](https://msdn.microsoft.com/library/ms175997.aspx).</span><span class="sxs-lookup"><span data-stu-id="4c263-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="4c263-149">Например, чтобы определить общее число записей в `Products` таблицы, можно использовать следующий запрос:</span><span class="sxs-lookup"><span data-stu-id="4c263-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample1.sql)]

<span data-ttu-id="4c263-150">Позвольте s Добавление метода к DAL, возвращающий данную информацию.</span><span class="sxs-lookup"><span data-stu-id="4c263-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="4c263-151">В частности, мы создадим метод DAL с именем `TotalNumberOfProducts()` , выполняющего `SELECT` инструкции, показанный выше.</span><span class="sxs-lookup"><span data-stu-id="4c263-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="4c263-152">Сначала откройте `Northwind.xsd` файл типизированного набора DataSet в `App_Code/DAL` папку.</span><span class="sxs-lookup"><span data-stu-id="4c263-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="4c263-153">После этого щелкните правой кнопкой мыши `ProductsTableAdapter` в конструкторе и выберите Добавить запрос.</span><span class="sxs-lookup"><span data-stu-id="4c263-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="4c263-154">Как мы видели в предыдущих руководствах ve это позволит нам для добавления нового метода к DAL, при вызове будет выполняться на определенной инструкции SQL или хранимую процедуру.</span><span class="sxs-lookup"><span data-stu-id="4c263-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="4c263-155">Как и в предыдущем курсе метода TableAdapter, в нашем решили использовать специальный оператор SQL.</span><span class="sxs-lookup"><span data-stu-id="4c263-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>

![Использовать специальный оператор SQL](efficiently-paging-through-large-amounts-of-data-vb/_static/image1.png)

<span data-ttu-id="4c263-157">**Рис. 1**: Использовать специальный оператор SQL</span><span class="sxs-lookup"><span data-stu-id="4c263-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>

<span data-ttu-id="4c263-158">На следующем экране можно указать тип создаваемого запроса.</span><span class="sxs-lookup"><span data-stu-id="4c263-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="4c263-159">Так как этот запрос будет возвращать одно скалярное значение общее число записей в `Products` таблицы выберите `SELECT` возвращающий одной значение параметра.</span><span class="sxs-lookup"><span data-stu-id="4c263-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>

![Запрос, используйте инструкцию SELECT, возвращающей одиночное значение](efficiently-paging-through-large-amounts-of-data-vb/_static/image2.png)

<span data-ttu-id="4c263-161">**Рис. 2**: Запрос, используйте инструкцию SELECT, возвращающей одиночное значение</span><span class="sxs-lookup"><span data-stu-id="4c263-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>

<span data-ttu-id="4c263-162">После выбора типа запроса, нужно ввести запрос.</span><span class="sxs-lookup"><span data-stu-id="4c263-162">After indicating the type of query to use, we must next specify the query.</span></span>

![Использование SELECT COUNT(\*) FROM запроса продукта](efficiently-paging-through-large-amounts-of-data-vb/_static/image3.png)

<span data-ttu-id="4c263-164">**Рис. 3**: ВЫБЕРИТЕ СЧЕТЧИК использования (\*) FROM запроса продукта</span><span class="sxs-lookup"><span data-stu-id="4c263-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>

<span data-ttu-id="4c263-165">Наконец укажите имя для метода.</span><span class="sxs-lookup"><span data-stu-id="4c263-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="4c263-166">В качестве s упомянутых выше, позволяют использовать `TotalNumberOfProducts`.</span><span class="sxs-lookup"><span data-stu-id="4c263-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>

![Присвойте имя TotalNumberOfProducts DAL метод](efficiently-paging-through-large-amounts-of-data-vb/_static/image4.png)

<span data-ttu-id="4c263-168">**Рис. 4**: Присвойте имя TotalNumberOfProducts DAL метод</span><span class="sxs-lookup"><span data-stu-id="4c263-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>

<span data-ttu-id="4c263-169">После нажатия кнопки Готово, мастер добавит `TotalNumberOfProducts` метода к DAL.</span><span class="sxs-lookup"><span data-stu-id="4c263-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="4c263-170">Возвращение скалярных методы DAL возвращают значения обнуляемых типов, на случай, если результат запроса SQL `NULL`.</span><span class="sxs-lookup"><span data-stu-id="4c263-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="4c263-171">Наши `COUNT` запрос, тем не менее, всегда будет возвращать отличного`NULL` значением; тем не менее метод DAL не вернет обнуляемое целое.</span><span class="sxs-lookup"><span data-stu-id="4c263-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="4c263-172">Помимо метода DAL нам понадобиться метод на уровне BLL.</span><span class="sxs-lookup"><span data-stu-id="4c263-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="4c263-173">Откройте `ProductsBLL` и добавьте `TotalNumberOfProducts` метод, который просто вызывает DAL s `TotalNumberOfProducts` метод:</span><span class="sxs-lookup"><span data-stu-id="4c263-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample2.vb)]

<span data-ttu-id="4c263-174">DAL s `TotalNumberOfProducts` метод возвращает значение типа обнуляемого целого; тем не менее, мы ve создан `ProductsBLL` класс s `TotalNumberOfProducts` метода, которые возвращает обычное целочисленное значение.</span><span class="sxs-lookup"><span data-stu-id="4c263-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="4c263-175">Таким образом, необходимо иметь `ProductsBLL` класс s `TotalNumberOfProducts` метод возвращать значимую часть обнуляемого целого, возвращенный DAL s `TotalNumberOfProducts` метод.</span><span class="sxs-lookup"><span data-stu-id="4c263-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="4c263-176">Вызов `GetValueOrDefault()` возвращает значение типа обнуляемого целого, если он существует; Если обнуляемого целого, которое является `null`, тем не менее, он возвращает целочисленное значение по умолчанию 0.</span><span class="sxs-lookup"><span data-stu-id="4c263-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="4c263-177">Шаг 3. Возврат точного подмножества записей</span><span class="sxs-lookup"><span data-stu-id="4c263-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="4c263-178">DAL следующей задачей является создание методов в DAL и BLL, которые принимают индекс первой строки и переменные максимальное число строк, речь выше и возвращающие соответствующие записи.</span><span class="sxs-lookup"><span data-stu-id="4c263-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="4c263-179">Перед этим, позволяющие s сначала посмотрим сценарий SQL.</span><span class="sxs-lookup"><span data-stu-id="4c263-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="4c263-180">Нам является то, что нам необходимо найти эффективный способ присваивания индекса каждой строке полного набора записей, разбиваемых по страницам, чтобы получить только те записи, начиная с индекс первой строки (до записи максимальное число записей).</span><span class="sxs-lookup"><span data-stu-id="4c263-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="4c263-181">Это не является сложной задачей, если уже существует столбец в таблице базы данных, который служит в качестве индекса строки.</span><span class="sxs-lookup"><span data-stu-id="4c263-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="4c263-182">На первый взгляд может показаться `Products` таблицы s `ProductID` поля, поскольку первый продукт имеет `ProductID` 1, второго — 2 и т. д.</span><span class="sxs-lookup"><span data-stu-id="4c263-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="4c263-183">Тем не менее удаление продукта из списка в последовательности возникает пропуск, этот подход.</span><span class="sxs-lookup"><span data-stu-id="4c263-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="4c263-184">Существует два общих способа присвоения эффективный способ связывания индекса строки с данными для постраничного просмотра, тем самым позволяя нужного подмножества записей, которые требуется извлечь.</span><span class="sxs-lookup"><span data-stu-id="4c263-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="4c263-185">**С помощью SQL Server 2005 s `ROW_NUMBER()` ключевое слово** знакомы с SQL Server 2005, `ROW_NUMBER()` ключевое слово связывает ранжирования с возвращаемых записей в определенном порядке.</span><span class="sxs-lookup"><span data-stu-id="4c263-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="4c263-186">Присвоенные номера можно использовать в качестве индекса строки для каждой строки.</span><span class="sxs-lookup"><span data-stu-id="4c263-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="4c263-187">**С помощью табличную переменную и `SET ROWCOUNT`**  s SQL Server [ `SET ROWCOUNT` инструкции](https://msdn.microsoft.com/library/ms188774.aspx) может использоваться для указания запроса должны быть обработаны; количество записей [табличные переменные](http://www.sqlteam.com/item.asp?ItemID=9454) локальные переменные T-SQL, которые могут содержать табличные данные, они похожи на [временные таблицы](http://www.sqlteam.com/item.asp?ItemID=2029).</span><span class="sxs-lookup"><span data-stu-id="4c263-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="4c263-188">Этот подход работает одинаково хорошо с Microsoft SQL Server 2005 и SQL Server 2000 (тогда как `ROW_NUMBER()` подход работает только с SQL Server 2005).</span><span class="sxs-lookup"><span data-stu-id="4c263-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="4c263-189">Идея заключается в том, чтобы создать табличную переменную со `IDENTITY` и столбцами для первичных ключей таблицы, данные которых является, разбиваемых по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="4c263-190">После этого содержимое таблицы, данные которого разбиваемых выводится в табличную переменную, тем самым связав последовательные индексы всем строкам (через `IDENTITY` столбец) для каждой записи в таблице.</span><span class="sxs-lookup"><span data-stu-id="4c263-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="4c263-191">После заполнения этой табличной переменной `SELECT` оператором в табличную переменную, присоединенных к исходной таблице, можно выполнить, чтобы извлечь определенной записи.</span><span class="sxs-lookup"><span data-stu-id="4c263-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="4c263-192">`SET ROWCOUNT` Оператор используется для ограничения числа записей, которые должны быть записаны в табличную переменную.</span><span class="sxs-lookup"><span data-stu-id="4c263-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="4c263-193">Этот подход s эффективность зависит от номеров запрашиваемых страниц, как `SET ROWCOUNT` значение присваивается значение индекс первой строки, а также максимальное число строк.</span><span class="sxs-lookup"><span data-stu-id="4c263-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="4c263-194">При работе с небольшими номерами страниц, таких как первый несколько страниц данных этот подход очень эффективен.</span><span class="sxs-lookup"><span data-stu-id="4c263-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="4c263-195">Тем не менее он демонстрирует производительность разбиения на страницы в стиле по умолчанию при загрузке страницы в конце.</span><span class="sxs-lookup"><span data-stu-id="4c263-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="4c263-196">В этом руководстве реализуется с помощью пользовательского разбиения по страницам `ROW_NUMBER()` ключевое слово.</span><span class="sxs-lookup"><span data-stu-id="4c263-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="4c263-197">Дополнительные сведения об использовании табличной переменной и `SET ROWCOUNT` методика, см. в разделе [более эффективным методом для разбиения на страницы через больших результирующих наборов](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span><span class="sxs-lookup"><span data-stu-id="4c263-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="4c263-198">`ROW_NUMBER()` Ключевое слово ранжирования связанные с каждой записи возвращается номер, используя следующий синтаксис:</span><span class="sxs-lookup"><span data-stu-id="4c263-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample3.sql)]

<span data-ttu-id="4c263-199">`ROW_NUMBER()` Возвращает числовое значение, указывающее ранг для каждой записи в соответствии с указанным порядком.</span><span class="sxs-lookup"><span data-stu-id="4c263-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="4c263-200">Например чтобы узнать номер для каждого продукта, упорядочены от самого дорого к самому дешевому, можно использовать следующий запрос:</span><span class="sxs-lookup"><span data-stu-id="4c263-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample4.sql)]

<span data-ttu-id="4c263-201">Рис. 5 показан этот запрос s результаты при выполнении в окне запросов в Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="4c263-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="4c263-202">Обратите внимание, что продукты упорядочены по цене, а также указан порядковый номер для каждой строки.</span><span class="sxs-lookup"><span data-stu-id="4c263-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>

![Порядковый номер включается для каждой записи возвращаются](efficiently-paging-through-large-amounts-of-data-vb/_static/image5.png)

<span data-ttu-id="4c263-204">**Рис. 5**: Порядковый номер включается для каждой записи возвращаются</span><span class="sxs-lookup"><span data-stu-id="4c263-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>

> [!NOTE]
> <span data-ttu-id="4c263-205">`ROW_NUMBER()` лишь один из многих новых функций ранжирования доступна в SQL Server 2005.</span><span class="sxs-lookup"><span data-stu-id="4c263-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="4c263-206">Более глубокое обсуждение `ROW_NUMBER()`, а также других функциях ранжирования, чтение [возвращение ранжированные результаты с помощью Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span><span class="sxs-lookup"><span data-stu-id="4c263-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>

<span data-ttu-id="4c263-207">При ранжировании результатов по заданному `ORDER BY` столбца в `OVER` предложение (`UnitPrice`, в приведенном выше примере), SQL Server должен отсортировать результаты.</span><span class="sxs-lookup"><span data-stu-id="4c263-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="4c263-208">Это — это Быстрая операция, если имеется кластеризованный индекс для соответствующих столбцов, результаты сортируются по, или если имеется покрытия индекса, но может быть более затратным, в противном случае.</span><span class="sxs-lookup"><span data-stu-id="4c263-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="4c263-209">Чтобы повысить производительность, достаточно больших запросов, рассмотрите возможность добавления некластеризованный индекс для столбца, по которому упорядочиваются результаты.</span><span class="sxs-lookup"><span data-stu-id="4c263-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="4c263-210">См. в разделе [Ранжирующие функции и производительности в SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) для более подробно изучить рекомендации по производительности.</span><span class="sxs-lookup"><span data-stu-id="4c263-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="4c263-211">Возвращаемые сведения о рангах `ROW_NUMBER()` нельзя использовать непосредственно в `WHERE` предложение.</span><span class="sxs-lookup"><span data-stu-id="4c263-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="4c263-212">Тем не менее, можно использовать производную таблицу для возвращения `ROW_NUMBER()` результат, который затем может встречаться в `WHERE` предложение.</span><span class="sxs-lookup"><span data-stu-id="4c263-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="4c263-213">Например, следующий запрос использует производную таблицу для возврата столбцов ProductName и UnitPrice, вместе с `ROW_NUMBER()` результат, а затем используется `WHERE` предложение, для которых номера цен лежат только возвращения продуктов — от 11 до 20:</span><span class="sxs-lookup"><span data-stu-id="4c263-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample5.sql)]

<span data-ttu-id="4c263-214">Распространения этой концепции немного дальше, мы используем этот подход, чтобы получить страницу данных для заданных нужные значения индекс первой строки и максимальное число строк:</span><span class="sxs-lookup"><span data-stu-id="4c263-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>

[!code-html[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="4c263-215">Как мы увидим далее в этом руководстве *`StartRowIndex`* предоставляемые ObjectDataSource индексируется начиная с нуля, тогда как `ROW_NUMBER()` значение, возвращенное SQL Server 2005, начинаются с 1.</span><span class="sxs-lookup"><span data-stu-id="4c263-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="4c263-216">Таким образом `WHERE` возвращает записи где `PriceRank` строго больше, чем *`StartRowIndex`* и меньше или равно *`StartRowIndex`*  +  *`MaximumRows`*.</span><span class="sxs-lookup"><span data-stu-id="4c263-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>

<span data-ttu-id="4c263-217">Теперь, мы ve, рассматриваются как `ROW_NUMBER()` может быть используется для получения определенной страницы данных, учитывая значения индекс первой строки и максимальное число строк, теперь нам нужно реализовать эту логику в виде методов DAL и BLL.</span><span class="sxs-lookup"><span data-stu-id="4c263-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="4c263-218">При создании такого метода нужно определить порядок, по которому ранжирования результатов; Пусть продукты сортируются по имени в алфавитном порядке s.</span><span class="sxs-lookup"><span data-stu-id="4c263-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="4c263-219">Это означает, что с реализацию пользовательского разбиения по страницам в этом руководстве мы невозможна для создания пользовательского разбитого на страницы отчета, чем можно было бы отсортировать.</span><span class="sxs-lookup"><span data-stu-id="4c263-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="4c263-220">В следующем учебном курсе Однако мы увидим как можно предоставить подобные функции.</span><span class="sxs-lookup"><span data-stu-id="4c263-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="4c263-221">В предыдущем разделе мы создали метод DAL в виде специальной инструкции SQL.</span><span class="sxs-lookup"><span data-stu-id="4c263-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="4c263-222">К сожалению, синтаксический анализатор T-SQL в Visual Studio, используемый t Мастер TableAdapter как `OVER` синтаксис, используемый `ROW_NUMBER()` функции.</span><span class="sxs-lookup"><span data-stu-id="4c263-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="4c263-223">Таким образом необходимо создать этот метод DAL как хранимую процедуру.</span><span class="sxs-lookup"><span data-stu-id="4c263-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="4c263-224">Выберите в обозревателе сервера из меню "Вид" (или нажмите сочетание клавиш Ctrl + Alt + S) и разверните `NORTHWND.MDF` узла.</span><span class="sxs-lookup"><span data-stu-id="4c263-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="4c263-225">Чтобы добавить новую хранимую процедуру, щелкните правой кнопкой мыши на узел хранимых процедур и выберите команду Добавить новую хранимую процедуру (см. рис. 6).</span><span class="sxs-lookup"><span data-stu-id="4c263-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>

![Добавить новую хранимую процедуру для продуктов по страницам](efficiently-paging-through-large-amounts-of-data-vb/_static/image6.png)

<span data-ttu-id="4c263-227">**Рис. 6**: Добавить новую хранимую процедуру для продуктов по страницам</span><span class="sxs-lookup"><span data-stu-id="4c263-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>

<span data-ttu-id="4c263-228">Эта хранимая процедура должна принимать два целочисленных параметра - `@startRowIndex` и `@maximumRows` и использовать `ROW_NUMBER()` отсортированную по `ProductName` поле, возвращает только те строки, больше чем `@startRowIndex` и меньше или равным `@startRowIndex`  +  `@maximumRow` s.</span><span class="sxs-lookup"><span data-stu-id="4c263-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="4c263-229">Введите приведенный ниже сценарий в новой хранимой процедуры и щелкните значок сохранения, чтобы добавить хранимую процедуру в базу данных.</span><span class="sxs-lookup"><span data-stu-id="4c263-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample7.sql)]

<span data-ttu-id="4c263-230">После создания хранимой процедуры, Отвлекитесь и протестировать его. Щелкните правой кнопкой мыши `GetProductsPaged` хранимой процедуры в обозревателе сервера укажите имя и параметра инструкции Execute.</span><span class="sxs-lookup"><span data-stu-id="4c263-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="4c263-231">Visual Studio появится приглашение для ввода параметров, `@startRowIndex` и `@maximumRow` s (см. рис. 7).</span><span class="sxs-lookup"><span data-stu-id="4c263-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="4c263-232">Попробуйте вводить различные значения и проанализировать результаты.</span><span class="sxs-lookup"><span data-stu-id="4c263-232">Try different values and examine the results.</span></span>

![Введите значение для @startRowIndex и @maximumRows параметров](efficiently-paging-through-large-amounts-of-data-vb/_static/image7.png)

<span data-ttu-id="4c263-234"><strong>Рис. 7</strong>: Введите значение для @startRowIndex и @maximumRows параметров</span><span class="sxs-lookup"><span data-stu-id="4c263-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>

<span data-ttu-id="4c263-235">После выбора этих входных значений параметров, результаты появятся в окне вывода.</span><span class="sxs-lookup"><span data-stu-id="4c263-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="4c263-236">Рис. 8 показаны результаты, если для обоих `@startRowIndex` и `@maximumRows` параметров.</span><span class="sxs-lookup"><span data-stu-id="4c263-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>

<span data-ttu-id="4c263-237">[![Записи, будет отображаться в второй страницы данных возвращаются](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="4c263-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span></span>

<span data-ttu-id="4c263-238">**Рис. 8**: Возвращаются записи, будет отображаться в данные из второй страницы ([Просмотр полноразмерного изображения](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="4c263-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span></span>

<span data-ttu-id="4c263-239">С этим хранимая процедура, созданная, и мы будет готов для создания `ProductsTableAdapter` метод.</span><span class="sxs-lookup"><span data-stu-id="4c263-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="4c263-240">Откройте `Northwind.xsd` типизированный набор DataSet, щелкните правой кнопкой мыши в `ProductsTableAdapter`и выберите пункт Добавить запрос.</span><span class="sxs-lookup"><span data-stu-id="4c263-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="4c263-241">Вместо создания запроса с помощью инструкции SQL ad-hoc, создайте его с помощью существующей хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="4c263-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>

![Создание метода DAL с использованием существующей хранимой процедуры](efficiently-paging-through-large-amounts-of-data-vb/_static/image11.png)

<span data-ttu-id="4c263-243">**Рис. 9**: Создание метода DAL с использованием существующей хранимой процедуры</span><span class="sxs-lookup"><span data-stu-id="4c263-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>

<span data-ttu-id="4c263-244">Далее мы приглашение выбрать нужную хранимую процедуру.</span><span class="sxs-lookup"><span data-stu-id="4c263-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="4c263-245">Выбрать `GetProductsPaged` хранимую процедуру из раскрывающегося списка.</span><span class="sxs-lookup"><span data-stu-id="4c263-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>

![Выберите GetProductsPaged хранимую процедуру из раскрывающегося списка](efficiently-paging-through-large-amounts-of-data-vb/_static/image12.png)

<span data-ttu-id="4c263-247">**Рис. 10**: Выберите GetProductsPaged хранимую процедуру из раскрывающегося списка</span><span class="sxs-lookup"><span data-stu-id="4c263-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>

<span data-ttu-id="4c263-248">Следующем экране вы вида данных возвращается хранимой процедурой: табличные данные, одно значение или нет значения.</span><span class="sxs-lookup"><span data-stu-id="4c263-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="4c263-249">Так как `GetProductsPaged` хранимая процедура может возвращать несколько записей, указывают, что он возвращает табличные данные.</span><span class="sxs-lookup"><span data-stu-id="4c263-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>

![Указывает, что хранимая процедура возвращает табличные данные](efficiently-paging-through-large-amounts-of-data-vb/_static/image13.png)

<span data-ttu-id="4c263-251">**Рис. 11**: Указывает, что хранимая процедура возвращает табличные данные</span><span class="sxs-lookup"><span data-stu-id="4c263-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>

<span data-ttu-id="4c263-252">И наконец укажите имена методов, для создания.</span><span class="sxs-lookup"><span data-stu-id="4c263-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="4c263-253">Как и в предыдущих учебных курсах, продолжим и создание методов с помощью обоих заполнения таблицы DataTable и вернуть таблицу данных.</span><span class="sxs-lookup"><span data-stu-id="4c263-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="4c263-254">Назовем первый метод `FillPaged` , а второй `GetProductsPaged`.</span><span class="sxs-lookup"><span data-stu-id="4c263-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>

![Имя методы FillPaged и GetProductsPaged](efficiently-paging-through-large-amounts-of-data-vb/_static/image14.png)

<span data-ttu-id="4c263-256">**Рис. 12**: Имя методы FillPaged и GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="4c263-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>

<span data-ttu-id="4c263-257">Кроме того для создания метода DAL, возвращающего нужную страницу продуктов, мы также необходимо предоставить подобные функции в BLL.</span><span class="sxs-lookup"><span data-stu-id="4c263-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="4c263-258">Как и метод DAL s BLL метода GetProductsPaged необходимо принять два набора входных данных целое число для указания индекс первой строки и максимальное число строк и должен возвращать только те записи, которые попадают в указанный диапазон.</span><span class="sxs-lookup"><span data-stu-id="4c263-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="4c263-259">Создайте в классе, так что просто вызывает метод вниз в DAL s метода GetProductsPaged класса ProductsBLL:</span><span class="sxs-lookup"><span data-stu-id="4c263-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample8.vb)]

<span data-ttu-id="4c263-260">Вы можете использовать любое имя для входных параметров метода s BLL, но, как мы скоро увидим, что решили использовать `startRowIndex` и `maximumRows` избавляет нас от лишних работу при настройке нового ObjectDataSource для использования этого метода.</span><span class="sxs-lookup"><span data-stu-id="4c263-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="4c263-261">Шаг 4. Настройка ObjectDataSource на использование пользовательского разбиения по страницам</span><span class="sxs-lookup"><span data-stu-id="4c263-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="4c263-262">С помощью методов BLL и DAL для доступа к определенному подмножеству данных мы будет готов для создания элемента управления GridView управлять этой страницы через его базовой записи, с помощью пользовательского разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="4c263-263">Сначала откройте `EfficientPaging.aspx` странице в `PagingAndSorting` папки, добавьте элемент управления GridView на страницу и настроить его для использования нового элемента управления ObjectDataSource.</span><span class="sxs-lookup"><span data-stu-id="4c263-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="4c263-264">В предыдущих курсах мы часто настраивали элемент управления ObjectDataSource, который настроен для использования `ProductsBLL` класс s `GetProducts` метод.</span><span class="sxs-lookup"><span data-stu-id="4c263-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="4c263-265">На этот раз тем не менее, мы хотим использовать `GetProductsPaged` метод вместо этого после `GetProducts` возвращает *все* продуктов в базе данных в то время как `GetProductsPaged` возвращает определенного подмножества записей.</span><span class="sxs-lookup"><span data-stu-id="4c263-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>

![Настройте элемент ObjectDataSource для использования метода GetProductsPaged класса ProductsBLL s](efficiently-paging-through-large-amounts-of-data-vb/_static/image15.png)

<span data-ttu-id="4c263-267">**Рис. 13**: Настройте элемент ObjectDataSource для использования метода GetProductsPaged класса ProductsBLL s</span><span class="sxs-lookup"><span data-stu-id="4c263-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>

<span data-ttu-id="4c263-268">С момента мы повторно создание только для чтения элемента управления GridView Отвлекитесь и задайте метод стрелку раскрывающегося списка в инструкции INSERT, UPDATE и удаление вкладок (нет).</span><span class="sxs-lookup"><span data-stu-id="4c263-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="4c263-269">После этого мастер ObjectDataSource запрашивает источники `GetProductsPaged` метод s `startRowIndex` и `maximumRows` входных значений параметров.</span><span class="sxs-lookup"><span data-stu-id="4c263-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="4c263-270">Эти входные параметры фактически устанавливается с GridView автоматически, просто оставьте исходный набор нет и нажмите кнопку Готово.</span><span class="sxs-lookup"><span data-stu-id="4c263-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>

![Оставьте источники входного параметра, как None](efficiently-paging-through-large-amounts-of-data-vb/_static/image16.png)

<span data-ttu-id="4c263-272">**Рис. 14**: Оставьте источники входного параметра, как None</span><span class="sxs-lookup"><span data-stu-id="4c263-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>

<span data-ttu-id="4c263-273">После завершения работы мастера ObjectDataSource GridView будет содержать BoundField или CheckBoxField для каждого из полей данных продукта.</span><span class="sxs-lookup"><span data-stu-id="4c263-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="4c263-274">Вы можете настроить внешний вид s GridView по своему усмотрению.</span><span class="sxs-lookup"><span data-stu-id="4c263-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="4c263-275">Я решил ve отображения только `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, и `UnitPrice` полей BoundField.</span><span class="sxs-lookup"><span data-stu-id="4c263-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="4c263-276">Кроме того настройте поддержку разбиения по страницам, установив флажок Включить разбиение по страницам в его смарт-теге GridView.</span><span class="sxs-lookup"><span data-stu-id="4c263-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="4c263-277">После внесения этих изменений декларативная разметка GridView и элемент управления ObjectDataSource должен выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="4c263-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample9.aspx)]

<span data-ttu-id="4c263-278">Если зайти на страницу через обозреватель, однако GridView именно не должен быть найден.</span><span class="sxs-lookup"><span data-stu-id="4c263-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>

![— GridView не отображается](efficiently-paging-through-large-amounts-of-data-vb/_static/image17.png)

<span data-ttu-id="4c263-280">**Рис. 15**: — GridView не отображается</span><span class="sxs-lookup"><span data-stu-id="4c263-280">**Figure 15**: The GridView is Not Displayed</span></span>

<span data-ttu-id="4c263-281">GridView отсутствует, так как элемент управления ObjectDataSource используется 0 как значения для обоих `GetProductsPaged` `startRowIndex` и `maximumRows` входных параметров.</span><span class="sxs-lookup"><span data-stu-id="4c263-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="4c263-282">Следовательно, результирующий запрос SQL не возвращает ни одной записи и поэтому GridView не отображается.</span><span class="sxs-lookup"><span data-stu-id="4c263-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="4c263-283">Чтобы исправить это, необходимо настроить ObjectDataSource на использование пользовательского разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="4c263-284">Это можно сделать следующим образом:</span><span class="sxs-lookup"><span data-stu-id="4c263-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="4c263-285">**Набор ObjectDataSource s `EnablePaging` свойства `true`**  это значит, что элемент управления ObjectDataSource, его необходимо передать в `SelectMethod` два дополнительных параметра: один для указания индекс первой строки ([ `StartRowIndexParameterName` ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)) и для указания максимального числа строк ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span><span class="sxs-lookup"><span data-stu-id="4c263-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="4c263-286">**Набор ObjectDataSource s `StartRowIndexParameterName` и `MaximumRowsParameterName` свойства соответствующим образом** `StartRowIndexParameterName` и `MaximumRowsParameterName` обозначают имена параметров, передаваемых в `SelectMethod` для пользовательского разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="4c263-287">По умолчанию эти параметры имеют имена `startIndexRow` и `maximumRows`, поэтому, при создании `GetProductsPaged` метод в BLL, мы использовали такие значения входных параметров.</span><span class="sxs-lookup"><span data-stu-id="4c263-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="4c263-288">Если вы решили использовать другие имена для BLL s `GetProductsPaged` метода, такого как `startIndex` и `maxRows`, для примера, вам потребовалось бы значение ObjectDataSource s `StartRowIndexParameterName` и `MaximumRowsParameterName` свойства соответствующим образом (например, startIndex для `StartRowIndexParameterName` и maxRows для `MaximumRowsParameterName`).</span><span class="sxs-lookup"><span data-stu-id="4c263-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="4c263-289">**Набор ObjectDataSource s [ `SelectCountMethod` свойство](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) имя метода, который возвращает общее число из записи выполняется, разбитых на страницы через (`TotalNumberOfProducts`)** помните, что `ProductsBLL` класс s `TotalNumberOfProducts`метод возвращает общее число записей, разбиваемых по страницам с помощью метода DAL, который выполняет `SELECT COUNT(*) FROM Products` запроса.</span><span class="sxs-lookup"><span data-stu-id="4c263-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="4c263-290">Эти сведения необходимы элементом ObjectDataSource, чтобы правильно отображения интерфейса разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="4c263-291">**Удалить `startRowIndex` и `maximumRows` `<asp:Parameter>` элементы из s декларативная разметка ObjectDataSource** при настройке элемента управления ObjectDataSource в мастере, Visual Studio автоматически добавляет два `<asp:Parameter>` элементов для `GetProductsPaged` метод s входных параметров.</span><span class="sxs-lookup"><span data-stu-id="4c263-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="4c263-292">Установив `EnablePaging` для `true`, эти параметры будут переданы автоматически; Если оставить их в декларативном синтаксисе, элемент управления ObjectDataSource будет пытаться передать *четыре* параметров `GetProductsPaged` метод и два параметра `TotalNumberOfProducts` метод.</span><span class="sxs-lookup"><span data-stu-id="4c263-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="4c263-293">Если вы забыли удалить эти `<asp:Parameter>` элементов, при просмотре страницы в обозревателе, вы получите сообщение об ошибке, например: *ObjectDataSource 'ObjectDataSource1' не удалось найти неуниверсальный метод «TotalNumberOfProducts» с параметрами: startRowIndex maximumRows*.</span><span class="sxs-lookup"><span data-stu-id="4c263-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="4c263-294">После внесения этих изменений декларативный синтаксис s ObjectDataSource должен выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="4c263-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample10.aspx)]

<span data-ttu-id="4c263-295">Обратите внимание, что `EnablePaging` и `SelectCountMethod` заданы свойства и `<asp:Parameter>` элементы будут удалены.</span><span class="sxs-lookup"><span data-stu-id="4c263-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="4c263-296">Рис. 16 показан снимок экрана окна свойств после внесения этих изменений.</span><span class="sxs-lookup"><span data-stu-id="4c263-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>

![Чтобы использовать пользовательское разбиение по страницам, настройте элемент управления ObjectDataSource](efficiently-paging-through-large-amounts-of-data-vb/_static/image18.png)

<span data-ttu-id="4c263-298">**Рис. 16**: Чтобы использовать пользовательское разбиение по страницам, настройте элемент управления ObjectDataSource</span><span class="sxs-lookup"><span data-stu-id="4c263-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>

<span data-ttu-id="4c263-299">После внесения этих изменений, посетите эту страницу через обозреватель.</span><span class="sxs-lookup"><span data-stu-id="4c263-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="4c263-300">Вы должны увидеть 10 продуктов в списке, представлены в алфавитном порядке.</span><span class="sxs-lookup"><span data-stu-id="4c263-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="4c263-301">Отвлекитесь и пошаговое выполнение на одной странице данных за раз.</span><span class="sxs-lookup"><span data-stu-id="4c263-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="4c263-302">Пока нет никакой разницы с точки зрения конечного пользователя s между стандартным и пользовательское разбиение по страницам, пользовательское разбиение гораздо более эффективно по страницам больших объемов данных, так как он получает только те записи, которые должны отображаться для данной страницы.</span><span class="sxs-lookup"><span data-stu-id="4c263-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>

<span data-ttu-id="4c263-303">[![К данным, упорядоченный по продукту — имя, является, разбитых на страницы с помощью пользовательского разбиения по страницам](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="4c263-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span></span>

<span data-ttu-id="4c263-304">**Рис. 17**: К данным, упорядоченный по продукту — имя, является, разбитых на страницы с помощью пользовательского разбиения по страницам ([Просмотр полноразмерного изображения](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="4c263-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span></span>

> [!NOTE]
> <span data-ttu-id="4c263-305">При пользовательском разбиении страница подсчета значение, возвращенное ObjectDataSource s `SelectCountMethod` хранится в GridView состояние представления s.</span><span class="sxs-lookup"><span data-stu-id="4c263-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="4c263-306">Другие переменные GridView `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` коллекции и т. д., хранятся в *состояние элемента управления*, которое сохраняется вне зависимости от значения параметра GridView s `EnableViewState` свойство.</span><span class="sxs-lookup"><span data-stu-id="4c263-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="4c263-307">Так как `PageCount` значение сохраняется во время обратной передачи, с помощью состояния представления, при использовании интерфейса разбиения по страницам, со ссылкой, чтобы перейти к последней странице, крайне важно включенное состояние представления s GridView.</span><span class="sxs-lookup"><span data-stu-id="4c263-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="4c263-308">(Если в интерфейсе разбиения по страницам не поддерживает прямую ссылку к последней странице, вы можете отключить состояние представления.)</span><span class="sxs-lookup"><span data-stu-id="4c263-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>

<span data-ttu-id="4c263-309">Щелкнув ссылки на последнюю страницу вызывает обратную передачу и указывает, что для обновления GridView его `PageIndex` свойство.</span><span class="sxs-lookup"><span data-stu-id="4c263-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="4c263-310">При нажатии ссылки на последнюю страницу GridView назначает его `PageIndex` одно значение меньшее, чем `PageCount` свойство.</span><span class="sxs-lookup"><span data-stu-id="4c263-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="4c263-311">В отключенном состоянии представления `PageCount` теряется при обратных передач и `PageIndex` вместо присваивается максимальное целое значение.</span><span class="sxs-lookup"><span data-stu-id="4c263-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="4c263-312">Затем GridView пытается определить начальный индекс строки путем перемножения `PageSize` и `PageCount` свойства.</span><span class="sxs-lookup"><span data-stu-id="4c263-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="4c263-313">В результате `OverflowException` так, как продукт превышает размер целочисленное значение максимально допустимого.</span><span class="sxs-lookup"><span data-stu-id="4c263-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="4c263-314">Реализация пользовательского разбиения по страницам и сортировка</span><span class="sxs-lookup"><span data-stu-id="4c263-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="4c263-315">Текущей реализацией пользовательского разбиения по страницам требует, что заказ, по которому страницам данных определяется статически при создании `GetProductsPaged` хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="4c263-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="4c263-316">Тем не менее вы записали, смарт-тега GridView s содержит флажок Включить сортировку, помимо возможности включить разбиение по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="4c263-317">К сожалению Если включить поддержку сортировки к GridView с текущей реализацией пользовательского разбиения по страницам будут отсортированы только записи на текущей просматриваемой странице данных.</span><span class="sxs-lookup"><span data-stu-id="4c263-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="4c263-318">Например при настройке GridView для разбиения по страницам, а затем, при просмотре первой страницы данных, отсортировать по названию продукта в убывающем порядке, в его обратный порядок продуктов на странице 1.</span><span class="sxs-lookup"><span data-stu-id="4c263-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="4c263-319">Как показано на рис. 18, продукт Carnarvon Tigers стал первым продуктом при сортировке в обратном алфавитном порядке, который пропускает 71 другие продукты, полученные после Carnarvon Tigers, в алфавитном порядке; в сортировке, считаются только те записи, на первой странице.</span><span class="sxs-lookup"><span data-stu-id="4c263-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>

<span data-ttu-id="4c263-320">[![Сортируются только данные отображаются на текущей странице](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="4c263-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span></span>

<span data-ttu-id="4c263-321">**Рис. 18**: Сортируются только данные отображаются на текущей странице ([Просмотр полноразмерного изображения](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="4c263-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span></span>

<span data-ttu-id="4c263-322">В сортировке участвуют только к текущей странице данных, поскольку сортировка происходит после получения данных из BLL s `GetProductsPaged` метод и этот метод возвращает только записи одной страницы.</span><span class="sxs-lookup"><span data-stu-id="4c263-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="4c263-323">Для правильной сортировки необходимо передать выражение сортировки `GetProductsPaged` метод таким образом, чтобы упорядочить данные до возврата нужной страницы данных.</span><span class="sxs-lookup"><span data-stu-id="4c263-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="4c263-324">Узнаете, как это сделать в нашем следующем учебном курсе.</span><span class="sxs-lookup"><span data-stu-id="4c263-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="4c263-325">Реализация пользовательского разбиения по страницам и удаления</span><span class="sxs-lookup"><span data-stu-id="4c263-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="4c263-326">Если необходимо включить функцию удаления в элементе управления GridView, данные которых отображаются с помощью настраиваемых способов разбиения по страницам, можно найти, при удалении последней записи на последней странице GridView исчезает вместо того чтобы надлежащим образом уменьшить GridView s `PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="4c263-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="4c263-327">Чтобы воспроизвести эту ситуацию, включите поддержку удаления в только что только что созданной.</span><span class="sxs-lookup"><span data-stu-id="4c263-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="4c263-328">Перейдите на последнюю страницу (страница 9), где должен отображаться один продукт, так как мы разбиение по страницам из 81 наименования продуктов, 10 продуктов за раз.</span><span class="sxs-lookup"><span data-stu-id="4c263-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="4c263-329">Удалите этот продукт.</span><span class="sxs-lookup"><span data-stu-id="4c263-329">Delete this product.</span></span>

<span data-ttu-id="4c263-330">После удаления последнего продукта GridView *следует* автоматически перейти на страницу восьмой, и этот механизм корректно работает с разбиением на страницы по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4c263-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="4c263-331">С помощью пользовательского разбиения по страницам, однако после удаления последнего продукта на последней странице GridView просто исчезает с экрана вообще.</span><span class="sxs-lookup"><span data-stu-id="4c263-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="4c263-332">Точная Причина *почему* это происходит, выходит за рамки данного учебника, см. в разделе [Удаление последней записи на последней странице из GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) низкоуровневые сведения относительно источника эту проблему.</span><span class="sxs-lookup"><span data-stu-id="4c263-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="4c263-333">Таким образом он s из-за следующие действия, выполняемые с GridView при нажатии кнопки Delete:</span><span class="sxs-lookup"><span data-stu-id="4c263-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="4c263-334">Удалить запись</span><span class="sxs-lookup"><span data-stu-id="4c263-334">Delete the record</span></span>
2. <span data-ttu-id="4c263-335">Получение записей для отображения для указанного `PageIndex` и `PageSize`</span><span class="sxs-lookup"><span data-stu-id="4c263-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="4c263-336">Проверка того, что `PageIndex` не превышает количество страниц данных в источнике данных; Если функция автоматически уменьшить GridView s `PageIndex` свойство</span><span class="sxs-lookup"><span data-stu-id="4c263-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="4c263-337">Связывание соответствующей страницы данных к GridView с помощью записей, полученных на шаге 2</span><span class="sxs-lookup"><span data-stu-id="4c263-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="4c263-338">Проблема вытекает из того, что `PageIndex` используется, когда получение записей, отображаемых по-прежнему `PageIndex` последней страницы, последняя запись которой была удалена.</span><span class="sxs-lookup"><span data-stu-id="4c263-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="4c263-339">Таким образом, на шаге 2 *не* записи возвращаются в том случае, поскольку на последней странице данных больше не содержит какие-либо записи.</span><span class="sxs-lookup"><span data-stu-id="4c263-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="4c263-340">Затем, на шаге 3 GridView осознает, что его `PageIndex` больше, чем общее число страниц в источнике данных (с момента мы ve удалена последняя запись последней страницы) и таким образом уменьшает его `PageIndex` свойство.</span><span class="sxs-lookup"><span data-stu-id="4c263-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="4c263-341">На шаге 4 GridView пытается выполнить привязку к данным, полученным на шаге 2; Тем не менее на шаге 2, возвращено ни одной записи, поэтому в результате чего пустой GridView.</span><span class="sxs-lookup"><span data-stu-id="4c263-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="4c263-342">С разбиением на страницы по умолчанию, область t проблема, так как на шаге 2 *все* записи из источника данных.</span><span class="sxs-lookup"><span data-stu-id="4c263-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="4c263-343">Чтобы устранить эту проблему у нас есть два варианта.</span><span class="sxs-lookup"><span data-stu-id="4c263-343">To fix this we have two options.</span></span> <span data-ttu-id="4c263-344">Первый — для создания обработчика событий для GridView s `RowDeleted` обработчик событий, который определяет, сколько записей, отображаемых на странице, которая была удалена.</span><span class="sxs-lookup"><span data-stu-id="4c263-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="4c263-345">Если была только одна запись, а затем эта запись должна была последней и необходимо уменьшить GridView s `PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="4c263-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="4c263-346">Само собой, требуется только обновление `PageIndex` Если операция удаления прошла успешна, который можно определить с помощью гарантий, что `e.Exception` свойство `null`.</span><span class="sxs-lookup"><span data-stu-id="4c263-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="4c263-347">Этот подход работает, поскольку он обновляет `PageIndex` после шага 1, но перед шаг 2.</span><span class="sxs-lookup"><span data-stu-id="4c263-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="4c263-348">Поэтому на этапе 2 возвращается правильный набор записей.</span><span class="sxs-lookup"><span data-stu-id="4c263-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="4c263-349">Для этого используйте код, аналогичный следующему:</span><span class="sxs-lookup"><span data-stu-id="4c263-349">To accomplish this, use code like the following:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample11.vb)]

<span data-ttu-id="4c263-350">Второе решение — создать обработчик событий для ObjectDataSource s `RowDeleted` событий и задать `AffectedRows` свойства со значением 1.</span><span class="sxs-lookup"><span data-stu-id="4c263-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="4c263-351">После удаления записи на шаге 1 (но до получения данных на шаге 2), обновляет GridView его `PageIndex` свойства, если одну или несколько строк, затронутых операцией.</span><span class="sxs-lookup"><span data-stu-id="4c263-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="4c263-352">Тем не менее `AffectedRows` свойство не задано, элемент управления ObjectDataSource, и поэтому этот шаг пропускается.</span><span class="sxs-lookup"><span data-stu-id="4c263-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="4c263-353">Это действие выполняется один из способов является установка вручную `AffectedRows` свойства, если операция удаления завершилась успешно.</span><span class="sxs-lookup"><span data-stu-id="4c263-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="4c263-354">Это можно сделать с помощью следующего кода:</span><span class="sxs-lookup"><span data-stu-id="4c263-354">This can be accomplished using code like the following:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample12.vb)]

<span data-ttu-id="4c263-355">Код обоих этих обработчиков можно найти в классе фонового кода `EfficientPaging.aspx` пример.</span><span class="sxs-lookup"><span data-stu-id="4c263-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="4c263-356">Сравнение производительности стандартного и пользовательского разбиения по страницам</span><span class="sxs-lookup"><span data-stu-id="4c263-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="4c263-357">Так как пользовательское разбиение по страницам только отображаемые записи, тогда как разбиение по страницам по умолчанию возвращает *все* записей для каждой страницы отображается, его s снимите, что пользовательское разбиение по страницам является более эффективным, чем разбиения по страницам по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4c263-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="4c263-358">Но насколько эффективнее пользовательское разбиение по страницам?</span><span class="sxs-lookup"><span data-stu-id="4c263-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="4c263-359">Какого рода выигрыш в производительности можно увидеть путем перемещения от одного вида разбиения к другому?</span><span class="sxs-lookup"><span data-stu-id="4c263-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="4c263-360">К сожалению, возникли s нет одного универсального все ответить здесь.</span><span class="sxs-lookup"><span data-stu-id="4c263-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="4c263-361">Выигрыш в производительности зависит от ряда факторов, главные два число записей, разбиваемых по страницам и нагрузки уделено базы данных каналов сервера и обмен данными между веб-сервер и сервер базы данных.</span><span class="sxs-lookup"><span data-stu-id="4c263-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="4c263-362">Для небольших таблиц, состоящих из нескольких десятков записей разница в производительности можно пренебречь.</span><span class="sxs-lookup"><span data-stu-id="4c263-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="4c263-363">Для больших таблиц с сотен и тысяч строк однако разница в производительности может стать существенной.</span><span class="sxs-lookup"><span data-stu-id="4c263-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="4c263-364">Статьи, [пользовательского разбиения по страницам в ASP.NET 2.0 с SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), несколько тестов, я сравнил различия в производительности между этих двух способов разбиения по страницам таблицы базы данных с помощью 50 000 записей.</span><span class="sxs-lookup"><span data-stu-id="4c263-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="4c263-365">В этих тестах я сравнил время выполнения запроса на уровне SQL Server (с помощью [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) и на странице ASP.NET с помощью [возможности трассировки ASP.NET s](https://msdn.microsoft.com/library/y13fw6we.aspx).</span><span class="sxs-lookup"><span data-stu-id="4c263-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="4c263-366">Имейте в виду, что эти тесты выполнялись на моем рабочем компьютере с одним активным пользователем и таким образом нельзя назвать научными и они не демонстрируют шаблонов нагрузки типичный веб-сайт.</span><span class="sxs-lookup"><span data-stu-id="4c263-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="4c263-367">Тем не менее, они позволяют показать относительную разницу между временем выполнения для по умолчанию и пользовательское разбиение по страницам при работе с достаточно большими объемами данных.</span><span class="sxs-lookup"><span data-stu-id="4c263-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>

|  | <span data-ttu-id="4c263-368">**Средняя Длительность (в секундах)**</span><span class="sxs-lookup"><span data-stu-id="4c263-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="4c263-369">**Число считываний**</span><span class="sxs-lookup"><span data-stu-id="4c263-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="4c263-370">**По умолчанию разбиение на страницы SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="4c263-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="4c263-371">1.411</span><span class="sxs-lookup"><span data-stu-id="4c263-371">1.411</span></span> | <span data-ttu-id="4c263-372">383</span><span class="sxs-lookup"><span data-stu-id="4c263-372">383</span></span> |
| <span data-ttu-id="4c263-373">**Пользовательского разбиения по страницам SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="4c263-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="4c263-374">0.002</span><span class="sxs-lookup"><span data-stu-id="4c263-374">0.002</span></span> | <span data-ttu-id="4c263-375">29</span><span class="sxs-lookup"><span data-stu-id="4c263-375">29</span></span> |
| <span data-ttu-id="4c263-376">**Трассировка ASP.NET разбиение по страницам по умолчанию**</span><span class="sxs-lookup"><span data-stu-id="4c263-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="4c263-377">2.379</span><span class="sxs-lookup"><span data-stu-id="4c263-377">2.379</span></span> | <span data-ttu-id="4c263-378">*Н/Д*</span><span class="sxs-lookup"><span data-stu-id="4c263-378">*N/A*</span></span> |
| <span data-ttu-id="4c263-379">**Пользовательского разбиения по страницам ASP.NET трассировки**</span><span class="sxs-lookup"><span data-stu-id="4c263-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="4c263-380">0.029</span><span class="sxs-lookup"><span data-stu-id="4c263-380">0.029</span></span> | <span data-ttu-id="4c263-381">*Н/Д*</span><span class="sxs-lookup"><span data-stu-id="4c263-381">*N/A*</span></span> |

<span data-ttu-id="4c263-382">Как вы видите, получения отдельной страницы данных в среднем требуется 354 меньше операций чтения и завершена за долю времени.</span><span class="sxs-lookup"><span data-stu-id="4c263-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="4c263-383">На странице ASP.NET, пользовательские страницы был подготавливать к просмотру в близко к 1/100<sup>th</sup> времени уходит при разбиении по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4c263-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="4c263-384">См. в разделе [моей статье](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) Дополнительные сведения о этих результатов, а также код и базу данных можно загрузить для воспроизведения этих тестов в своей среде.</span><span class="sxs-lookup"><span data-stu-id="4c263-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="4c263-385">Сводка</span><span class="sxs-lookup"><span data-stu-id="4c263-385">Summary</span></span>

<span data-ttu-id="4c263-386">Разбиение по страницам по умолчанию очень просто в реализации достаточно лишь установить флажок Включить разбиение по страницам данных Web управления s смарт-тега, но за эту простоту приходится расплачиваться производительностью.</span><span class="sxs-lookup"><span data-stu-id="4c263-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="4c263-387">С разбиением на страницы по умолчанию, когда пользователь запрашивает все страницы данных *все* записи, несмотря на то, что лишь небольшая часть из них могут отображаться.</span><span class="sxs-lookup"><span data-stu-id="4c263-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="4c263-388">Чтобы избавиться от этой лишней, ObjectDataSource предлагает альтернативные разбиение по страницам параметр пользовательское разбиение по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="4c263-389">Хотя пользовательское разбиение позволяет повысить разбиение по страницам s проблем с производительностью, путем извлечения только тех записей, которые должны отображаться, по умолчанию он s больше усилий для реализации пользовательского разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="4c263-390">Во-первых запрос должен быть написан, правильно (и эффективно), отслеживать обращения к определенной нужного подмножества записей.</span><span class="sxs-lookup"><span data-stu-id="4c263-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="4c263-391">Это можно сделать несколькими способами; было рассмотрено в этом учебнике – используют новые для SQL Server 2005 s `ROW_NUMBER()` позволяет ранжировать результаты, а затем запрашивали только результаты, индекс которых лежит в пределах указанного диапазона.</span><span class="sxs-lookup"><span data-stu-id="4c263-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="4c263-392">Кроме того нам нужно реализовать средства, позволяющие определить общее число записей, разбиваемых по страницам.</span><span class="sxs-lookup"><span data-stu-id="4c263-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="4c263-393">После создания этих методов DAL и BLL, необходимо также настроить элемент управления ObjectDataSource, чтобы определить, сколько всего записей разбиваемых по страницам и корректно передавать значения индекс первой строки и максимальное число строк в BLL.</span><span class="sxs-lookup"><span data-stu-id="4c263-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="4c263-394">При реализации пользовательского разбиения по страницам требуется несколько этапов и практически не сложнее, чем разбиения по страницам по умолчанию, пользовательское разбиение по страницам при приложить достаточно большими объемами данных.</span><span class="sxs-lookup"><span data-stu-id="4c263-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="4c263-395">Как изучить результаты, пользовательское разбиение по страницам может сэкономить секунды время визуализации страницы ASP.NET и сделать более светлым нагрузку на сервер базы данных одну или несколько порядков.</span><span class="sxs-lookup"><span data-stu-id="4c263-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="4c263-396">Счастливого вам программирования!</span><span class="sxs-lookup"><span data-stu-id="4c263-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="4c263-397">Об авторе</span><span class="sxs-lookup"><span data-stu-id="4c263-397">About the Author</span></span>

<span data-ttu-id="4c263-398">[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP.NET и основатель веб- [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Microsoft с 1998 года.</span><span class="sxs-lookup"><span data-stu-id="4c263-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="4c263-399">Скотт — независимый консультант, преподаватель и автор.</span><span class="sxs-lookup"><span data-stu-id="4c263-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="4c263-400">Его последняя книга — [ *Sams Teach ASP.NET 2.0 in 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span><span class="sxs-lookup"><span data-stu-id="4c263-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="4c263-401">Ним можно связаться по адресу [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="4c263-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="4c263-402">или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).</span><span class="sxs-lookup"><span data-stu-id="4c263-402">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="4c263-403">[Назад](paging-and-sorting-report-data-vb.md)
> [Вперед](sorting-custom-paged-data-vb.md)</span><span class="sxs-lookup"><span data-stu-id="4c263-403">[Previous](paging-and-sorting-report-data-vb.md)
[Next](sorting-custom-paged-data-vb.md)</span></span>
