---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
title: Эффективное разбиение на страницы больших объемов данных (VB) | Документация Майкрософт
author: rick-anderson
description: Параметр разбиения по страницам по умолчанию для элемента управления представления данных не подходит при работе с большими объемами данных, так как его базовый элемент управления источника данных получает...
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 3e20e64a-8808-4b49-88d6-014e2629d56f
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-vb
msc.type: authoredcontent
ms.openlocfilehash: 0c788c4109d0d2839de969c628399290376a1ccd
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2019
ms.locfileid: "74612968"
---
# <a name="efficiently-paging-through-large-amounts-of-data-vb"></a><span data-ttu-id="0e697-103">Эффективное разбиение на страницы больших объемов данных (VB)</span><span class="sxs-lookup"><span data-stu-id="0e697-103">Efficiently Paging Through Large Amounts of Data (VB)</span></span>

<span data-ttu-id="0e697-104">по [Скотт Митчелл](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="0e697-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="0e697-105">[Скачивание примера приложения](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) или [Загрузка PDF-файла](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="0e697-105">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_VB.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-vb/_static/datatutorial25vb1.pdf)</span></span>

> <span data-ttu-id="0e697-106">Параметр разбиения по страницам по умолчанию элемента управления представления данных не подходит для работы с большими объемами данных, так как его базовый элемент управления источника данных получает все записи, даже если отображается только подмножество данных.</span><span class="sxs-lookup"><span data-stu-id="0e697-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="0e697-107">В таких обстоятельствах необходимо включить пользовательское разбиение на страницы.</span><span class="sxs-lookup"><span data-stu-id="0e697-107">In such circumstances, we must turn to custom paging.</span></span>

## <a name="introduction"></a><span data-ttu-id="0e697-108">Введение</span><span class="sxs-lookup"><span data-stu-id="0e697-108">Introduction</span></span>

<span data-ttu-id="0e697-109">Как обсуждалось в предыдущем учебном курсе, разбиение по страницам можно реализовать одним из двух способов:</span><span class="sxs-lookup"><span data-stu-id="0e697-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="0e697-110">**Разбиение по страницам по умолчанию** можно реализовать, просто установив флажок Включить разбиение по страницам в смарт-теге элемента управления данными. Однако при просмотре страницы данных ObjectDataSource извлекает *все* записи, несмотря на то, что на странице отображаются только их подмножество.</span><span class="sxs-lookup"><span data-stu-id="0e697-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="0e697-111">**Пользовательское разбиение** на страницы улучшает производительность разбиения по страницам по умолчанию, получая из базы данных только те записи, которые должны отображаться для конкретной странице данных, запрошенных пользователем. Однако пользовательское разбиение по страницам требует немного больше усилий, чем разбиение по умолчанию</span><span class="sxs-lookup"><span data-stu-id="0e697-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="0e697-112">Из-за простоты реализации просто установите флажок и повторите попытку.</span><span class="sxs-lookup"><span data-stu-id="0e697-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="0e697-113">разбиение по страницам по умолчанию является привлекательным вариантом.</span><span class="sxs-lookup"><span data-stu-id="0e697-113">default paging is an attractive option.</span></span> <span data-ttu-id="0e697-114">Однако его подход «НД» при извлечении всех записей делает его предполагающийным выбором при разбиении на страницы достаточно большого объема данных или для сайтов с большим количеством одновременных пользователей.</span><span class="sxs-lookup"><span data-stu-id="0e697-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="0e697-115">В таких обстоятельствах необходимо включить пользовательское разбиение на страницы, чтобы обеспечить скорость реагирования системы.</span><span class="sxs-lookup"><span data-stu-id="0e697-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="0e697-116">Задача пользовательского разбиения по страницам — возможность написать запрос, возвращающий точный набор записей, необходимых для конкретной страницы данных.</span><span class="sxs-lookup"><span data-stu-id="0e697-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="0e697-117">К счастью, Microsoft SQL Server 2005 предоставляет новое ключевое слово для ранжирования результатов, что позволяет нам создавать запросы, которые эффективно извлекают подмножество записей.</span><span class="sxs-lookup"><span data-stu-id="0e697-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="0e697-118">В этом учебнике мы увидим, как использовать это новое ключевое слово SQL Server 2005 для реализации пользовательского разбиения на страницы в элементе управления GridView.</span><span class="sxs-lookup"><span data-stu-id="0e697-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="0e697-119">Несмотря на то, что пользовательский интерфейс для пользовательского разбиения по страницам аналогичен постраничному разбиению по умолчанию, переход от одной страницы к другой с помощью пользовательского разбиения по страницам может быть несколько порядков быстрее, чем разбиение по страницам</span><span class="sxs-lookup"><span data-stu-id="0e697-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="0e697-120">Точное увеличение производительности, которое проявляется с помощью пользовательского разбиения на страницы, зависит от общего числа страниц, на которых выполняется разбивка на страницы, и нагрузки на сервер базы данных.</span><span class="sxs-lookup"><span data-stu-id="0e697-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="0e697-121">По завершении работы с этим руководством мы рассмотрим некоторые приблизительные метрики, демонстрирующие преимущества производительности, получаемые с помощью пользовательского разбиения на страницы.</span><span class="sxs-lookup"><span data-stu-id="0e697-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>

## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="0e697-122">Шаг 1. Основные сведения о пользовательском процессе разбиения на страницы</span><span class="sxs-lookup"><span data-stu-id="0e697-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="0e697-123">При разбиении по страницам данных точные записи, отображаемые на странице, зависят от запрашиваемой страницы данных и количества записей, отображаемых на странице.</span><span class="sxs-lookup"><span data-stu-id="0e697-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="0e697-124">Например, представьте, что нам нужно пролистать продукты 81, отображая 10 продуктов на странице.</span><span class="sxs-lookup"><span data-stu-id="0e697-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="0e697-125">При просмотре первой страницы нам нужно, чтобы продукты с 1 по 10 были При просмотре второй страницы мы будем заинтересованы в продуктах с 11 по 20 и т. д.</span><span class="sxs-lookup"><span data-stu-id="0e697-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="0e697-126">Есть три переменные, которые определяют, какие записи необходимо получить, и как должен быть визуализирован интерфейс разбиения по страницам:</span><span class="sxs-lookup"><span data-stu-id="0e697-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="0e697-127">**Начать индекс строки** индекс первой строки на странице отображаемых данных; Этот индекс можно вычислить, умножив индекс страницы по записям, отображаемым на страницу, и добавив ее.</span><span class="sxs-lookup"><span data-stu-id="0e697-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="0e697-128">Например, при разбиении по записям 10 за раз для первой страницы (чей индекс страницы равен 0) Индекс начальной строки равен 0 \* 10 + 1 или 1; для второй страницы (чей индекс страницы равен 1) Индекс начальной строки равен 1 \* 10 + 1 или 11.</span><span class="sxs-lookup"><span data-stu-id="0e697-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="0e697-129">**Максимальное число строк** , отображаемых на страницу по максимальному числу записей.</span><span class="sxs-lookup"><span data-stu-id="0e697-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="0e697-130">Эта переменная называется максимальным числом строк, так как для последней страницы может быть меньше записей, чем размер страницы.</span><span class="sxs-lookup"><span data-stu-id="0e697-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="0e697-131">Например, при разбиении по страницам 10 записей продуктов 81 на странице девятая и последняя страницы будут содержать только одну запись.</span><span class="sxs-lookup"><span data-stu-id="0e697-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="0e697-132">Ни одна страница не будет показывать больше записей, чем максимальное значение строк.</span><span class="sxs-lookup"><span data-stu-id="0e697-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="0e697-133">**Общее** количество записей общее число страниц, на которые размещается страница.</span><span class="sxs-lookup"><span data-stu-id="0e697-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="0e697-134">Хотя эта переменная не требуется для определения того, какие записи следует получить для данной страницы, она определяет интерфейс разбиения на себя.</span><span class="sxs-lookup"><span data-stu-id="0e697-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="0e697-135">Например, если имеется 81 продуктов, то интерфейс разбиения по страницам будет отображать девять номеров страниц в пользовательском интерфейсе разбиения на страницы.</span><span class="sxs-lookup"><span data-stu-id="0e697-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="0e697-136">При использовании разбиения по страницам по умолчанию индекс начальной строки вычисляются как произведение индекса страницы и размера страницы плюс один, в то время как максимальное количество строк — это просто размер страницы.</span><span class="sxs-lookup"><span data-stu-id="0e697-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="0e697-137">Поскольку разбиение по страницам по умолчанию извлекает все записи из базы данных при отрисовке любой страницы данных, индекс каждой строки известен, поэтому перемещение в строку «начало индекса строки» является тривиальной задачей.</span><span class="sxs-lookup"><span data-stu-id="0e697-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="0e697-138">Кроме того, доступен общий счетчик записей, так как это просто количество записей в DataTable (или любого объекта, используемого для хранения результатов базы данных).</span><span class="sxs-lookup"><span data-stu-id="0e697-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="0e697-139">При наличии переменных "Индекс начальной строки" и "максимальное число строк" реализация пользовательского разбиения по страницам должна возвращать только точное подмножество записей, начиная с индекса начальной строки, и до максимального количества строк записей после этого.</span><span class="sxs-lookup"><span data-stu-id="0e697-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="0e697-140">Пользовательское разбиение на страницы дает две проблемы:</span><span class="sxs-lookup"><span data-stu-id="0e697-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="0e697-141">Необходимо иметь возможность эффективно связать индекс строки с каждой строкой во всех данных, на которых выполняется разгрузка, чтобы можно было начать Возврат записей по указанному индексу начальной строки.</span><span class="sxs-lookup"><span data-stu-id="0e697-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="0e697-142">Необходимо указать общее количество записей, на которые размещается страница</span><span class="sxs-lookup"><span data-stu-id="0e697-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="0e697-143">В следующих двух шагах мы рассмотрим сценарий SQL, необходимый для ответа на эти две проблемы.</span><span class="sxs-lookup"><span data-stu-id="0e697-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="0e697-144">Помимо скрипта SQL, нам также потребуется реализовать методы в DAL и BLL.</span><span class="sxs-lookup"><span data-stu-id="0e697-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="0e697-145">Шаг 2. возвращение общего количества записей, передаваемых по страницам</span><span class="sxs-lookup"><span data-stu-id="0e697-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="0e697-146">Прежде чем исследовать, как получить точное подмножество записей для отображаемой страницы, давайте сначала посмотрим, как вернуть общее количество записей, на которые размещается страница.</span><span class="sxs-lookup"><span data-stu-id="0e697-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="0e697-147">Эти сведения необходимы для правильной настройки интерфейса пользователя с разбиением на страницы.</span><span class="sxs-lookup"><span data-stu-id="0e697-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="0e697-148">Общее число записей, возвращаемых определенным запросом SQL, можно получить с помощью [агрегатной функции`COUNT`](https://msdn.microsoft.com/library/ms175997.aspx).</span><span class="sxs-lookup"><span data-stu-id="0e697-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="0e697-149">Например, чтобы определить общее число записей в таблице `Products`, можно использовать следующий запрос:</span><span class="sxs-lookup"><span data-stu-id="0e697-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample1.sql)]

<span data-ttu-id="0e697-150">Добавим в DAL метод, возвращающий эту информацию.</span><span class="sxs-lookup"><span data-stu-id="0e697-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="0e697-151">В частности, мы создадим метод DAL с именем `TotalNumberOfProducts()`, который выполняет приведенную выше инструкцию `SELECT`.</span><span class="sxs-lookup"><span data-stu-id="0e697-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="0e697-152">Сначала откройте файл типизированного набора данных `Northwind.xsd` в папке `App_Code/DAL`.</span><span class="sxs-lookup"><span data-stu-id="0e697-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="0e697-153">Затем щелкните правой кнопкой мыши `ProductsTableAdapter` в конструкторе и выберите команду Добавить запрос.</span><span class="sxs-lookup"><span data-stu-id="0e697-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="0e697-154">Как мы видели в предыдущих учебных курсах, это позволит нам добавить в DAL новый метод, который при вызове будет выполнять определенную инструкцию или хранимую процедуру SQL.</span><span class="sxs-lookup"><span data-stu-id="0e697-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="0e697-155">Как и в случае с нашими методами TableAdapter в предыдущих руководствах, для этого нужно использовать специальный оператор SQL.</span><span class="sxs-lookup"><span data-stu-id="0e697-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>

![Использование специального оператора SQL](efficiently-paging-through-large-amounts-of-data-vb/_static/image1.png)

<span data-ttu-id="0e697-157">**Рис. 1**. Использование специального оператора SQL</span><span class="sxs-lookup"><span data-stu-id="0e697-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>

<span data-ttu-id="0e697-158">На следующем экране можно указать тип создаваемого запроса.</span><span class="sxs-lookup"><span data-stu-id="0e697-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="0e697-159">Так как этот запрос возвращает одно скалярное значение, общее число записей в `Products` таблице выберите `SELECT`, который возвращает параметр одного значения.</span><span class="sxs-lookup"><span data-stu-id="0e697-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>

![Настройка запроса для использования инструкции SELECT, возвращающей одиночное значение](efficiently-paging-through-large-amounts-of-data-vb/_static/image2.png)

<span data-ttu-id="0e697-161">**Рис. 2**. Настройка запроса для использования инструкции SELECT, возвращающей одиночное значение</span><span class="sxs-lookup"><span data-stu-id="0e697-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>

<span data-ttu-id="0e697-162">После указания используемого типа запроса необходимо указать запрос.</span><span class="sxs-lookup"><span data-stu-id="0e697-162">After indicating the type of query to use, we must next specify the query.</span></span>

![Использование запроса выбор числа (\*) из продуктов](efficiently-paging-through-large-amounts-of-data-vb/_static/image3.png)

<span data-ttu-id="0e697-164">**Рис. 3**. Использование запроса SELECT COUNT (\*) из продуктов</span><span class="sxs-lookup"><span data-stu-id="0e697-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>

<span data-ttu-id="0e697-165">Наконец, укажите имя метода.</span><span class="sxs-lookup"><span data-stu-id="0e697-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="0e697-166">Как было упомянуто выше, давайте используем `TotalNumberOfProducts`.</span><span class="sxs-lookup"><span data-stu-id="0e697-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>

![Назовите метод DAL Тоталнумберофпродуктс](efficiently-paging-through-large-amounts-of-data-vb/_static/image4.png)

<span data-ttu-id="0e697-168">**Рис. 4**. имя метода DAL тоталнумберофпродуктс</span><span class="sxs-lookup"><span data-stu-id="0e697-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>

<span data-ttu-id="0e697-169">После нажатия кнопки "Готово" Мастер добавит в DAL метод `TotalNumberOfProducts`.</span><span class="sxs-lookup"><span data-stu-id="0e697-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="0e697-170">Скалярные методы, возвращающие DAL, возвращают типы, допускающие значение null, в случае, если результат запроса SQL `NULL`.</span><span class="sxs-lookup"><span data-stu-id="0e697-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="0e697-171">Однако наш `COUNT`ный запрос всегда будет возвращать значение, отличное от`NULL`. независимо от этого метод DAL возвращает целое число, допускающее значение null.</span><span class="sxs-lookup"><span data-stu-id="0e697-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="0e697-172">В дополнение к методу DAL нам также нужен метод в BLL.</span><span class="sxs-lookup"><span data-stu-id="0e697-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="0e697-173">Откройте файл `ProductsBLL` класса и добавьте метод `TotalNumberOfProducts`, который просто вызывает метод DAL s `TotalNumberOfProducts`:</span><span class="sxs-lookup"><span data-stu-id="0e697-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample2.vb)]

<span data-ttu-id="0e697-174">Метод DAL `TotalNumberOfProducts` возвращает целое число, допускающее значение null. Однако мы создали метод `ProductsBLL` класса `TotalNumberOfProducts`, чтобы он возвращал стандартное целое число.</span><span class="sxs-lookup"><span data-stu-id="0e697-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="0e697-175">Поэтому необходимо, чтобы метод `ProductsBLL` класса s `TotalNumberOfProducts` возвращал часть значения обнуляемого целого числа, возвращенного методом DAL s `TotalNumberOfProducts`.</span><span class="sxs-lookup"><span data-stu-id="0e697-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="0e697-176">Вызов `GetValueOrDefault()` возвращает значение обнуляемого целого числа, если оно существует; Однако если целочисленное значение, допускающее значение null, равно `null`, то возвращается целое число по умолчанию 0.</span><span class="sxs-lookup"><span data-stu-id="0e697-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="0e697-177">Шаг 3. возврат точного подмножества записей</span><span class="sxs-lookup"><span data-stu-id="0e697-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="0e697-178">Следующей задачей является создание методов DAL и BLL, принимающих переменные начальной строки и максимального числа строк, которые обсуждались ранее, и возвращают соответствующие записи.</span><span class="sxs-lookup"><span data-stu-id="0e697-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="0e697-179">Прежде чем это сделать, давайте взглянем на необходимый скрипт SQL.</span><span class="sxs-lookup"><span data-stu-id="0e697-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="0e697-180">Проблема заключается в том, что мы должны иметь возможность эффективно назначать индекс каждой строке во всех результатах, чтобы мы могли возвращать только те записи, начиная с индекса начальной строки (и до максимального количества записей).</span><span class="sxs-lookup"><span data-stu-id="0e697-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="0e697-181">Это не является проблемой, если в таблице базы данных уже есть столбец, который служит индексом строки.</span><span class="sxs-lookup"><span data-stu-id="0e697-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="0e697-182">На первый взгляд мы можем подумать, что поле `Products` таблицы `ProductID` будет достаточно, так как первый продукт имеет `ProductID` 1, второй — 2 и т. д.</span><span class="sxs-lookup"><span data-stu-id="0e697-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="0e697-183">Однако удаление продукта оставляет разрыв в последовательности, отменяя этот подход.</span><span class="sxs-lookup"><span data-stu-id="0e697-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="0e697-184">Существует два общих метода, с помощью которых можно эффективно связать индекс строки с данными для постраничного просмотра, тем самым обеспечивая точное подмножество извлекаемых записей:</span><span class="sxs-lookup"><span data-stu-id="0e697-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="0e697-185">**Используя SQL Server 2005 s `ROW_NUMBER()` ключевое слово** new для SQL Server 2005, ключевое слово `ROW_NUMBER()` связывает ранжирование с каждой возвращаемой записью на основе определенного порядка.</span><span class="sxs-lookup"><span data-stu-id="0e697-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="0e697-186">Этот рейтинг можно использовать в качестве индекса строки для каждой строки.</span><span class="sxs-lookup"><span data-stu-id="0e697-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="0e697-187">**Использование табличной переменной и `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT`](https://msdn.microsoft.com/library/ms188774.aspx) можно использовать для указания количества записей, которые должен обработать запрос перед завершением операции. [табличные переменные](http://www.sqlteam.com/item.asp?ItemID=9454) — это локальные переменные T-SQL, которые могут содержать табличные данные, в аналогах с [временными таблицами](http://www.sqlteam.com/item.asp?ItemID=2029).</span><span class="sxs-lookup"><span data-stu-id="0e697-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="0e697-188">Этот подход работает одинаково хорошо с Microsoft SQL Server 2005 и SQL Server 2000 (в то время как `ROW_NUMBER()` подход работает только с SQL Server 2005).</span><span class="sxs-lookup"><span data-stu-id="0e697-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="0e697-189">Идея состоит в том, чтобы создать табличную переменную, имеющую `IDENTITY` столбец и столбцы для первичных ключей таблицы, данные на которых разгружаются по страницам.</span><span class="sxs-lookup"><span data-stu-id="0e697-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="0e697-190">Затем содержимое таблицы, данные из которой догружаются по страницам, копируется в табличную переменную, тем самым связывая индекс последовательной строки (с помощью `IDENTITY` столбца) для каждой записи в таблице.</span><span class="sxs-lookup"><span data-stu-id="0e697-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="0e697-191">После заполнения табличной переменной можно выполнить инструкцию `SELECT` в табличной переменной, присоединенной к базовой таблице, чтобы извлечь определенные записи.</span><span class="sxs-lookup"><span data-stu-id="0e697-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="0e697-192">Инструкция `SET ROWCOUNT` используется для разумного ограничения количества записей, которые необходимо выгрузить в табличную переменную.</span><span class="sxs-lookup"><span data-stu-id="0e697-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="0e697-193">Эффективность этого подхода зависит от запрашиваемого номера страницы, так как `SET ROWCOUNT` значение присваивается значение индекса начальной строки плюс максимальное число строк.</span><span class="sxs-lookup"><span data-stu-id="0e697-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="0e697-194">При разбиении на страницы с низкой нумерацией, например первые несколько страниц данных, этот подход очень эффективен.</span><span class="sxs-lookup"><span data-stu-id="0e697-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="0e697-195">Однако при извлечении страницы рядом с ней используется производительность по умолчанию, аналогичная разбиению по страницам.</span><span class="sxs-lookup"><span data-stu-id="0e697-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="0e697-196">В этом руководстве реализуется пользовательский разбиение на страницы с помощью ключевого слова `ROW_NUMBER()`.</span><span class="sxs-lookup"><span data-stu-id="0e697-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="0e697-197">Дополнительные сведения об использовании табличной переменной и `SET ROWCOUNT`ной методики см. [в разделе более эффективный метод разбиения по страницам больших результирующих наборов](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span><span class="sxs-lookup"><span data-stu-id="0e697-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="0e697-198">Ключевое слово `ROW_NUMBER()` связывает ранжирование с каждой записью, возвращенной в определенном порядке, с помощью следующего синтаксиса:</span><span class="sxs-lookup"><span data-stu-id="0e697-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample3.sql)]

<span data-ttu-id="0e697-199">`ROW_NUMBER()` возвращает числовое значение, указывающее ранг каждой записи в отношении указанного порядка.</span><span class="sxs-lookup"><span data-stu-id="0e697-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="0e697-200">Например, чтобы просмотреть рейтинг каждого продукта, упорядоченный от наиболее дорогих к наименьшему, можно использовать следующий запрос:</span><span class="sxs-lookup"><span data-stu-id="0e697-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample4.sql)]

<span data-ttu-id="0e697-201">На рис. 5 показаны результаты этого запроса при выполнении в окне запроса в Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="0e697-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="0e697-202">Обратите внимание, что продукты упорядочиваются по цене вместе с рейтингом цены для каждой строки.</span><span class="sxs-lookup"><span data-stu-id="0e697-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>

![Рейтинг цены включен для каждой возвращенной записи](efficiently-paging-through-large-amounts-of-data-vb/_static/image5.png)

<span data-ttu-id="0e697-204">**Рис. 5**. рейтинг цены включен для каждой возвращенной записи</span><span class="sxs-lookup"><span data-stu-id="0e697-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>

> [!NOTE]
> <span data-ttu-id="0e697-205">`ROW_NUMBER()` — это только одна из многих новых функций ранжирования, доступных в SQL Server 2005.</span><span class="sxs-lookup"><span data-stu-id="0e697-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="0e697-206">Более подробное обсуждение `ROW_NUMBER()`, а также других функций ранжирования см. в статье [Возврат ранжированных результатов с Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span><span class="sxs-lookup"><span data-stu-id="0e697-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>

<span data-ttu-id="0e697-207">При ранжировании результатов по указанному столбцу `ORDER BY` в предложении `OVER` (`UnitPrice`, в приведенном выше примере), SQL Server должны отсортировать результаты.</span><span class="sxs-lookup"><span data-stu-id="0e697-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="0e697-208">Это быстрая операция, если имеется кластеризованный индекс по столбцам, в котором упорядочиваются результаты, или если присутствует индекс, который в противном случае может быть более затратным.</span><span class="sxs-lookup"><span data-stu-id="0e697-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="0e697-209">Чтобы повысить производительность для достаточно больших запросов, рассмотрите возможность добавления некластеризованного индекса для столбца, по которому упорядочиваются результаты.</span><span class="sxs-lookup"><span data-stu-id="0e697-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="0e697-210">Более подробные сведения о производительности см. в разделе [ранжирующие функции и производительность в SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) .</span><span class="sxs-lookup"><span data-stu-id="0e697-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="0e697-211">Сведения о ранжировании, возвращаемые `ROW_NUMBER()`, нельзя использовать непосредственно в предложении `WHERE`.</span><span class="sxs-lookup"><span data-stu-id="0e697-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="0e697-212">Однако производную таблицу можно использовать для возврата результата `ROW_NUMBER()`, который затем может появиться в предложении `WHERE`.</span><span class="sxs-lookup"><span data-stu-id="0e697-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="0e697-213">Например, следующий запрос использует производную таблицу для возврата столбцов ProductName и UnitPrice вместе с `ROW_NUMBER()`ным результатом, а затем использует предложение `WHERE`, чтобы получить только те продукты, ранг цены которых составляет от 11 до 20:</span><span class="sxs-lookup"><span data-stu-id="0e697-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample5.sql)]

<span data-ttu-id="0e697-214">Более того, чтобы расширить эту концепцию, мы можем использовать этот подход для получения определенной страницы данных по заданному индексу начальной строки и максимальным значениям строк:</span><span class="sxs-lookup"><span data-stu-id="0e697-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>

[!code-html[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="0e697-215">Как будет показано далее в этом учебнике, *`StartRowIndex`* , предоставленный ObjectDataSource, индексируется начиная с нуля, а значение `ROW_NUMBER()`, возвращаемое SQL Server 2005, индексируется начиная с 1.</span><span class="sxs-lookup"><span data-stu-id="0e697-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="0e697-216">Таким образом, предложение `WHERE` возвращает те записи, в которых `PriceRank` строго больше *`StartRowIndex`* и меньше или равно *`StartRowIndex`* \* + `MaximumRows`.\*</span><span class="sxs-lookup"><span data-stu-id="0e697-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>

<span data-ttu-id="0e697-217">Теперь, когда мы рассмотрели, как `ROW_NUMBER()` можно использовать для получения определенной страницы данных по значениям индекса начальной и максимальной строк, нам нужно реализовать эту логику как методы DAL и BLL.</span><span class="sxs-lookup"><span data-stu-id="0e697-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="0e697-218">При создании этого запроса необходимо выбрать упорядочивание, по которому будут ранжированы результаты. Позвольте s Сортировать продукты по именам в алфавитном порядке.</span><span class="sxs-lookup"><span data-stu-id="0e697-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="0e697-219">Это означает, что при реализации пользовательского разбиения по страницам в этом учебнике не будет возможности создать пользовательский отчет с разбивкой на страницы, чем также можно будет отсортировать.</span><span class="sxs-lookup"><span data-stu-id="0e697-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="0e697-220">Тем не менее, в следующем учебном курсе мы увидим, как можно предоставить такую функциональность.</span><span class="sxs-lookup"><span data-stu-id="0e697-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="0e697-221">В предыдущем разделе мы создали метод DAL в качестве специального оператора SQL.</span><span class="sxs-lookup"><span data-stu-id="0e697-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="0e697-222">К сожалению, средство синтаксического анализа T-SQL в Visual Studio, используемое мастером TableAdapter, не похоже на синтаксис `OVER`, используемый функцией `ROW_NUMBER()`.</span><span class="sxs-lookup"><span data-stu-id="0e697-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="0e697-223">Поэтому необходимо создать этот метод DAL в качестве хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="0e697-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="0e697-224">Выберите обозреватель сервера в меню Вид (или нажмите клавиши CTRL + ALT + S) и разверните узел `NORTHWND.MDF`.</span><span class="sxs-lookup"><span data-stu-id="0e697-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="0e697-225">Чтобы добавить новую хранимую процедуру, щелкните правой кнопкой мыши узел Хранимые процедуры и выберите команду Добавить новую хранимую процедуру (см. рис. 6).</span><span class="sxs-lookup"><span data-stu-id="0e697-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>

![Добавление новой хранимой процедуры для разбиения по страницам продуктов](efficiently-paging-through-large-amounts-of-data-vb/_static/image6.png)

<span data-ttu-id="0e697-227">**Рис. 6**. Добавление новой хранимой процедуры для разбиения по страницам продуктов</span><span class="sxs-lookup"><span data-stu-id="0e697-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>

<span data-ttu-id="0e697-228">Эта хранимая процедура должна принимать два целочисленных входных параметра — `@startRowIndex` и `@maximumRows` и использовать функцию `ROW_NUMBER()`, упорядоченную по полю `ProductName`, возвращая только те строки, которые больше указанного `@startRowIndex` и меньше или равны `@startRowIndex` + `@maximumRow` s.</span><span class="sxs-lookup"><span data-stu-id="0e697-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="0e697-229">Введите следующий скрипт в новую хранимую процедуру, а затем щелкните значок Сохранить, чтобы добавить хранимую процедуру в базу данных.</span><span class="sxs-lookup"><span data-stu-id="0e697-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample7.sql)]

<span data-ttu-id="0e697-230">После создания хранимой процедуры уделите время ее протестировать. Щелкните правой кнопкой мыши имя хранимой процедуры `GetProductsPaged` в обозреватель сервера и выберите пункт Выполнить.</span><span class="sxs-lookup"><span data-stu-id="0e697-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="0e697-231">В Visual Studio будет предложено ввести входные параметры, `@startRowIndex` и `@maximumRow` (см. рис. 7).</span><span class="sxs-lookup"><span data-stu-id="0e697-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="0e697-232">Попробуйте использовать другие значения и проверьте результаты.</span><span class="sxs-lookup"><span data-stu-id="0e697-232">Try different values and examine the results.</span></span>

![Введите значение для параметров @startRowIndex и @maximumRows](efficiently-paging-through-large-amounts-of-data-vb/_static/image7.png)

<span data-ttu-id="0e697-234"><strong>Рис. 7</strong>. Ввод значения для параметров @startRowIndex и @maximumRows</span><span class="sxs-lookup"><span data-stu-id="0e697-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>

<span data-ttu-id="0e697-235">После выбора значений входных параметров в окне вывода отобразятся результаты.</span><span class="sxs-lookup"><span data-stu-id="0e697-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="0e697-236">На рис. 8 показаны результаты при передаче в 10 для параметров `@startRowIndex` и `@maximumRows`.</span><span class="sxs-lookup"><span data-stu-id="0e697-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>

<span data-ttu-id="0e697-237">[![записи, которые будут отображаться на второй странице данных, возвращаются](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="0e697-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-vb/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image8.png)</span></span>

<span data-ttu-id="0e697-238">**Рис. 8**. возвращаются записи, которые будут отображаться на второй странице данных ([щелкните, чтобы просмотреть изображение с полным размером](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="0e697-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image10.png))</span></span>

<span data-ttu-id="0e697-239">После создания этой хранимой процедуры мы повторно готовы к созданию метода `ProductsTableAdapter`.</span><span class="sxs-lookup"><span data-stu-id="0e697-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="0e697-240">Откройте `Northwind.xsd` типизированный набор данных, щелкните правой кнопкой мыши `ProductsTableAdapter`и выберите пункт Добавить запрос.</span><span class="sxs-lookup"><span data-stu-id="0e697-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="0e697-241">Вместо создания запроса с помощью специальной инструкции SQL создайте ее с помощью существующей хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="0e697-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>

![Создание метода DAL с помощью существующей хранимой процедуры](efficiently-paging-through-large-amounts-of-data-vb/_static/image11.png)

<span data-ttu-id="0e697-243">**Рис. 9**. Создание метода DAL с помощью существующей хранимой процедуры</span><span class="sxs-lookup"><span data-stu-id="0e697-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>

<span data-ttu-id="0e697-244">Далее будет предложено выбрать хранимую процедуру для вызова.</span><span class="sxs-lookup"><span data-stu-id="0e697-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="0e697-245">Выберите `GetProductsPaged` хранимую процедуру из раскрывающегося списка.</span><span class="sxs-lookup"><span data-stu-id="0e697-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>

![Выберите хранимую процедуру GetProductsPaged из раскрывающегося списка.](efficiently-paging-through-large-amounts-of-data-vb/_static/image12.png)

<span data-ttu-id="0e697-247">**Рис. 10**. Выбор хранимой процедуры GetProductsPaged из раскрывающегося списка</span><span class="sxs-lookup"><span data-stu-id="0e697-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>

<span data-ttu-id="0e697-248">Затем на следующем экране запрашивается тип данных, возвращаемых хранимой процедурой: табличные данные, одно значение или значение No.</span><span class="sxs-lookup"><span data-stu-id="0e697-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="0e697-249">Так как хранимая процедура `GetProductsPaged` может возвращать несколько записей, укажите, что она возвращает табличные данные.</span><span class="sxs-lookup"><span data-stu-id="0e697-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>

![Указывает, что хранимая процедура возвращает табличные данные](efficiently-paging-through-large-amounts-of-data-vb/_static/image13.png)

<span data-ttu-id="0e697-251">**Рис. 11**. Указание того, что хранимая процедура возвращает табличные данные</span><span class="sxs-lookup"><span data-stu-id="0e697-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>

<span data-ttu-id="0e697-252">Наконец, укажите имена методов, которые необходимо создать.</span><span class="sxs-lookup"><span data-stu-id="0e697-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="0e697-253">Как и в предыдущих учебных курсах, вы можете создавать методы, используя как заполнение DataTable, так и возвратить таблицу данных.</span><span class="sxs-lookup"><span data-stu-id="0e697-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="0e697-254">Присвойте первому методу имя `FillPaged` а второй `GetProductsPaged`.</span><span class="sxs-lookup"><span data-stu-id="0e697-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>

![Назовите методы Филлпажед и GetProductsPaged](efficiently-paging-through-large-amounts-of-data-vb/_static/image14.png)

<span data-ttu-id="0e697-256">**Рис. 12**. Назовите методы Филлпажед и GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="0e697-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>

<span data-ttu-id="0e697-257">Помимо создания метода DAL для возврата определенной страницы продуктов, нам также нужно предоставить такую функциональность в BLL.</span><span class="sxs-lookup"><span data-stu-id="0e697-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="0e697-258">Как и метод DAL, метод BLL GetProductsPaged должен принимать два целочисленных значения для указания индекса начальной и максимальной строк, а также должен возвращать только те записи, которые попадают в указанный диапазон.</span><span class="sxs-lookup"><span data-stu-id="0e697-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="0e697-259">Создайте такой метод BLL в классе ProductsBLL, который просто вызывает метод DAL s GetProductsPaged, вот так:</span><span class="sxs-lookup"><span data-stu-id="0e697-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample8.vb)]

<span data-ttu-id="0e697-260">Для входных параметров метода BLL можно использовать любое имя, но, как мы увидим чуть позже, при настройке ObjectDataSource для использования этого метода вы сможете использовать `startRowIndex` и `maximumRows` избавляет нас от дополнительного ряда работы.</span><span class="sxs-lookup"><span data-stu-id="0e697-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="0e697-261">Шаг 4. Настройка элемента управления ObjectDataSource для использования пользовательского разбиения на страницы</span><span class="sxs-lookup"><span data-stu-id="0e697-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="0e697-262">С помощью методов BLL и DAL для получения доступа к определенному подмножеству записей мы повторно готовы к созданию элемента управления GridView, который просматривает базовые записи, используя пользовательское разбиение по страницам.</span><span class="sxs-lookup"><span data-stu-id="0e697-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="0e697-263">Начните с открытия страницы `EfficientPaging.aspx` в папке `PagingAndSorting`, добавьте GridView на страницу и настройте его для использования нового элемента управления ObjectDataSource.</span><span class="sxs-lookup"><span data-stu-id="0e697-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="0e697-264">В прошлых учебных курсах мы часто настроили ObjectDataSource на использование метода `GetProducts` `ProductsBLL` классов.</span><span class="sxs-lookup"><span data-stu-id="0e697-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="0e697-265">Но на этот раз мы хотим использовать вместо этого метод `GetProductsPaged`, так как метод `GetProducts` возвращает *все* продукты в базе данных, а `GetProductsPaged` возвращает только определенное подмножество записей.</span><span class="sxs-lookup"><span data-stu-id="0e697-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>

![Настройка ObjectDataSource для использования метода GetProductsPaged класса ProductsBLL](efficiently-paging-through-large-amounts-of-data-vb/_static/image15.png)

<span data-ttu-id="0e697-267">**Рис. 13**. Настройка ObjectDataSource для использования метода GetProductsPaged класса ProductsBLL</span><span class="sxs-lookup"><span data-stu-id="0e697-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>

<span data-ttu-id="0e697-268">Так как мы повторно создаем GridView, доступное только для чтения, задавайте в раскрывающийся список метод на вкладках Вставка, обновление и удаление значение (нет).</span><span class="sxs-lookup"><span data-stu-id="0e697-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="0e697-269">Затем мастер ObjectDataSource запрашивает источники `GetProductsPaged` метода s `startRowIndex` и `maximumRows` значения входных параметров.</span><span class="sxs-lookup"><span data-stu-id="0e697-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="0e697-270">Эти входные параметры фактически задаются в элементе управления GridView автоматически, поэтому просто оставьте исходное значение None и нажмите кнопку Готово.</span><span class="sxs-lookup"><span data-stu-id="0e697-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>

![Оставить источникам входных параметров значение None](efficiently-paging-through-large-amounts-of-data-vb/_static/image16.png)

<span data-ttu-id="0e697-272">**Рис. 14**. Оставьте источники входных параметров как нет</span><span class="sxs-lookup"><span data-stu-id="0e697-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>

<span data-ttu-id="0e697-273">После завершения работы мастера ObjectDataSource элемент GridView будет содержать BoundField или CheckBoxField для каждого поля данных продукта.</span><span class="sxs-lookup"><span data-stu-id="0e697-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="0e697-274">Вы можете адаптировать внешний вид GridView s по своему усмотрению.</span><span class="sxs-lookup"><span data-stu-id="0e697-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="0e697-275">Я решил отобразить только `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`и `UnitPrice` BoundFields.</span><span class="sxs-lookup"><span data-stu-id="0e697-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="0e697-276">Кроме того, настройте GridView для поддержки разбиения на страницы, установив флажок Включить разбиение по страницам в его смарт-теге.</span><span class="sxs-lookup"><span data-stu-id="0e697-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="0e697-277">После этих изменений декларативная разметка GridView и ObjectDataSource должна выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="0e697-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample9.aspx)]

<span data-ttu-id="0e697-278">Однако если вы посещаете страницу в браузере, GridView не сможет найти.</span><span class="sxs-lookup"><span data-stu-id="0e697-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>

![Элемент управления GridView не отображается](efficiently-paging-through-large-amounts-of-data-vb/_static/image17.png)

<span data-ttu-id="0e697-280">**Рис. 15**. элемент управления GridView не отображается</span><span class="sxs-lookup"><span data-stu-id="0e697-280">**Figure 15**: The GridView is Not Displayed</span></span>

<span data-ttu-id="0e697-281">Элемент GridView отсутствует, поскольку ObjectDataSource в настоящее время использует 0 в качестве значений для обоих входных параметров `GetProductsPaged` `startRowIndex` и `maximumRows`.</span><span class="sxs-lookup"><span data-stu-id="0e697-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="0e697-282">Таким образом, результирующий запрос SQL не возвращает никаких записей, поэтому GridView не отображается.</span><span class="sxs-lookup"><span data-stu-id="0e697-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="0e697-283">Чтобы устранить эту проблему, необходимо настроить ObjectDataSource для использования пользовательского разбиения на страницы.</span><span class="sxs-lookup"><span data-stu-id="0e697-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="0e697-284">Это можно сделать, выполнив следующие действия.</span><span class="sxs-lookup"><span data-stu-id="0e697-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="0e697-285">**Задайте свойство objectdatasource `EnablePaging` для `true`** это указывает элементу ObjectDataSource, что он должен передаваться в `SelectMethod` два дополнительных параметра: один для указания индекса начальной строки ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)) и один для указания максимального числа строк ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span><span class="sxs-lookup"><span data-stu-id="0e697-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="0e697-286">**Установите свойства ObjectDataSource `StartRowIndexParameterName` и `MaximumRowsParameterName` соответствующим образом** , свойства `StartRowIndexParameterName` и `MaximumRowsParameterName` указывают имена входных параметров, передаваемых в `SelectMethod` для настраиваемого разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="0e697-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="0e697-287">По умолчанию эти имена параметров являются `startIndexRow` и `maximumRows`, поэтому при создании метода `GetProductsPaged` в BLL я использовал эти значения для входных параметров.</span><span class="sxs-lookup"><span data-stu-id="0e697-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="0e697-288">Если вы решили использовать разные имена параметров для метода BLL `GetProductsPaged`, например `startIndex` и `maxRows`, то, например, потребуется задать свойства ObjectDataSource `StartRowIndexParameterName` и `MaximumRowsParameterName` соответственно (например, startIndex для `StartRowIndexParameterName` и maxRows для `MaximumRowsParameterName`).</span><span class="sxs-lookup"><span data-stu-id="0e697-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="0e697-289">**Задайте в [свойстве ObjectDataSource`SelectCountMethod`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) имя метода, возвращающего общее количество записей, на которые выводится страница (`TotalNumberOfProducts`), чтобы** метод `ProductsBLL` классов s `TotalNumberOfProducts` возвращал общее количество записей, на которые помещается страница, используя метод DAL, выполняющий запрос `SELECT COUNT(*) FROM Products`.</span><span class="sxs-lookup"><span data-stu-id="0e697-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="0e697-290">Эти сведения необходимы ObjectDataSource для правильного отображения интерфейса разбиения по страницам.</span><span class="sxs-lookup"><span data-stu-id="0e697-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="0e697-291">**Удалите элементы `startRowIndex` и `maximumRows` `<asp:Parameter>` из декларативной разметки ObjectDataSource s** при настройке ObjectDataSource с помощью мастера Visual Studio автоматически добавил два элемента `<asp:Parameter>` для входных параметров метода `GetProductsPaged`.</span><span class="sxs-lookup"><span data-stu-id="0e697-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="0e697-292">Если присвоить параметру `EnablePaging` значение `true`, эти параметры будут передаваться автоматически. Если они также появляются в декларативном синтаксисе, то ObjectDataSource попытается передать *четыре* параметра методу `GetProductsPaged` и два параметра в метод `TotalNumberOfProducts`.</span><span class="sxs-lookup"><span data-stu-id="0e697-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="0e697-293">Если вы забыли удалить эти `<asp:Parameter>` элементы, при посещении страницы в браузере вы получите следующее сообщение об ошибке: *ObjectDataSource ' ObjectDataSource1 ' не может найти неуниверсальный метод ' тоталнумберофпродуктс ' с параметрами: startRowIndex, maximumRows*.</span><span class="sxs-lookup"><span data-stu-id="0e697-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="0e697-294">После внесения этих изменений декларативный синтаксис ObjectDataSource s должен выглядеть следующим образом:</span><span class="sxs-lookup"><span data-stu-id="0e697-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample10.aspx)]

<span data-ttu-id="0e697-295">Обратите внимание, что заданы свойства `EnablePaging` и `SelectCountMethod` и элементы `<asp:Parameter>` были удалены.</span><span class="sxs-lookup"><span data-stu-id="0e697-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="0e697-296">На рис. 16 показан снимок экрана окно свойств после внесения этих изменений.</span><span class="sxs-lookup"><span data-stu-id="0e697-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>

![Чтобы использовать пользовательское разбиение на страницы, настройте элемент управления ObjectDataSource](efficiently-paging-through-large-amounts-of-data-vb/_static/image18.png)

<span data-ttu-id="0e697-298">**Рисунок 16**. Настройка элемента управления ObjectDataSource с помощью пользовательского разбиения на страницы</span><span class="sxs-lookup"><span data-stu-id="0e697-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>

<span data-ttu-id="0e697-299">После внесения этих изменений посетите эту страницу в браузере.</span><span class="sxs-lookup"><span data-stu-id="0e697-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="0e697-300">Вы должны увидеть 10 продуктов в списке, упорядоченный в алфавитном порядке.</span><span class="sxs-lookup"><span data-stu-id="0e697-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="0e697-301">Потратьте время на пошаговое выполнение данных по одной странице.</span><span class="sxs-lookup"><span data-stu-id="0e697-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="0e697-302">Хотя визуальное отличие от перспективы конечных пользователей между разбиением по страницам по умолчанию и пользовательским разбиением на страницы не существует, пользовательское разбиение по страницам позволяет более эффективно просматривать большие объемы данных по мере получения только тех записей, которые должны отображаться для данной страницы.</span><span class="sxs-lookup"><span data-stu-id="0e697-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>

<span data-ttu-id="0e697-303">[![данных, упорядоченных по имени продукта, выдается с помощью пользовательского разбиения на страницы.](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="0e697-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-vb/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image19.png)</span></span>

<span data-ttu-id="0e697-304">**Рис. 17**. данные, упорядоченные по названию продукта, выявляются страницами с помощью пользовательского разбиения на страницы ([щелкните, чтобы просмотреть изображение с полным размером](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png)).</span><span class="sxs-lookup"><span data-stu-id="0e697-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image21.png))</span></span>

> [!NOTE]
> <span data-ttu-id="0e697-305">При использовании пользовательского разбиения на страницы значение счетчика страниц, возвращаемое `SelectCountMethod` ObjectDataSource, сохраняется в состоянии представления GridView s.</span><span class="sxs-lookup"><span data-stu-id="0e697-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="0e697-306">Другие переменные GridView `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` Collection и т. д. сохраняются в *состоянии элемента управления*, которое сохраняется независимо от значения свойства GridView s `EnableViewState`.</span><span class="sxs-lookup"><span data-stu-id="0e697-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="0e697-307">Так как значение `PageCount` сохраняется между обратными передачами с помощью состояния представления, при использовании интерфейса разбиения по страницам, включающего ссылку для перехода на последнюю страницу, необходимо включить состояние представления GridView s.</span><span class="sxs-lookup"><span data-stu-id="0e697-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="0e697-308">(Если интерфейс разбиения по страницам не содержит прямую ссылку на последнюю страницу, то можно отключить состояние просмотра.)</span><span class="sxs-lookup"><span data-stu-id="0e697-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>

<span data-ttu-id="0e697-309">Щелчок последней ссылки на страницу вызывает обратную передачу и указывает GridView обновить свойство `PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="0e697-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="0e697-310">Если щелкнуть ссылку на последнюю страницу, GridView присваивает свойству `PageIndex` значение, которое меньше его свойства `PageCount`.</span><span class="sxs-lookup"><span data-stu-id="0e697-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="0e697-311">При отключенном состоянии представления `PageCount` значение теряется во всех обратных передачах, а `PageIndex` назначается максимальное целое значение.</span><span class="sxs-lookup"><span data-stu-id="0e697-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="0e697-312">Затем GridView пытается определить начальный индекс строки путем умножения свойств `PageSize` и `PageCount`.</span><span class="sxs-lookup"><span data-stu-id="0e697-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="0e697-313">Это приводит к `OverflowException`у, так как продукт превышает максимально допустимый размер целого числа.</span><span class="sxs-lookup"><span data-stu-id="0e697-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="0e697-314">Реализация пользовательского разбиения по страницам и сортировки</span><span class="sxs-lookup"><span data-stu-id="0e697-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="0e697-315">Текущая реализация пользовательского разбиения по страницам требует, чтобы порядок, в котором данные выдаются из страницы, был задан статически при создании `GetProductsPaged` хранимой процедуры.</span><span class="sxs-lookup"><span data-stu-id="0e697-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="0e697-316">Однако вы могли заметить, что смарт-тег GridView s содержит флажок Включить сортировку в дополнение к параметру Включить разбиение на страницы.</span><span class="sxs-lookup"><span data-stu-id="0e697-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="0e697-317">К сожалению, Добавление поддержки сортировки в GridView с текущей реализацией пользовательского разбиения по страницам сортирует только записи на просматриваемой на данный момент странице данных.</span><span class="sxs-lookup"><span data-stu-id="0e697-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="0e697-318">Например, если вы настраиваете GridView для поддержки разбиения на страницы, а затем, когда просматриваете первую страницу данных, сортировать по названию продукта в убывающем порядке, порядок продуктов на странице 1 будет реверсирован.</span><span class="sxs-lookup"><span data-stu-id="0e697-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="0e697-319">Как показано на рис. 18, в качестве первого продукта при сортировке в противоположном алфавитном порядке, например Карнарвон, не учитываются 71 других продуктов, которые выводятся после Карнарвон Tiger по алфавиту. в сортировке учитываются только записи на первой странице.</span><span class="sxs-lookup"><span data-stu-id="0e697-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>

<span data-ttu-id="0e697-320">[![сортируются только данные, отображаемые на текущей странице](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="0e697-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-vb/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-vb/_static/image22.png)</span></span>

<span data-ttu-id="0e697-321">**Рис. 18**. Сортировка только данных, отображаемых на текущей странице ([щелкните, чтобы просмотреть изображение с полным размером](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="0e697-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-vb/_static/image24.png))</span></span>

<span data-ttu-id="0e697-322">Сортировка применяется только к текущей странице данных, поскольку сортировка происходит после извлечения данных из метода BLL `GetProductsPaged`, и этот метод возвращает только те записи, которые относятся к конкретной странице.</span><span class="sxs-lookup"><span data-stu-id="0e697-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="0e697-323">Чтобы правильно реализовать сортировку, необходимо передать выражение сортировки методу `GetProductsPaged`, чтобы данные могли быть соответствующим образом упорядочены перед возвратом определенной страницы данных.</span><span class="sxs-lookup"><span data-stu-id="0e697-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="0e697-324">Мы посмотрим, как это сделать в следующем руководстве.</span><span class="sxs-lookup"><span data-stu-id="0e697-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="0e697-325">Реализация пользовательского разбиения по страницам и удаление</span><span class="sxs-lookup"><span data-stu-id="0e697-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="0e697-326">При включении функции удаления в элементе управления GridView, данные которого выводятся с помощью настраиваемых методов разбиения по страницам, вы обнаружите, что при удалении последней записи с последней страницы GridView исчезает, а не уменьшается при необходимости уменьшения `PageIndex`GridView s.</span><span class="sxs-lookup"><span data-stu-id="0e697-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="0e697-327">Чтобы воспроизвести эту ошибку, включите удаление для учебника только что созданного.</span><span class="sxs-lookup"><span data-stu-id="0e697-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="0e697-328">Перейдите на последнюю страницу (стр. 9), где вы должны увидеть один продукт, так как мы подкачкой продукты 81, 10 продуктов за раз.</span><span class="sxs-lookup"><span data-stu-id="0e697-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="0e697-329">Удалите этот продукт.</span><span class="sxs-lookup"><span data-stu-id="0e697-329">Delete this product.</span></span>

<span data-ttu-id="0e697-330">После удаления последнего продукта GridView *будет* автоматически переходить к восьмой странице, и такие функции будут работать с разбиением по страницам по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0e697-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="0e697-331">Однако при использовании пользовательского разбиения по страницам после удаления последнего продукта на последней странице GridView просто исчезает с экрана.</span><span class="sxs-lookup"><span data-stu-id="0e697-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="0e697-332">Точная *Причина, по которой это* происходит, немного выходит за рамки данного учебника. см. статью [Удаление последней записи на последней странице из GridView с настраиваемым разбиением на страницы](http://scottonwriting.net/sowblog/posts/7326.aspx) для сведений низкого уровня, как в источник этой проблемы.</span><span class="sxs-lookup"><span data-stu-id="0e697-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="0e697-333">В сводке это происходит из-за следующей последовательности действий, выполняемых элементом GridView при нажатии кнопки "Удалить":</span><span class="sxs-lookup"><span data-stu-id="0e697-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="0e697-334">Удаление записи</span><span class="sxs-lookup"><span data-stu-id="0e697-334">Delete the record</span></span>
2. <span data-ttu-id="0e697-335">Получение соответствующих записей, отображаемых для указанного `PageIndex` и `PageSize`</span><span class="sxs-lookup"><span data-stu-id="0e697-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="0e697-336">Убедитесь, что `PageIndex` не превышает количество страниц данных в источнике данных; Если это так, автоматически уменьшите свойство `PageIndex` GridView s</span><span class="sxs-lookup"><span data-stu-id="0e697-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="0e697-337">Свяжите соответствующую страницу данных с элементом GridView, используя записи, полученные на шаге 2.</span><span class="sxs-lookup"><span data-stu-id="0e697-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="0e697-338">Проблема состоит в том, что в шаге 2 `PageIndex`, используемый при извлечении отображаемых записей, по-прежнему является `PageIndex` последней страницы, единственная запись которой была только что удалена.</span><span class="sxs-lookup"><span data-stu-id="0e697-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="0e697-339">Поэтому на шаге 2 никакие записи *не* возвращаются, так как последняя страница данных больше не содержит никаких записей.</span><span class="sxs-lookup"><span data-stu-id="0e697-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="0e697-340">Затем в шаге 3 в элементе управления GridView понимается, что его свойство `PageIndex` больше, чем общее число страниц в источнике данных (так как мы удалили последнюю запись на последней странице), и, таким образом, уменьшаем его свойство `PageIndex`.</span><span class="sxs-lookup"><span data-stu-id="0e697-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="0e697-341">На шаге 4 GridView пытается привязать себя к данным, полученным на шаге 2. Однако на шаге 2 не было возвращено ни одной записи, поэтому в результате возвращается пустой элемент GridView.</span><span class="sxs-lookup"><span data-stu-id="0e697-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="0e697-342">При использовании разбиения по страницам по умолчанию эта проблема не имеет значения, так как на шаге 2 *все* записи извлекаются из источника данных.</span><span class="sxs-lookup"><span data-stu-id="0e697-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="0e697-343">Чтобы устранить эту проблему, у нас есть два варианта.</span><span class="sxs-lookup"><span data-stu-id="0e697-343">To fix this we have two options.</span></span> <span data-ttu-id="0e697-344">Первый заключается в создании обработчика событий для обработчика событий GridView `RowDeleted`, который определяет, сколько записей отображалось на странице, которая была только что удалена.</span><span class="sxs-lookup"><span data-stu-id="0e697-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="0e697-345">Если существовала только одна запись, то только что удаленная запись должна была быть последней и нужно уменьшить `PageIndex`GridView s.</span><span class="sxs-lookup"><span data-stu-id="0e697-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="0e697-346">Конечно, мы хотим обновить только `PageIndex`, если операция удаления фактически была успешной, что можно определить, убедившись в том, что `e.Exception` свойство имеет значение `null`.</span><span class="sxs-lookup"><span data-stu-id="0e697-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="0e697-347">Этот подход работает потому, что он обновляет `PageIndex` после шага 1, но до шага 2.</span><span class="sxs-lookup"><span data-stu-id="0e697-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="0e697-348">Таким образом, на шаге 2 возвращается соответствующий набор записей.</span><span class="sxs-lookup"><span data-stu-id="0e697-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="0e697-349">Для этого используйте код, подобный приведенному ниже.</span><span class="sxs-lookup"><span data-stu-id="0e697-349">To accomplish this, use code like the following:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample11.vb)]

<span data-ttu-id="0e697-350">Альтернативный обходной путь состоит в создании обработчика событий для события `RowDeleted` ObjectDataSource s и задании для свойства `AffectedRows` значения 1.</span><span class="sxs-lookup"><span data-stu-id="0e697-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="0e697-351">После удаления записи в шаге 1 (но до повторного извлечения данных на шаге 2) GridView обновляет свойство `PageIndex`, если одна или несколько строк были затронуты операцией.</span><span class="sxs-lookup"><span data-stu-id="0e697-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="0e697-352">Однако свойство `AffectedRows` не задается ObjectDataSource и, следовательно, этот шаг опускается.</span><span class="sxs-lookup"><span data-stu-id="0e697-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="0e697-353">Один из способов выполнения этого шага — вручную задать свойство `AffectedRows`, если операция удаления завершается успешно.</span><span class="sxs-lookup"><span data-stu-id="0e697-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="0e697-354">Это можно сделать с помощью кода, подобного приведенному ниже.</span><span class="sxs-lookup"><span data-stu-id="0e697-354">This can be accomplished using code like the following:</span></span>

[!code-vb[Main](efficiently-paging-through-large-amounts-of-data-vb/samples/sample12.vb)]

<span data-ttu-id="0e697-355">Код для обоих обработчиков событий можно найти в классе кода программной части `EfficientPaging.aspx` примере.</span><span class="sxs-lookup"><span data-stu-id="0e697-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="0e697-356">Сравнение производительности по умолчанию и пользовательского разбиения на страницы</span><span class="sxs-lookup"><span data-stu-id="0e697-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="0e697-357">Поскольку пользовательское разбиение по страницам извлекает только необходимые записи, в то время как разбиение по страницам по умолчанию возвращает *все* записи для каждой просматриваемой страницы, то ясно, что настраиваемое разбиение по страницам более эффективно, чем разбиение</span><span class="sxs-lookup"><span data-stu-id="0e697-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="0e697-358">Но насколько эффективнее пользовательское разбиение на страницы?</span><span class="sxs-lookup"><span data-stu-id="0e697-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="0e697-359">Какой выигрыш в производительности можно увидеть, перемещаясь с разбиения по страницам по умолчанию на пользовательское разбиение?</span><span class="sxs-lookup"><span data-stu-id="0e697-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="0e697-360">К сожалению, нет ни одного размера, удовлетворяющего всем ответам.</span><span class="sxs-lookup"><span data-stu-id="0e697-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="0e697-361">Выигрыш в производительности зависит от ряда факторов, наиболее заметных двух из которых является число страниц, на которых выполняется разгрузка, и нагрузку на сервер базы данных и каналы связи между веб-сервером и сервером базы данных.</span><span class="sxs-lookup"><span data-stu-id="0e697-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="0e697-362">Для небольших таблиц, имеющих всего несколько десятков записей, разница в производительности может быть незначительной.</span><span class="sxs-lookup"><span data-stu-id="0e697-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="0e697-363">Однако в больших таблицах с тысячами сотен тысяч строк разница в производительности имеет значение акутом.</span><span class="sxs-lookup"><span data-stu-id="0e697-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="0e697-364">В статье «мой [пользовательское подкачка» в ASP.NET 2,0 с SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)содержится несколько тестов производительности, которые я выполнял, чтобы демонстрировать различия в производительности между этими двумя методами разбиения по страницам в таблице базы данных с 50 000 записей.</span><span class="sxs-lookup"><span data-stu-id="0e697-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="0e697-365">В этих тестах я рассматривал время выполнения запроса на уровне SQL Server (с помощью [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) и на странице ASP.NET с помощью [функций трассировки ASP.NET](https://msdn.microsoft.com/library/y13fw6we.aspx).</span><span class="sxs-lookup"><span data-stu-id="0e697-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="0e697-366">Помните, что эти тесты были запущены в моем окне разработки с одним активным пользователем, и поэтому являются неинженерными и не воспроизводят типичные шаблоны нагрузки веб-сайтов.</span><span class="sxs-lookup"><span data-stu-id="0e697-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="0e697-367">Независимо от этого результаты показывают относительные различия времени выполнения по умолчанию и пользовательского разбиения на страницы при работе с достаточно большим объемом данных.</span><span class="sxs-lookup"><span data-stu-id="0e697-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>

|  | <span data-ttu-id="0e697-368">**СР. Длительность (в секундах)**</span><span class="sxs-lookup"><span data-stu-id="0e697-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="0e697-369">**Число считываний**</span><span class="sxs-lookup"><span data-stu-id="0e697-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="0e697-370">**Профайлер SQL по умолчанию для разбиения на страницы**</span><span class="sxs-lookup"><span data-stu-id="0e697-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="0e697-371">1,411</span><span class="sxs-lookup"><span data-stu-id="0e697-371">1.411</span></span> | <span data-ttu-id="0e697-372">383</span><span class="sxs-lookup"><span data-stu-id="0e697-372">383</span></span> |
| <span data-ttu-id="0e697-373">**Пользовательское разбиение по страницам SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="0e697-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="0e697-374">0,002</span><span class="sxs-lookup"><span data-stu-id="0e697-374">0.002</span></span> | <span data-ttu-id="0e697-375">29</span><span class="sxs-lookup"><span data-stu-id="0e697-375">29</span></span> |
| <span data-ttu-id="0e697-376">**Трассировка ASP.NET по умолчанию для подкачки**</span><span class="sxs-lookup"><span data-stu-id="0e697-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="0e697-377">2,379</span><span class="sxs-lookup"><span data-stu-id="0e697-377">2.379</span></span> | <span data-ttu-id="0e697-378">*Н/Д*</span><span class="sxs-lookup"><span data-stu-id="0e697-378">*N/A*</span></span> |
| <span data-ttu-id="0e697-379">**ASP.NET трассировка пользовательской подкачки**</span><span class="sxs-lookup"><span data-stu-id="0e697-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="0e697-380">0,029</span><span class="sxs-lookup"><span data-stu-id="0e697-380">0.029</span></span> | <span data-ttu-id="0e697-381">*Н/Д*</span><span class="sxs-lookup"><span data-stu-id="0e697-381">*N/A*</span></span> |

<span data-ttu-id="0e697-382">Как видите, получение определенной страницы данных требует 354 меньшего числа операций чтения в среднем и завершено в доли времени.</span><span class="sxs-lookup"><span data-stu-id="0e697-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="0e697-383">На странице ASP.NET пользователь может подготовить страницу к просмотру в течение 1/100-<sup>го</sup> времени, которое было затрачено при использовании разбиения по страницам по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="0e697-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="0e697-384">Дополнительные сведения об этих результатах вместе с кодом и базе данных, которую можно загрузить для воспроизведения тестов в собственной среде, см. в [моей статье](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) .</span><span class="sxs-lookup"><span data-stu-id="0e697-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="0e697-385">Сводка</span><span class="sxs-lookup"><span data-stu-id="0e697-385">Summary</span></span>

<span data-ttu-id="0e697-386">Разбиение по страницам по умолчанию — очень просто для реализации просто установите флажок Включить разбиение по страницам в смарт-теге Web Control s, но такая простота достигается за счет производительности.</span><span class="sxs-lookup"><span data-stu-id="0e697-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="0e697-387">При использовании разбиения по страницам по умолчанию, когда пользователь запрашивает любую страницу данных, возвращаются *все* записи, несмотря на то, что может отображаться лишь небольшая часть этих записей.</span><span class="sxs-lookup"><span data-stu-id="0e697-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="0e697-388">Для борьбы с этими издержками производительности ObjectDataSource предлагает альтернативный вариант подкачки.</span><span class="sxs-lookup"><span data-stu-id="0e697-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="0e697-389">В то время как пользовательское разбиение по страницам улучшает производительность по умолчанию, извлекая только те записи, которые должны быть отображены, они больше участвовали в реализации пользовательского разбиения на страницы.</span><span class="sxs-lookup"><span data-stu-id="0e697-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="0e697-390">Во-первых, необходимо записать запрос, который правильно (и эффективно) обращается к конкретному подмножеству запрошенных записей.</span><span class="sxs-lookup"><span data-stu-id="0e697-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="0e697-391">Это можно сделать несколькими способами. Мы проверили в этом учебнике функцию SQL Server 2005 s New `ROW_NUMBER()` для ранжирования результатов, а затем возвращать только те результаты, ранжирование которых попадает в указанный диапазон.</span><span class="sxs-lookup"><span data-stu-id="0e697-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="0e697-392">Кроме того, необходимо добавить средства для определения общего количества записей, на которые размещается страница.</span><span class="sxs-lookup"><span data-stu-id="0e697-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="0e697-393">После создания этих методов DAL и BLL также необходимо настроить ObjectDataSource таким образом, чтобы он мог определить, сколько всего записей размещается по страницам, и может правильно передать значения индекса начальной и максимальной строк в BLL.</span><span class="sxs-lookup"><span data-stu-id="0e697-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="0e697-394">Хотя реализация пользовательского разбиения по страницам требует выполнения ряда действий и почти не так проста, как разбиение по страницам по умолчанию, настраиваемое разбиение по страницам является обязательным при разбиении на страницы достаточно большого объема данных.</span><span class="sxs-lookup"><span data-stu-id="0e697-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="0e697-395">По мере изучения результатов, пользовательское разбиение по страницам может проанализировать секунды во время отрисовки страницы ASP.NET и может осветлить нагрузку на сервер базы данных на один или несколько порядков.</span><span class="sxs-lookup"><span data-stu-id="0e697-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="0e697-396">Поздравляем с программированием!</span><span class="sxs-lookup"><span data-stu-id="0e697-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="0e697-397">Об авторе</span><span class="sxs-lookup"><span data-stu-id="0e697-397">About the Author</span></span>

<span data-ttu-id="0e697-398">[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP. NET и основатель [4GuysFromRolla.com](http://www.4guysfromrolla.com), работал с веб-технологиями Майкрософт с 1998.</span><span class="sxs-lookup"><span data-stu-id="0e697-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="0e697-399">Скотт работает как независимый консультант, преподаватель и модуль записи.</span><span class="sxs-lookup"><span data-stu-id="0e697-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="0e697-400">Его последняя книга — [*Sams обучать себя ASP.NET 2,0 за 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span><span class="sxs-lookup"><span data-stu-id="0e697-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="0e697-401">Он доступен по адресу [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="0e697-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="0e697-402">или через его блог, который можно найти по адресу [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span><span class="sxs-lookup"><span data-stu-id="0e697-402">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="0e697-403">[Назад](paging-and-sorting-report-data-vb.md)
> [Вперед](sorting-custom-paged-data-vb.md)</span><span class="sxs-lookup"><span data-stu-id="0e697-403">[Previous](paging-and-sorting-report-data-vb.md)
[Next](sorting-custom-paged-data-vb.md)</span></span>
