---
uid: web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-cs
title: Вложенные данные веб-элементов управления (C#) | Документация Майкрософт
author: rick-anderson
description: В этом учебном курсе мы изучим способ использования элемента управления Repeater вложенным в другой элемент управления Repeater. На примерах будет проиллюстрировано, как заполнять внутренний Repeater обоих d...
ms.author: riande
ms.date: 09/13/2006
ms.assetid: ad3cb0ec-26cf-42d7-b81b-184a34ec9f86
msc.legacyurl: /web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-cs
msc.type: authoredcontent
ms.openlocfilehash: 2fda8883a1cd45a7018c639efcce94cf0e59974c
ms.sourcegitcommit: 62db31596a7da029263cf06335aff12236fb3186
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/26/2019
ms.locfileid: "58440304"
---
<a name="nested-data-web-controls-c"></a>Вложенные веб-элементы управления данными (C#)
====================
по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачайте пример приложения](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_CS.exe) или [скачать PDF](nested-data-web-controls-cs/_static/datatutorial32cs1.pdf)

> В этом учебном курсе мы изучим способ использования элемента управления Repeater вложенным в другой элемент управления Repeater. Примеры иллюстрируют заполнять внутренний Repeater декларативно и программно.


## <a name="introduction"></a>Вступление

В дополнение к статическому коду HTML и синтаксис привязки данных шаблоны могут также включать веб-элементы управления и пользовательские элементы управления. Эти веб-элементы управления, которые были назначены с помощью декларативной, синтаксис привязки данных или может осуществляться программными средствами в соответствующих серверных обработчиках событий.

Внедрение элементов управления в шаблоне, могут быть настроены и оказавшую положительное влияние на внешний вид и взаимодействия с пользователем. Например, в [использование полей TemplateField в элементе управления GridView](../custom-formatting/using-templatefields-in-the-gridview-control-cs.md) было показано, как настраивать отображение GridView s путем добавления элемента управления календаря в TemplateField для показа s Дата найма сотрудника; в [Добавление Проверяющие элементы управления для редактирования и вставки интерфейсы](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-cs.md) и [Настройка интерфейса изменения данных](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-cs.md) руководствах мы видели настройке правки и вставки интерфейсы путем добавления проверки элементы управления, текстовых полей, элементов управления DropDownList и других веб-элементов управления.

Шаблоны могут также содержать другие данные веб-элементов управления. То есть мы может иметь элемент управления DataList, содержащий другой элемент управления DataList (или Repeater или GridView или DetailsView и т. д.) в своих шаблонах. Проблема с таким элементом является привязка соответствующих данных к внутренним данным веб-элемента управления. Доступно несколько разных подходов, – от декларативных вариантов, использующих ObjectDataSource, до программных.

В этом учебном курсе мы изучим способ использования элемента управления Repeater вложенным в другой элемент управления Repeater. Внешний элемент управления Repeater будет содержать элемент для каждой категории в базе данных, отображая категории s имя и описание. Каждого элемента категории s внутреннему элементу управления Repeater будет отображать информацию о каждом продукте, принадлежащем к этой категории (см. рис. 1) в виде маркированного списка. Наши примеры иллюстрируют заполнять внутренний Repeater декларативно и программно.


[![Перечислены каждой категории вместе с ее продуктами](nested-data-web-controls-cs/_static/image2.png)](nested-data-web-controls-cs/_static/image1.png)

**Рис. 1**: Каждая категория вместе с ее продуктами перечислены ([Просмотр полноразмерного изображения](nested-data-web-controls-cs/_static/image3.png))


## <a name="step-1-creating-the-category-listing"></a>Шаг 1. Создание списка категорий

При создании страницы, использующей вложенные данные веб-элементы управления, я нахожу полезным для разработки, создания и проверки внешнего веб-управления, во-первых, не думая о вложенном внутреннем элементе управления. Таким образом позволяют запустить принципа действия, необходимые для добавления элемента управления Repeater к странице, указаны имя и описание для каждой категории s.

Сначала откройте `NestedControls.aspx` странице в `DataListRepeaterBasics` папку и добавьте элемент управления Repeater к странице, устанавливая его `ID` свойства `CategoryList`. В смарт-теге элемента управления Repeater s, решили создать новый ObjectDataSource, именуемый `CategoriesDataSource`.


[![Назовите новый элемент управления ObjectDataSource CategoriesDataSource](nested-data-web-controls-cs/_static/image5.png)](nested-data-web-controls-cs/_static/image4.png)

**Рис. 2**: Новый ObjectDataSource следует назвать `CategoriesDataSource` ([Просмотр полноразмерного изображения](nested-data-web-controls-cs/_static/image6.png))


Настройте элемент управления ObjectDataSource, таким образом, чтобы он извлекает данные из `CategoriesBLL` класс s `GetCategories` метод.


[![Настройте элемент ObjectDataSource для использования метода GetCategories класса CategoriesBLL s](nested-data-web-controls-cs/_static/image8.png)](nested-data-web-controls-cs/_static/image7.png)

**Рис. 3**: Настройка ObjectDataSource для использования `CategoriesBLL` класс s `GetCategories` метод ([Просмотр полноразмерного изображения](nested-data-web-controls-cs/_static/image9.png))


Чтобы указать шаблон повторителя s содержимого необходимо перейти в представление источника и вручную ввести декларативный синтаксис. Добавить `ItemTemplate` , отображающий имя категории s в `<h4>` и описание категории s в элементе абзаца (`<p>`). Кроме того, позволяют s отделим каждую категорию горизонтальной чертой (`<hr>`). После внесения этих изменений страница должна содержать декларативный синтаксис для элемента управления Repeater и элемент управления ObjectDataSource, аналогичную следующей:


[!code-aspx[Main](nested-data-web-controls-cs/samples/sample1.aspx)]

Рис. 4 показаны результаты выполненной работы в браузере.


[![Каждой категории — имя и описание присутствует в списке, разделенных горизонтальная линия](nested-data-web-controls-cs/_static/image11.png)](nested-data-web-controls-cs/_static/image10.png)

**Рис. 4**: Каждой категории — имя и описание присутствует в списке, разделены горизонтальной чертой ([Просмотр полноразмерного изображения](nested-data-web-controls-cs/_static/image12.png))


## <a name="step-2-adding-the-nested-product-repeater"></a>Шаг 2. Добавление элемента управления Repeater вложенного продукта

В завершении создания списка категорий, DAL следующей задачей является добавление элемента управления Repeater для `CategoryList` s `ItemTemplate` , отображающий сведения об этих продуктов, принадлежащих к соответствующей категории. Существует ряд способов, мы можем извлечь данные для этого внутреннего элемента управления Repeater, два из которых мы вскоре исследуем. Теперь позволяют s просто создать продуктов Repeater в `CategoryList` Repeater s `ItemTemplate`. В частности позвольте s продуктов отображения элемента управления Repeater, каждый продукт в маркированном списке с каждым элемент списка, включая s имя и цену продукта.

Для создания этого элемента управления Repeater, необходимо вручную ввести декларативный синтаксис внутренний Repeater s и шаблоны в `CategoryList` s `ItemTemplate`. Добавьте следующую разметку в `CategoryList` Repeater s `ItemTemplate`:


[!code-aspx[Main](nested-data-web-controls-cs/samples/sample2.aspx)]

## <a name="step-3-binding-the-category-specific-products-to-the-productsbycategorylist-repeater"></a>Шаг 3. Привязка продукты конкретной категории к элементу управления Repeater с названием ProductsByCategoryList

Если на этом этапе зайти на страницу через обозреватель, экран будет выглядеть так же, как показано на рис. 4 поскольку мы ve еще, чтобы привязать данные к элементу управления Repeater. Существует несколько способов, что можно взять соответствующие записи продуктов и привязать их к элементу управления Repeater, некоторые более эффективно, чем другие. Основная проблема – получить обратно соответствующий продукт для указанной категории.

Данные для привязки к внутреннему элементу управления Repeater либо осуществляется декларативно, элемент управления ObjectDataSource в `CategoryList` Repeater s `ItemTemplate`, или программно из страницы с выделенным кодом s страницы ASP.NET. Аналогичным образом, эти данные могут быть привязаны к внутреннему элементу управления Repeater либо декларативно — через внутренний элемент управления Repeater s `DataSourceID` свойство или через декларативный синтаксис привязки данных, или программно, ссылаясь на внутренний элемент управления Repeater в `CategoryList` Repeater s `ItemDataBound` обработчик событий, программной настройке его `DataSource` и вызова его `DataBind()` метод. Позвольте s изучение каждого из этих подходов.

## <a name="accessing-the-data-declaratively-with-an-objectdatasource-control-and-theitemdataboundevent-handler"></a>Доступ к данным декларативно с помощью элемента управления ObjectDataSource и`ItemDataBound`обработчик событий

Так как мы работали ObjectDataSource широко во всей этой серии руководств, самым естественным выбором для доступа к данным в этом примере — отказаться от использования ObjectDataSource. `ProductsBLL` Класс имеет `GetProductsByCategoryID(categoryID)` метод, который возвращает сведения о продуктах, принадлежащих указанному *`categoryID`*. Таким образом, мы можем добавить элемент управления ObjectDataSource для `CategoryList` Repeater s `ItemTemplate` и настройте его для доступа к данным из этого метода класса s.

К сожалению элемент управления Repeater разрешает его шаблоны для редактирования в режиме конструктора, поэтому необходимо вручную добавить декларативный синтаксис для этого элемента управления ObjectDataSource. Следующий синтаксис показывает `CategoryList` Repeater s `ItemTemplate` после добавления этого нового источника ObjectDataSource (`ProductsByCategoryDataSource`):


[!code-aspx[Main](nested-data-web-controls-cs/samples/sample3.aspx)]

При использовании подхода ObjectDataSource, нам нужно установить `ProductsByCategoryList` Repeater s `DataSourceID` свойства `ID` из элемента управления ObjectDataSource (`ProductsByCategoryDataSource`). Кроме того, обратите внимание, что наш элемент управления ObjectDataSource имеет `<asp:Parameter>` элемент, который задает *`categoryID`* значение, которое будет передано в `GetProductsByCategoryID(categoryID)` метод. Но как указать это значение? В идеальном случае мы d можно просто установить `DefaultValue` свойство `<asp:Parameter>` элемент, используя синтаксис привязки данных, следующим образом:


[!code-aspx[Main](nested-data-web-controls-cs/samples/sample4.aspx)]

К сожалению, синтаксис привязки данных допустим только в элементы управления, имеющие `DataBinding` событий. `Parameter` Класс не имеет такого события, и поэтому выше синтаксис недопустим и приведет к ошибке времени выполнения.

Чтобы задать это значение, необходимо создать обработчик событий для `CategoryList` Repeater s `ItemDataBound` событий. Помните, что `ItemDataBound` событие запускается один раз для каждого элемента, привязанного к элементу управления Repeater. Таким образом, при каждом возникновении этого события для внешний элемент управления Repeater можно назначить текущий `CategoryID` значение `ProductsByCategoryDataSource` ObjectDataSource s `CategoryID` параметра.

Создайте обработчик событий для `CategoryList` Repeater s `ItemDataBound` событий следующим кодом:


[!code-csharp[Main](nested-data-web-controls-cs/samples/sample5.cs)]

Этот обработчик событий начинает, гарантируя, что мы повторно с данными элементов, вместо того, чтобы элемент заголовка, нижнего колонтитула или разделитель. Далее создается ссылка фактический `CategoriesRow` экземпляр, который только что был привязан к текущему `RepeaterItem`. Наконец, мы указываем ссылку ObjectDataSource в `ItemTemplate` и назначить его `CategoryID` значение параметра для `CategoryID` текущего `RepeaterItem`.

С помощью этого обработчика событий `ProductsByCategoryList` в каждом объекте `RepeaterItem` привязан к продуктам в `RepeaterItem` категории. Рис. 5 показан снимок экрана результирующие выходные данные.


[![Внешний элемент управления Repeater перечисляет каждую категорию; Один внутренний перечислены продукты для этой категории](nested-data-web-controls-cs/_static/image14.png)](nested-data-web-controls-cs/_static/image13.png)

**Рис. 5**: Внешний элемент управления Repeater перечисляет каждую категорию; в списках один внутренний продукты для этой категории ([Просмотр полноразмерного изображения](nested-data-web-controls-cs/_static/image15.png))


## <a name="accessing-the-products-by-category-data-programmatically"></a>Программный доступ к продуктам по данным категорий

Вместо использования элемента ObjectDataSource для получения продуктов для текущей категории, мы создаем метод в класс фонового кода страницы s наших ASP.NET (или в `App_Code` папке или в отдельном проекте библиотеки классов), возвращающий соответствующий набор продукты при передаче в `CategoryID`. Предположим, что нам необходимо было такого метода в классе фонового кода страницы s ASP.NET и что он именуется `GetProductsInCategory(categoryID)`. С помощью этого метода можно привязывать продукты для текущей категории к внутреннему элементу управления Repeater, используя следующий синтаксис:


[!code-aspx[Main](nested-data-web-controls-cs/samples/sample6.aspx)]

Элемент управления Repeater s `DataSource` свойство использует синтаксис привязки данных, чтобы указать, что его данные исходят от `GetProductsInCategory(categoryID)` метод. Так как `Eval("CategoryID")` возвращает значение типа `Object`, мы приводим объект к `Integer` перед передачей его в `GetProductsInCategory(categoryID)` метод. Обратите внимание, что `CategoryID` запрашиваемых, ниже приведен синтаксис через привязку данных `CategoryID` в *внешнего* Repeater (`CategoryList`), то s привязаны к записям в `Categories` таблицы. Таким образом, нам известно, что `CategoryID` не может быть базой `NULL` значение, поэтому мы просто можно привести `Eval` метод без проверки, если мы повторно освободили `DBNull`.

В этом случае нам необходимо создать `GetProductsInCategory(categoryID)` метод, который будет извлекать соответствующий набор продуктов для заданного *`categoryID`*. Это можно сделать путем простого возврата `ProductsDataTable` возвращаемые `ProductsBLL` класс s `GetProductsByCategoryID(categoryID)` метод. Разрешить создание s `GetProductsInCategory(categoryID)` метод в класс фонового кода для наших `NestedControls.aspx` страницы. Сделать это следующим образом:


[!code-csharp[Main](nested-data-web-controls-cs/samples/sample7.cs)]

Этот метод просто создает экземпляр `ProductsBLL` метод и возвращает результаты `GetProductsByCategoryID(categoryID)` метод. Обратите внимание, что метод должен быть помечен как `Public` или `Protected`; Если метод помечен `Private`, он не будет доступен из декларативной разметки страницы s ASP.NET.

После внесения этих изменений для использования новой методики, Отвлекитесь и просмотрите страницу через обозреватель. Выходные данные должны быть идентичны выходные данные, при использовании элемента управления ObjectDataSource и `ItemDataBound` подход обработчика событий (см. рис. 5 см. снимок экрана).

> [!NOTE]
> Создание метода может показаться `GetProductsInCategory(categoryID)` метод в класс фонового кода страницы s ASP.NET. В конце концов, этот метод просто создает экземпляр `ProductsBLL` класса и возвращает результаты его `GetProductsByCategoryID(categoryID)` метод. Почему просто не вызвать этот метод напрямую из синтаксиса привязки данных во внутреннем Repeater, например: `DataSource='<%# ProductsBLL.GetProductsByCategoryID((int)(Eval("CategoryID"))) %>'`? Несмотря на то, что этот синтаксис не будет работать с текущей реализацией класса `ProductsBLL` класса (так как `GetProductsByCategoryID(categoryID)` метод является методом экземпляра), можно изменить `ProductsBLL` чтобы он включал статический `GetProductsByCategoryID(categoryID)` метод или чтобы класс включал статический метод `Instance()` метод, чтобы вернуть новый экземпляр `ProductsBLL` класса.


Хотя такие изменения устранят нужду для `GetProductsInCategory(categoryID)` метод в класс фонового кода страницы s ASP.NET, метод класса фонового кода дает нам большую гибкость в работе с полученными данными, как скоро можно будет увидеть.

## <a name="retrieving-all-of-the-product-information-at-once"></a>Извлечение всех информации о продукте за один раз

Две предыдущих методики мы ve исследуется взять эти продукты для текущей категории, делая вызов к `ProductsBLL` класс s `GetProductsByCategoryID(categoryID)` метод (первый подход сделал это с помощью нового ObjectDataSource, второй, `GetProductsInCategory(categoryID)` метод в Класс фонового кода). При каждом вызове этого метода, вызовы уровня бизнес-логики до уровня доступа к данным, который запрашивает базу данных с инструкцией SQL, который возвращает строки из `Products` таблица, `CategoryID` поле совпадает с предоставленным параметром ввода.

Учитывая *N* категорий в системе, этот подход дает *N* + 1 вызов к одной базе данных запроса к базе данных для получения всех категорий и затем *N* вызовы для получения продуктов относящихся к каждой категории. Тем не менее, мы можно получить все необходимые данные в одном вызове вызовы только две базы данных для получения всех категорий, и второй для получения всех продуктов. После получения всех продуктов, эти продукты можно отфильтровать таким образом, что только продукты, совпадающие с текущим `CategoryID` привязаны к этой категории s внутреннему элементу управления Repeater.

Для обеспечения данной функциональности, нам нужно только внести небольшое изменение в `GetProductsInCategory(categoryID)` метод в класс фонового кода страницы s наших ASP.NET. Вместо того, чтобы вслепую возвращать результаты `ProductsBLL` класс s `GetProductsByCategoryID(categoryID)` , можно вместо этого сначала обратиться к *все* продуктов (если они еще не получен) и затем вернуть только отфильтрованное представление продукты, зависимости от переданного `CategoryID`.


[!code-csharp[Main](nested-data-web-controls-cs/samples/sample8.cs)]

Обратите внимание на добавление переменной уровня страницы, `allProducts`. Содержит сведения о всех продуктах и заполняется первый раз `GetProductsInCategory(categoryID)` вызывается метод. Убедившись, что `allProducts` объект создан и заполнен, метод фильтрует результаты s DataTable, таким образом, что только строки, в которых `CategoryID` соответствует указанному `CategoryID` доступны. Этот подход уменьшает количество раз, в базе данных осуществляется из *N* + 1 до двух.

Это улучшение не вносит никаких изменений в визуализированную разметку страницы, а также эта платформа предоставляет уменьшает число получаемых записей по сравнению с другим подходом. Он просто уменьшает количество вызовов к базе данных.

> [!NOTE]
> Один интуитивно причин, что уменьшение числа обращений к базе данных будет несомненно повысят производительность. Тем не менее это может оказаться так. Если у вас есть большое количество продуктов, `CategoryID` — `NULL`, для примера, а затем вызов `GetProducts` метод возвращает число продуктов, которые никогда не отображаются. Кроме того, возвращение всех продуктов может быть излишним, если вы повторно отображается только подмножество категорий, в которых может быть в случае, если реализовано разбиение на страницы.


Как всегда, когда дело доходит до анализа производительности двух методик, только Подогнанное является контролируемое тестирование для вашего приложения s распространенных сценариев.

## <a name="summary"></a>Сводка

В этом руководстве мы узнали, как вкладывать один веб-управления данными в другую, специально изучая, как у внешний элемент управления Repeater отображал элемент для каждой категории с внутреннему элементу управления Repeater выводил продукты для каждой категории в маркированном списке. Основная проблема, при создании вложенного интерфейса пользователя заключается в доступ к и привязки правильных данных к внутренним веб-управления. Существует множество доступных приемов, два из которых было рассмотрено в этом руководстве. В первом рассмотренном подходе используется элемент управления ObjectDataSource в шаблоне веб-элемента управления s `ItemTemplate` , была привязана к внутренним веб-управления через его `DataSourceID` свойство. Второй способ получить доступ к данным через метод в класс фонового кода s страницы ASP.NET. Затем этот метод можно привязать к внутренним данным веб-элемента управления s `DataSource` свойство через синтаксис привязки данных.

Хотя интерфейс пользователя в этом руководстве используется элемент управления Repeater, вложенный в элемент управления Repeater, эти приемы можно расширить другими элементами управления веб-данных. Можно вложить элемент управления Repeater внутри элемента управления GridView, или GridView в элемент управления DataList и так далее.

Счастливого вам программирования!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP.NET и основатель веб- [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Microsoft с 1998 года. Скотт — независимый консультант, преподаватель и автор. Его последняя книга — [ *Sams Teach ASP.NET 2.0 in 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Ним можно связаться по адресу [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Особая благодарность

В этой серии руководств пособий рецензировалась многими компетентными редакторами. Джонс (Zack Jones) и (Liz Shulok), стали Лиз Шалок в этом руководстве. Хотите поработать с моих последующих статей для MSDN? Если Да, напишите мне [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](showing-multiple-records-per-row-with-the-datalist-control-cs.md)
> [Вперед](displaying-data-with-the-datalist-and-repeater-controls-vb.md)
