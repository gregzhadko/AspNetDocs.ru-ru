---
uid: web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
title: Реализация оптимистичного параллелизма (C#) | Документация Майкрософт
author: rick-anderson
description: Для веб-приложения, который позволяет нескольким пользователям редактировать данные есть риск, что два пользователя может редактировать те же данные в то же время. В этом tutori...
ms.author: riande
ms.date: 07/17/2006
ms.assetid: 56e15b33-93b8-43ad-8e19-44c6647ea05c
msc.legacyurl: /web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
msc.type: authoredcontent
ms.openlocfilehash: 08a9e1db4f8c34b438d45c0fb74d852bbd249615
ms.sourcegitcommit: 289e051cc8a90e8f7127e239fda73047bde4de12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/25/2019
ms.locfileid: "58422783"
---
<a name="implementing-optimistic-concurrency-c"></a>Реализация оптимистичного параллелизма (C#)
====================
по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачайте пример приложения](http://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe) или [скачать PDF](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)

> Для веб-приложения, который позволяет нескольким пользователям редактировать данные есть риск, что два пользователя может редактировать те же данные в то же время. В этом руководстве мы реализуем управление оптимистичным параллелизмом для устранения этой опасности.


## <a name="introduction"></a>Вступление

Для веб-приложений, которые позволяют пользователям просматривать данные только или для тех, которые включают только один пользователь может изменять данные отсутствует опасность случайной перезаписи изменений другого двух одновременных пользователей. Для веб-приложений, которые позволяют нескольким пользователям обновлять или удалять данные но есть вероятность конфликта одновременно работающих пользователей изменений одного пользователя. Без применения политики параллелизма на месте когда два пользователя одновременном редактировании одной записи, пользователь, который фиксирует изменения последним, переопределяет изменения, внесенные в первом.

Например представьте, что два пользователя, Цзисунь и Сэм, одновременно открыли страницу приложения, позволяющего посетителям обновлять и удалять продукты с помощью элемента управления GridView. И нажмите кнопку Изменить в GridView примерно то же время. Цзисунь изменяет название продукта на «Чай Chai» и нажимает кнопку кнопкой "Обновить". Конечным результатом является `UPDATE` инструкцию, которая отправляется в базу данных, которая задает *все* из обновляемые поля продукта (хотя Цзисунь изменил только одно поле `ProductName`). На данный момент база данных содержит значения «Чай Chai» категории «Напитки», поставщик Exotic Liquids и так далее для данного конкретного продукта. Тем не менее GridView на экране Сэма по-прежнему отображается название продукта в редактируемой строке GridView как «Chai». Несколько секунд после фиксации изменений Цзисунь Сэм обновляет категорию на «Специи» и нажимает кнопку обновления. В результате `UPDATE` инструкции, отправляемые в базу данных, которая устанавливает название продукта «Chai» `CategoryID` соответствующий идентификатор категории «Напитки» и т. д. Цзисунь изменения названия продукта были перезаписаны. Рис. 1 изображена эта последовательность событий.


[![При одновременном обновлении записи существует вероятность s s один пользователь изменяет перезаписать другие устройства](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)

**Рис. 1**: При одновременном обновлении записи существует s потенциал s одного пользователя изменениями перезаписать другие устройства ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image3.png))


Аналогично при открытии страницы двумя пользователями, один пользователь может быть обновлять запись, когда она удалена другим пользователем. Или между после загрузки пользователем страницы и при нажатии кнопки Delete, другой пользователь может изменить содержание этой записи.

Существует три [управления параллелизмом](http://en.wikipedia.org/wiki/Concurrency_control) возможные стратегии:

- **Ничего не делать** -при изменении одновременно работающими пользователями одной записи, дайте последней фиксации выиграть (поведение по умолчанию)
- [**Оптимистичный параллелизм** ](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) -Предположим, хотя возможны конфликты параллелизма профессиональным сейчас или позже, подавляющее большинство случаев такие конфликты не возникают; таким образом, если конфликт возникает, просто информировать пользователей, их изменения Невозможно сохранить, поскольку и те же данные были изменены другим пользователем
- **Пессимистичный параллелизм** -предполагается, что конфликты параллелизма широко распространены и пользователей не устраивает простое благосостояние сказали, что их изменения не были сохранены из-за одновременных действий других пользователей; таким образом, когда пользователь начинает обновление записи, заблокируйте его , тем самым предотвращая редактирование или удаление этой записи до сохранения изменений других пользователей

Всех наших учебниках до сих использовали стратегия разрешения параллелизма по умолчанию — а именно, мы позволили выиграть последней записи. В этом руководстве мы рассмотрим, как реализовать управление оптимистичным параллелизмом.

> [!NOTE]
> Не рассматриваются примеры пессимистичного параллелизма в этой серии руководств. Пессимистичный параллелизм используется редко, что такие блокировки, если не правильно освобождаться, можно предотвратить обновление данных другим пользователям. Например если пользователь блокирует запись для редактирования и затем покидает один день, до его закрытия, ни один другой пользователь будет иметь возможность обновить ее до исходного пользователя, возвращает и завершения его обновления. Таким образом в ситуациях, где используется пессимистичный параллелизм, обычно наблюдается тайм-аута, после достижения Отмена блокировки. Запрос в службу продаж веб-сайтов, который заблокировать определенное место короткий промежуток времени, пока пользователь не завершит процесс заказа, приведен пример управления пессимистичным параллелизмом.


## <a name="step-1-looking-at-how-optimistic-concurrency-is-implemented"></a>Шаг 1. Просмотрев как оптимистическая блокировка реализуется

Управление оптимистичным параллелизмом осуществляется путем обеспечения, что запись обновляемой или удаляемой имеет те же значения, как при запуске процесса обновления или удаления. Например при нажатии кнопки "Изменить" в изменяемого элемента управления GridView, записи чтение из базы данных и отображения значений в текстовые поля и другие веб-элементов управления. Эти исходные значения сохраняются элементом GridView. Позже когда пользователь делает ее изменения и щелкает кнопкой "Обновить", исходные и новые значения отправляются уровня бизнес-логики, а затем вниз до уровня доступа к данным. Уровень доступа к данным необходимо выполнить инструкцию SQL, которая будет только обновить запись, если исходные значения, которые пользователь начал редактирование совпадают со значениями по-прежнему в базе данных. Рис. 2 изображена эта последовательность событий.


[![Для обновления или удаления, для успешного выполнения исходные значения должен быть равным текущие значения базы данных](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)

**Рис. 2**: Для обновления или удаления будет успешной, исходные значения должен быть равным текущие значения базы данных ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image6.png))


Существуют различные подходы к реализации оптимистичного параллелизма (см. в разделе [статье](http://peterbromberg.net/) [логика обновления оптимистичного параллелизма](http://www.eggheadcafe.com/articles/20050719.asp) для кратко рассмотрим несколько вариантов). Типизированный набор DataSet ADO.NET предоставляет одну реализацию, которая может быть настроена с помощью простой установки флажка. Активизация оптимистичного параллелизма для TableAdapter в типизированном наборе DataSet дополняет `UPDATE` и `DELETE` инструкций сравнением всех исходных значений в `WHERE` предложение. Следующие `UPDATE` инструкция, к примеру, обновляет название и цену продукта, только в том случае, если текущие значения базы данных равны значениям, которые были изначально получены при обновлении записи GridView. `@ProductName` И `@UnitPrice` параметры содержат новые значения, введенные пользователем, в то время как `@original_ProductName` и `@original_UnitPrice` содержат значения, которые были изначально загружены в GridView, если была нажата кнопка редактирования:


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample1.sql)]

> [!NOTE]
> Это `UPDATE` упрощена для удобочитаемости. На практике `UnitPrice` возврата `WHERE` предложение будет сложнее, поскольку `UnitPrice` может содержать `NULL` и проверка `NULL = NULL` всегда возвращает значение False (вместо этого необходимо использовать `IS NULL`).


Помимо использования другой базовой инструкции `UPDATE` инструкции, Настройка использования TableAdapter для использования оптимистичного параллелизма также изменяет подписи его DB прямые методы. Вспомните наш первый учебник, [ *создание уровня доступа к данным*](../introduction/creating-a-data-access-layer-cs.md), что непосредственные методы DB были те, которые принимает список скалярных значений в качестве входных параметров (вместо того чтобы DataRow со строгой типизацией или Экземпляр объекта DataTable). При использовании оптимистичного параллелизма, DB прямой `Update()` и `Delete()` включают входные параметры для исходных значений также. Кроме того, код в BLL для использования пакета обновления ( `Update()` перегрузок метода, которые принимают объектов DataRow и DataTables, а не скалярных значений) также необходимо изменить.

Чем расширить существующий класс TableAdapter DAL для использования оптимистичного параллелизма (для чего необходимо соответствующее изменение BLL для размещения), давайте вместо этого создать новый типизированный набор DataSet с именем `NorthwindOptimisticConcurrency`, к которому добавим `Products` TableAdapter, использует оптимистичный параллелизм. После этого мы создадим `ProductsOptimisticConcurrencyBLL` класс уровня бизнес-логики, с соответствующими изменениями для поддержки DAL оптимистичного параллелизма. После этого фундамента мы будем готовы к созданию страницы ASP.NET.

## <a name="step-2-creating-a-data-access-layer-that-supports-optimistic-concurrency"></a>Шаг 2. Создание уровня доступа к данным, с поддержкой оптимистичного параллелизма

Чтобы создать новый типизированный набор DataSet, щелкните правой кнопкой мыши `DAL` папку внутри `App_Code` папку и добавьте новый набор данных с именем `NorthwindOptimisticConcurrency`. Как мы видели в первом руководстве, это приводит к добавлению нового TableAdapter к типизированному DataSet, автоматический запуск мастера настройки TableAdapter. На первом экране мы вам будет предложено указать базу данных, подключиться - подключиться к одной базе данных "Борей" с помощью `NORTHWNDConnectionString` Azure с помощью `Web.config`.


[![Подключиться к одной и той же базе данных "Борей"](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)

**Рис. 3**: Подключиться к одной и той же базе данных "Борей" ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image9.png))


Далее необходимо указать способ запроса данных: через специальный оператор SQL, новую хранимую процедуру или существующую хранимую процедуру. Так как мы использовали ad-hoc-запросов SQL в исходном DAL, используйте этот параметр, здесь также.


[![Укажите данные, получаемые с помощью инструкции SQL Ad-Hoc](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)

**Рис. 4**: Укажите данные для извлечения с помощью инструкции SQL Ad-Hoc ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image12.png))


На следующем экране введите SQL-запрос, используемый для получения информации о продукте. Давайте использовать тот же точный запрос SQL, используемый для `Products` TableAdapter в исходном DAL, возвращающий все `Product` столбцы вместе с именами поставщика и категории продукта:


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample2.sql)]


[![Использовать один и тот же запрос SQL из Products TableAdapter в исходном DAL](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)

**Рис. 5**: Использовать один и тот же запрос SQL из `Products` TableAdapter в исходном DAL ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image15.png))


Прежде чем перейти к следующему экрану, нажмите кнопку Дополнительно. Чтобы этот адаптер таблицы используют управление оптимистичным параллелизмом, просто установите флажок «Использовать оптимистичный параллелизм».


[![Включить управление оптимистичным параллелизмом, проверка &quot;использовать оптимистичный параллелизм&quot; флажок](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)

**Рис. 6**: Включить управление оптимистичным параллелизмом, установив флажок «Использовать оптимистичный параллелизм» ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image18.png))


Наконец необходимо укажите что TableAdapter должен использовать шаблоны доступа к данным, которые Заполнение DataTable и вернуть таблицу данных; также указывать, что должна быть создана непосредственные методы DB. Измените имя метода для возврата шаблон DataTable из GetData на GetProducts, использовавшимся соглашения об именовании, которые были использованы в исходном DAL.


[![TableAdapter использует все шаблоны доступа к данным](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)

**Рис. 7**: У адаптера таблицы используют все шаблоны доступа к данным ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image21.png))


По завершении работы мастера конструктор DataSet будет включать, строго типизированный `Products` DataTable и TableAdapter. Отвлекитесь и измените имя DataTable из `Products` для `ProductsOptimisticConcurrency`, что можно сделать, щелкнув правой кнопкой мыши в строке заголовка объекта DataTable и выбрав переименование в контекстном меню.


[![К типизированному DataSet добавлены DataTable и TableAdapter](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)

**Рис. 8**: DataTable и TableAdapter были добавлены к типизированному DataSet ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image24.png))


Чтобы увидеть различия между `UPDATE` и `DELETE` запросов между `ProductsOptimisticConcurrency` TableAdapter (использует оптимистичный параллелизм) и TableAdapter Products (которая не), щелкните TableAdapter и перейдите в окно свойств. В `DeleteCommand` и `UpdateCommand` свойств `CommandText` подсвойств можно увидеть фактический синтаксис SQL, который отправляется в базу данных при вызове обновления DAL или методы, связанные с delete. Для `ProductsOptimisticConcurrency` TableAdapter `DELETE` выглядит:


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample3.sql)]

Тогда как `DELETE` для TableAdapter продуктов в исходном DAL будет гораздо проще:


[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample4.sql)]

Как вы видите, `WHERE` предложение в `DELETE` для TableAdapter, использующего оптимистичный параллелизм, включает сравнение между каждой из `Product` таблицы текущих значений столбцов и исходные значения во время GridView (или DetailsView и FormView) последнего заполнения. Так как все поля, отличных от `ProductID`, `ProductName`, и `Discontinued` может иметь `NULL` значения, дополнительные параметры и проверки, которые правильно сравнивать `NULL` значения в `WHERE` предложение.

Мы не добавлять любые дополнительные DataTables в оптимистичного параллелизма с поддержкой набор данных для этого руководства, как страницы ASP.NET предоставляет только в том случае, обновление и удаление информации о продуктах. Тем не менее, мы еще нужно добавить `GetProductByProductID(productID)` метод `ProductsOptimisticConcurrency` адаптера таблицы.

Для этого щелкните правой кнопкой мыши в строке заголовка TableAdapter (область непосредственно над `Fill` и `GetProducts` имена методов) и выберите Добавить запрос в контекстном меню. Запустится мастер настройки запроса адаптера таблицы. Как с начальной конфигурацией для нашего адаптера TableAdapter, необязательно для создания `GetProductByProductID(productID)` метода, использующего специальный оператор SQL (см. рис. 4). Так как `GetProductByProductID(productID)` метод возвращает сведения об определенном продукте, указать, что этот запрос является `SELECT` тип, который возвращает строки запроса.


[![Пометка типа запроса как &quot;SELECT, возвращающая строки&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)

**Рис. 9**: Пометка типа запроса как «`SELECT` , возвращающая строки» ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image27.png))


На следующем экране мы предложено ввести SQL-запрос для использования с предварительно загруженным запрос по умолчанию адаптера таблицы. Дополните существующий запрос для включения в предложении `WHERE ProductID = @ProductID`, как показано на рис. 10.


[![Добавить предложение, предварительно загружен запрос для возврата определенной записи продукта](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)

**Рис. 10**: Добавить `WHERE` предложение в Pre-Loaded запрос для возврата определенной записи продукта ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image30.png))


Наконец, измените имена созданных методов на `FillByProductID` и `GetProductByProductID`.


[![Переименование методов на FillByProductID и GetProductByProductID](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)

**Рис. 11**: Переименуйте методы, которые `FillByProductID` и `GetProductByProductID` ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image33.png))


После завершения работы мастера, элемент управления TableAdapter включает два метода для получения данных: `GetProducts()`, который возвращает *все* продуктов; и `GetProductByProductID(productID)`, которая возвращает указанный продукт.

## <a name="step-3-creating-a-business-logic-layer-for-the-optimistic-concurrency-enabled-dal"></a>Шаг 3. Создание уровня бизнес-логики для DAL оптимистичного параллелизма с поддержкой

Существующий класс `ProductsBLL` включает примеры использования пакетного обновления и прямой шаблонов DB. `AddProduct` Метод и `UpdateProduct` используют схему пакетного обновления, передавая `ProductRow` экземпляр метода обновления адаптера таблицы. `DeleteProduct` Метод, с другой стороны, использует непосредственной схемы базы данных, вызывающий `Delete(productID)` метод.

С новым `ProductsOptimisticConcurrency` TableAdapter, DB прямые методы теперь требуют, что исходные значения можно передавать и в. Например `Delete` метод теперь требует более чем 10 входных параметров: исходный `ProductID`, `ProductName`, `SupplierID`, `CategoryID`, `QuantityPerUnit`, `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`, и `Discontinued`. Он использует значения дополнительных входных параметров в `WHERE` предложении `DELETE` инструкция, введенная в базу данных только для удаления указанной записи, если текущие значения базы данных соответствуют оригинальным.

Хотя подпись метода для TableAdapter `Update` метод, используемый в схему пакетного обновления, не изменена, имеет код, необходимый для записи исходных и новых значений. Таким образом а не пытаться использовать оптимистичный параллелизм с поддержкой DAL с существующим `ProductsBLL` , создадим новый класс уровня бизнес-логики для работы с новым DAL.

Добавьте класс с именем `ProductsOptimisticConcurrencyBLL` для `BLL` папку внутри `App_Code` папки.


![Добавление класса ProductsOptimisticConcurrencyBLL в папку BLL](implementing-optimistic-concurrency-cs/_static/image34.png)

**Рис. 12**: Добавление `ProductsOptimisticConcurrencyBLL` класс в папку BLL


Добавьте следующий код, чтобы `ProductsOptimisticConcurrencyBLL` класса:


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample5.cs)]

Обратите внимание, использование `NorthwindOptimisticConcurrencyTableAdapters` инструкции до начала объявления класса. `NorthwindOptimisticConcurrencyTableAdapters` Пространство имен содержит `ProductsOptimisticConcurrencyTableAdapter` класс, предоставляющий методы DAL. Также вы найдете перед объявлением класса `System.ComponentModel.DataObject` атрибут, который указывает, что Visual Studio, чтобы включить этот класс в раскрывающемся списке мастера ObjectDataSource.

`ProductsOptimisticConcurrencyBLL` `Adapter` Предоставляет быстрый доступ к экземпляру `ProductsOptimisticConcurrencyTableAdapter` класса и соответствует шаблону, используемого в исходных классах BLL (`ProductsBLL`, `CategoriesBLL`, и так далее). Наконец `GetProducts()` метод просто вызывает DAL `GetProducts()` DAL и возвращает `ProductsOptimisticConcurrencyDataTable` заполненный `ProductsOptimisticConcurrencyRow` экземпляра для всех записей в базе данных.

## <a name="deleting-a-product-using-the-db-direct-pattern-with-optimistic-concurrency"></a>Удаление продукта с помощью непосредственной схемы базы данных с поддержкой оптимистичного параллелизма

При использовании непосредственной схемы базы данных, для DAL, поддерживающего оптимистичный параллелизм, методам должны быть переданы новых и исходные значения. Для удаления отсутствуют новые значения, поэтому только исходные значения должны передаваться в. В BLL, необходимо принять все исходные параметры в качестве входных параметров. Пусть `DeleteProduct` метод в `ProductsOptimisticConcurrencyBLL` класс использовать непосредственным методом базы данных. Это означает, что этот метод должен принимать во всех полях данных десять продукта в качестве входных параметров и передавать их DAL, как показано в следующем коде:


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample6.cs)]

Если исходные значения — значения последнего загруженные в GridView (или DetailsView и FormView) - отличаются от значений в базе данных, когда пользователь нажимает кнопку Delete `WHERE` предложение будет соответствовать любой записи базы данных и ни одной записи будут возвращены. Таким образом TableAdapter `Delete` метод возвратит `0` , а МЕТОД `DeleteProduct` метод возвратит `false`.

## <a name="updating-a-product-using-the-batch-update-pattern-with-optimistic-concurrency"></a>Обновление продукта с помощью схемы пакетного обновления с поддержкой оптимистичного параллелизма

Как отмечалось ранее, TableAdapter `Update` метод для шаблона пакетного обновления имеет ту же сигнатуру метода, независимо от того, работает ли оптимистичный параллелизм. А именно `Update` метод ожидает DataRow, массив объектов DataRow, DataTable или типизированный набор DataSet. Существуют дополнительные входные параметры для указания исходных значений. Это возможно, поскольку DataTable следит за исходные и измененные значения для его DataRow(s). Когда DAL выпускает инструкцию его `UPDATE` инструкции `@original_ColumnName` – измененными значениями исходные значения объекта DataRow, тогда как `@ColumnName` – измененными значениями объекта DataRow измененные значения.

В `ProductsBLL` класса (с использованием нашей исходного, отличных от оптимистичного параллелизма DAL), при использовании шаблона пакетного обновления для обновления информации о продукте код выполняет следующую последовательность действий:

1. Чтение текущей информации о продукте базы данных в `ProductRow` экземпляра с помощью адаптера таблицы `GetProductByProductID(productID)` метод
2. Назначение новых значений для `ProductRow` из этапа 1
3. Вызов метода `Update` метод, передавая `ProductRow` экземпляра

Эта последовательность операций, тем не менее, не будет правильно поддерживать оптимистичный параллелизм поскольку `ProductRow` в шаге 1 заполняется непосредственно из базы данных, это означает, что исходные значения, используемые DataRow являются те, которые в настоящее время существует в базы данных, а не те, которые были привязаны к GridView в начале процесса редактирования. Вместо этого при использовании оптимистичного параллелизма поддержкой DAL, нам нужно изменить `UpdateProduct` перегрузки метода, выполните следующие действия:

1. Чтение текущей информации о продукте базы данных в `ProductsOptimisticConcurrencyRow` экземпляра с помощью адаптера таблицы `GetProductByProductID(productID)` метод
2. Назначить *исходного* значения `ProductsOptimisticConcurrencyRow` из этапа 1
3. Вызовите `ProductsOptimisticConcurrencyRow` экземпляра `AcceptChanges()` метод, который указывает объект DataRow, что текущие значения являются «исходными»
4. Назначить *новый* значения `ProductsOptimisticConcurrencyRow` экземпляра
5. Вызов метода `Update` метод, передавая `ProductsOptimisticConcurrencyRow` экземпляра

Шаг 1 выполняется чтение всех текущих значений базы данных для определенной записи продукта. Этот шаг не требуется в перегрузке `UpdateProduct` , обновляющей *все* столбцы продукта (поскольку эти значения будут перезаписаны на шаге 2), но необходим для перегрузок, где только подмножество значений столбца передаются в качестве входные параметры. После назначения исходных значений для `ProductsOptimisticConcurrencyRow` экземпляра, `AcceptChanges()` вызывается метод, который помечает DataRow текущие значения как исходные значения для использования в `@original_ColumnName` параметров в `UPDATE` инструкции. После этого новые значения параметров назначаются `ProductsOptimisticConcurrencyRow` и, наконец, `Update` вызывается метод, передавая объект DataRow.

В следующем коде показан `UpdateProduct` перегрузку, которая принимает все данные о продуктах поля в качестве входных параметров. Пока не отображается, `ProductsOptimisticConcurrencyBLL` класс, включенные в загрузку для в этом руководстве также содержится `UpdateProduct` перегрузку, которая принимает только имя и цену продукта в качестве входных параметров.


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample7.cs)]

## <a name="step-4-passing-the-original-and-new-values-from-the-aspnet-page-to-the-bll-methods"></a>Шаг 4. Передача исходных и новых значений из страницы ASP.NET методам BLL

С помощью DAL и BLL остается только создать страницу ASP.NET, можно использовать встроенную в систему логику оптимистичного параллелизма. В частности данные веб-элемента управления (GridView, DetailsView и FormView) необходимо помнить, что исходные значения и элемент управления ObjectDataSource должен передавать оба набора значений для уровня бизнес-логики. Кроме того страница ASP.NET должна быть настроена таким образом, для правильной обработки одновременных нарушений.

Сначала откройте `OptimisticConcurrency.aspx` странице в `EditInsertDelete` папки и добавления элемента управления GridView в конструктор, установив его `ID` свойства `ProductsGrid`. Смарт-теге элемента GridView, необязательно, чтобы создать новый ObjectDataSource, именуемый `ProductsOptimisticConcurrencyDataSource`. Поскольку мы хотим данный элемент управления ObjectDataSource для использования DAL с поддержкой оптимистичного параллелизма, настройте его для использования `ProductsOptimisticConcurrencyBLL` объекта.


[![Рядом с ObjectDataSource объект ProductsOptimisticConcurrencyBLL](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)

**Рис. 13**: Для использования ObjectDataSource `ProductsOptimisticConcurrencyBLL` объекта ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image37.png))


Выберите `GetProducts`, `UpdateProduct`, и `DeleteProduct` методы из раскрывающихся списков в мастере. Для метода UpdateProduct используйте перегрузку, принимающая все поля данных продукта.

## <a name="configuring-the-objectdatasource-controls-properties"></a>Настройка свойств элемента управления ObjectDataSource

По завершении работы мастера декларативная разметка ObjectDataSource должен выглядеть следующим образом:


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample8.aspx)]

Как вы видите, `DeleteParameters` коллекция содержит `Parameter` экземпляр для каждого из 10 входных параметров в `ProductsOptimisticConcurrencyBLL` класса `DeleteProduct` метод. Аналогичным образом `UpdateParameters` коллекция содержит `Parameter` экземпляр для каждого из входных параметров в `UpdateProduct`.

Для предыдущих учебников, в которых использовалось изменение данных, мы бы удалили ObjectDataSource `OldValuesParameterFormatString` свойство на этом этапе, так как это свойство указывает, что метод BLL ожидает старые (или исходные) значения должны быть переданы в, а также новые значения. Кроме того значение этого свойства указывает названия входных параметров для исходных значений. Поскольку мы передаем в исходные значения в BLL, сделать *не* удалите это свойство.

> [!NOTE]
> Значение `OldValuesParameterFormatString` должно соответствовать именам входных параметров в BLL, которые ожидают исходные значения. Так как мы назвали эти параметры `original_productName`, `original_supplierID`, и т. д., можно оставить `OldValuesParameterFormatString` значение свойства как `original_{0}`. Если, однако, входные параметры методов BLL имеют такие имена, как `old_productName`, `old_supplierID`, и т. д., необходимо обновить `OldValuesParameterFormatString` свойства `old_{0}`.


Есть один параметр последнее свойство, который должен выполняться в порядке для ObjectDataSource верно передавал исходные значения методам BLL. Элемент управления ObjectDataSource имеет [свойство ConflictDetection](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx) , могут быть назначены [одно из двух значений](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx):

- `OverwriteChanges` -значение по умолчанию; исходным входным параметрам методов BLL не отправляет исходные значения
- `CompareAllValues` — исходные значения передаются методам BLL; Выберите этот параметр, при использовании оптимистичного параллелизма

Отвлекитесь и задать `ConflictDetection` свойства `CompareAllValues`.

## <a name="configuring-the-gridviews-properties-and-fields"></a>Настройка свойств и полей GridView

С правильно настроить свойства элемента ObjectDataSource перейдем к настройке GridView. Во-первых поскольку мы хотим GridView для поддержки редактирования и удаления, установите флажки Разрешить редактирование и разрешить удаление смарт-теге элемента GridView. При этом будет добавлено поле CommandField которого `ShowEditButton` и `ShowDeleteButton` устанавливается `true`.

При привязке к `ProductsOptimisticConcurrencyDataSource` ObjectDataSource, GridView содержит поле для каждого из полей данных продукта. Хотя можно изменять такие GridView, взаимодействие с пользователем не являются приемлимыми. `CategoryID` И `SupplierID` поля BoundField, кроме отрисовывается как текстовые поля, требующее от пользователя ввести соответствующую категорию и поставщика в качестве номера Идентификаторов. Будут отсутствовать форматирование числовых полей и элементы управления проверки для обеспечения указано название продукта и цена за единицу, единиц на складе, заказанных единиц порядок и значения уровня повторного заказа имеют оба собственное числовое значение и больше или равно нулевое значение.

Как уже говорилось в *Добавление проверяющих элементов управления для редактирования и вставки интерфейсы* и *Настройка интерфейса изменения данных* руководства и пользовательского интерфейса можно настроить Замена полей BoundFields полей TemplateField. Я модифицировала этот GridView и его интерфейс редактирования следующим образом:

- Удалить `ProductID`, `SupplierName`, и `CategoryName` полей BoundField
- Преобразовать `ProductName` BoundField в поле TemplateField и добавили элемент управления RequiredFieldValidation.
- Преобразовать `CategoryID` и `SupplierID` полей BoundField в поля TemplateField и настроил интерфейс редактирования для использования элементов управления DropDownList, а не в текстовые поля. В эти поля TemplateField `ItemTemplates`, `CategoryName` и `SupplierName` отображаются поля данных.
- Преобразовать `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, и `ReorderLevel` поля BoundField, кроме полей TemplateField и добавленных элементах управления CompareValidator.

Так как мы уже рассмотрели способы выполнения этих задач в предыдущих учебных курсах, я просто списке окончательный декларативный синтаксис и оставлю реализацию в качестве упражнения.


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample9.aspx)]

Мы очень близки к заврешению создания полностью рабочий пример. Тем не менее есть несколько тонкостей, которые будут незаметно и незаметно приведут к проблемам. Кроме того мы по-прежнему необходим интерфейс уведомления пользователя об одновременном нарушении.

> [!NOTE]
> Чтобы веб-управления данными верно передавал исходные значения для элемента управления ObjectDataSource (который затем передаются BLL), крайне важно, GridView `EnableViewState` свойству `true` (по умолчанию). При отключении состояния представления исходные значения будут потеряны при обратной передаче.


## <a name="passing-the-correct-original-values-to-the-objectdatasource"></a>Передача верных исходных значений ObjectDataSource

Существует несколько проблем с тем, как будет настроена GridView. Если ObjectDataSource `ConflictDetection` свойству `CompareAllValues` (как в нащем), когда ObjectDataSource `Update()` или `Delete()` элементом GridView (или DetailsView и FormView), ObjectDataSource пытается скопировать GridView исходные значения в соответствующие `Parameter` экземпляров. См. рис. 2 графическое представление этого процесса.

В частности GridView присваиваются значения в инструкциях двусторонней привязки данных, каждый раз, они привязываются к GridView. Поэтому очень важно, все необходимые исходные значения записывались через двусторонней привязки данных и предоставлялись в преобразуемом формате.

Чтобы увидеть, почему это важно, Отвлекитесь и посетите нашу страницу в браузере. Как и ожидалось, GridView перечисляет каждый продукт с помощью кнопки Edit и Delete в самом левом столбце.


[![Продукты, перечисленные в элементе управления GridView](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)

**Рис. 14**: Продукты, перечисленные в элементе управления GridView ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image40.png))


Если нажать кнопку «Удалить», для какой-либо продукт `FormatException` возникает исключение.


[![Попытка удаления результатов продуктов в FormatException](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)

**Рис. 15**: Попытка удалить любой продукт приводит `FormatException` ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image43.png))


`FormatException` Возникает, когда элемент управления ObjectDataSource пытается прочитать в исходном `UnitPrice` значение. Так как `ItemTemplate` имеет `UnitPrice` денежном формате (`<%# Bind("UnitPrice", "{0:C}") %>`), он включает символ валюты, например $19.95. `FormatException` Возникает при попытке преобразовать строку в элемент управления ObjectDataSource `decimal`. Чтобы обойти эту проблему, у нас есть несколько вариантов:

- Удаление форматирования денежных единиц `ItemTemplate`. То есть вместо использования `<%# Bind("UnitPrice", "{0:C}") %>`, просто используйте `<%# Bind("UnitPrice") %>`. Недостатком этого способа является то, что цена больше не отформатирована.
- Отображение `UnitPrice` в формате валюты в `ItemTemplate`, но использовать `Eval` ключевое слово для выполнения этой задачи. Помните, что `Eval` выполняет односторонней привязки данных. По-прежнему требуется предоставить `UnitPrice` значение для исходных значений, поэтому мы все равно нужен оператор двусторонней привязки данных в `ItemTemplate`, но это может быть помещен в элемент управления Label Web, `Visible` свойству `false`. В ItemTemplate можно использовать следующую разметку:


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample10.aspx)]

- Удаление форматирования денежных единиц `ItemTemplate`, с использованием `<%# Bind("UnitPrice") %>`. В GridView `RowDataBound` обработчик событий, программный доступ в течение которого элемент управления Label Web `UnitPrice` значение и установите его `Text` свойство форматированную версию.
- Оставьте `UnitPrice` формат как валюты. В GridView `RowDeleting` обработчик событий, замените существующее исходное `UnitPrice` значение ($19.95) фактическим десятичным значением с помощью `Decimal.Parse`. Мы узнали, как выполнение подобной задачи в `RowUpdating` обработчик событий в [ *обработка BLL и исключения уровня DAL на странице ASP.NET* ](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md) руководства.

В данном примере я решил использовать второй способ добавления скрытых Label Web элемент управления `Text` свойство является двусторонней данные, привязанные к значению `UnitPrice` значение.

После решения этой проблемы, попробуйте повторно нажмите кнопку удаления любого продукта. Это время, вы получите `InvalidOperationException` при попытке вызова МЕТОДА ObjectDataSource `UpdateProduct` метод.


[![ObjectDataSource не может найти метод с входные параметры, он хочет отправить](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)

**Рис. 16**: ObjectDataSource не может найти метод с входные параметры, он хочет отправить ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image46.png))


Взглянув на сообщение исключения, становится ясно, что элемент управления ObjectDataSource хочет вызвать МЕТОД `DeleteProduct` метод, который включает в себя `original_CategoryName` и `original_SupplierName` входных параметров. Это обусловлено `ItemTemplate` s для `CategoryID` и `SupplierID` полей TemplateField в настоящий момент содержат двусторонней привязки инструкции с `CategoryName` и `SupplierName` полей данных. Вместо этого нам нужно включать `Bind` инструкции с `CategoryID` и `SupplierID` полей данных. Для этого замените существующие инструкции привязки с `Eval` инструкций, а затем добавьте скрытые метка, для свойств `Text` свойства привязаны к `CategoryID` и `SupplierID` поля данных, с помощью двусторонней привязки данных, как показано ниже:


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample11.aspx)]

С этими изменениями мы стали успешно удалять и редактировать информацию о продуктах! На шаге 5 мы рассмотрим способ проверки обнаружения одновременных нарушений. Но пока потратьте несколько минут и попробуйте обновить и удалить несколько записей, чтобы убедиться, что обновления и удаления для одного пользователя работает должным образом.

## <a name="step-5-testing-the-optimistic-concurrency-support"></a>Шаг 5. Тестирование поддержки оптимистичного параллелизма

Чтобы убедиться, что одновременные нарушения выполняется обнаруженных (а не приводит к автоматической перезаписи данных), нам нужно открыть двух окнах браузера на эту страницу. В обоих экземплярах обозревателя нажмите кнопку "Изменить" для продукта Chai. Затем в одном из обозревателей, измените имя на «Чай Chai» и нажмите кнопку обновления. Обновление должна завершиться успешно и возвращать GridView в состояние до редактирования с «Чай Chai» в качестве нового названия продукта.

В другом экземпляре обозревателя имя продукта текстовое поле по-прежнему отображается «Chai». В этом втором окне обозревателя, обновите `UnitPrice` для `25.00`. Без поддержки оптимистичного параллелизма обновления во втором экземпляре обозревателя изменится имя продукта обратно на «Chai», тем самым переписывая изменения, выполненные в первом экземпляре обозревателя. С помощью оптимистичного параллелизма, тем не менее, щелчок кнопкой "Обновить" на втором экземпляре обозревателя приводит [DBConcurrencyException](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx).


[![При обнаружении одновременного нарушения возникает исключение DBConcurrencyException](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)

**Рис. 17**: При обнаружении одновременного нарушения, `DBConcurrencyException` возникает исключение ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image49.png))


`DBConcurrencyException` Возникает только в том случае, когда используется схема пакетного обновления DAL. Исключение не вызывалось непосредственной схемы базы данных, просто указывается, что строки не были затронуты. Чтобы проиллюстрировать это, возвращают установим для элемента управления GridView в их состояние до редактирования. Затем в первом экземпляре обозревателя нажмите кнопку "Изменить" и измените имя продукта с «Чай Chai» на «Chai» и нажмите кнопку обновления. В окне второго обозревателя нажмите кнопку «Удалить» для продукта Chai.

После нажатия кнопки Delete, обратной передаче страницы, ObjectDataSource вызывает GridView `Delete()` метод и элемент управления ObjectDataSource вызывает `ProductsOptimisticConcurrencyBLL` класса `DeleteProduct` , передавая исходные значения. Исходный `ProductName` значение для второго экземпляра обозревателя равно «Чай Chai», который не совпадает с текущим `ProductName` значение в базе данных. Таким образом `DELETE` обращенное к базе данных влияет на нулевые строки, поскольку отсутствует запись в базе данных, `WHERE` удовлетворяет предложение. `DeleteProduct` Возвращает метод `false` и ObjectDataSource привязываются к GridView.

С точки зрения конечного пользователя, нажав кнопку "Удалить" для «Чай Chai» во втором окне обозревателя вызвал мигание экрана и, при вернуться, этот продукт является по-прежнему существует, несмотря на то, что теперь он отображается как «Chai» (Изменение названия продукта, первый браузером экземпляр). Если пользователь нажимает кнопку Delete еще раз, операция удаления будут успешными, так как GridView исходного `ProductName` значение («Chai») теперь соответствует значение в базе данных.

В обоих случаях взаимодействие с пользователем далеко от идеала. Нам явно не требуется для представления пользователю работать с мелкими деталями `DBConcurrencyException` возникло исключение при использовании шаблона пакетного обновления. И поведение, когда с помощью непосредственной схемы базы данных несколько запутанным, так как не удалось выполнить команду пользователей, но не было точные причины.

Чтобы исправить эти две проблемы, мы можем создать метку веб-элементов управления на странице, предоставляющие объяснения, почему update или delete не удалось. Для схемы пакетного обновления, мы можем определить ли `DBConcurrencyException` возникло исключение в обработчике событий последующего уровня элемента GridView, отображается предупреждение, при необходимости. Для прямого метода DB можно проверить возвращаемое значение метода BLL (который является `true` если изменена одна строка, `false` в противном случае) и при необходимости отображать информационное сообщение.

## <a name="step-6-adding-informational-messages-and-displaying-them-in-the-face-of-a-concurrency-violation"></a>Шаг 6. Добавление информационных сообщений и их отображение, смотря на одновременное нарушение

При возникновении одновременного нарушения, поведение, демонстрируемое зависит от того, какой использовался пакетного обновления DAL или непосредственной схемы базы данных. В этом руководстве используются оба шаблона с помощью схемы пакетного обновления используется для обновления и непосредственной схемы базы данных, используемый для удаления. Чтобы начать работу, давайте добавим два элемента управления Label Web к нашей странице, прояснить, что о возникновении одновременного нарушения при попытке удаления или обновления данных. Значение элемента управления Label `Visible` и `EnableViewState` свойства `false`; в результате они будут скрыты при всех, за исключением того, для тех определенной страницы посещает where их `Visible` программно свойству `true`.


[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample12.aspx)]

Дополнение к параметру их `Visible`, `EnabledViewState`, и `Text` свойства, я также установил `CssClass` свойства `Warning`, чего метку, отображаемую в больших, red, курсив, полужирный шрифт. Этот класс `Warning` CSS был определен и добавлен в Styles.css обратно в *Проверка события, связанные с вставки, обновления и удаления* руководства.

После добавления этих меток, конструктор в Visual Studio должна быть аналогична рис. 18.


[![Были добавлены два элемента управления Label к странице](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)

**Рис. 18**: Две метки элементов управления были добавлены на страницу ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image52.png))


С этими элементами управления Label Web на месте, мы готовы к рассмотрению определения, когда произошло нарушение параллелизма, в какую точку соответствующую метку `Visible` можно присвоить свойство `true`, отображается информационное сообщение.

## <a name="handling-concurrency-violations-when-updating"></a>Обработка одновременных нарушений при обновлении

Сначала рассмотрим обработку одновременных нарушений при использовании шаблона пакетного обновления. Так как такие нарушения при использовании пакета обновить шаблон Причина `DBConcurrencyException` исключение, необходимо добавить код к нашей странице ASP.NET, чтобы определить ли `DBConcurrencyException` возникло исключение во время обновления. Если таким образом, мы должны отображаться сообщение для пользователя сообщение о том, их изменения не были сохранены, так как другой пользователь был изменен и те же данные между после начала редактирования записи и щелчку кнопкой "Обновить".

Как мы видели в *обработка BLL и исключения уровня DAL на странице ASP.NET* руководства, такие исключения может быть обнаружено и отброшены обработчиках событий последующего уровня веб-элемента управления. Следовательно, необходимо создать обработчик событий для элемента GridView `RowUpdated` обработчик, проверяющий возникновение `DBConcurrencyException` исключения. Этот обработчик событий передается ссылка на любое исключение, возникшее во время процесса обновления, как показано в событии обработчик кода ниже:


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample13.cs)]

В возникновении исключения из `DBConcurrencyException` исключения, этот обработчик событий отображает `UpdateConflictMessage` метки элемента управления и указывает, что исключение было обработано. Этот код в месте, при возникновении одновременного нарушения при обновлении записи пользователя изменения будут потеряны, поскольку они переписывают выполненные изменения другого пользователя в то же время. В частности GridView возвращается в состояние до редактирования и связанных с текущей базой данных. Это обновит строке GridView изменения другого пользователя, которые ранее не были видны. Кроме того `UpdateConflictMessage` элемент управления Label будет объяснить пользователю что произошло. На рис. 19 подробно описана эта последовательность событий.


[![Пользователь s обновления теряются в условиях возникновения одновременного нарушения](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)

**Рис. 19**: Пользователь s обновления теряются в условиях возникновения одновременного нарушения ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image55.png))


> [!NOTE]
> Кроме того, вместо того чтобы возвращать GridView в состояние до редактирования, можно оставить GridView в состояние редактирования, установив `KeepInEditMode` свойство переданное `GridViewUpdatedEventArgs` необходимо присвоить значение true. При использовании этого подхода, тем не менее, необходимо выполнить повторную привязку данных к GridView (путем вызова его `DataBind()` метод), чтобы значения другого пользователя будут загружены в интерфейс редактирования. Код, можно загрузить с помощью этого руководства содержит эти две строки кода в `RowUpdated` снабжены комментариями; просто раскомментируйте следующие строки кода, чтобы GridView остался в режиме редактирования после возникновения одновременного нарушения.


## <a name="responding-to-concurrency-violations-when-deleting"></a>Реагирование на одновременные нарушения при удалении

С помощью непосредственной схемы базы данных есть исключение не создается при возникновении одновременного нарушения. Вместо этого инструкция базы данных просто не изменяет запись, как предложение WHERE не соответствует ни одной записи. Все созданные в BLL способы изменения данных спроектированы таким образом, что они возвращают логическое значение, указывающее, является ли они изменяются в каждой записи. Таким образом, чтобы определить, при возникновении одновременного нарушения при удалении записи, можно проверить возвращаемое значение метода `DeleteProduct` метод.

Возвращаемое значение метода BLL можно проверить в обработчиках событий последующего уровня ObjectDataSource через `ReturnValue` свойство `ObjectDataSourceStatusEventArgs` объект, передаваемый в обработчик событий. Так как нас интересует определение возвращаемого значения из `DeleteProduct` метод, необходимо создать обработчик событий для элемента управления ObjectDataSource `Deleted` событий. `ReturnValue` Свойство имеет тип `object` и может быть `null` Если возникло исключение, и метод была прервана, прежде чем она может возвращать значение. Таким образом, мы должны убедиться, что `ReturnValue` свойство не является `null` и является логическим значением. При условии, что эта проверка прошла успешно, мы покажем `DeleteConflictMessage` метки элемента управления, если `ReturnValue` является `false`. Это можно сделать с помощью следующего кода:


[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample14.cs)]

При возникновении одновременного нарушения запрос пользователя на удаление отменяется. Обновляется GridView, в том, что изменения, внесенные в течение этой записи между моментом, когда пользователь загрузки страницы и когда он нажимает кнопку Delete. Когда процесс нарушения, `DeleteConflictMessage` метке, объяснением произошедшего (см. рис. 20).


[![Пользователь s удаление отменен в следствие одновременного нарушения](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)

**Рис. 20**: Пользователь s удаление отменен в следствие одновременного нарушения ([Просмотр полноразмерного изображения](implementing-optimistic-concurrency-cs/_static/image58.png))


## <a name="summary"></a>Сводка

Возможности одновременного нарушения существуют во всех приложениях, позволяет нескольким пользователям одновременно обновлять или удалять данные. Если подобные нарушения не учитываются, при одновременном обновлении те же данные, кто получает в последней записи «wins», перезапись другой пользователь изменяет изменения. Кроме того разработчики могут реализовать оптимистичное или пессимистичное управление параллелизмом. Управление оптимистичным параллелизмом предполагает, что одновременные нарушения происходят редко и просто запрещает обновление или удаления, составляющей одновременного нарушения. Управление пессимистичным параллелизмом предполагает, что параллельную обработку нарушения возникают часто и просто отклонение одного пользователя может обновлять или удалять команды не допускается. Управление пессимистичным параллелизмом обновление записи включает блокировки, тем самым предотвращая других пользователей, изменять и удалять записи при ее.

Типизированный набор DataSet в .NET предоставляет возможности для поддержки управления оптимистичного параллелизма. В частности `UPDATE` и `DELETE` , обращенные к базе данных включают все столбцы таблицы, тем самым гарантируя, что обновления или удаления произойдет только текущие данные записи, совпадающие с исходными данными пользователя был при выполнение обновления или удаления. После настройки DAL для поддержки оптимистичного параллелизма методы BLL должны быть обновлены. Кроме того страница ASP.NET, которая вызывает BLL должен быть настроен таким образом, элемент управления ObjectDataSource извлекает исходные значения из своего веб-управления данными и передавал их в BLL.

Как мы видели в этом учебнике, реализация управления оптимистичным параллелизмом в веб-приложение ASP.NET включает обновление DAL и BLL и добавление поддержки к странице ASP.NET. Является ли эта дополнительная работа разумной тратой вашего времени и усилий зависит от приложения. При наличии редко одновременно работающих пользователей, обновление данных, или данные, которые они обновляют отличается от друг с другом, управление параллелизмом не является ключевым вопросом. Если, однако, вы постоянно работает множество пользователей на вашем узле с теми же данными, управление параллелизмом может помочь предотвратить случайную перезапись одними один пользователь обновления или удаления.

Счастливого вам программирования!

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP.NET и основатель веб- [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Microsoft с 1998 года. Скотт — независимый консультант, преподаватель и автор. Его последняя книга — [ *Sams Teach ASP.NET 2.0 in 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Ним можно связаться по адресу [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).

> [!div class="step-by-step"]
> [Назад](customizing-the-data-modification-interface-cs.md)
> [Вперед](adding-client-side-confirmation-when-deleting-cs.md)
