---
uid: web-forms/overview/data-access/working-with-batched-data/wrapping-database-modifications-within-a-transaction-cs
title: Перенос изменений базы данных в транзакции (C#) | Документация Майкрософт
author: rick-anderson
description: Это руководство представляет собой первый из четырех, ищущий обновление, удаление и вставка пакеты данных. В этом учебнике рассказано, как разрешить транзакций базы данных...
ms.author: riande
ms.date: 06/26/2007
ms.assetid: b45fede3-c53a-4ea1-824b-20200808dbae
msc.legacyurl: /web-forms/overview/data-access/working-with-batched-data/wrapping-database-modifications-within-a-transaction-cs
msc.type: authoredcontent
ms.openlocfilehash: 1c174b824595f2d85eef97f467ff99082cfeb6d3
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65108295"
---
# <a name="wrapping-database-modifications-within-a-transaction-c"></a>Перенос изменений базы данных в транзакции (C#)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачать код](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_63_CS.zip) или [скачать PDF](wrapping-database-modifications-within-a-transaction-cs/_static/datatutorial63cs1.pdf)

> Это руководство представляет собой первый из четырех, ищущий обновление, удаление и вставка пакеты данных. В этом руководстве мы Узнайте, как транзакции базы данных позволяют вносить изменения пакета должно быть выполнено как атомарную операцию, которая гарантирует, что все действия завершится успехом или ошибкой все шаги.

## <a name="introduction"></a>Вступление

Как мы видели, начиная с [Обзор Вставка, обновление и удаление данных](../editing-inserting-and-deleting-data/an-overview-of-inserting-updating-and-deleting-data-cs.md) руководстве GridView предоставляет встроенную поддержку редактирования на уровне строк и удаления. Несколькими щелчками мыши можно создать интерфейс изменения форматированных данных без написания кода, до тех пор, пока вы являетесь содержимого редактирования и удаления на основе строки. Однако в некоторых случаях этого недостаточно, и нам нужно предоставить пользователям возможность изменить или удалить пакет записей.

К примеру наиболее веб-клиенты электронной почты использование сетки списка каждое сообщение, где каждая строка включает флажок наряду с информацией по электронной почте s (тема, отправитель и так далее). Этот интерфейс позволяет пользователю удалить несколько сообщений, установите их и нажмите кнопку Удалить выбранные сообщения. Интерфейс для редактирования пакета идеально подходит в ситуациях, где пользователи часто изменять множество различных записей. Вместо того чтобы, что вынуждает пользователя нажмите кнопку Изменить, внести свои изменения и затем нажмите кнопку "Обновить" для каждой записи, которое должно быть изменено, пакетной службы, интерфейс редактирования отображает каждой строки с его интерфейс редактирования. Пользователь может быстро изменять набор строк, которые должны быть изменены и затем сохранить эти изменения, нажав кнопку все обновления. В этой серии руководств мы рассмотрим, как создавать интерфейсы для вставки, редактирования и удаления пакетов данных.

При выполнении пакетных операций оно важно определить, является ли возможно для некоторых операций в пакете для успешного выполнения, а другие ошибкой. Рассмотрите возможность удаления интерфейс — что должно происходить, если первый выбранной записи успешно удален, но вторая завершился неудачно, скажем, из-за нарушения ограничения внешнего ключа пакета? Сначала удалить запись s откатить или приемлемо для первой записи остаются удаленные?

Если вы не хотите пакетной службы будет считаться [атомарной операции](http://en.wikipedia.org/wiki/Atomic_operation), один где либо все действия успешно или сбоем все действия, а затем уровень доступа к данным необходимо дополнить для поддержки [базы данных транзакции](http://en.wikipedia.org/wiki/Database_transaction). Транзакции базы данных гарантирует атомарность для набора `INSERT`, `UPDATE`, и `DELETE` — это компонент, поддерживаемый все большинство современных баз данных и выполняются в рамках транзакции инструкции.

В этом руководстве мы рассмотрим способы расширения DAL для использования транзакций базы данных. Последующих руководствах рассмотрим реализацию веб-страниц для пакетной вставки, обновления и удаления интерфейсов. Позвольте s приступить к работе!

> [!NOTE]
> При изменении данных в пакетной транзакции, атомарность требуется не всегда. В некоторых сценариях может быть допускается использование некоторых изменений данных успешно и другими пользователями в одном пакете ошибкой, например, когда удаление набора данных по электронной почте из клиента веб-службы электронной почты. Если есть s обработать базу данных ошибок во время выполнения удаления, ее вероятно приемлемым, что эти записи, обрабатываются без ошибок остаются удаленные s. В таком случае DAL не нужно изменять для поддержки транзакций базы данных. Существуют другие пакетной операции ситуации, тем не менее, где важна атомарность. Если клиент перемещается ее средств с одного банковского счета на другой, необходимо выполнить две операции: должно быть вычтено из первой учетной записи и затем добавляется второй денежные средства. Банк может не волнует, что первым шагом успешного выполнения, но второй шаг не удастся, его пользователи терпимо будут обеспокоен. Я советую вам для работы с этим руководством и реализовать усовершенствования в слой DAL для поддержки транзакций базы данных, даже если вы не планируете использовать их в пакетной вставки, обновления и удаления интерфейсы, которые мы будем строить в трех следующих руководствах.

## <a name="an-overview-of-transactions"></a>Общие сведения о транзакции

В большинстве баз данных включают поддержку *транзакции*, которые поддерживают несколько команд базе данных быть сгруппированы в одной логической единице работы. Команды базы данных, которые составляют транзакцию гарантированно атомарным, это означает, что все команды завершится ошибкой или все будет выполнена успешно.

В общем случае транзакции реализуются с помощью инструкций SQL, используя следующий шаблон:

1. Указывают на начало транзакции.
2. Выполнение инструкций SQL, которые составляют транзакцию.
3. Если возникает ошибка в одной из инструкций из шага 2, производится откат транзакции.
4. Если все инструкции из шага 2 завершается без ошибок, зафиксируйте транзакцию.

Инструкции SQL, используемый для создания, фиксации и откат транзакции можно ввести вручную при написания скриптов SQL или создании хранимых процедур или через программный означает использование ADO.NET или классы в [ `System.Transactions` пространство имен](https://msdn.microsoft.com/library/system.transactions.aspx). В этом учебном курсе мы рассмотрим только управление транзакциями, с помощью ADO.NET. В следующем учебном курсе мы рассмотрим способы использования хранимых процедур в слое доступа к данным, после чего мы изучим инструкции SQL для создания, откат и Фиксация транзакции. В то же время, обратитесь к [управление транзакциями в хранимые процедуры SQL Server](http://www.4guysfromrolla.com/webtech/080305-1.shtml) Дополнительные сведения.

> [!NOTE]
> [ `TransactionScope` Класс](https://msdn.microsoft.com/library/system.transactions.transactionscope.aspx) в `System.Transactions` пространства имен позволяет разработчикам программным способом программы-оболочки для ряд инструкций в пределах транзакции и включает в себя поддержку сложных операций с участием нескольких источников, таких как две разные базы данных или даже разнородных типов хранилищ данных, таких как базы данных Microsoft SQL Server, базы данных Oracle и веб-службы. Я решил использовать транзакции ADO.NET в этом руководстве, а не хранить `TransactionScope` класс, поскольку ADO.NET определено точнее, для транзакций базы данных и во многих случаях являются гораздо меньше много ресурсов. Кроме того, в некоторых обстоятельствах `TransactionScope` класс использует координатор распределенных транзакций Microsoft (MSDTC). Проблемы конфигурации, реализации и производительности окружающей MSDTC упрощает довольно специализированные и дополнительные темы и выходит за рамки этих учебников.

При работе с поставщиком SqlClient в ADO.NET, транзакции инициируются путем вызова [ `SqlConnection` класс](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx) s [ `BeginTransaction` метод](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.begintransaction.aspx), который возвращает [ `SqlTransaction` объекта](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.aspx). Инструкции изменения данных, в состав транзакции, помещаются в `try...catch` блока. Если произошла ошибка в операторе в `try` block, выполнение передается `catch` блока, где можно выполнить откат транзакции с помощью `SqlTransaction` объект s [ `Rollback` метод](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.rollback.aspx). Если все операторы завершился успешно, вызов `SqlTransaction` объект s [ `Commit` метод](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.commit.aspx) в конце `try` блок фиксирует транзакцию. В следующем фрагменте кода показана схема работы. См. в разделе [поддержание согласованности базы данных с транзакциями](http://aspnet.4guysfromrolla.com/articles/072705-1.aspx) дополнительный синтаксис и примеры использования транзакций с помощью ADO.NET.

[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample1.cs)]

По умолчанию в типизированный набор DataSet TableAdapters не использовать транзакции. Чтобы обеспечить поддержку транзакций, нам нужно дополнить классов TableAdapter для включения дополнительных методов, использующих выше шаблон для выполнения ряда инструкций изменения данных в области транзакции. На шаге 2 будет показано, как использовать разделяемые классы для добавления этих методов.

## <a name="step-1-creating-the-working-with-batched-data-web-pages"></a>Шаг 1. Создание рабочего с пакетными данными веб-страниц

Прежде чем приступать, показывающих, как дополнить DAL для поддержки транзакций базы данных, позволяют s уделим несколько минут для создания веб-страниц ASP.NET, которые понадобятся в этом руководстве, а также три приведенные далее. Начните с добавления новой папки с именем `BatchData` и добавьте следующие страницы ASP.NET, сопоставление каждой страницы с `Site.master` главной страницы.

- `Default.aspx`
- `Transactions.aspx`
- `BatchUpdate.aspx`
- `BatchDelete.aspx`
- `BatchInsert.aspx`

![Добавление страниц ASP.NET для элемента управления SqlDataSource руководств](wrapping-database-modifications-within-a-transaction-cs/_static/image1.gif)

**Рис. 1**: Добавление страниц ASP.NET для элемента управления SqlDataSource руководств

Как и в других папках, `Default.aspx` будет использовать `SectionLevelTutorialListing.ascx` пользовательский элемент управления, чтобы получить список учебников в своем разделе. Поэтому добавьте данный пользовательский элемент управления для `Default.aspx` , перетащив его из обозревателя решений на странице s режиме конструктора.

[![Добавление элемента управления Sectionleveltutoriallisting.ascx к странице Default.aspx](wrapping-database-modifications-within-a-transaction-cs/_static/image2.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image1.png)

**Рис. 2**: Добавить `SectionLevelTutorialListing.ascx` для пользовательского элемента управления `Default.aspx` ([Просмотр полноразмерного изображения](wrapping-database-modifications-within-a-transaction-cs/_static/image2.png))

Наконец, добавьте эти четыре страницы как записи для `Web.sitemap` файла. В частности, добавьте следующую разметку после Настройка карты узла `<siteMapNode>`:

[!code-xml[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample2.xml)]

После обновления `Web.sitemap`, Отвлекитесь и просмотрите учебный веб-узел в обозревателе. В меню слева теперь есть элементы по работе с пакетными данными учебниками.

![Карта узла теперь включают записи для работы с учебниками пакетными данными](wrapping-database-modifications-within-a-transaction-cs/_static/image3.gif)

**Рис. 3**: Карта узла теперь включают записи для работы с учебниками пакетными данными

## <a name="step-2-updating-the-data-access-layer-to-support-database-transactions"></a>Шаг 2. Обновление уровня доступа к данным для поддержки транзакций базы данных

Как уже говорилось в первом учебнике [создание уровня доступа к данным](../introduction/creating-a-data-access-layer-cs.md), представляет собой DataTables и адаптеров таблиц TableAdapter типизированного набора DataSet в DAL. DataTables хранят данные в то время как адаптеры таблиц обеспечивают функциональные возможности для считывания данных из базы данных в DataTables, обновить базу данных с помощью изменения, внесенные в таблицы данных и т. д. Помните, что TableAdapters предоставляет два шаблона для обновления данных, которую я называют пакетного обновления и непосредственные методы DB. С помощью шаблона пакетного обновления TableAdapter передается DataSet, DataTable или коллекции из DataRow. Эти данные перечисляется и для каждой вставки, изменения или удаленной строки, `InsertCommand`, `UpdateCommand`, или `DeleteCommand` выполняется. С помощью непосредственного шаблона DB TableAdapter вместо этого передается значения столбцов, необходимые для вставки, обновления или удаления одной записи. DB прямой метод шаблона затем использует эти значения, переданный для выполнения соответствующего `InsertCommand`, `UpdateCommand`, или `DeleteCommand` инструкции.

Независимо от того, шаблон обновления, используемый создаваемые автоматически методы TableAdapters не использовать транзакции. По умолчанию каждой инструкции insert, update или delete, выполненных TableAdapter рассматривается как дискретные одной операции. Например представьте, что непосредственного шаблона DB используется некоторый код в BLL для вставки десяти записей в базе данных. Этот код вызовет TableAdapter s `Insert` метод десять раз. Если выполнена первые пять операций вставки, но шестого вызывающий исключение, первые пять вставленной записи останется в базе данных. Аналогичным образом, если шаблон пакетного обновления используется для выполнения операций вставки, обновления и удаления для вставленных, изменения и удаленные строки в объект DataTable, если первый некоторых изменений выполнено успешно, но поздней произошла ошибка, эти более ранние изменения, завершена, будет оставаться в базе данных.

В некоторых сценариях мы стремимся обеспечить атомарность через последовательность изменений. Для этого мы вручную расширить TableAdapter, добавив новые методы, которые выполняются `InsertCommand`, `UpdateCommand`, и `DeleteCommand` s в рамках транзакции. В [создание уровня доступа к данным](../introduction/creating-a-data-access-layer-cs.md) рассматривалось использование [разделяемые классы](http://en.wikipedia.org/wiki/Partial_type) для расширения функциональных возможностей DataTables в типизированный набор DataSet. Этот метод можно также с помощью адаптеров таблиц TableAdapter.

Типизированный набор DataSet `Northwind.xsd` находится в `App_Code` папка s `DAL` во вложенную папку. Создайте вложенную папку в `DAL` папку с именем `TransactionSupport` и добавьте новый файл класса с именем `ProductsTableAdapter.TransactionSupport.cs` (см. рис. 4). Этот файл будет содержать частичная реализация `ProductsTableAdapter` , включает методы для выполнения изменений данных, используя транзакцию.

![Добавьте папку с именем TransactionSupport и файл класса с именем ProductsTableAdapter.TransactionSupport.cs](wrapping-database-modifications-within-a-transaction-cs/_static/image4.gif)

**Рис. 4**: Добавьте папку с именем `TransactionSupport` и файл класса с именем `ProductsTableAdapter.TransactionSupport.cs`

Введите следующий код в `ProductsTableAdapter.TransactionSupport.cs` файла:

[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample3.cs)]

`partial` Ключевое слово в объявлении класса указывает компилятору, что элементы, добавленные в пределах, должны быть добавлены в `ProductsTableAdapter` в класс `NorthwindTableAdapters` пространства имен. Примечание `using System.Data.SqlClient` инструкция в верхней части файла. Поскольку TableAdapter был настроен на использование поставщика SqlClient, внутренне он использует [ `SqlDataAdapter` ](https://msdn.microsoft.com/library/system.data.sqlclient.sqldataadapter.aspx) объекта для выдачи команд в базе данных. Следовательно, нам нужно использовать `SqlTransaction` класс на начало транзакции, а затем зафиксировать его или ее отката. Если вы используете хранилище данных, отличных от Microsoft SQL Server, необходимо использовать соответствующий поставщик.

Эти методы предоставляют стандартные блоки, необходимые для запуска, отката и фиксации транзакции. Они помечены `public`, позволяя использовать изнутри `ProductsTableAdapter`от другого класса в DAL и из другой уровень в архитектуре, такие как слой бизнес-ЛОГИКИ. `BeginTransaction` Открывает внутренний адаптер таблицы s `SqlConnection` (при необходимости), начинает транзакцию и присваивает его `Transaction` свойство и прикрепляет транзакцию к внутреннему `SqlDataAdapter` s `SqlCommand` объектов. `CommitTransaction` и `RollbackTransaction` вызвать `Transaction` объект s `Commit` и `Rollback` методы, соответственно, перед тем как закрыть внутренний `Connection` объекта.

## <a name="step-3-adding-methods-to-update-and-delete-data-under-the-umbrella-of-a-transaction"></a>Шаг 3. Добавление методов для обновления и удаления данных в рамках транзакции

С помощью этих методов завершения, мы повторно Готово для добавления методов для `ProductsDataTable` или BLL, выполнить ряд команд в рамках транзакции. Следующий метод использует шаблон пакетного обновления для обновления `ProductsDataTable` экземпляра с помощью транзакции. Он запускает транзакцию путем вызова `BeginTransaction` метод, а затем используется `try...catch` блок для выдачи инструкции изменения данных. Если вызов `Adapter` объект s `Update` метода приводят к возникновению исключения будут перенесены выполнения `catch` блока, где будет выполнен откат транзакции и исключение создается повторно. Помните, что `Update` метод реализует шаблон пакетного обновления путем перечисления строк, предоставленного `ProductsDataTable` и выполнение необходимого `InsertCommand`, `UpdateCommand`, и `DeleteCommand` s. Если любой из этих команд приведет к ошибке, транзакция откатывается, Отмена предыдущего изменения, внесенные во время существования транзакции s. Следует `Update` инструкции завершаются без ошибки, транзакция фиксируется в полном объеме.

[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample4.cs)]

Добавить `UpdateWithTransaction` метод `ProductsTableAdapter` класса через разделяемый класс в `ProductsTableAdapter.TransactionSupport.cs`. Кроме того, этот метод может быть добавлен к s уровня бизнес-логики `ProductsBLL` класса несколько незначительных синтаксических изменений. А именно, ключевое слово в `this.BeginTransaction()`, `this.CommitTransaction()`, и `this.RollbackTransaction()` потребуется заменить `Adapter` (Помните, что `Adapter` — это имя свойства в `ProductsBLL` типа `ProductsTableAdapter`).

`UpdateWithTransaction` Метод использует шаблон пакетного обновления, но ряд вызовов непосредственные методы DB также может использоваться в пределах области транзакции, как показано в следующем метод. `DeleteProductsWithTransaction` Метод принимает в качестве входных данных `List<T>` типа `int`, которые являются `ProductID` удаляемых. Запускает транзакцию путем вызова, метод `BeginTransaction` и затем в `try` block, выполняет итерацию предоставленного списка вызова непосредственного шаблона DB `Delete` метод для каждого `ProductID` значение. Если какие-либо вызовы `Delete` завершается ошибкой, управление передается `catch` блока, где откат транзакции и исключение создается повторно. Если во всех вызовах `Delete` выполниться успешно, а затем транзакция фиксируется. Добавьте следующий метод для `ProductsBLL` класса.

[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample5.cs)]

## <a name="applying-transactions-across-multiple-tableadapters"></a>Применение транзакций через несколько адаптеров таблиц

Код, связанные с транзакциями, рассмотренный позволяет несколько инструкций на `ProductsTableAdapter` следует рассматривать как атомарную операцию. Но что делать, если несколько изменений в разных таблицах базы данных должны выполняться атомарным образом? Например при удалении категории, мы может сначала необходимо переназначить его текущие продукты, для некоторых других категорий. Эти два шага, переназначение продукты и удаление категории должен быть выполнен в виде атомарной операции. Но `ProductsTableAdapter` включает в себя только методы изменения `Products` таблицы и `CategoriesTableAdapter` включает в себя только методы изменения `Categories` таблицы. Так как транзакция может охватывать обоих адаптеров таблиц

Один из вариантов — Добавление метода для `CategoriesTableAdapter` с именем `DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)` и у этого метода вызовите хранимую процедуру, которая связывает продукты и удаляет категорию в пределах транзакции, определенной в хранимой процедуре. Мы рассмотрим как начало, фиксация и откат транзакции в хранимых процедурах в дальнейших учебных курсах.

Другой вариант — Создание вспомогательного класса в слое DAL, содержащий `DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)` метод. Этот метод создаст экземпляр `CategoriesTableAdapter` и `ProductsTableAdapter` и затем задать два TableAdapters `Connection` свойства на тот же `SqlConnection` экземпляра. AT этой точки, либо один из двух адаптеров таблиц TableAdapter будет инициировать транзакцию с помощью вызова `BeginTransaction`. Методы адаптеров таблиц для переназначения продукты и удаление категории будет вызываться в `try...catch` блок с транзакция фиксируется или откатывается назад при необходимости.

## <a name="step-4-adding-theupdatewithtransactionmethod-to-the-business-logic-layer"></a>Шаг 4. Добавление`UpdateWithTransaction`метод уровня бизнес-логики

На шаге 3 мы добавили `UpdateWithTransaction` метод `ProductsTableAdapter` в слое DAL. Мы следует добавить соответствующий метод BLL. Хотя уровень представления данных может вызвать напрямую к DAL для вызова `UpdateWithTransaction` метод, strived этих учебников для определения многоуровневой архитектуры, которая изолирует DAL от слоя представления. Таким образом он behooves нам по-прежнему этот подход.

Откройте `ProductsBLL` и добавьте метод с именем `UpdateWithTransaction` который просто вызывает вниз, чтобы соответствующий метод DAL. Теперь должно существовать два новых метода в `ProductsBLL`: `UpdateWithTransaction`, который вы только что добавили, и `DeleteProductsWithTransaction`, который был добавлен на шаге 3.

[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample6.cs)]

> [!NOTE]
> Эти методы не включают `DataObjectMethodAttribute` атрибут, назначенный большинство методов в `ProductsBLL` класса потому, что мы будем вызывает эти методы непосредственно из кода классов страницы ASP.NET. Помните, что `DataObjectMethodAttribute` используется для пометки, какие методы должны отображаться в ObjectDataSource s Настройка источника данных, мастера и какие вкладке (SELECT, UPDATE, INSERT или DELETE). Так как GridView не имеет встроенной возможности пакетной службы, изменение или удаление, необходимо программным способом вызова этих методов вместо того, чтобы использовать без кода декларативный подход.

## <a name="step-5-atomically-updating-database-data-from-the-presentation-layer"></a>Шаг 5. Атомарным образом обновление баз данных от слоя представления

Чтобы проиллюстрировать влияние транзакции при обновлении пакета записей, позволяют s создания пользовательского интерфейса, представлены все продукты в элементе управления GridView, а также веб-сайт кнопки элемента управления, который, при нажатии переназначает продукты `CategoryID` значения. В частности, развивается переназначение категории, чтобы несколько первых продуктов назначаются является допустимым `CategoryID` несуществующий присвоено значение, а другие — намеренно `CategoryID` значение. Если мы попытаемся обновить базу данных с продуктом, `CategoryID` не соответствует существующей категории s `CategoryID`, произойдет нарушение ограничения внешнего ключа, и возникает исключение. Что мы увидим в этом примере, что, при использовании транзакций исключением, вызванным из нарушение ограничения внешнего ключа приведет к предыдущей допустимым `CategoryID` изменения к откату. Без использования транзакции, однако останется изменения начальной категорий.

Сначала откройте `Transactions.aspx` странице в `BatchData` папки и перетащите элемент управления GridView с панели инструментов в конструктор. Задайте его `ID` для `Products` и его смарт-теге, привязать его к элементу управления ObjectDataSource с именем `ProductsDataSource`. Настройте элемент ObjectDataSource для извлечения данных из `ProductsBLL` класс s `GetProducts` метод. Это GridView только для чтения, поэтому устанавливается раскрывающиеся списки в UPDATE, INSERT и удаление вкладок (нет) и нажмите кнопку Готово.

[![Рис. 5. Настройка ObjectDataSource на использование метода GetProducts класса ProductsBLL s](wrapping-database-modifications-within-a-transaction-cs/_static/image5.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image3.png)

**Рис. 5**: Рис. 5. Настройка ObjectDataSource для использования `ProductsBLL` класс s `GetProducts` метод ([Просмотр полноразмерного изображения](wrapping-database-modifications-within-a-transaction-cs/_static/image4.png))

[![Установите раскрывающиеся списки в UPDATE, INSERT и удаление вкладок (нет)](wrapping-database-modifications-within-a-transaction-cs/_static/image6.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image5.png)

**Рис. 6**: Задайте раскрывающиеся списки в UPDATE, INSERT и удаление вкладок (нет) ([Просмотр полноразмерного изображения](wrapping-database-modifications-within-a-transaction-cs/_static/image6.png))

После завершения работы мастера настройки источников данных Visual Studio создаст поля BoundFields и CheckBoxField для полей данных продукта. Удалить все эти поля, за исключением `ProductID`, `ProductName`, `CategoryID`, и `CategoryName` и переименуйте `ProductName` и `CategoryName` поля BoundField, кроме `HeaderText` свойства Product и Category, соответственно. В смарт-теге флажок Enable Paging. После внесения этих изменений, GridView и ObjectDataSource s декларативная разметка должна выглядеть следующим образом:

[!code-aspx[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample7.aspx)]

Добавьте три элемента управления кнопки Web над элементом управления GridView. Значение первой кнопки s свойство Text для обновления сетки, второй s, чтобы изменить категории (с помощью ТРАНЗАКЦИЙ) и третьим s, чтобы изменить категории (без ТРАНЗАКЦИИ).

[!code-aspx[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample8.aspx)]

На этом этапе конструктор в Visual Studio должен выглядеть снимок экрана, показанный на рис. 7.

[![Страница содержит GridView и три кнопки веб-элементов управления](wrapping-database-modifications-within-a-transaction-cs/_static/image7.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image7.png)

**Рис. 7**: Страница содержит GridView и три кнопки веб-элементов управления ([Просмотр полноразмерного изображения](wrapping-database-modifications-within-a-transaction-cs/_static/image8.png))

Создание обработчиков событий для каждого из трех кнопки s `Click` события и используйте следующий код:

[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample9.cs)]

Обновление кнопку s `Click` обработчик события просто выполняет повторную привязку данных к GridView, вызвав `Products` GridView s `DataBind` метод.

Второй обработчик событий переназначает продукты `CategoryID` s и использует новый метод транзакции из BLL производительности базы данных обновляет в рамках транзакции. Обратите внимание, что каждый продукт s `CategoryID` произвольно присваивается то же значение, что его `ProductID`. Это подойдет для первого несколько продуктов, так как эти продукты имеют `ProductID` значения, которые происходят для сопоставления с допустимым `CategoryID` s. Но раз `ProductID` начало s, слишком большим, такое случайными пересечение `ProductID` s и `CategoryID` s больше не применяется.

Третий `Click` обработчик событий обновляет продукты `CategoryID` s таким же образом, но отправляет обновление базы данных с помощью `ProductsTableAdapter` по умолчанию s `Update` метод. Это `Update` метод не переносится ряда команд в рамках транзакции, поэтому эти изменения будут сделаны перед первой ошибки Нарушение обнаружено ограничение внешнего ключа будет сохраняться.

Чтобы продемонстрировать это, посетите эту страницу через обозреватель. Изначально вы увидите на первой странице данных, как показано на рис. 8. Затем щелкните кнопку Изменить категории (с помощью ТРАНЗАКЦИЙ). Это вызывает обратную передачу и пытаться обновить все продукты `CategoryID` значений, но приведет к нарушению ограничения внешнего ключа (см. рис. 9).

[![Товары показываются в GridView с возможностью разбивки на страницы](wrapping-database-modifications-within-a-transaction-cs/_static/image8.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image9.png)

**Рис. 8**: Товары показываются в GridView с возможностью разбивки на страницы ([Просмотр полноразмерного изображения](wrapping-database-modifications-within-a-transaction-cs/_static/image10.png))

[![Переназначение категорий приводит к нарушению ограничения внешнего ключа](wrapping-database-modifications-within-a-transaction-cs/_static/image9.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image11.png)

**Рис. 9**: Переназначение категорий приводит нарушение ограничения внешнего ключа ([Просмотр полноразмерного изображения](wrapping-database-modifications-within-a-transaction-cs/_static/image12.png))

Теперь нажмите кнопку "Назад" в браузере s и затем нажмите кнопку Обновить сетку. При обновлении данных точно такие же выходные данные должны увидеть, как показано на рис. 8. То есть, даже если некоторые из продуктов `CategoryID` s было изменено на допустимые значения и обновлен в базе данных, они откатывались обратно в том случае, когда произошло нарушение ограничения внешнего ключа.

Теперь попробуйте нажать кнопку Изменить категории (без ТРАНЗАКЦИИ). Это приведет к та же ошибка нарушения ограничения внешнего ключа (см. рис. 9), но в этот раз те продукты, `CategoryID` значения были изменены для юридических значение не будет выполнен откат. Нажмите кнопку "Назад" в браузере s и нажмите кнопку Обновить сетку. Как показано на рис. 10, `CategoryID` назначили s первые восемь продуктов. Например, на рис. 8 Chang было `CategoryID` 1, но в рис 10 ИТ s была переназначена на 2.

[![Некоторые значения CategoryID продуктов не обновлены во время другие были](wrapping-database-modifications-within-a-transaction-cs/_static/image10.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image13.png)

**Рис. 10**: Некоторые продукты `CategoryID` значения были обновлены во время другие были не ([Просмотр полноразмерного изображения](wrapping-database-modifications-within-a-transaction-cs/_static/image14.png))

## <a name="summary"></a>Сводка

По умолчанию методы TableAdapter s не заключайте инструкции выполненного базы данных в пределах транзакции, но немного поработав мы добавим методы, которые создают, commit и rollback транзакции. В этом руководстве мы создали три такие методы в `ProductsTableAdapter` класса: `BeginTransaction`, `CommitTransaction`, и `RollbackTransaction`. Мы узнали, как использовать эти методы вместе с `try...catch` блок, чтобы сделать атомарным ряд инструкций, изменяющих данные. В частности, мы создали `UpdateWithTransaction` метод в `ProductsTableAdapter`, который использует шаблон пакетного обновления выполнить необходимые изменения в строки, передаваемой `ProductsDataTable`. Мы также добавили `DeleteProductsWithTransaction` метод `ProductsBLL` классов в BLL, который принимает `List` из `ProductID` значения в качестве входных данных и вызывает метод шаблон непосредственные методы DB `Delete` для каждого `ProductID`. Оба метода для начала создания транзакции и последующего выполнения инструкции изменения данных в пределах `try...catch` блока. Если возникает исключение, транзакция откатывается, в противном случае он фиксируется.

Шаг 5 показано влияние транзакций пакетных обновлений и пакетов обновлений, которые не использовать транзакцию. В трех следующих руководствах мы будет основываться на фундаменте, заложенном в этом руководстве и создавать пользовательские интерфейсы для выполнения пакетной вставки, удаления и вставки.

Счастливого вам программирования!

## <a name="further-reading"></a>Дополнительные сведения

Дополнительные сведения по темам, обсуждавшимся в этом руководстве см. в следующих ресурсах:

- [Поддержание согласованности базы данных с транзакциями](http://aspnet.4guysfromrolla.com/articles/072705-1.aspx)
- [Управление транзакциями в SQL Server хранимых процедур](http://www.4guysfromrolla.com/webtech/080305-1.shtml)
- [Транзакции, стало проще: `System.Transactions`](https://blogs.msdn.com/florinlazar/archive/2004/07/23/192239.aspx)
- [Класс TransactionScope и адаптеров обработки данных](http://andyclymer.blogspot.com/2007/01/transactionscope-and-dataadapters.html)
- [Использование транзакций базы данных Oracle в .NET](http://www.oracle.com/technology/pub/articles/price_dbtrans_dotnet.html)

## <a name="about-the-author"></a>Об авторе

[Скотт Митчелл](http://www.4guysfromrolla.com/ScottMitchell.shtml), автор семи книг по ASP/ASP.NET и основатель веб- [4GuysFromRolla.com](http://www.4guysfromrolla.com), работает с веб-технологиями Microsoft с 1998 года. Скотт — независимый консультант, преподаватель и автор. Его последняя книга — [ *Sams Teach ASP.NET 2.0 in 24 часа*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco). Ним можно связаться по адресу [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com) или через его блог, который можно найти в [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).

## <a name="special-thanks-to"></a>Особая благодарность

В этой серии руководств пособий рецензировалась многими компетентными редакторами. Дейв Gardner (Hilton giesenow) и Терезой Мерфи, стали Лиз Шалок в этом руководстве. Хотите поработать с моих последующих статей для MSDN? Если Да, напишите мне [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Вперед](batch-updating-cs.md)
