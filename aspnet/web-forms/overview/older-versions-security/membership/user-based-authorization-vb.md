---
uid: web-forms/overview/older-versions-security/membership/user-based-authorization-vb
title: Авторизация на основе пользователей (VB) | Документация Майкрософт
author: rick-anderson
description: В этом учебнике мы рассмотрим ограничение доступа к страницам и ограничение функциональных возможностей на уровне страниц с помощью различных методов.
ms.author: riande
ms.date: 01/18/2008
ms.assetid: bc937e9d-5c14-4fc4-aec7-440da924dd18
msc.legacyurl: /web-forms/overview/older-versions-security/membership/user-based-authorization-vb
msc.type: authoredcontent
ms.openlocfilehash: dfac0c6fa955e59c6ea996533f2447e89ec8d468
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2019
ms.locfileid: "74587932"
---
# <a name="user-based-authorization-vb"></a>Авторизация на основе пользователей (VB)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачать код](https://download.microsoft.com/download/3/f/5/3f5a8605-c526-4b34-b3fd-a34167117633/ASPNET_Security_Tutorial_07_VB.zip) или [скачать PDF](https://download.microsoft.com/download/3/f/5/3f5a8605-c526-4b34-b3fd-a34167117633/aspnet_tutorial07_UserAuth_vb.pdf)

> В этом учебнике мы рассмотрим ограничение доступа к страницам и ограничение функциональных возможностей на уровне страниц с помощью различных методов.

## <a name="introduction"></a>Введение

Большинство веб-приложений, предлагающих учетные записи пользователей, делают это в части, чтобы предоставить определенным посетителям доступ к определенным страницам в пределах сайта. В большинстве сетевых мессажебоард сайтов, например, все пользователи — анонимные и аутентифицированные, могут просматривать записи мессажебоард, но только пользователи, прошедшие проверку подлинности, могут посетить веб-страницу, чтобы создать новую запись. И могут существовать административные страницы, доступные только определенному пользователю (или определенному набору пользователей). Более того, функции на уровне страницы могут различаться для каждого пользователя. При просмотре списка записей прошедшие проверку пользователи показывают интерфейс для оценки каждой записи, в то время как этот интерфейс недоступен для анонимных посетителей.

ASP.NET позволяет легко определять правила авторизации на основе пользователей. С небольшой разметкой в `Web.config`можно заблокировать определенные веб-страницы или целые каталоги, чтобы они были доступны только определенному подмножеству пользователей. Функции на уровне страницы можно включать или отключать в зависимости от текущего пользователя с помощью программных и декларативных средств.

В этом учебнике мы рассмотрим ограничение доступа к страницам и ограничение функциональных возможностей на уровне страниц с помощью различных методов. Приступим к работе!

## <a name="a-look-at-the-url-authorization-workflow"></a>Обзор рабочего процесса авторизации URL-адреса

Как обсуждалось в [*обзоре учебника по проверке подлинности*](../introduction/an-overview-of-forms-authentication-vb.md) с помощью форм, когда среда выполнения ASP.NET обрабатывает запрос ресурса ASP.NET, запрос вызывает ряд событий в течение жизненного цикла. *HTTP-модули* — это управляемые классы, код которых выполняется в ответ на определенное событие в жизненном цикле запроса. ASP.NET поставляется с несколькими HTTP-модулями, которые выполняют базовые задачи в фоновом режиме.

Один из таких модулей HTTP — [`FormsAuthenticationModule`](https://msdn.microsoft.com/library/system.web.security.formsauthenticationmodule.aspx). Как обсуждалось в предыдущих руководствах, основной функцией `FormsAuthenticationModule` является определение удостоверения текущего запроса. Для этого необходимо проверить билет проверки подлинности форм, который находится в файле cookie или внедрен в URL-адрес. Эта идентификация происходит во время [`AuthenticateRequest` события](https://msdn.microsoft.com/library/system.web.httpapplication.authenticaterequest.aspx).

Другим важным модулем HTTP является [`UrlAuthorizationModule`](https://msdn.microsoft.com/library/system.web.security.urlauthorizationmodule.aspx), который создается в ответ на [событие`AuthorizeRequest`](https://msdn.microsoft.com/library/system.web.httpapplication.authorizerequest.aspx) (которое происходит после события `AuthenticateRequest`). `UrlAuthorizationModule` проверяет разметку конфигурации в `Web.config`, чтобы определить, есть ли у текущего удостоверения полномочия на посещение указанной страницы. Этот процесс называется *авторизацией URL-адреса*.

Мы рассмотрим синтаксис правил авторизации URL-адреса на шаге 1, но сначала рассмотрим, что `UrlAuthorizationModule` в зависимости от того, авторизован ли запрос. Если `UrlAuthorizationModule` определяет, что запрос является полномочным, он не выполняет никаких действий и запрос просматривается по своему жизненному циклу. Однако если запрос *не* авторизован, то `UrlAuthorizationModule` прерывает жизненный цикл и предписывает объекту `Response` вернуть [неавторизованное состояние HTTP 401](http://www.checkupdown.com/status/E401.html) . При использовании проверки подлинности с помощью форм это состояние HTTP 401 никогда не возвращается клиенту, так как если `FormsAuthenticationModule` обнаруживает состояние HTTP 401, изменяет его на [Перенаправление http 302](http://www.checkupdown.com/status/E302.html) на страницу входа.

На рис. 1 показан рабочий процесс конвейера ASP.NET, `FormsAuthenticationModule`и `UrlAuthorizationModule` при получении неавторизованного запроса. В частности, на рис. 1 показан запрос анонимного посетителя для `ProtectedPage.aspx`, то есть страницы, которая запрещает доступ анонимным пользователям. Поскольку посетитель является анонимным, `UrlAuthorizationModule` прерывает запрос и возвращает сообщение о неавторизованном состоянии HTTP 401. Затем `FormsAuthenticationModule` преобразует состояние 401 в перенаправление 302 на страницу входа. После проверки подлинности пользователя с помощью страницы входа он перенаправляется на `ProtectedPage.aspx`. На этот раз `FormsAuthenticationModule` идентифицирует пользователя в соответствии с его билетом проверки подлинности. Теперь, когда посетитель прошел проверку подлинности, `UrlAuthorizationModule` разрешает доступ к странице.

[![рабочего процесса проверки подлинности с помощью форм и URL-адреса](user-based-authorization-vb/_static/image2.png)](user-based-authorization-vb/_static/image1.png)

**Рис. 1**. Рабочий процесс проверки подлинности с помощью форм и URL-адресов ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image3.png))

На рис. 1 показано взаимодействие, возникающее, когда анонимный посетитель пытается получить доступ к ресурсу, который недоступен для анонимных пользователей. В этом случае анонимный посетитель перенаправляется на страницу входа с помощью страницы, которую пытался посетить, указанную в строке запроса. После успешного входа пользователь будет автоматически перенаправлен к ресурсу, который изначально пытался просмотреть.

Если несанкционированный запрос выполняется анонимным пользователем, этот рабочий процесс является простым и легко понять, что произошло и почему. Но помните, что `FormsAuthenticationModule` перенаправит *всех* неавторизованных пользователей на страницу входа, даже если запрос выполнен пользователем, прошедшим проверку подлинности. Это может привести к путанице в работе пользователя, если прошедший проверку подлинности пользователь пытается посетить страницу, для которой она не имеет полномочий.

Представьте, что на нашем веб-сайте настроены правила авторизации URL-адресов, так что страница ASP.NET `OnlyTito.aspx` была акцессибли только в Тито. Теперь представьте, что Сэм посещает сайт, входит в систему, а затем пытается посетить `OnlyTito.aspx`. `UrlAuthorizationModule` остановит жизненный цикл запроса и возвратит сообщение о неавторизованном состоянии HTTP 401, которое `FormsAuthenticationModule` определит, а затем перенаправит SAM на страницу входа. Хотя Сэм уже вошел в систему, он может спросить, почему она отправлена обратно на страницу входа. Она может быть причиной того, что учетные данные для входа были потеряны каким бы то ни было. Если SAM перевводит свои учетные данные со страницы входа, она будет зарегистрирована (опять же) и перенаправлена на `OnlyTito.aspx`. `UrlAuthorizationModule` обнаружит, что Сэм не сможет посетить эту страницу, и она будет возвращена на страницу входа.

На рис. 2 показан этот непонятный рабочий процесс.

[![рабочий процесс по умолчанию может привести к путанице в цикле](user-based-authorization-vb/_static/image5.png)](user-based-authorization-vb/_static/image4.png)

**Рис. 2**. Рабочий процесс по умолчанию может привести к путанице в цикле ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image6.png))

Рабочий процесс, проиллюстрированный на рис. 2, может быстро бефуддле даже самых самых компьютерных посетителей. Мы рассмотрим способы предотвращения этого цикла в шаге 2.

> [!NOTE]
> ASP.NET использует два механизма для определения того, может ли текущий пользователь получить доступ к определенной веб-странице: авторизация по URL-адресу и авторизация файлов. Авторизация файлов реализуется [`FileAuthorizationModule`](https://msdn.microsoft.com/library/system.web.security.fileauthorizationmodule.aspx), который определяет полномочия путем консультации запрошенных списков ACL файлов. Авторизация файлов чаще всего используется с проверкой подлинности Windows, так как списки управления доступом (ACL) применяются к учетным записям Windows. При использовании проверки подлинности с помощью форм все запросы на уровне операционной системы и файловой системы выполняются одной и той же учетной записью Windows независимо от пользователя, который посещает сайт. Поскольку эта серия руководств посвящена проверке подлинности на формах, мы не будем обсуждать авторизацию файлов.

### <a name="the-scope-of-url-authorization"></a>Область авторизации URL-адресов

`UrlAuthorizationModule` является управляемым кодом, который является частью среды выполнения ASP.NET. До версии 7 веб-сервера Microsoft [службы IIS (IIS)](https://www.iis.net/) существует отдельный барьер между КОНВЕЙЕРОМ HTTP IIS и конвейером среды выполнения ASP.NET. Вкратце, в IIS 6 и более ранних версиях, ASP. `UrlAuthorizationModule` NET выполняется только при делегировании запроса из IIS в среду выполнения ASP.NET. По умолчанию IIS обрабатывает статическое содержимое сами по себе, например HTML-страницы и CSS, JavaScript и файлы изображений, и передает запросы в среду выполнения ASP.NET только при запросе страницы с расширением `.aspx`, `.asmx`или `.ashx`.

Однако IIS 7 позволяет выполнять интегрированные конвейеры IIS и ASP.NET. С помощью нескольких параметров конфигурации можно настроить IIS 7 для вызова `UrlAuthorizationModule` для *всех* запросов. Это означает, что правила авторизации URL-адресов могут быть определены для файлов любого типа. Кроме того, IIS 7 включает собственный механизм авторизации URL-адресов. Дополнительные сведения об интеграции ASP.NET и собственной функции авторизации URL-адресов в IIS 7 см. в разделе [Общие сведения об авторизации URL-адресов IIS7](https://www.iis.net/articles/view.aspx/IIS7/Managing-IIS7/Configuring-Security/URL-Authorization/Understanding-IIS7-URL-Authorization). Чтобы получить более подробные сведения об интеграции ASP.NET и IIS 7, изучите копию книги Шахрам Кхосрави, профессиональный набор средств *IIS 7 и ASP.NET для интегрированного программирования* (ISBN: 978-0470152539).

В двух словах, в версиях до IIS 7 правила авторизации URL-адресов применяются только к ресурсам, обрабатываемым средой выполнения ASP.NET. Но в IIS 7 можно использовать собственную функцию авторизации URL-адресов IIS или интегрировать технологию ASP. `UrlAuthorizationModule` NET в конвейер HTTP IIS, тем самым расширяя эту функциональность на все запросы.

> [!NOTE]
> Есть несколько незначительных, но важных различий в том, как ASP. Функции авторизации URL-адресов `UrlAuthorizationModule` и IIS 7 обрабатывают правила авторизации. В этом руководстве не рассматриваются функции авторизации URL-адресов IIS 7, а также различия в анализе правил авторизации по сравнению с `UrlAuthorizationModule`. Дополнительные сведения об этих разделах см. в документации по IIS 7 на сайте MSDN или в [www.IIS.NET](https://www.iis.net/).

## <a name="step-1-defining-url-authorization-rules-inwebconfig"></a>Шаг 1. Определение правил авторизации URL-адресов в`Web.config`

`UrlAuthorizationModule` определяет, следует ли предоставлять или запрещать доступ к запрошенному ресурсу для определенного удостоверения на основе правил авторизации URL-адреса, определенных в конфигурации приложения. Правила авторизации написаны в [элементе`<authorization>`](https://msdn.microsoft.com/library/8d82143t.aspx) в форме `<allow>` и `<deny>` дочерних элементов. Каждый дочерний элемент `<allow>` и `<deny>` может указывать:

- Определенный пользователь
- Разделенный запятыми список пользователей
- Все анонимные пользователи, обозначенные вопросительным знаком (?)
- Все пользователи, обозначенные звездочкой (\*)

В следующей разметке показано, как использовать правила авторизации URL-адресов, чтобы разрешить пользователям Тито и Скотт и запретить все остальные:

[!code-xml[Main](user-based-authorization-vb/samples/sample1.xml)]

Элемент `<allow>` определяет, какие пользователи разрешены — Тито и Скотт, тогда как элемент `<deny>` указывает, что *все* пользователи запрещены.

> [!NOTE]
> Элементы `<allow>` и `<deny>` также могут задавать правила авторизации для ролей. В следующем учебном курсе рассматривается авторизация на основе ролей.

Следующий параметр предоставляет доступ любому пользователю, кроме SAM (включая анонимных посетителей):

[!code-xml[Main](user-based-authorization-vb/samples/sample2.xml)]

Чтобы разрешить только пользователей, прошедших проверку подлинности, используйте следующую конфигурацию, которая запрещает доступ всем анонимным пользователям:

[!code-xml[Main](user-based-authorization-vb/samples/sample3.xml)]

Правила авторизации определяются в элементе `<system.web>` в `Web.config` и применяются ко всем ASP.NET ресурсам в веб-приложении. Зачастую приложение имеет разные правила авторизации для различных разделов. Например, на сайте электронной коммерции все посетители могут заменять продукты, просматривать Обзор продукта, искать в каталоге и т. д. Однако только пользователи, прошедшие проверку подлинности, могут получить доступ к извлечению или страницам для управления журналом доставки. Кроме того, могут существовать части сайта, доступные только по выбранным пользователям, например администраторам сайта.

ASP.NET позволяет легко определить различные правила авторизации для различных файлов и папок на сайте. Правила авторизации, указанные в файле `Web.config` корневой папки, применяются ко всем ресурсам ASP.NET на сайте. Однако эти параметры авторизации по умолчанию можно переопределить для конкретной папки, добавив `Web.config` с `<authorization>`ным разделом.

Давайте попробуем обновить наш веб-сайт, чтобы только пользователи, прошедшие проверку подлинности, могли посетить страницы ASP.NET в папке `Membership`. Для этого необходимо добавить файл `Web.config` в папку `Membership` и задать для его параметров авторизации значение запретить анонимных пользователей. Щелкните правой кнопкой мыши папку `Membership` в обозреватель решений, выберите меню Добавить новый элемент в контекстном меню и добавьте новый файл веб-конфигурации с именем `Web.config`.

[![добавить файл Web. config в папку членства](user-based-authorization-vb/_static/image8.png)](user-based-authorization-vb/_static/image7.png)

**Рис. 3**. добавление файла `Web.config` в папку `Membership` ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image9.png))

На этом этапе проект должен содержать два `Web.config` файлов: один в корневом каталоге и один в папке `Membership`.

[![ваше приложение теперь должно содержать два файла Web. config](user-based-authorization-vb/_static/image11.png)](user-based-authorization-vb/_static/image10.png)

**Рис. 4**. Теперь приложение должно содержать два `Web.config` файлов ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image12.png))

Обновите файл конфигурации в папке `Membership`, чтобы запретить доступ анонимным пользователям.

[!code-xml[Main](user-based-authorization-vb/samples/sample4.xml)]

Вот и все!

Чтобы протестировать это изменение, перейдите на домашнюю страницу в браузере и убедитесь, что вы вышли из нее. Поскольку поведение приложения ASP.NET по умолчанию — разрешить всем посетителям, а так как мы не сделали изменений авторизации в файле `Web.config` корневого каталога, мы можем посетить файлы в корневом каталоге как анонимного посетителя.

Щелкните ссылку Создание учетных записей пользователей, найденную в левом столбце. Вы перейдете к `~/Membership/CreatingUserAccounts.aspx`. Так как файл `Web.config` в папке `Membership` определяет правила авторизации для запрета анонимного доступа, `UrlAuthorizationModule` прерывает выполнение запроса и возвращает сообщение о неавторизованном состоянии HTTP 401. `FormsAuthenticationModule` изменяет это значение на состояние перенаправления 302, отправляя нам страницу входа. Обратите внимание, что страница, к которой мы пытались получить доступ (`CreatingUserAccounts.aspx`), передается на страницу входа с помощью параметра `ReturnUrl` QueryString.

[![, так как правила авторизации URL-адреса запрещают анонимный доступ, мы будем перенаправлены на страницу входа.](user-based-authorization-vb/_static/image14.png)](user-based-authorization-vb/_static/image13.png)

**Рис. 5**. Поскольку правила авторизации URL-адреса запрещают анонимный доступ, мы будем перенаправлены на страницу входа ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image15.png)).

После успешного входа в систему мы перенаправлены на страницу `CreatingUserAccounts.aspx`. На этот раз `UrlAuthorizationModule` разрешает доступ к странице, так как мы больше не анонимны.

### <a name="applying-url-authorization-rules-to-a-specific-location"></a>Применение правил авторизации URL-адресов к определенному расположению

Параметры авторизации, определенные в разделе `<system.web>` `Web.config`, применяются ко всем ASP.NET ресурсам в этом каталоге и его подкаталогах (до тех пор, пока другое значение не будет переопределено другим файлом `Web.config`). Однако в некоторых случаях может потребоваться, чтобы все ресурсы ASP.NET в данном каталоге имели определенную конфигурацию авторизации, за исключением одной или двух конкретных страниц. Это можно сделать, добавив элемент `<location>` в `Web.config`, указав его в файле, правила авторизации которого отличаются и определив его уникальные правила авторизации.

Чтобы проиллюстрировать использование элемента `<location>` для переопределения параметров конфигурации для конкретного ресурса, давайте настроим параметры авторизации таким образом, чтобы только Тито мог посещать `CreatingUserAccounts.aspx`. Для этого добавьте элемент `<location>` в файл `Web.config` папки `Membership` и обновите его разметку таким образом, чтобы он выглядел следующим образом:

[!code-xml[Main](user-based-authorization-vb/samples/sample5.xml)]

Элемент `<authorization>` в `<system.web>` определяет правила авторизации URL-адресов по умолчанию для ресурсов ASP.NET в папке `Membership` и ее вложенных папках. Элемент `<location>` позволяет переопределять эти правила для определенного ресурса. В приведенной выше разметке элемент `<location>` ссылается на `CreatingUserAccounts.aspx` страницу и указывает правила авторизации, такие как разрешить Тито, но запретить всем остальным.

Чтобы проверить это изменение авторизации, откройте веб-сайт как анонимного пользователя. При попытке посетить любую страницу в папке `Membership`, например `UserBasedAuthorization.aspx`, `UrlAuthorizationModule` отклонит запрос, и вы будете перенаправлены на страницу входа. После входа в систему как, скажем, Скотт, вы можете посетить любую страницу в папке `Membership`, *за исключением* `CreatingUserAccounts.aspx`. Попытка посетить `CreatingUserAccounts.aspx` войти в систему как угодно, но Тито приведет к несанкционированной попытке доступа, перенаправить вас на страницу входа.

> [!NOTE]
> Элемент `<location>` должен находиться за пределами элемента `<system.web>` конфигурации. Для каждого ресурса, параметры авторизации которого необходимо переопределить, необходимо использовать отдельный элемент `<location>`.

### <a name="a-look-at-how-theurlauthorizationmoduleuses-the-authorization-rules-to-grant-or-deny-access"></a>Рассмотрим, как`UrlAuthorizationModule`использует правила авторизации для предоставления или запрета доступа

`UrlAuthorizationModule` определяет, следует ли авторизовать определенное удостоверение для определенного URL-адреса, анализируя правила авторизации URL-адресов по одному, начиная с первого и выполнив его работу. Как только соответствие будет найдено, пользователю будет предоставлен или запрещен доступ, в зависимости от того, найдена ли совпадение в элементе `<allow>` или `<deny>`. <strong>Если совпадений не найдено, пользователю предоставляется доступ.</strong> Следовательно, если требуется ограничить доступ, необходимо использовать элемент `<deny>` в качестве последнего элемента в конфигурации авторизации URL-адреса. <strong>Если опустить</strong> элемент<strong>`<deny>`</strong> <strong>, доступ будет предоставлен всем пользователям.</strong>

Чтобы лучше понять процесс, используемый `UrlAuthorizationModule` для определения центра сертификации, рассмотрим пример правил авторизации URL-адресов, рассмотренных ранее на этом шаге. Первое правило — это элемент `<allow>`, который обеспечивает доступ к Тито и Скотт. Вторым правилом является элемент `<deny>`, который запрещает доступ всем. При посещении анонимного пользователя `UrlAuthorizationModule` начинается с запроса, анонимно или Скотт или Тито? Ответ, очевидно, равен «нет», поэтому он переходит к второму правилу. Является анонимным в наборе всех? Так как ответ имеет значение Да, действует правило `<deny>`, и посетитель перенаправляется на страницу входа. Аналогично, если Цзисунь посещается, `UrlAuthorizationModule` начинается с запроса, Цзисунь Скотт или Тито? Так как это не так, `UrlAuthorizationModule` переходит к второму вопросу, Цзисунь в наборе всех? Она имеет права, поэтому она также запрещает доступ. Наконец, если Тито посещаете, первый вопрос, выданный `UrlAuthorizationModule`, является ответом голосами подтверждающими, поэтому Тито получает доступ.

Поскольку `UrlAuthorizationModule` обрабатывает правила авторизации сверху вниз, прекращая при любом совпадении, важно иметь более конкретные правила перед менее конкретными. Это значит, что для определения правил авторизации, запрещающих Цзисунь и анонимных пользователей, но разрешающих всех других пользователей, прошедших проверку подлинности, следует начинать с наиболее конкретного правила, которое влияет на Цзисунь, а затем перейти к менее конкретным правилам, которые позволяют использовать все остальные Пользователи, прошедшие проверку подлинности, но отклоняющие анонимных пользователей. Следующие правила авторизации URL-адресов реализуют эту политику, сначала запрещая Цзисунь, а затем запрещает анонимных пользователей. Любому пользователю, прошедшему проверку подлинности, отличному от Цзисунь, будет предоставлен доступ, поскольку ни одна из этих `<deny>` инструкций не будет совпадать.

[!code-xml[Main](user-based-authorization-vb/samples/sample6.xml)]

## <a name="step-2-fixing-the-workflow-for-unauthorized-authenticated-users"></a>Шаг 2. Исправление рабочего процесса для неавторизованных пользователей, прошедших проверку подлинности

Как мы обсуждали ранее в этом учебнике, в разделе о рабочем процессе авторизации URL-адреса в любое время, когда происходит несанкционированный запрос, `UrlAuthorizationModule` прерывает запрос и возвращает ошибку HTTP 401 с несанкционированным состоянием. Это состояние 401 изменяется `FormsAuthenticationModule` в состояние перенаправления 302, которое отправляет пользователя на страницу входа. Этот рабочий процесс выполняется при любом неавторизованном запросе, даже если пользователь прошел проверку подлинности.

Возврат пользователя, прошедшего проверку подлинности на страницу входа, скорее всего, приведет к их путанице, так как они уже входили в систему. С небольшой скоростью работы мы можем улучшить этот рабочий процесс путем перенаправления пользователей, прошедших проверку подлинности, которые делают несанкционированные запросы к странице, объясняющей, что они попытались получить доступ к ограниченной странице.

Начните с создания новой страницы ASP.NET в корневой папке веб-приложения с именем `UnauthorizedAccess.aspx`; не забудьте связать эту страницу с главной страницей `Site.master`. После создания этой страницы удалите элемент управления содержимым, который ссылается на `LoginContent` ContentPlaceHolder, чтобы отображалось содержимое по умолчанию главной страницы. Затем добавьте сообщение, объясняющее ситуацию, а именно, чтобы пользователь пытался получить доступ к защищенному ресурсу. После добавления такого сообщения декларативная разметка страницы `UnauthorizedAccess.aspx` должна выглядеть следующим образом:

[!code-aspx[Main](user-based-authorization-vb/samples/sample7.aspx)]

Теперь необходимо изменить рабочий процесс таким образом, чтобы несанкционированный запрос выполнялся прошедшим проверку подлинности пользователем, который отправляется на `UnauthorizedAccess.aspx` страницу, а не на страницу входа. Логика, которая перенаправляет неавторизованные запросы на страницу входа, скрыта в частном методе класса `FormsAuthenticationModule`, поэтому мы не можем настроить это поведение. Однако мы можем добавить собственную логику на страницу входа, которая перенаправляет пользователя в `UnauthorizedAccess.aspx`при необходимости.

Когда `FormsAuthenticationModule` перенаправляет неавторизованного посетителя на страницу входа, он добавляет запрошенный, неавторизованный URL-адрес к строке запроса с именем `ReturnUrl`. Например, если неавторизованный пользователь попытался посетить `OnlyTito.aspx`, `FormsAuthenticationModule` перенаправит их в `Login.aspx?ReturnUrl=OnlyTito.aspx`. Таким образом, если страница входа достигла пользователя, прошедшего проверку подлинности, с помощью строки запроса, включающей параметр `ReturnUrl`, то мы понимаем, что этот пользователь, не прошедший проверку подлинности, только что пытался посетить страницу, которой он не авторизован для просмотра. В этом случае нам нужно перенаправить его на `UnauthorizedAccess.aspx`.

Для этого добавьте следующий код в обработчик событий `Page_Load` на странице входа:

[!code-vb[Main](user-based-authorization-vb/samples/sample8.vb)]

Приведенный выше код перенаправляет подлинность неавторизованных пользователей на страницу `UnauthorizedAccess.aspx`. Чтобы увидеть эту логику в действии, перейдите на сайт в качестве анонимного посетителя и щелкните ссылку Создание учетных записей пользователей в левом столбце. Откроется страница `~/Membership/CreatingUserAccounts.aspx`, на шаге 1 мы настроили доступ только к Тито. Так как анонимные пользователи запрещены, `FormsAuthenticationModule` перенаправляет нас назад на страницу входа.

На этом этапе выполняется анонимность, поэтому `Request.IsAuthenticated` возвращает `False` и мы не перенаправлены на `UnauthorizedAccess.aspx`. Вместо этого отображается страница входа. Войдите в систему как пользователь, отличный от Тито, например Брюс. После ввода соответствующих учетных данных страница входа в систему перенаправит нас назад в `~/Membership/CreatingUserAccounts.aspx`. Тем не менее, поскольку эта страница доступна только для Тито, мы не уполномочены просматривать ее и сразу же возвращаются на страницу входа. Однако на этот раз `Request.IsAuthenticated` возвращает `True` (а параметр `ReturnUrl` QueryString существует), поэтому мы перенаправлены на страницу `UnauthorizedAccess.aspx`.

[![с проверкой подлинности неавторизованные пользователи перенаправляются в Унаусоризедакцесс. aspx](user-based-authorization-vb/_static/image17.png)](user-based-authorization-vb/_static/image16.png)

**Рис. 6**. Проверка подлинности неавторизованных пользователей перенаправляется на `UnauthorizedAccess.aspx` ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image18.png))

Этот настраиваемый рабочий процесс обеспечивает более разумное и простое взаимодействие с пользователем за счет короткого цикла, показанного на рис. 2.

## <a name="step-3-limiting-functionality-based-on-the-currently-logged-in-user"></a>Шаг 3. ограничение функциональных возможностей на основе текущего пользователя

Авторизация URL-адресов упрощает задание правил грубой авторизации. Как было показано на шаге 1, с авторизацией URL-адресов мы можем кратко указать, какие удостоверения разрешены и какие из них запрещают просматривать определенную страницу или все страницы в папке. Однако в некоторых случаях может потребоваться разрешить всем пользователям посещать страницу, но ограничить функциональность страницы в зависимости от того, кто ее посещает.

Рассмотрим вариант веб-сайта электронной коммерции, который позволяет посетителям, прошедшим проверку подлинности, просматривать свои продукты. Когда анонимный пользователь посещает страницу продукта, он увидит только сведения о продукте, и ему не будет предоставлена возможность покинуть проверку. Однако прошедший проверку подлинности пользователь, просматривающий ту же страницу, увидит интерфейс рецензирования. Если прошедший проверку подлинности пользователь еще не проверил этот продукт, интерфейс позволит ему отправить отзыв. в противном случае они покажут их ранее отправленный отзыв. Чтобы выполнить этот сценарий дальше, на странице продукта могут отображаться дополнительные сведения и предлагаются расширенные функции для пользователей, работающих с компанией электронной коммерции. Например, страница продукта может содержать список запасов на складе и параметры для изменения цены и описания продукта при посещении сотрудником.

Такие подробные правила авторизации можно реализовать декларативно или программно (или с помощью какого-либо сочетания этих двух параметров). В следующем разделе мы рассмотрим, как реализовать детализированную авторизацию с помощью элемента управления LoginView. После этого будут рассмотрены программные методы. Прежде чем можно будет рассмотреть применение правил авторизации точной детализации, сначала необходимо создать страницу, функциональность которой зависит от пользователя, который его посещает.

Давайте создадим страницу, в которой перечислены файлы в определенном каталоге в элементе управления GridView. Вместе с перечнем имени, размера и других данных каждого файла GridView будет содержать два столбца элементов управления LinkButton: одно с именем и одно с названием удалить. Если выбрано представление LinkButton, будет отображено содержимое выбранного файла. Если щелкнуть элемент LinkButton DELETE, файл будет удален. Сначала создадим эту страницу, чтобы ее функции просмотра и удаления были доступны всем пользователям. В разделах Использование элемента управления LoginView и программное ограничение функциональных возможностей мы поможем увидеть, как включить или отключить эти функции в зависимости от пользователя, который посещает страницу.

> [!NOTE]
> Страница ASP.NET, которую собираетесь создать, использует элемент управления GridView для вывода списка файлов. Поскольку эта серия руководств посвящена проверке подлинности, авторизации, учетным записям пользователей и ролям, я не хочу тратить слишком много времени на обсуждение внутренних операций элемента управления GridView. В этом учебнике содержатся подробные пошаговые инструкции по настройке этой страницы, а также сведения о том, почему были произведены определенные варианты, а также о том, какие свойства влияют на выводимые данные. Чтобы тщательно изучить элемент управления GridView, изучите раздел учебник по *[работе с данными в ASP.NET 2,0](../../data-access/index.md)* .

Для начала откройте файл `UserBasedAuthorization.aspx` в папке `Membership` и добавьте элемент управления GridView на страницу с именем `FilesGrid`. В смарт-теге GridView щелкните ссылку изменить столбцы, чтобы открыть диалоговое окно поля. Снимите флажок автоматически создавать поля в левом нижнем углу. Затем добавьте кнопку Выбрать, кнопку Удалить и два BoundFields из левого верхнего угла (кнопки выбрать и удалить можно найти в типе CommandField). Задайте для свойства `SelectText` для кнопки выбора значение View, а для свойств First BoundField `HeaderText` и `DataField` — имя. Задайте для свойства `HeaderText` второго BoundField значение Size в байтах, его `DataField` свойству Length, свойству `DataFormatString` {0:N0}, а свойству `HtmlEncode` — значение false.

После настройки столбцов GridView нажмите кнопку ОК, чтобы закрыть диалоговое окно поля. В окно свойств задайте для свойства `DataKeyNames` GridView значение `FullName`. На этом этапе декларативная разметка GridView должна выглядеть следующим образом:

[!code-aspx[Main](user-based-authorization-vb/samples/sample9.aspx)]

После создания разметки GridView мы готовы написать код, который будет получать файлы в определенном каталоге и привязывать их к GridView. Добавьте следующий код в обработчик событий `Page_Load` страницы:

[!code-vb[Main](user-based-authorization-vb/samples/sample10.vb)]

Приведенный выше код использует [класс`DirectoryInfo`](https://msdn.microsoft.com/library/system.io.directoryinfo.aspx) для получения списка файлов в корневой папке приложения. [Метод`GetFiles()`](https://msdn.microsoft.com/library/system.io.directoryinfo.getfiles.aspx) возвращает все файлы в каталоге в виде массива [объектов`FileInfo`](https://msdn.microsoft.com/library/system.io.fileinfo.aspx), которые затем привязываются к GridView. Объект `FileInfo` имеет набор свойств, таких как `Name`, `Length`и `IsReadOnly`, между прочим. Как видно из его декларативной разметки, GridView отображает только свойства `Name` и `Length`.

> [!NOTE]
> Классы `DirectoryInfo` и `FileInfo` находятся в [пространстве имен`System.IO`](https://msdn.microsoft.com/library/system.io.aspx). Поэтому необходимо либо предварять эти имена классов именами пространств имен, либо иметь пространство имен, импортированное в файл класса (через `Imports System.IO`).

Уделите немного времени, чтобы перейти на эту страницу через браузер. Отобразится список файлов, находящихся в корневом каталоге приложения. Если щелкнуть любое представление или удалить LinkButton, обратная передача будет выполняться, но никакие действия не будут выполнены, так как мы еще создали обработчики необходимых событий.

[![GridView перечисляет файлы в корневом каталоге веб-приложения.](user-based-authorization-vb/_static/image20.png)](user-based-authorization-vb/_static/image19.png)

**Рис. 7**. в элементе управления GridView перечислены файлы в корневом каталоге веб-приложения ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image21.png))

Для вывода содержимого выбранного файла необходимо иметь средства. Вернитесь в Visual Studio и добавьте текстовое поле с именем `FileContents` над GridView. Задайте для свойства `TextMode` значение `MultiLine` и его свойства `Columns` и `Rows` равными 95% и 10 соответственно.

[!code-aspx[Main](user-based-authorization-vb/samples/sample11.aspx)]

Затем создайте обработчик событий для [события`SelectedIndexChanged`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.gridview.selectedindexchanged.aspx) GridView и добавьте следующий код:

[!code-vb[Main](user-based-authorization-vb/samples/sample12.vb)]

Этот код использует свойство `SelectedValue` GridView для определения полного имени выбранного файла. На внутреннем уровне для получения `SelectedValue`используется ссылка на `DataKeys` коллекцию, поэтому необходимо задать для свойства `DataKeyNames` GridView значение Name, как описано ранее на этом шаге. [Класс`File`](https://msdn.microsoft.com/library/system.io.file.aspx) используется для считывания содержимого выбранного файла в строку, которая затем присваивается свойству `Text` текстового поля `FileContents`, тем самым отображая содержимое выбранного файла на странице.

[![содержимое выбранного файла отображается в текстовом поле](user-based-authorization-vb/_static/image23.png)](user-based-authorization-vb/_static/image22.png)

**Рис. 8**. содержимое выбранного файла отображается в текстовом поле ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image24.png))

> [!NOTE]
> Если просмотреть содержимое файла, содержащего разметку HTML, а затем попытаться просмотреть или удалить файл, появится сообщение об ошибке `HttpRequestValidationException`. Это происходит потому, что при обратной передаче содержимое текстового поля отправляется обратно на веб-сервер. По умолчанию ASP.NET вызывает ошибку `HttpRequestValidationException` всякий раз, когда обнаруживается потенциально опасное содержимое обратной передачи, например HTML-разметка. Чтобы отключить эту ошибку, отключите проверку запроса для страницы, добавив `ValidateRequest="false"` в директиву `@Page`. Дополнительные сведения о преимуществах проверки запросов, а также о том, какие меры предосторожности следует предпринять при отключении, см. в статье Проверка запросов на чтение и [предотвращение атак](https://asp.net/learn/whitepapers/request-validation/).

Наконец, добавьте обработчик событий со следующим кодом для [события`RowDeleting`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.gridview.rowdeleting.aspx)GridView:

[!code-vb[Main](user-based-authorization-vb/samples/sample13.vb)]

Код просто отображает полное имя файла для удаления в текстовом поле `FileContents` *без* фактического удаления файла.

[![нажатии кнопки удалить, файл не удаляется.](user-based-authorization-vb/_static/image26.png)](user-based-authorization-vb/_static/image25.png)

**Рис. 9**. при нажатии кнопки удалить файл фактически не удаляется ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image27.png))

На шаге 1 мы настроили правила авторизации URL-адресов, чтобы запретить анонимным пользователям просматривать страницы в папке `Membership`. Чтобы лучше проработать проверку подлинности, разрешите анонимным пользователям посетить страницу `UserBasedAuthorization.aspx`, но с ограниченной функциональностью. Чтобы открыть эту страницу до тех пор, пока все пользователи будут доступны всем пользователям, добавьте следующий элемент `<location>` в файл `Web.config` в папке `Membership`:

[!code-xml[Main](user-based-authorization-vb/samples/sample14.xml)]

После добавления этого элемента `<location>` протестируйте новые правила авторизации URL-адресов, выполнив выход из сайта. Анонимный пользователь должен посетить страницу `UserBasedAuthorization.aspx`.

В настоящее время любой прошедший проверку подлинности или анонимный пользователь может посетить страницу `UserBasedAuthorization.aspx` и просмотреть или удалить файлы. Сделаем это, чтобы только пользователи, прошедшие проверку подлинности, могли просматривать содержимое файла, и только Тито может удалить файл. Такие детализированные правила авторизации можно применять декларативно, программно или с помощью сочетания обоих методов. Рассмотрим декларативный подход к ограничению того, кто может просматривать содержимое файла. Мы будем использовать программный подход к ограничению того, кто может удалять файл.

### <a name="using-the-loginview-control"></a>Использование элемента управления LoginView

Как мы видели в прошлых учебных курсах, элемент управления LoginView полезен для отображения различных интерфейсов для проверенных и анонимных пользователей, а также предоставляет простой способ скрытия функциональных возможностей, недоступных анонимным пользователям. Так как анонимные пользователи не могут просматривать или удалять файлы, необходимо отображать текстовое поле `FileContents` только при посещении страницы пользователем, прошедшим проверку подлинности. Чтобы добиться этого, добавьте на страницу элемент управления LoginView, присвойте ему имя `LoginViewForFileContentsTextBox`и переместите декларативную разметку `FileContents` текстового поля в `LoggedInTemplate`элемента управления LoginView.

[!code-aspx[Main](user-based-authorization-vb/samples/sample15.aspx)]

Веб-элементы управления в шаблонах LoginView больше не доступны непосредственно из класса кода программной части. Например, `FilesGrid` обработчики событий `SelectedIndexChanged` и `RowDeleting` GridView в настоящее время ссылаются на элемент управления TextBox `FileContents` с помощью следующего кода:

[!code-aspx[Main](user-based-authorization-vb/samples/sample16.aspx)]

Однако этот код больше не является допустимым. Перемещая текстовое поле `FileContents` в `LoggedInTemplate` к этому текстовому полю нельзя получить прямой доступ. Вместо этого необходимо использовать метод `FindControl("controlId")` для программной ссылки на элемент управления. Обновите обработчики событий `FilesGrid`, чтобы они ссылались на текстовое поле следующим образом:

[!code-vb[Main](user-based-authorization-vb/samples/sample17.vb)]

После перемещения текстового поля в `LoggedInTemplate` LoginView и обновления кода страницы для ссылки на текстовое поле с помощью шаблона `FindControl("controlId")` посетите страницу как анонимного пользователя. Как показано на рис. 10, текстовое поле `FileContents` не отображается. Однако представление LinkButton по-прежнему отображается.

[![элемент управления LoginView визуализирует только текстовое поле Филеконтентс для пользователей, прошедших проверку подлинности](user-based-authorization-vb/_static/image29.png)](user-based-authorization-vb/_static/image28.png)

**Рис. 10**. элемент управления LoginView визуализирует только `FileContents` текстовое поле для пользователей, прошедших проверку подлинности ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image30.png))

Одним из способов скрытия кнопки просмотра для анонимных пользователей является преобразование поля GridView в TemplateField. При этом будет создан шаблон, содержащий декларативную разметку для представления LinkButton. Затем можно добавить элемент управления LoginView в TemplateField и поместить LinkButton в `LoggedInTemplate`LoginView, тем самым скрывая кнопку просмотра от анонимных посетителей. Для этого щелкните ссылку Edit Columns (изменить столбцы) в смарт-теге GridView, чтобы открыть диалоговое окно "поля". Затем нажмите кнопку выбрать в списке в левом нижнем углу, а затем щелкните преобразовать это поле в ссылку TemplateField. Это приведет к изменению декларативной разметки поля из:

[!code-aspx[Main](user-based-authorization-vb/samples/sample18.aspx)]

 До. 

[!code-aspx[Main](user-based-authorization-vb/samples/sample19.aspx)]

 На этом этапе мы можем добавить LoginView в TemplateField. Следующая разметка отображает представление LinkButton только для пользователей, прошедших проверку подлинности. 

[!code-aspx[Main](user-based-authorization-vb/samples/sample20.aspx)]

Как показано на рис. 11, конечный результат не так прост, как столбец View по-прежнему отображается, даже если представление LinkButton в столбце скрыто. Мы рассмотрим, как скрыть весь столбец GridView (а не только LinkButton) в следующем разделе.

[![элемент управления LoginView скрывает представление LinkButton для анонимных посетителей](user-based-authorization-vb/_static/image32.png)](user-based-authorization-vb/_static/image31.png)

**Рис. 11**. элемент управления LoginView скрывает представление LinkButton для анонимных посетителей ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image33.png)).

### <a name="programmatically-limiting-functionality"></a>Программное ограничение функциональности

В некоторых обстоятельствах декларативные методы недостаточно для ограничения функциональности страницы. Например, доступность определенных функций страницы может зависеть от критериев, которые выходят за рамки того, является ли пользователь веб-страницы анонимным или прошедшим проверку подлинности. В таких случаях различные элементы пользовательского интерфейса могут отображаться или скрываться с помощью программных средств.

Чтобы программно ограничить функциональные возможности, необходимо выполнить две задачи:

1. Определите, может ли пользователь, посещающий страницу, получить доступ к функциональным возможностям, и
2. Программно изменять пользовательский интерфейс в зависимости от того, имеет ли пользователь доступ к рассматриваемой функциональности.

Чтобы продемонстрировать применение этих двух задач, давайте разрешите Тито только удалять файлы из GridView. Нашей первой задачей является определение того, Тито ли она посещение страницы. После определения необходимо скрыть (или показать) столбец удаления GridView. Столбцы GridView доступны через свойство `Columns`; столбец отображается только в том случае, если его свойство `Visible` имеет значение `True` (по умолчанию).

Добавьте следующий код в обработчик событий `Page_Load` перед привязкой данных к GridView:

[!code-vb[Main](user-based-authorization-vb/samples/sample21.vb)]

Как мы обсуждали в [*обзоре учебника по проверке подлинности*](../introduction/an-overview-of-forms-authentication-vb.md) с помощью форм, `User.Identity.Name` возвращает имя удостоверения. Соответствует имени пользователя, которое было указано в элементе управления Login. Если Тито посещает страницу, свойство `Visible` для второго столбца GridView устанавливается в значение `True`; в противном случае для него задается значение `False`. В итоге, когда кто-то, отличный от Тито, посещает страницу либо другой аутентифицированный пользователь, либо анонимного пользователя, столбец DELETE не готовится к просмотру (см. рис. 12). Однако когда Тито посещает страницу, появляется столбец Delete (см. рис. 13).

[![столбец DELETE не отображается при посещении другим пользователем, отличным от Тито (например, Брюс).](user-based-authorization-vb/_static/image35.png)](user-based-authorization-vb/_static/image34.png)

**Рис. 12**. столбец удаления не отображается при посещении другим пользователем, отличным от Тито (например, Брюс) ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image36.png))

[![отрисовывается столбец удаления для Тито](user-based-authorization-vb/_static/image38.png)](user-based-authorization-vb/_static/image37.png)

**Рис. 13**. отображение столбца DELETE для Тито ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image39.png))

## <a name="step-4-applying-authorization-rules-to-classes-and-methods"></a>Шаг 4. применение правил авторизации к классам и методам

На шаге 3 анонимным пользователям запрещено просматривать содержимое файла и запрещать всем пользователям, кроме Тито, удалять файлы. Это было сделано путем скрытия связанных элементов пользовательского интерфейса для неавторизованных посетителей с помощью декларативных и программных методов. Для нашего простого примера правильное скрытие элементов пользовательского интерфейса было непросто, но как насчет более сложных сайтов, где может быть несколько различных способов выполнения одних и тех же функций? При ограничении этой функциональности неавторизованными пользователями, что происходит, если мы забыли скрыть или отключить все применимые элементы пользовательского интерфейса?

Простой способ обеспечить несанкционированный доступ к определенной части функциональности неавторизованным пользователем заключается в том, чтобы дополнить этот класс или метод [атрибутом`PrincipalPermission`](https://msdn.microsoft.com/library/system.security.permissions.principalpermissionattribute.aspx). Когда среда выполнения .NET использует класс или выполняет один из его методов, он проверяет, имеет ли текущий контекст безопасности разрешение на использование класса или выполнение метода. Атрибут `PrincipalPermission` предоставляет механизм, с помощью которого можно определить эти правила.

Давайте покажем, как использовать атрибут `PrincipalPermission` в обработчиках событий `SelectedIndexChanged` и `RowDeleting` GridView, чтобы запретить выполнение анонимных пользователей и пользователей, кроме Тито, соответственно. Все, что нам нужно сделать, — это добавить соответствующий атрибут в вершине каждого определения функции:

[!code-vb[Main](user-based-authorization-vb/samples/sample22.vb)]

Атрибут обработчика событий `SelectedIndexChanged` указывает, что только пользователи, прошедшие проверку подлинности, могут выполнять обработчик событий, когда атрибут в обработчике событий `RowDeleting` ограничивает выполнение Тито.

> [!NOTE]
> Атрибут может применяться к классу, методу, свойству или событию. При добавлении атрибута он должен быть частью инструкции объявления класса, метода, свойства или события. Поскольку Visual Basic использует разрывы строк в качестве разделителей инструкций, атрибуты должны располагаться в той же строке, что и объявление, или непосредственно над ним с помощью символа продолжения строки (символ подчеркивания). В приведенном выше фрагменте кода символ продолжения строки используется для размещения атрибута в одной строке и объявления метода в другом.

Если, каким-то образом пользователь, отличный от Тито, пытается выполнить обработчик событий `RowDeleting` или пользователь, не прошедший проверку подлинности, пытается выполнить `SelectedIndexChanged` обработчик событий, среда выполнения .NET выдаст `SecurityException`.

[![если контекст безопасности не имеет прав для выполнения метода, создается исключение SecurityException](user-based-authorization-vb/_static/image41.png)](user-based-authorization-vb/_static/image40.png)

**Рис. 14**. Если контекст безопасности не имеет прав для выполнения метода, выдается `SecurityException` ([щелкните, чтобы просмотреть изображение с полным размером](user-based-authorization-vb/_static/image42.png))

> [!NOTE]
> Чтобы разрешить нескольким контекстам безопасности доступ к классу или методу, следует снабдить класс или метод атрибутом `PrincipalPermission` для каждого контекста безопасности. То есть, чтобы разрешить Тито и Брюс выполнять обработчик событий `RowDeleting`, добавьте *два* атрибута `PrincipalPermission`:

[!code-vb[Main](user-based-authorization-vb/samples/sample23.vb)]

Помимо страниц ASP.NET, многие приложения также имеют архитектуру, включающую различные уровни, такие как бизнес-логика и уровни доступа к данным. Эти уровни обычно реализуются как библиотеки классов и предлагают классы и методы для выполнения бизнес-логики и функций, связанных с данными. Атрибут `PrincipalPermission` полезен для применения правил авторизации к этим слоям.

Дополнительные сведения об использовании атрибута `PrincipalPermission` для определения правил авторизации в классах и методах см. в записи блога [Скотта Гатри (](https://weblogs.asp.net/scottgu/) [Добавление правил авторизации к бизнес-слоям и уровням данных с помощью `PrincipalPermissionAttributes`](https://weblogs.asp.net/scottgu/archive/2006/10/04/Tip_2F00_Trick_3A00_-Adding-Authorization-Rules-to-Business-and-Data-Layers-using-PrincipalPermissionAttributes.aspx).

## <a name="summary"></a>Сводка

В этом учебнике мы рассмотрели, как применять правила авторизации на основе пользователей. Мы начали с взглянуть на ASP. Инфраструктура авторизации URL-адресов NET. В каждом запросе `UrlAuthorizationModule` обработчика ASP.NET проверяет правила авторизации URL-адресов, определенные в конфигурации приложения, чтобы определить, авторизован ли идентификатор для доступа к запрошенному ресурсу. Коротко говоря, авторизация URL-адресов позволяет легко указывать правила авторизации для конкретной страницы или для всех страниц в определенном каталоге.

Платформа авторизации URL-адресов применяет правила авторизации отдельно для каждой страницы. При использовании авторизации URL-адреса запрашивающее удостоверение авторизовано для доступа к определенному ресурсу. Однако многие сценарии вызывают более детализированные правила авторизации. Вместо того, чтобы определять, кому разрешен доступ к странице, может потребоваться предоставить всем доступ к странице, но для отображения различных данных или предоставления различных функциональных возможностей в зависимости от пользователя, который посещает страницу. Авторизация на уровне страницы обычно включает скрытие конкретных элементов пользовательского интерфейса, чтобы предотвратить доступ неавторизованных пользователей к запрещенным функциям. Кроме того, можно использовать атрибуты для ограничения доступа к классам и выполнения его методов для определенных пользователей.

Поздравляем с программированием!

### <a name="further-reading"></a>Дополнительные сведения

Дополнительные сведения о разделах, обсуждаемых в этом руководстве, см. в следующих ресурсах:

- [Добавление правил авторизации к бизнес-слоям и уровням данных с помощью `PrincipalPermissionAttributes`](https://weblogs.asp.net/scottgu/archive/2006/10/04/Tip_2F00_Trick_3A00_-Adding-Authorization-Rules-to-Business-and-Data-Layers-using-PrincipalPermissionAttributes.aspx)
- [Авторизация ASP.NET](https://msdn.microsoft.com/library/wce3kxhd.aspx)
- [Изменения между безопасностью IIS6 и IIS7](https://www.iis.net/articles/view.aspx/IIS7/Managing-IIS7/Configuring-Security/Changes-between-IIS6-and-IIS7-Security)
- [Настройка конкретных файлов и подкаталогов](https://msdn.microsoft.com/library/6hbkh9s7.aspx)
- [Ограничение функциональных возможностей изменения данных на основе пользователя](../../data-access/editing-inserting-and-deleting-data/limiting-data-modification-functionality-based-on-the-user-vb.md)
- [Краткие руководства по элементу управления LoginView](https://quickstarts.asp.net/QuickStartv20/aspnet/doc/ctrlref/login/loginview.aspx)
- [Общие сведения об авторизации URL-адресов IIS7](https://www.iis.net/articles/view.aspx/IIS7/Managing-IIS7/Configuring-Security/URL-Authorization/Understanding-IIS7-URL-Authorization)
- [Техническая документация по `UrlAuthorizationModule`](https://msdn.microsoft.com/library/system.web.security.urlauthorizationmodule.aspx)
- [Работа с данными в ASP.NET 2,0](../../data-access/index.md)

### <a name="about-the-author"></a>Об авторе

Скотт Митчелл, автор нескольких книг по ASP/ASP. NET и основатель 4GuysFromRolla.com, работал с веб-технологиями Майкрософт с 1998. Скотт работает как независимый консультант, преподаватель и модуль записи. Его последняя книга — *[Sams обучать себя ASP.NET 2,0 за 24 часа](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)* . Скотт можно получить по адресу [mitchell@4guysfromrolla.com](mailto:mitchell@4guysfromrolla.com) или через свой блог по адресу [http://ScottOnWriting.NET](http://scottonwriting.net/).

### <a name="special-thanks-to"></a>Специальная благодарность

Эта серия руководств была рассмотрена многими полезными рецензентами. Хотите ознакомиться с моими будущими статьями MSDN? Если это так, расположите строку в [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com).

> [!div class="step-by-step"]
> [Назад](validating-user-credentials-against-the-membership-user-store-vb.md)
> [Вперед](storing-additional-user-information-vb.md)
