---
uid: web-forms/overview/older-versions-security/roles/role-based-authorization-cs
title: Авторизация на основе ролейC#() | Документация Майкрософт
author: rick-anderson
description: В этом учебнике начинается изучение того, как инфраструктура ролей связывает роли пользователя с его контекстом безопасности. Затем он проверяет, как применять URL-адрес на основе ролей...
ms.author: riande
ms.date: 03/24/2008
ms.assetid: 4d9b63fa-c3d4-4e85-82b1-26ae3ba3ca1c
msc.legacyurl: /web-forms/overview/older-versions-security/roles/role-based-authorization-cs
msc.type: authoredcontent
ms.openlocfilehash: 46153ab310bdee814baaa53c372fb92f8a23ce11
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2019
ms.locfileid: "74619942"
---
# <a name="role-based-authorization-c"></a>Авторизация на основе ролей (C#)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачать код](https://download.microsoft.com/download/6/0/3/6032582f-360d-4739-b935-38721fdb86ea/CS.11.zip) или [скачать PDF](https://download.microsoft.com/download/6/0/3/6032582f-360d-4739-b935-38721fdb86ea/aspnet_tutorial11_RoleAuth_cs.pdf)

> В этом учебнике начинается изучение того, как инфраструктура ролей связывает роли пользователя с его контекстом безопасности. Затем рассматривается применение правил авторизации URL-адресов на основе ролей. Далее мы рассмотрим использование декларативных и программных средств для изменения отображаемых данных и функциональных возможностей, предлагаемых страницей ASP.NET.

## <a name="introduction"></a>Введение

В учебнике по <a id="_msoanchor_1"> </a> [*авторизации на основе пользователей*](../membership/user-based-authorization-cs.md) мы увидели, как использовать авторизацию URL-адресов, чтобы указать, какие пользователи могут посетить определенный набор страниц. С небольшой разметкой в `Web.config`мы могли бы ASP.NET, чтобы только пользователи, прошедшие проверку подлинности, могли посетить страницу. Также можно указать, что разрешены только пользователи, Тито и Bob, или указывать, что разрешены все пользователи, прошедшие проверку подлинности, за исключением SAM.

В дополнение к авторизации URL-адресов мы также рассматривали декларативные и программные методы управления отображаемыми данными и функциональные возможности, предоставляемые страницей на основе посещаемого пользователем пользователя. В частности, мы создали страницу, в которой указано содержимое текущего каталога. Любой пользователь может посетить эту страницу, но только пользователи, прошедшие проверку подлинности, могли просматривать содержимое файлов, и только Тито может удалить эти файлы.

Применение правил авторизации для отдельных пользователей может стать очень кошмарным для бухгалтерского учета. Более сопровождаемый подход заключается в использовании авторизации на основе ролей. Хорошая новость заключается в том, что средства в нашей реализации для применения правил авторизации работают точно так же хорошо, как и для учетных записей пользователей. Правила авторизации URL-адресов могут указывать роли, а не пользователей. Элемент управления LoginView, который отображает различные выходные данные для прошедших проверку подлинности и анонимных пользователей, может быть настроен для отображения содержимого на основе ролей пользователя, вошедшего в систему. И API ролей содержат методы для определения ролей пользователя, вошедшего в систему.

В этом учебнике начинается изучение того, как инфраструктура ролей связывает роли пользователя с его контекстом безопасности. Затем рассматривается применение правил авторизации URL-адресов на основе ролей. Далее мы рассмотрим использование декларативных и программных средств для изменения отображаемых данных и функциональных возможностей, предлагаемых страницей ASP.NET. Приступим к работе!

## <a name="understanding-how-roles-are-associated-with-a-users-security-context"></a>Основные сведения о том, как роли связаны с контекстом безопасности пользователя

Каждый раз, когда запрос входит в конвейер ASP.NET, он связывается с контекстом безопасности, который содержит сведения, идентифицирующие запрашивающий. При использовании проверки подлинности с помощью форм в качестве маркера идентификации используется билет проверки подлинности. Как мы обсуждали в <a id="_msoanchor_2"> </a> [*обзоре проверки подлинности*](../introduction/an-overview-of-forms-authentication-cs.md) с помощью форм и <a id="_msoanchor_3"> </a> [*настройки проверки подлинности с помощью форм и дополнительных разделов*](../introduction/forms-authentication-configuration-and-advanced-topics-cs.md) , `FormsAuthenticationModule` отвечает за определение удостоверения запрашивающего, который он выполняет во время [события`AuthenticateRequest`](https://msdn.microsoft.com/library/system.web.httpapplication.authenticaterequest.aspx).

Если обнаружен допустимый неистекший билет проверки подлинности, `FormsAuthenticationModule` декодирует его для определения удостоверения запрашивающей стороны. Он создает новый объект `GenericPrincipal` и присваивает его объекту `HttpContext.User`. Основное назначение, например `GenericPrincipal`, — определить имя пользователя, прошедшего проверку подлинности, и роли, к которым он принадлежит. Это очевидно тем, что все объекты-принципалы имеют свойство `Identity` и метод `IsInRole(roleName)`. Однако `FormsAuthenticationModule`не интересует запись сведений о ролях, а создаваемый им объект `GenericPrincipal` не указывает ни одной роли.

Если платформа ролей включена, [`RoleManagerModule`](https://msdn.microsoft.com/library/system.web.security.rolemanagermodule.aspx) HTTP-модуль после `FormsAuthenticationModule` и идентифицирует роли пользователя, прошедшего проверку подлинности, во время [`PostAuthenticateRequest` события](https://msdn.microsoft.com/library/system.web.httpapplication.postauthenticaterequest.aspx), которое срабатывает после события `AuthenticateRequest`. Если запрос происходит от пользователя, прошедшего проверку подлинности, `RoleManagerModule` перезаписывает объект `GenericPrincipal`, созданный `FormsAuthenticationModule`, и заменяет его [объектом`RolePrincipal`](https://msdn.microsoft.com/library/system.web.security.roleprincipal.aspx). Класс `RolePrincipal` использует API ролей для определения ролей, к которым принадлежит пользователь.

На рис. 1 показан рабочий процесс конвейера ASP.NET при использовании проверки подлинности с помощью форм и инфраструктуры ролей. Сначала выполняется `FormsAuthenticationModule`, который идентифицирует пользователя с помощью билета проверки подлинности и создает новый объект `GenericPrincipal`. Затем `RoleManagerModule` шаги в и перезаписывает объект `GenericPrincipal` объекту `RolePrincipal`.

Если анонимный пользователь посещает сайт, ни `FormsAuthenticationModule`, ни `RoleManagerModule` не создает объект Principal.

[![события конвейера ASP.NET для аутентифицированного пользователя при использовании проверки подлинности с помощью форм и инфраструктуры ролей](role-based-authorization-cs/_static/image2.png)](role-based-authorization-cs/_static/image1.png)

**Рис. 1**. события конвейера ASP.NET для аутентифицированного пользователя при использовании проверки подлинности с помощью форм и инфраструктуры ролей ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image3.png))

### <a name="caching-role-information-in-a-cookie"></a>Кэширование сведений о ролях в файле cookie

Метод `IsInRole(roleName)` объекта `RolePrincipal` вызывает `Roles.GetRolesForUser`, чтобы получить роли для пользователя, чтобы определить, является ли пользователь членом *roleName*. При использовании `SqlRoleProvider`результатом является запрос к базе данных хранилища ролей. При использовании правил авторизации URL-адресов на основе ролей метод `IsInRole` `RolePrincipal`будет вызываться при каждом запросе к странице, защищенной правилами авторизации URL-адресов на основе ролей. Вместо того чтобы выполнять поиск сведений о ролях в базе данных при каждом запросе, платформа ролей включает параметр для кэширования ролей пользователя в файле cookie.

Если платформа ролей настроена для кэширования ролей пользователя в файле cookie, `RoleManagerModule` создает файл cookie во время [события`EndRequest`](https://msdn.microsoft.com/library/system.web.httpapplication.endrequest.aspx)конвейера ASP.NET. Этот файл cookie используется в последующих запросах в `PostAuthenticateRequest`, что происходит при создании объекта `RolePrincipal`. Если файл cookie является допустимым и его срок действия не истек, данные в файле cookie анализируются и используются для заполнения ролей пользователя, тем самым экономя `RolePrincipal` от необходимости выполнять вызов класса `Roles` для определения ролей пользователя. На рис. 2 показан этот рабочий процесс.

[![сведения о роли пользователя могут храниться в файле cookie для повышения производительности.](role-based-authorization-cs/_static/image5.png)](role-based-authorization-cs/_static/image4.png)

**Рис. 2**. сведения о роли пользователя могут храниться в файле cookie для повышения производительности ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image6.png))

По умолчанию механизм "cookie" для кэша роли отключен. Его можно включить с помощью разметки конфигурации `<roleManager>` в `Web.config`. Мы обсуждали использование [элемента`<roleManager>`](https://msdn.microsoft.com/library/ms164660.aspx) для указания поставщиков ролей в <a id="_msoanchor_4"> </a>учебнике [*Создание ролей и управление ими*](creating-and-managing-roles-cs.md) , поэтому этот элемент уже должен находиться в `Web.config`ном файле приложения. Параметры cookie кэша роли указываются как атрибуты элемента `<roleManager>` и обобщены в таблице 1.

> [!NOTE]
> Параметры конфигурации, перечисленные в таблице 1, указывают свойства файла cookie результирующего кэша роли. Дополнительные сведения о файлах cookie, их работе и их различных свойствах см. в [руководстве по файлам cookie](http://www.quirksmode.org/js/cookies.html).

| <strong>Property</strong> |                                                                                                                                                                                                                                                                                                                                                         <strong>Описание</strong>                                                                                                                                                                                                                                                                                                                                                          |
|---------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|   `cacheRolesInCookie`    |                                                                                                                                                                                                                                                                                                                              Логическое значение, указывающее, используется ли кэширование файлов cookie. По умолчанию — `false`.                                                                                                                                                                                                                                                                                                                              |
|       `cookieName`        |                                                                                                                                                                                                                                                                                                                                     Имя файла cookie кэша роли. Значение по умолчанию —. АСПКСРОЛЕС ".                                                                                                                                                                                                                                                                                                                                     |
|       `cookiePath`        |                                                                                                                                                                                                                                Путь к файлу cookie имени роли. Атрибут Path позволяет разработчику ограничить область файла cookie определенной иерархией каталогов. Значение по умолчанию — "/", которое информирует браузер о необходимости отправить файл cookie билета проверки подлинности в любой запрос, сделанный в домене.                                                                                                                                                                                                                                 |
|    `cookieProtection`     |                                                                                                                                                               Указывает, какие методы используются для защиты файла cookie кэша роли. Допустимые значения: `All` (по умолчанию); `Encryption`; `None`; и `Validation`. Дополнительные сведения об этих уровнях защиты см <a id="_anchor_5"> </a>. на шаге 3 руководства по [*настройке проверки подлинности с помощью форм и дополнительные разделы*](../introduction/forms-authentication-configuration-and-advanced-topics-cs.md) .                                                                                                                                                                |
|    `cookieRequireSSL`     |                                                                                                                                                                                                                                                                                                   Логическое значение, указывающее, требуется ли SSL-соединение для передачи файла cookie проверки подлинности. Значение по умолчанию — `false`.                                                                                                                                                                                                                                                                                                   |
| `cookieSlidingExpiration` |                                                                                                                                                                                                                                                  Логическое значение, указывающее, будет ли время ожидания файла cookie сбрасываться каждый раз, когда пользователь посещает сайт в течение одного сеанса. Значение по умолчанию — `false`. Это значение уместно, только если `createPersistentCookie` имеет значение `true`.                                                                                                                                                                                                                                                  |
|      `cookieTimeout`      |                                                                                                                                                                                                                                                                         Указывает время в минутах, по истечении которого срок действия файла cookie билета проверки подлинности истекает. Значение по умолчанию — `30`. Это значение уместно, только если `createPersistentCookie` имеет значение `true`.                                                                                                                                                                                                                                                                         |
| `createPersistentCookie`  |                                                                                                                                                                   Логическое значение, указывающее, является ли файл cookie кэша роли файлом cookie сеанса или постоянным файлом cookie. Если `false` (значение по умолчанию), используется файл cookie сеанса, который удаляется при закрытии браузера. Если `true`, используется постоянный файл cookie; срок действия истекает `cookieTimeout` количество минут после его создания или после предыдущего посещения, в зависимости от значения `cookieSlidingExpiration`.                                                                                                                                                                    |
|         `domain`          |                                                                                                                                                 Указывает значение домена cookie. Значение по умолчанию — пустая строка, которая заставляет браузер использовать домен, из которого он был выдан (например, www.yourdomain.com). В этом случае файл cookie <strong>не</strong> будет отправляться при выполнении запросов к поддоменам, таким как admin.yourdomain.com. Если вы хотите, чтобы файл cookie передавался во все поддомены, необходимо настроить атрибут `domain`, указав для него значение "yourdomain.com".                                                                                                                                                 |
|    `maxCachedResults`     | Указывает максимальное число имен ролей, кэшируемых в файле cookie. Значение по умолчанию — 25. `RoleManagerModule` не создает файл cookie для пользователей, которые принадлежат к более `maxCachedResults` ролям. Следовательно, метод `IsInRole` объекта `RolePrincipal` будет использовать класс `Roles` для определения ролей пользователя. Причина `maxCachedResults` существует, так как многие агенты пользователей не развышают 4 096 байт. Поэтому это ограничение снижает вероятность превышения этого ограничения на размер. При наличии чрезвычайно длинных имен ролей может потребоваться указать меньшее `maxCachedResults` значение. контраривисе. при наличии чрезвычайно коротких имен ролей можно увеличить это значение. |

**Таблица 1.** Параметры конфигурации файла cookie кэша роли

Давайте настроим наше приложение на использование файлов cookie кэша неустойчивой роли. Для этого обновите элемент `<roleManager>` в `Web.config`, чтобы включить следующие атрибуты, связанные с файлом cookie:

[!code-xml[Main](role-based-authorization-cs/samples/sample1.xml)]

Я обновил элемент `<roleManager>`, добавив три атрибута: `cacheRolesInCookie`, `createPersistentCookie`и `cookieProtection`. Если присвоить параметру `cacheRolesInCookie` значение `true`, `RoleManagerModule` будет автоматически кэшировать роли пользователя в файле cookie вместо того, чтобы выполнять поиск сведений о ролях пользователя при каждом запросе. Я явно установил `createPersistentCookie` и `cookieProtection` атрибуты для `false` и `All`соответственно. Технически, мне не нужно было задавать значения для этих атрибутов, так как им назначены значения по умолчанию, но я поместил их сюда, чтобы явно ясно, что я не использую постоянные файлы cookie и что файл cookie зашифрован и проверен.

Вот и все! Исходя этого, платформа ролей будет кэшировать роли пользователей в файлах cookie. Если браузер пользователя не поддерживает файлы cookie, или если их файлы cookie удаляются или теряются каким-либо образом, это не является большой особенностью. объект `RolePrincipal` будет просто использовать класс `Roles` в случае, если нет файла cookie (или недопустимого или устаревшего).

> [!NOTE]
> Шаблоны корпорации Майкрософт &amp; рекомендации не рекомендуют использовать файлы cookie кэша постоянной роли. Поскольку владение файлом cookie кэша роли достаточно для того, чтобы доказать членство в роли, злоумышленник может каким-либо образом получить доступ к допустимому файлу cookie пользователя, который может олицетворять этого пользователя. Вероятность этого возрастает, если файл cookie сохраняется в браузере пользователя. Дополнительные сведения об этих рекомендациях по безопасности, а также другие вопросы безопасности см. в [списке вопросов безопасности для ASP.NET 2,0](https://msdn.microsoft.com/library/ms998375.aspx).

## <a name="step-1-defining-role-based-url-authorization-rules"></a>Шаг 1. Определение правил авторизации URL-адресов на основе ролей

Как обсуждалось в <a id="_msoanchor_6"> </a>руководстве по [*авторизации на основе пользователей*](../membership/user-based-authorization-cs.md) , авторизация URL-адресов предоставляет средства для ограничения доступа к набору страниц для отдельных пользователей или ролей. Правила авторизации URL-адреса записываются в `Web.config` использование [элемента`<authorization>`](https://msdn.microsoft.com/library/8d82143t.aspx) с `<allow>` и `<deny>` дочерними элементами. В дополнение к правилам авторизации, связанным с пользователем, обсуждаемым в предыдущих учебных курсах, каждый `<allow>` и `<deny>` дочерний элемент могут также включать:

- Определенная роль
- Разделенный запятыми список ролей

Например, правила авторизации URL-адресов предоставляют доступ этим пользователям в ролях Администраторы и руководители, но запрещают доступ ко всем остальным:

[!code-xml[Main](role-based-authorization-cs/samples/sample2.xml)]

Элемент `<allow>` в приведенном выше разметке указывает, что разрешены роли администраторов и супервизоров. элемент `<deny>` указывает, что *все* пользователи запрещены.

Настроим приложение таким образом, чтобы `ManageRoles.aspx`, `UsersAndRoles.aspx`и `CreateUserWizardWithRoles.aspx` страницы были доступны только этим пользователям в роли администраторов, а `RoleBasedAuthorization.aspx` страница остается доступной для всех посетителей.

Чтобы сделать это, начните с добавления файла `Web.config` в папку `Roles`.

[![добавить файл Web. config в каталог ролей](role-based-authorization-cs/_static/image8.png)](role-based-authorization-cs/_static/image7.png)

**Рис. 3**. добавление файла `Web.config` в каталог `Roles` ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image9.png))

Затем добавьте следующую разметку конфигурации в `Web.config`:

[!code-xml[Main](role-based-authorization-cs/samples/sample3.xml)]

Элемент `<authorization>` в разделе `<system.web>` указывает, что только пользователи с ролью "Администраторы" могут получить доступ к ресурсам ASP.NET в каталоге `Roles`. Элемент `<location>` определяет альтернативный набор правил авторизации URL-адресов для страницы `RoleBasedAuthorization.aspx`, что позволяет всем пользователям посещать страницу.

После сохранения изменений в `Web.config`Войдите в систему как пользователь, который не входит в роль "Администраторы", и попробуйте посетить одну из защищенных страниц. `UrlAuthorizationModule` обнаружит, что у вас нет разрешения на посещение запрошенного ресурса; Следовательно, `FormsAuthenticationModule` перенаправит вас на страницу входа. После этого страница входа будет перенаправлена на страницу `UnauthorizedAccess.aspx` (см. рис. 4). Это последнее перенаправление со страницы входа в `UnauthorizedAccess.aspx` происходит из-за кода, добавленного на страницу входа в шаге 2 руководства <a id="_msoanchor_7"> </a>по [*авторизации на основе пользователя*](../membership/user-based-authorization-cs.md) . В частности, страница входа автоматически перенаправляет всех пользователей, прошедших проверку подлинности, в `UnauthorizedAccess.aspx` если строка запроса содержит параметр `ReturnUrl`, так как этот параметр указывает, что пользователь приступил к странице входа после попытки просмотра страницы, которой он не авторизован для просмотра.

[Для просмотра защищенных страниц ![только пользователи с ролью "Администраторы"](role-based-authorization-cs/_static/image11.png)](role-based-authorization-cs/_static/image10.png)

**Рис. 4**. только пользователи с ролью "Администраторы" могут просматривать защищенные страницы ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image12.png))

Выйдите из системы и войдите в систему от имени пользователя, который является членом роли "Администраторы". Теперь вы можете просматривать три защищенных страницы.

[![Тито может посетить страницу Усерсандролес. aspx, так как он находится в роли "Администраторы"](role-based-authorization-cs/_static/image14.png)](role-based-authorization-cs/_static/image13.png)

**Рис. 5**. Тито может посетить страницу `UsersAndRoles.aspx`, так как она находится в роли "Администраторы" ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image15.png))

> [!NOTE]
> При указании правил авторизации URL-адресов для ролей или пользователей важно помнить, что правила анализируются по одному, сверху вниз. Как только соответствие будет найдено, пользователю будет предоставлен или запрещен доступ, в зависимости от того, найдена ли совпадение в элементе `<allow>` или `<deny>`. **Если совпадений не найдено, пользователю предоставляется доступ.** Следовательно, если вы хотите ограничить доступ к одной или нескольким учетным записям пользователей, обязательно используйте элемент `<deny>` в качестве последнего элемента в конфигурации авторизации URL-адреса. **Если правила авторизации URL-адреса не включают** элемент`<deny>` **, всем пользователям будет предоставлен доступ.** Чтобы получить более полное представление о том, как анализируются правила авторизации URL-адресов, ознакомьтесь с разделом «знакомство с тем, как `UrlAuthorizationModule` использует правила авторизации для предоставления или запрета <a id="_msoanchor_8"> </a>доступа» учебника по [*авторизации на основе пользователей*](../membership/user-based-authorization-cs.md) .

## <a name="step-2-limiting-functionality-based-on-the-currently-logged-in-users-roles"></a>Шаг 2. ограничение функциональных возможностей на основе ролей текущего пользователя, вошедшего в систему

Авторизация URL-адресов позволяет легко указывать грубые правила авторизации, определяющие, какие удостоверения разрешены и какие из них запрещают просматривать определенную страницу (или все страницы в папке и ее вложенных папках). Однако в некоторых случаях может потребоваться разрешить всем пользователям посещать страницу, но ограничить функциональность страницы на основе ролей пользователя. Это может привести к отображению или скрытию данных на основе роли пользователя или к дополнительным функциям для пользователей, принадлежащих к определенной роли.

Такие детализированные правила авторизации на основе ролей можно реализовать декларативно или программно (или с помощью какого-либо сочетания этих двух). В следующем разделе мы рассмотрим, как реализовать декларативную авторизацию детализации с помощью элемента управления LoginView. После этого будут рассмотрены программные методы. Прежде чем можно будет рассмотреть применение правил авторизации точной детализации, сначала необходимо создать страницу, функциональность которой зависит от роли пользователя, который его посещает.

Давайте создадим страницу, в которой перечислены все учетные записи пользователей в системе в GridView. GridView будет включать имя пользователя, адрес электронной почты, дату последнего входа и комментарии пользователя. Кроме отображения сведений о каждом пользователе, GridView будет включать возможности редактирования и удаления. Сначала мы создадим эту страницу с возможностью редактирования и удаления, доступной всем пользователям. В разделах «Использование элемента управления LoginView» и «программное ограничение функциональных возможностей» показано, как включить или отключить эти функции на основе роли пользователя.

> [!NOTE]
> Страница ASP.NET, которую собираетесь создать, использует элемент управления GridView для вывода учетных записей пользователей. Поскольку эта серия руководств посвящена проверке подлинности, авторизации, учетным записям пользователей и ролям, я не хочу тратить слишком много времени на обсуждение внутренних операций элемента управления GridView. В этом учебнике содержатся подробные пошаговые инструкции по настройке этой страницы, а также сведения о том, почему были произведены определенные варианты, а также о том, какие свойства влияют на выводимые данные. Подробное изучение элемента управления GridView см. в статье Руководство по *[работе с данными в](../../data-access/index.md)* серии руководств по ASP.NET 2,0.

Для начала откройте страницу `RoleBasedAuthorization.aspx` в папке `Roles`. Перетащите элемент GridView с страницы на конструктор и задайте для его `ID` значение `UserGrid`. Сейчас мы создадим код, который вызывает метод `Membership.GetAllUsers` и привязывает полученный объект `MembershipUserCollection` к GridView. `MembershipUserCollection` содержит объект `MembershipUser` для каждой учетной записи пользователя в системе; `MembershipUser` объекты имеют такие свойства, как `UserName`, `Email`, `LastLoginDate`и т. д.

Прежде чем написать код, связывающий учетные записи пользователей с сеткой, давайте сначала определим поля GridView. В смарт-теге GridView щелкните ссылку "изменить столбцы", чтобы открыть диалоговое окно "поля" (см. рис. 6). Снимите флажок "автоматически создавать поля" в левом нижнем углу. Так как нам требуется, чтобы этот GridView включал в себя возможности редактирования и удаления, добавьте CommandField и задайте для его свойств `ShowEditButton` и `ShowDeleteButton` значение true. Затем добавьте четыре поля для отображения свойств `UserName`, `Email`, `LastLoginDate`и `Comment`. Используйте BoundField для двух свойств, предназначенных только для чтения (`UserName` и `LastLoginDate`) и полей TemplateField для двух изменяемых полей (`Email` и `Comment`).

В первом BoundField отображается свойство `UserName`; Задайте для свойств `HeaderText` и `DataField` значение UserName. Это поле не будет доступно для редактирования, поэтому установите для его свойства `ReadOnly` значение true. Настройте `LastLoginDate` BoundField, задав для его `HeaderText` значение "Last Login", а для его `DataField` значение "LastLoginDate". Давайте отформатим выходные данные этого BoundField, чтобы отображались только даты (вместо даты и времени). Для этого задайте для свойства `HtmlEncode` BoundField значение false, а для свойства `DataFormatString` значение "{0:d}". Также присвойте свойству `ReadOnly` значение true.

Задайте свойствам `HeaderText` двух полей TemplateField значения "Email" и "Comment".

[![поля GridView можно настроить с помощью диалогового окна "поля"](role-based-authorization-cs/_static/image17.png)](role-based-authorization-cs/_static/image16.png)

**Рис. 6**. поля GridView можно настроить в диалоговом окне "поля" ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image18.png))

Теперь необходимо определить `ItemTemplate` и `EditItemTemplate` для полей TemplateField "Email" и "Comment". Добавьте элемент управления Label в каждый из `ItemTemplate` и привяжите свои свойства `Text` к свойствам `Email` и `Comment` соответственно.

Для TemplateField "Email" добавьте в `EditItemTemplate` текстовое поле с именем `Email` и привяжите его свойство `Text` к свойству `Email`, используя двустороннюю привязку данных. Добавьте RequiredFieldValidator и Регуларекспрессионвалидатор в `EditItemTemplate`, чтобы убедиться, что посетитель, редактирующий свойство электронной почты, указал допустимый адрес электронной почты. Для TemplateField "Comment" добавьте многострочное текстовое поле с именем `Comment` в `EditItemTemplate`. Задайте для свойств `Columns` и `Rows` текстового поля значение 40 и 4 соответственно, а затем Привяжите свойство `Text` к свойству `Comment`, используя двустороннюю привязку данных.

После настройки этих полей TemplateField их декларативная разметка должна выглядеть следующим образом:

[!code-aspx[Main](role-based-authorization-cs/samples/sample4.aspx)]

При изменении или удалении учетной записи пользователя необходимо знать значение свойства `UserName` пользователя. Задайте для свойства `DataKeyNames` GridView значение UserName, чтобы эта информация была доступна через коллекцию `DataKeys` GridView.

Наконец, добавьте на страницу элемент управления ValidationSummary и задайте для его свойства `ShowMessageBox` значение true, а для свойства `ShowSummary` — значение false. При использовании этих параметров ValidationSummary отобразит оповещение на стороне клиента, если пользователь попытается изменить учетную запись пользователя с отсутствующим или недопустимым адресом электронной почты.

[!code-aspx[Main](role-based-authorization-cs/samples/sample5.aspx)]

Теперь мы выполнили декларативную разметку этой страницы. Следующая задача — привязать набор учетных записей пользователей к GridView. Добавьте метод с именем `BindUserGrid` в класс кода программной части `RoleBasedAuthorization.aspx` страницы, который привязывает `MembershipUserCollection`, возвращенные `Membership.GetAllUsers`, к `UserGrid` GridView. Вызовите этот метод из обработчика событий `Page_Load` на первой странице посещения.

[!code-csharp[Main](role-based-authorization-cs/samples/sample6.cs)]

Используя этот код, перейдите на страницу в браузере. Как показано на рис. 7, вы увидите элемент GridView со сведениями о каждой учетной записи пользователя в системе.

[![GridView Усергрид содержит сведения о каждом пользователе в системе.](role-based-authorization-cs/_static/image20.png)](role-based-authorization-cs/_static/image19.png)

**Рис. 7**. `UserGrid` GridView содержит сведения о каждом пользователе в системе ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image21.png))

> [!NOTE]
> `UserGrid` GridView перечисляет всех пользователей в интерфейсе без страничных служб. Этот простой интерфейс Grid не подходит для сценариев, в которых имеется несколько десятков пользователей. Одним из вариантов является настройка GridView для включения разбиения на страницы. Метод `Membership.GetAllUsers` имеет две перегрузки: один, который не принимает входные параметры и возвращает всех пользователей и один, принимающий целочисленные значения для индекса страницы и размера страницы, и возвращает только указанное подмножество пользователей. Вторую перегрузку можно использовать для более эффективной страницы пользователей, поскольку она возвращает только точное подмножество учетных записей пользователей, а не *все* . Если у вас тысячи учетных записей пользователей, может потребоваться рассмотреть интерфейс на основе фильтров, в котором будут показаны только те пользователи, имена которых начинаются с выбранного символа. [`Membership.FindUsersByName method`](https://msdn.microsoft.com/library/system.web.security.membership.findusersbyname.aspx) идеально подходит для создания пользовательского интерфейса на основе фильтров. В следующем учебном курсе мы рассмотрим создание такого интерфейса.

Элемент управления GridView предлагает встроенную поддержку редактирования и удаления, когда элемент управления привязан к правильно настроенному элементу управления источниками данных, например SqlDataSource или ObjectDataSource. Однако `UserGrid` GridView имеет программную привязку данных; Поэтому необходимо написать код для выполнения этих двух задач. В частности, необходимо создать обработчики событий для событий `RowEditing`, `RowCancelingEdit`, `RowUpdating`и `RowDeleting` GridView, которые срабатывают, когда посетитель нажимает кнопки "Правка", "Отмена", "Обновить" или "Удалить" в GridView.

Начните с создания обработчиков событий для событий `RowEditing`, `RowCancelingEdit`и `RowUpdating` GridView, а затем добавьте следующий код:

[!code-csharp[Main](role-based-authorization-cs/samples/sample7.cs)]

Обработчики событий `RowEditing` и `RowCancelingEdit` просто устанавливают свойство `EditIndex` GridView, а затем повторно привязывают список учетных записей пользователей к сетке. Интересные вещи происходят в обработчике событий `RowUpdating`. Этот обработчик событий начинает работу, гарантируя, что данные являются допустимыми, а затем захватит `UserName` значение измененной учетной записи пользователя из коллекции `DataKeys`. `Email` и `Comment` текстовые поля в двух полей TemplateField "`EditItemTemplate` s", которые затем упоминаются программными средствами. Их свойства `Text` содержат измененный адрес электронной почты и комментарий.

Чтобы обновить учетную запись пользователя с помощью API членства, необходимо сначала получить сведения о пользователе, которые мы делаем с помощью вызова `Membership.GetUser(userName)`. После этого возвращаемые свойства `Email` и `Comment` объекта `MembershipUser` обновляются значениями, указанными в двух текстовых полях интерфейса редактирования. Наконец, эти изменения сохраняются с помощью вызова [`Membership.UpdateUser`](https://msdn.microsoft.com/library/system.web.security.membership.updateuser.aspx). Обработчик событий `RowUpdating` завершает работу, переменяя элемент управления GridView на его интерфейс предварительного редактирования.

Затем создайте обработчик событий `RowDeleting`, а затем добавьте следующий код:

[!code-csharp[Main](role-based-authorization-cs/samples/sample8.cs)]

Приведенный выше обработчик событий начинает с получения значения `UserName` из коллекции `DataKeys` GridView. Это `UserName` значение затем передается в [метод`DeleteUser`](https://msdn.microsoft.com/library/system.web.security.membership.deleteuser.aspx)класса членства. Метод `DeleteUser` удаляет учетную запись пользователя из системы, включая связанные данные о членстве (например, роли, к которым принадлежит этот пользователь). После удаления пользователя `EditIndex` сетки присваивается значение-1 (если пользователь щелкнул DELETE, пока другая строка находилась в режиме редактирования) и вызывается метод `BindUserGrid`.

> [!NOTE]
> Перед удалением учетной записи пользователя для кнопки удалить не требуется никаких подтверждений от пользователя. Я рекомендую добавить некоторую форму подтверждения пользователя, чтобы уменьшить вероятность случайного удаления учетной записи. Одним из самых простых способов подтверждения действия является применение диалогового окна подтверждения на стороне клиента. Дополнительные сведения об этом способе см. в разделе [Добавление подтверждения на стороне клиента при удалении](https://asp.net/learn/data-access/tutorial-42-cs.aspx).

Убедитесь, что эта страница работает так, как ожидалось. Вы можете изменить адрес электронной почты и комментарий любого пользователя, а также удалить любую учетную запись пользователя. Так как страница `RoleBasedAuthorization.aspx` доступна всем пользователям, любой пользователь — даже анонимные посетители — могут посетить эту страницу и изменить и удалить учетные записи пользователей. Теперь обновите эту страницу, чтобы только пользователи из ролей супервизоров и администраторов могли изменять адрес электронной почты и комментарий пользователя, и только администраторы могут удалить учетную запись пользователя.

В разделе "использование элемента управления LoginView" рассматривается использование элемента управления LoginView для отображения инструкций, относящихся к роли пользователя. Если пользователь в роли "Администраторы" посещает эту страницу, будут показаны инструкции по изменению и удалению пользователей. Если пользователь в роли супервизора достигает этой страницы, будут показаны инструкции по изменению пользователей. Если посетитель является анонимным или не входит в роль супервизоров или администраторов, отобразится сообщение о том, что не может изменить или удалить сведения об учетной записи пользователя. В разделе «программное ограничение функциональности» мы создадим код, который программно показывает или скрывает кнопки «Изменить» и «удалить» в зависимости от роли пользователя.

### <a name="using-the-loginview-control"></a>Использование элемента управления LoginView

Как мы видели в прошлых учебных курсах, элемент управления LoginView полезен для отображения различных интерфейсов для прошедших проверку подлинности и анонимных пользователей, но элемент управления LoginView можно также использовать для отображения разметки на основе ролей пользователя. Давайте будем использовать элемент управления LoginView для вывода различных инструкций на основе роли пользователя.

Начните с добавления LoginView над `UserGrid` GridView. Как обсуждалось ранее, элемент управления LoginView имеет два встроенных шаблона: `AnonymousTemplate` и `LoggedInTemplate`. Введите краткое сообщение в обоих шаблонах, информирующее пользователя, что он не может изменять или удалять сведения о пользователях.

[!code-aspx[Main](role-based-authorization-cs/samples/sample9.aspx)]

Помимо `AnonymousTemplate` и `LoggedInTemplate`, элемент управления LoginView может включать *группы ролей*, которые являются шаблонами для конкретных ролей. Каждый группы ролей содержит одно свойство, `Roles`, которое указывает, к каким ролям применяется группы ролей. Свойству `Roles` может быть присвоена одна роль (например, "Администраторы") или разделенный запятыми список ролей (например, "Администраторы, руководители").

Чтобы управлять группы ролей, щелкните ссылку Edit группы ролей (изменить) в смарт-теге элемента управления, чтобы открыть редактор коллекции группы ролей. Добавьте два новых группы ролей. Задайте для свойства `Roles` первого группы ролей значение "Администраторы", а для второго — "руководители".

[![Управление шаблонами ролей LoginView с помощью редактора коллекции группы ролей](role-based-authorization-cs/_static/image23.png)](role-based-authorization-cs/_static/image22.png)

**Рис. 8**. Управление шаблонами ролей LoginView с помощью редактора коллекции группы ролей ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image24.png))

Нажмите кнопку ОК, чтобы закрыть редактор коллекции группы ролей. в результате будет обновлена декларативная разметка LoginView, включающая `<RoleGroups>`ный раздел с `<asp:RoleGroup>` дочерним элементом для каждого группы ролей, определенного в редакторе коллекции группы ролей. Более того, раскрывающийся список "представления" в смарт-теге LoginView, который изначально передали только `AnonymousTemplate` и `LoggedInTemplate` – теперь также включает добавленные группы ролей.

Измените группы ролей, чтобы пользователи в роли "руководители" отображали инструкции по изменению учетных записей пользователей, а пользователи в роли "Администраторы" — инструкции по изменению и удалению. После внесения этих изменений декларативная разметка LoginView должна выглядеть следующим образом.

[!code-aspx[Main](role-based-authorization-cs/samples/sample10.aspx)]

После внесения этих изменений сохраните страницу и откройте ее в браузере. Сначала посетите страницу от имени анонимного пользователя. Должно отображаться сообщение "вы не вошли в систему. Таким образом, нельзя изменять или удалять сведения о пользователях. " Затем войдите в систему как пользователь, прошедший проверку подлинности, но не в роли супервизоров и администраторов. На этот раз вы увидите сообщение "вы не являетесь членом роли администраторов или Администраторы. Таким образом, нельзя изменять или удалять сведения о пользователях. "

Затем войдите в систему как пользователь, являющийся членом роли "руководители". На этот раз вы увидите сообщение, относящееся к роли супервизоров (см. рис. 9). Если вы входите в систему как пользователь в роли "Администраторы", вы должны увидеть сообщение, относящееся к роли "Администраторы" (см. рис. 10).

[![Брюс отображается сообщение, относящееся к роли супервизоров](role-based-authorization-cs/_static/image26.png)](role-based-authorization-cs/_static/image25.png)

**Рис. 9**. Отображение сообщения, относящегося к роли руководителя ([щелкните для просмотра полного изображения](role-based-authorization-cs/_static/image27.png)) в Брюс.

[![Тито отображается сообщение, относящееся к роли администраторов.](role-based-authorization-cs/_static/image29.png)](role-based-authorization-cs/_static/image28.png)

**Рис. 10**. Отображение сообщения, специфического для роли администраторов ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image30.png))

По мере отображения снимков экрана на рис. 9 и 10, в LoginView отображается только один шаблон, даже если применяется несколько шаблонов. Брюс и Тито входят в систему пользователей, но в процессе LoginView отображаются только соответствующие группы ролей, а не `LoggedInTemplate`. Более того, Тито принадлежит как администраторам, так и Супервизорам, но элемент управления LoginView подготавливает к просмотру шаблон, относящийся к роли администраторов, а не супервизоров.

На рис. 11 показан рабочий процесс, используемый элементом управления LoginView для определения шаблона, подготавливается к просмотру. Обратите внимание, что если указано более одного группы ролей, шаблон LoginView визуализирует *первый* группы ролей, соответствующий. Другими словами, если бы мы поместили руководителей группы ролей в качестве первого группы ролей, а администраторы — во второй, то когда Тито посетит эту страницу, он увидит сообщение Супервизоры.

[![рабочего процесса элемента управления LoginView для определения того, какой шаблон подготавливается к просмотру](role-based-authorization-cs/_static/image32.png)](role-based-authorization-cs/_static/image31.png)

**Рис. 11**. Рабочий процесс элемента управления LoginView для определения того, какой шаблон подготавливается к просмотру ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image33.png))

### <a name="programmatically-limiting-functionality"></a>Программное ограничение функциональности

Хотя элемент управления LoginView отображает различные инструкции в зависимости от роли пользователя, который посещает страницу, кнопки Правка и отмена остаются видимыми для всех. Необходимо программно скрыть кнопки "изменить и удалить" для анонимных посетителей и пользователей, которые не являются ни администраторами, ни администраторами. Для всех, кто не является администратором, необходимо скрыть кнопку Удалить. Для этого мы напишем фрагмент кода, который программно ссылается на элемент LinkButton CommandField Edit и DELETE и задает для свойств `Visible` значение `false`при необходимости.

Самый простой способ программно ссылаться на элементы управления в CommandField — сначала преобразовать его в шаблон. Чтобы сделать это, щелкните ссылку "изменить столбцы" в смарт-теге GridView, выберите CommandField из списка текущих полей и щелкните ссылку "преобразовать это поле в TemplateField". Это превращает CommandField в TemplateField с помощью `ItemTemplate` и `EditItemTemplate`. В `ItemTemplate` содержатся ссылки для редактирования и удаления, тогда как в `EditItemTemplate` содержится обновление и отмена LinkButton.

[![преобразовать CommandField в TemplateField](role-based-authorization-cs/_static/image35.png)](role-based-authorization-cs/_static/image34.png)

**Рис. 12**. Преобразование CommandField в TemplateField ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image36.png))

Обновите элемент LinkButton для редактирования и удаления в `ItemTemplate`, задав для свойств `ID` значение `EditButton` и `DeleteButton`соответственно.

[!code-aspx[Main](role-based-authorization-cs/samples/sample11.aspx)]

Каждый раз, когда данные привязаны к GridView, GridView перечисляет записи в своем свойстве `DataSource` и создает соответствующий объект `GridViewRow`. При создании каждого `GridViewRow`ного объекта срабатывает событие `RowCreated`. Чтобы скрыть кнопки «Изменить» и «удалить» для неавторизованных пользователей, необходимо создать обработчик событий для этого события и программно ссылаться на элемент LinkButton «редактирование и удаление», устанавливая соответствующие свойства `Visible`.

Создайте обработчик событий `RowCreated` событие, а затем добавьте следующий код:

[!code-csharp[Main](role-based-authorization-cs/samples/sample12.cs)]

Помните, что событие `RowCreated` срабатывает для *всех* строк GridView, включая заголовок, нижний колонтитул, интерфейс пейджера и т. д. Мы хотим ссылаться только на ссылки на изменения и удаление элементов LinkButton только в том случае, если строка данных не находится в режиме редактирования (поскольку строка в режиме редактирования содержит кнопки обновления и отмены вместо Edit и DELETE). Эта проверка обрабатывается оператором `if`.

Если мы работаем с строкой данных, которая не находится в режиме редактирования, указываются ссылки на правки и удаления, а их `Visible` свойства задаются на основе логических значений, возвращаемых методом `IsInRole(roleName)` объекта `User`. Объект User ссылается на участника, созданного `RoleManagerModule`; Следовательно, метод `IsInRole(roleName)` использует API ролей для определения принадлежности текущего посетителя к объекту *roleName*.

> [!NOTE]
> Мы могли бы использовать класс Roles напрямую, заменив вызов `User.IsInRole(roleName)` вызовом [метода`Roles.IsUserInRole(roleName)`](https://msdn.microsoft.com/library/system.web.security.roles.isuserinrole.aspx). Я решил использовать метод `IsInRole(roleName)` объекта Principal в этом примере, так как он более эффективен, чем использование API ролей напрямую. Ранее в этом учебнике мы настроили диспетчер ролей для кэширования ролей пользователя в файле cookie. Эти кэшированные данные cookie используются только при вызове метода `IsInRole(roleName)` участника; прямые вызовы API ролей всегда подразумевают поездку в хранилище ролей. Даже если роли не кэшируются в файле cookie, вызов метода `IsInRole(roleName)` объекта Principal обычно более эффективен, так как при первом вызове запроса он кэширует результаты. API ролей, с другой стороны, не выполняет кэширование. Поскольку событие `RowCreated` запускается один раз для каждой строки в GridView, использование `User.IsInRole(roleName)` включает в себя только один проход в хранилище ролей, а `Roles.IsUserInRole(roleName)` требует *N* поездок, где *N* — число учетных записей пользователей, отображаемых в сетке.

Свойство `Visible` кнопки "Изменить" имеет значение `true`, если пользователь посещает эту страницу в роли "Администраторы" или "руководители". в противном случае задается значение `false`. Свойство `Visible` кнопки "Удалить" имеет значение `true` только в том случае, если пользователь входит в роль "Администраторы".

Протестируйте эту страницу в браузере. При посещении страницы в качестве анонимного посетителя или в качестве пользователя, который не является ни супервизором, ни администратором, CommandField пуст; Он по-прежнему существует, но в качестве тонкого Серебряный без кнопок "Изменить" или "Удалить".

> [!NOTE]
> CommandField можно полностью скрыть, когда на странице посещается не Супервизор и не администратор. Я оставлю это в качестве упражнения для читателя.

[![кнопки "Изменить" и "Удалить" скрыты для руководителей и не администраторов](role-based-authorization-cs/_static/image38.png)](role-based-authorization-cs/_static/image37.png)

**Рис. 13**. кнопки "Изменить" и "Удалить" скрыты для неруководителей и не администраторов ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image39.png))

Если пользователь, принадлежащий роли супервизоров (но не к роли администратора) посещает, он видит только кнопку Изменить.

[![если кнопка Изменить доступна для руководителей, кнопка Удалить скрыта.](role-based-authorization-cs/_static/image41.png)](role-based-authorization-cs/_static/image40.png)

**Рис. 14**. когда кнопка "Изменить" доступна для руководителей, кнопка "Удалить" скрыта ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image42.png))

Если администратор посещает, у нее есть доступ к кнопкам "Изменить" и "Удалить".

[![кнопки "Изменить" и "Удалить" доступны только для администраторов](role-based-authorization-cs/_static/image44.png)](role-based-authorization-cs/_static/image43.png)

**Рис. 15**. кнопки "Изменить" и "Удалить" доступны только для администраторов ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image45.png))

## <a name="step-3-applying-role-based-authorization-rules-to-classes-and-methods"></a>Шаг 3. применение правил авторизации на основе ролей к классам и методам

На этапе 2 мы ограничены возможностями правки для пользователей в ролях и администраторах, а также удаляют возможности только для администраторов. Это было выполнено путем скрытия связанных элементов пользовательского интерфейса для неавторизованных пользователей с помощью программных методов. Такие меры не гарантируют, что неавторизованный пользователь не сможет выполнить привилегированное действие. Могут существовать элементы пользовательского интерфейса, которые добавляются позже или которые мы забыли скрыть для неавторизованных пользователей. Или злоумышленник может обнаружить другой способ получения страницы ASP.NET для выполнения нужного метода.

Простой способ обеспечить несанкционированный доступ к определенной части функциональности неавторизованным пользователем заключается в том, чтобы дополнить этот класс или метод [атрибутом`PrincipalPermission`](https://msdn.microsoft.com/library/system.security.permissions.principalpermissionattribute.aspx). Когда среда выполнения .NET использует класс или выполняет один из его методов, он проверяет, имеет ли текущий контекст безопасности разрешение. Атрибут `PrincipalPermission` предоставляет механизм, с помощью которого можно определить эти правила.

Мы рассматривали использование атрибута `PrincipalPermission` обратно в руководстве по <a id="_msoanchor_9"> </a> [*авторизации на основе пользователя*](../membership/user-based-authorization-cs.md) . В частности, мы увидели, как оформлять `SelectedIndexChanged` и `RowDeleting` обработчик событий GridView, чтобы их могли выполнять только пользователи, прошедшие проверку подлинности и Тито соответственно. Атрибут `PrincipalPermission` работает так же, как и роли.

Давайте покажем, как использовать атрибут `PrincipalPermission` в обработчиках событий `RowUpdating` и `RowDeleting` GridView, чтобы запретить выполнение несанкционированных пользователей. Все, что нам нужно сделать, — это добавить соответствующий атрибут в вершине каждого определения функции:

[!code-csharp[Main](role-based-authorization-cs/samples/sample13.cs)]

Атрибут обработчика событий `RowUpdating` указывает, что только пользователи в ролях Administrators или супервизоров могут выполнять обработчик событий, когда атрибут в обработчике событий `RowDeleting` ограничивает выполнение для пользователей в роли администраторов.

> [!NOTE]
> Атрибут `PrincipalPermission` представлен как класс в пространстве имен `System.Security.Permissions`. Не забудьте добавить оператор `using System.Security.Permissions` в верхней части файла класса программной части для импорта этого пространства имен.

Если, каким-либо образом, не являющимся администратором, пытается выполнить обработчик событий `RowDeleting` или если не является супервизором или не администратором пытается выполнить `RowUpdating` обработчик событий, среда выполнения .NET выдаст `SecurityException`.

[![если контекст безопасности не имеет прав для выполнения метода, создается исключение SecurityException](role-based-authorization-cs/_static/image47.png)](role-based-authorization-cs/_static/image46.png)

**Рис. 16**. Если контекст безопасности не имеет прав для выполнения метода, выдается `SecurityException` ([щелкните, чтобы просмотреть изображение с полным размером](role-based-authorization-cs/_static/image48.png))

Помимо страниц ASP.NET, многие приложения также имеют архитектуру, включающую различные уровни, такие как бизнес-логика и уровни доступа к данным. Эти уровни обычно реализуются как библиотеки классов и предлагают классы и методы для выполнения бизнес-логики и функций, связанных с данными. Атрибут `PrincipalPermission` полезен и для применения правил авторизации к этим слоям.

Дополнительные сведения об использовании атрибута `PrincipalPermission` для определения правил авторизации в классах и методах см. в записи блога [Скотта Гатри (](https://weblogs.asp.net/scottgu/) [Добавление правил авторизации к бизнес-слоям и уровням данных с помощью `PrincipalPermissionAttributes`](https://weblogs.asp.net/scottgu/archive/2006/10/04/Tip_2F00_Trick_3A00_-Adding-Authorization-Rules-to-Business-and-Data-Layers-using-PrincipalPermissionAttributes.aspx).

## <a name="summary"></a>Сводка

В этом учебнике мы рассмотрели, как задать грубые и детализированные правила авторизации на основе ролей пользователя. Сценарии. Функция авторизации URL-адресов в сети позволяет разработчику страницы указать, какие удостоверения разрешены или запрещены для доступа к страницам. Как мы видели в учебнике <a id="_msoanchor_10"> </a>по [*авторизации на основе пользователей*](../membership/user-based-authorization-cs.md) , правила авторизации URL-адресов можно применять к отдельным пользователям. Они также могут применяться к роли по ролям, как показано на шаге 1 этого руководства.

Правила авторизации точного детализации можно применять декларативно или программно. На этапе 2 мы рассматривали использование функции группы ролей элемента управления LoginView для отображения различных выходных данных на основе ролей пользователя. Мы также рассматривали способы программного определения того, принадлежит ли пользователь к определенной роли, и как соответствующим образом скорректировать функциональность страницы.

Поздравляем с программированием!

### <a name="further-reading"></a>Дополнительные сведения

Дополнительные сведения о разделах, обсуждаемых в этом руководстве, см. в следующих ресурсах:

- [Добавление правил авторизации к бизнес-слоям и уровням данных с помощью `PrincipalPermissionAttributes`](https://weblogs.asp.net/scottgu/archive/2006/10/04/Tip_2F00_Trick_3A00_-Adding-Authorization-Rules-to-Business-and-Data-Layers-using-PrincipalPermissionAttributes.aspx)
- [Изучение членства, ролей и профиля ASP.NET 2.0: работа с ролями](http://aspnet.4guysfromrolla.com/articles/121405-1.aspx)
- [Список контрольных вопросов для ASP.NET 2,0](https://msdn.microsoft.com/library/ms998375.aspx)
- [Техническая документация по элементу `<roleManager>`](https://msdn.microsoft.com/library/ms164660.aspx)

### <a name="about-the-author"></a>Об авторе

Скотт Митчелл, автор нескольких книг по ASP/ASP. NET и основатель 4GuysFromRolla.com, работал с веб-технологиями Майкрософт с 1998. Скотт работает как независимый консультант, преподаватель и модуль записи. Его последняя книга — *[Sams обучать себя ASP.NET 2,0 за 24 часа](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)* . Скотт можно получить по адресу [mitchell@4guysfromrolla.com](mailto:mitchell@4guysfromrolla.com) или через свой блог по адресу [http://ScottOnWriting.NET](http://scottonwriting.net/).

### <a name="special-thanks-to"></a>Особая благодарность...

Эта серия руководств была рассмотрена многими полезными рецензентами. Потенциальные рецензенты для этого руководства включают Сучи Банержи и Терезой Мерфи. Хотите ознакомиться с моими будущими статьями MSDN? Если да, расположите строку в [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](assigning-roles-to-users-cs.md)
> [Вперед](creating-and-managing-roles-vb.md)
