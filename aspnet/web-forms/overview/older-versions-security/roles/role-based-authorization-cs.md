---
uid: web-forms/overview/older-versions-security/roles/role-based-authorization-cs
title: Ролевая авторизация (C#) | Документация Майкрософт
author: rick-anderson
description: Этим руководством мы будем с рассмотрения как framework ролей связывает роли пользователя с его контекста безопасности. Затем он проверяет применение URL-адрес на основе ролей...
ms.author: riande
ms.date: 03/24/2008
ms.assetid: 4d9b63fa-c3d4-4e85-82b1-26ae3ba3ca1c
msc.legacyurl: /web-forms/overview/older-versions-security/roles/role-based-authorization-cs
msc.type: authoredcontent
ms.openlocfilehash: d0c58bcbcc294fa6fc7d194864a3e7b67356cf2c
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65133826"
---
# <a name="role-based-authorization-c"></a>Авторизация на основе ролей (C#)

по [Скотт Митчелл](https://twitter.com/ScottOnWriting)

[Скачать код](http://download.microsoft.com/download/6/0/3/6032582f-360d-4739-b935-38721fdb86ea/CS.11.zip) или [скачать PDF](http://download.microsoft.com/download/6/0/3/6032582f-360d-4739-b935-38721fdb86ea/aspnet_tutorial11_RoleAuth_cs.pdf)

> Этим руководством мы будем с рассмотрения как framework ролей связывает роли пользователя с его контекста безопасности. Затем он проверяет Практическое применение правил на основе ролей для авторизации URL-адрес. После того, что мы рассмотрим использование декларативные и программные средства для изменения данных, отображаемых и возможностей, предоставляемых страницы ASP.NET.

## <a name="introduction"></a>Вступление

В <a id="_msoanchor_1"> </a> [ *авторизации на основе пользователя* ](../membership/user-based-authorization-cs.md) учебнике мы рассмотрели использование авторизации URL-адреса для указания, какие пользователи могут посещать определенный набор страниц. С помощью лишь небольшой фрагмент разметки в `Web.config`, мы может указать, что разрешить только пользователям, прошедшим проверку страницы ASP.NET. Или мы могут диктовать, что был разрешен только пользователям Tito и Боб или указать, что были разрешены все прошедшие проверку пользователи, за исключением Sam.

В дополнение к авторизации URL-адреса мы также рассмотрели декларативные и программные методы для управления данным, отображаемым и возможностей, предоставляемых на основе пользователя посещении страницы. В частности мы создали страницу, перечислявшую содержимое текущего каталога. Любой пользователь может посетите эту страницу, но только пользователи, прошедшие проверку подлинности, может просматривать содержимое файлов и только Tito может удалить файлы.

Применение правил авторизации на основе пользователя по может увеличиваться в кошмар внутренних операций. Более удобное подходом является использование авторизации на основе ролей. Хорошо то, что средства в своем распоряжении, для применения правила авторизации работают одинаково хорошо с ролями, как и для учетных записей пользователей. Правила авторизации URL-адрес можно указать ролям, а не пользователи. Элемент управления LoginView, который отображает разные выходные данные для прошедшего проверку подлинности и анонимных пользователей, можно настроить для отображения разных содержимого на основе ролей пользователя, выполнившего. И роли API включает методы для определения роли пользователя, вошедшего в систему.

Этим руководством мы будем с рассмотрения как framework ролей связывает роли пользователя с его контекста безопасности. Затем он проверяет Практическое применение правил на основе ролей для авторизации URL-адрес. После того, что мы рассмотрим использование декларативные и программные средства для изменения данных, отображаемых и возможностей, предоставляемых страницы ASP.NET. Давайте начнем!

## <a name="understanding-how-roles-are-associated-with-a-users-security-context"></a>Основные сведения о ролях как связаны с контекст безопасности пользователя

Каждый раз, когда запрос входит в конвейер ASP.NET он связан с контекстом безопасности, который включает информацию, идентифицирующую запрашивающей стороне. При использовании проверки подлинности форм, билет проверки подлинности используется в качестве токен удостоверения. Как уже говорилось в <a id="_msoanchor_2"> </a> [ *Обзор аутентификации форм* ](../introduction/an-overview-of-forms-authentication-cs.md) и <a id="_msoanchor_3"> </a> [ *форм Настройка проверки подлинности и дополнительные разделы* ](../introduction/forms-authentication-configuration-and-advanced-topics-cs.md) руководства и `FormsAuthenticationModule` отвечает за определение удостоверение запрашивающего пользователя, это делается во время [ `AuthenticateRequest` событий](https://msdn.microsoft.com/library/system.web.httpapplication.authenticaterequest.aspx).

При обнаружении билет проверки подлинности допустимых, неистекшим сроком `FormsAuthenticationModule` декодирует его, чтобы выяснить, запрашивающего лица. Он создает новую `GenericPrincipal` и назначает для `HttpContext.User` объекта. Цель участника, такие как `GenericPrincipal`, необходимо определить имя пользователя вошедшего в систему и что она принадлежит к роли. Этой цели свидетельствует тот факт, что все объекты-участники имеют `Identity` свойство и `IsInRole(roleName)` метод. `FormsAuthenticationModule`, Однако не заинтересован в запись сведений о ролях и `GenericPrincipal` он создает объект не содержит каких-либо ролей.

Если роли framework включена, [ `RoleManagerModule` ](https://msdn.microsoft.com/library/system.web.security.rolemanagermodule.aspx) HTTP-модуль шаги после `FormsAuthenticationModule` и идентифицирует роли пользователя вошедшего в систему во время [ `PostAuthenticateRequest` событий](https://msdn.microsoft.com/library/system.web.httpapplication.postauthenticaterequest.aspx), который срабатывает после `AuthenticateRequest` событий. Если запрос поступил от прошедшего проверку пользователя, `RoleManagerModule` перезаписывает `GenericPrincipal` объект, созданный `FormsAuthenticationModule` и заменяет его с помощью [ `RolePrincipal` объект](https://msdn.microsoft.com/library/system.web.security.roleprincipal.aspx). `RolePrincipal` Класс использует интерфейс API ролей, чтобы определить, какие роли он принадлежит.

Рис. 1 изображена конвейерным рабочим процессом ASP.NET, при использовании проверки подлинности форм и платформой ролей. `FormsAuthenticationModule` Выполняется первым, определяет пользователя через ее билете проверки подлинности и создает новую `GenericPrincipal` объекта. Далее, `RoleManagerModule` шаги и перезаписывает `GenericPrincipal` со `RolePrincipal` объекта.

Если анонимный пользователь посещает сайт, ни `FormsAuthenticationModule` ни `RoleManagerModule` создается объект-участник.

[![События конвейера ASP.NET для прошедшего проверку подлинности пользователя при использовании проверки подлинности форм и платформой ролей](role-based-authorization-cs/_static/image2.png)](role-based-authorization-cs/_static/image1.png)

**Рис. 1**: События конвейера ASP.NET для проверки подлинности пользователя при использование проверки подлинности форм и ролей Framework ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image3.png))

### <a name="caching-role-information-in-a-cookie"></a>Сведений о ролях в файле Cookie

`RolePrincipal` Объекта `IsInRole(roleName)` вызовы методов `Roles.GetRolesForUser` для получения ролей для пользователя, чтобы определить, является ли пользователь членом *roleName*. При использовании `SqlRoleProvider`, в результате запроса к базе данных store роли. При использовании правил на основе ролей для авторизации URL-адрес `RolePrincipal`в `IsInRole` метод будет вызываться при каждом запросе к странице, который защищается правила авторизации URL-адрес на основе ролей. А не для поиска сведения о роли в базе данных при каждом запросе, платформа роли включает параметр, чтобы кэшировать ролей пользователя в файле cookie.

Если framework роли настроен для кэширования ролей пользователя в файле cookie, `RoleManagerModule` создает куки-файл во время конвейер ASP.NET [ `EndRequest` событий](https://msdn.microsoft.com/library/system.web.httpapplication.endrequest.aspx). Этот файл cookie используется в последующих запросах в `PostAuthenticateRequest`, когда это `RolePrincipal` создается объект. Если файл cookie является допустимым и не истек, данные в файле cookie анализируются и используются для заполнения ролей пользователя, предотвращая `RolePrincipal` от необходимости вызвать `Roles` класса для определения ролей пользователя. Рис. 2 показан этот рабочий процесс.

[![Сведения о роли пользователя могут храниться в файле Cookie для повышения производительности](role-based-authorization-cs/_static/image5.png)](role-based-authorization-cs/_static/image4.png)

**Рис. 2**: Пользователя роли сведения могут храниться в файле Cookie для повышения производительности ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image6.png))

По умолчанию механизм роли кэша cookie отключен. Его можно включить с помощью `<roleManager>` разметку настройки в `Web.config`. Мы рассмотрели [ `<roleManager>` элемент](https://msdn.microsoft.com/library/ms164660.aspx) для указания поставщиков ролей в <a id="_msoanchor_4"> </a> [ *Создание и управление ролями* ](creating-and-managing-roles-cs.md) руководства Поэтому этот элемент должен уже есть в вашем приложении `Web.config` файл. Параметры файлов cookie для кэша роли задаются в виде атрибутов `<roleManager>` элемент того они обобщены в таблице 1.

> [!NOTE]
> Параметры конфигурации, перечисленных в таблице 1 укажите свойства итоговый кэша cookie ролей. Дополнительные сведения в файлы cookie, как они работают и их различных свойств [учебнике файлы cookie](http://www.quirksmode.org/js/cookies.html).

| <strong>Property</strong> |                                                                                                                                                                                                                                                                                                                                                         <strong>Описание</strong>                                                                                                                                                                                                                                                                                                                                                          |
|---------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|   `cacheRolesInCookie`    |                                                                                                                                                                                                                                                                                                                              Логическое значение, указывающее, используется ли кэширование файлов cookie. По умолчанию — `false`.                                                                                                                                                                                                                                                                                                                              |
|       `cookieName`        |                                                                                                                                                                                                                                                                                                                                     Имя файла кэша cookie ролей. Значение по умолчанию — «. ASPXROLES».                                                                                                                                                                                                                                                                                                                                     |
|       `cookiePath`        |                                                                                                                                                                                                                                Путь к имени файла cookie ролей. Атрибут path позволяет разработчику для ограничения области действия файла cookie в иерархию определенного каталога. Значение по умолчанию — «/», который сообщает браузеру отправлять файл cookie для билета проверки подлинности на любой запрос, выполненных в домене.                                                                                                                                                                                                                                 |
|    `cookieProtection`     |                                                                                                                                                               Указывает, какие методы используются для защиты файла cookie кэша роли. Допустимые значения: `All` (по умолчанию); `Encryption`; `None`; и `Validation`. Вернитесь к шагу 3 <a id="_anchor_5"> </a> [ *конфигурацию проверки подлинности форм и дополнительные разделы* ](../introduction/forms-authentication-configuration-and-advanced-topics-cs.md) Дополнительные сведения об этих уровнях защиты.                                                                                                                                                                |
|    `cookieRequireSSL`     |                                                                                                                                                                                                                                                                                                   Логическое значение, указывающее, требуется ли SSL-подключения для передачи cookie проверки подлинности. Значение по умолчанию — `false`.                                                                                                                                                                                                                                                                                                   |
| `cookieSlidingExpiration` |                                                                                                                                                                                                                                                  Логическое значение, указывающее ли время ожидания файла cookie сбрасывается при каждом посещении сайта во время одного сеанса. Значение по умолчанию — `false`. Это значение относится только тогда, когда `createPersistentCookie` присваивается `true`.                                                                                                                                                                                                                                                  |
|      `cookieTimeout`      |                                                                                                                                                                                                                                                                         Время в минутах, после которого истекает срок файла cookie для билета проверки подлинности. Значение по умолчанию — `30`. Это значение относится только тогда, когда `createPersistentCookie` присваивается `true`.                                                                                                                                                                                                                                                                         |
| `createPersistentCookie`  |                                                                                                                                                                   Логическое значение, указывающее, является ли файл cookie кэша роли файл cookie или постоянный файл cookie. Если `false` (по умолчанию), используется файл cookie сеанса, который удаляется при закрытии браузера. Если `true`, используется постоянный файл cookie, срок его действия истекает `cookieTimeout` число минут после его создания или после предыдущего посещение, в зависимости от значения `cookieSlidingExpiration`.                                                                                                                                                                    |
|         `domain`          |                                                                                                                                                 Указывает значение домена файла cookie. Значение по умолчанию — пустая строка, которой, браузер будет использовать домен, из которого он выдан (например, www.yourdomain.com). В этом случае файл cookie будет <strong>не</strong> отправляться при отправке запросов в поддоменов, таких как admin.yourdomain.com. Если требуется, чтобы файл cookie передается все поддомены необходимо настроить `domain` атрибута, задав для него «yourdomain.com».                                                                                                                                                 |
|    `maxCachedResults`     | Указывает максимальное число имен ролей, кэшированные в файле cookie. Значение по умолчанию — 25. `RoleManagerModule` Не создает файл cookie для пользователей, принадлежащих к более чем `maxCachedResults` ролей. Следовательно `RolePrincipal` объекта `IsInRole` метод будет использовать `Roles` класса для определения ролей пользователя. Причина `maxCachedResults` существует так, как много агентов пользователя, они позволяют файлы cookie, размер которых превышает 4096 байт. Поэтому данное завершение отрезка предназначен для снижения вероятности превышения этого ограничения размера. Если имеются роли с очень длинными именами, может потребоваться рекомендуется указать меньшее `maxCachedResults` значением; contrariwise, если имена ролей крайне малую продолжительность, вы, вероятно, это значение можно увеличить. |

**Таблица 1.** Параметры конфигурации роли кэша файлов Cookie

Давайте настроим наше приложение, чтобы использовать файлы cookie временных роли кэша. Чтобы добиться этого, обновите `<roleManager>` элемент `Web.config` включать следующие атрибуты, связанные с куки-файл:

[!code-xml[Main](role-based-authorization-cs/samples/sample1.xml)]

Я обновил `<roleManager>` элемент, добавив три атрибута: `cacheRolesInCookie`, `createPersistentCookie`, и `cookieProtection`. Установив `cacheRolesInCookie` для `true`, `RoleManagerModule` теперь автоматически кэширует ролей пользователя в файле cookie, вместо того чтобы найти сведения о роли пользователя при каждом запросе. Явно задать `createPersistentCookie` и `cookieProtection` атрибуты к `false` и `All`, соответственно. С технической точки зрения мне не нужно указать значения для этих атрибутов, поскольку я просто назначить их значения по умолчанию, но я поставить их здесь явным образом очистить постоянные файлы cookie не используется и что файл cookie и шифруется и проверены.

Вот и все! Исходя из этого framework ролей будет кэшировать роль пользователя в файлах cookie. Если браузер пользователя поддерживает файлы cookie, или файлы cookie удалена или утеряна, каким-либо образом, это не проблема – `RolePrincipal` объект просто использует `Roles` класс в случае, что не куки-файл (или один из уже недействительны или просрочены) доступен.

> [!NOTE]
> Шаблоны корпорации Майкрософт &amp; рекомендации группа не рекомендует использовать файлы cookie сохраняемой роли кэша. Так как владение роли кэша cookie достаточно подтвердить членство в роли, если злоумышленник каким-то сможет получить доступ к файлу cookie является допустимым пользователем он может олицетворять этого пользователя. Вероятность такого события увеличивается, если куки-файл сохраняется в браузере пользователя. Дополнительные сведения об этой рекомендации безопасности, а также другие проблемы безопасности, см. [список вопросов безопасности для ASP.NET 2.0](https://msdn.microsoft.com/library/ms998375.aspx).

## <a name="step-1-defining-role-based-url-authorization-rules"></a>Шаг 1. Определение правил авторизации URL-адрес на основе ролей

Как уже говорилось в <a id="_msoanchor_6"> </a> [ *авторизации на основе пользователя* ](../membership/user-based-authorization-cs.md) учебнике Авторизация URL-адреса предоставляет средства для ограничения доступа к набор страниц пользователя на уровне пользователей или роли, роли основы. Правила авторизации URL-адрес выраженная в `Web.config` с помощью [ `<authorization>` элемент](https://msdn.microsoft.com/library/8d82143t.aspx) с `<allow>` и `<deny>` дочерних элементов. Помимо правил авторизации, связанный с пользователем, описанных в предыдущих учебных курсах каждая `<allow>` и `<deny>` дочерний элемент также может включать:

- Определенной роли
- Разделенный запятыми список ролей

Например правила авторизации URL-адрес предоставить доступ для тех пользователей в роли «Администраторы» и «руководители, но запретить доступ для всех других пользователей:

[!code-xml[Main](role-based-authorization-cs/samples/sample2.xml)]

`<allow>` Элемент в разметке выше в том, что роли «Администраторы» и «руководители разрешены; `<deny>` указывает элемент, который *все* пользователям запрещен.

Давайте настроим наше приложение, чтобы `ManageRoles.aspx`, `UsersAndRoles.aspx`, и `CreateUserWizardWithRoles.aspx` страницы доступны только для тех пользователей в роли "Администраторы", хотя `RoleBasedAuthorization.aspx` страницы будут оставаться доступными для всех посетителей.

Чтобы выполнить это, начнем с добавления `Web.config` файл `Roles` папки.

[![Добавьте файл Web.config в каталог роли](role-based-authorization-cs/_static/image8.png)](role-based-authorization-cs/_static/image7.png)

**Рис. 3**: Добавить `Web.config` файл `Roles` каталога ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image9.png))

Добавьте следующую разметку настройки к `Web.config`:

[!code-xml[Main](role-based-authorization-cs/samples/sample3.xml)]

`<authorization>` Элемент в `<system.web>` раздела указывает, что только пользователи в роли "Администраторы" могут получить доступ к ресурсам ASP.NET в `Roles` каталога. `<location>` Элемент определяет дополнительный набор правил авторизации URL-адрес для `RoleBasedAuthorization.aspx` странице, позволяя всем пользователям перейти на страницу.

После сохранения изменений в `Web.config`, войдите в систему как пользователь, который не находится в роли "Администраторы" и попробуйте войти на защищенных страницах на. `UrlAuthorizationModule` Обнаруживает, что у вас нет разрешения, чтобы перейти на запрошенный ресурс; следовательно, `FormsAuthenticationModule` вы будете перенаправлены на страницу входа. На страницу входа затем вы перейдете в `UnauthorizedAccess.aspx` страницы (см. рис. 4). Это окончательный перенаправление со страницы входа для `UnauthorizedAccess.aspx` возникает из-за кода, мы добавили на страницу входа в шаге 2 <a id="_msoanchor_7"> </a> [ *авторизации на основе пользователя* ](../membership/user-based-authorization-cs.md) руководства. В частности, перенаправляет на страницу входа каждому прошедшему проверку пользователю для `UnauthorizedAccess.aspx` Если строка запроса содержит `ReturnUrl` параметра, как этот параметр указывает, что пользователь попасть на страницу входа после попытка просмотреть страницу, он не был право просмотра.

[![Только пользователи, в роли "Администраторы" могут просматривать защищенные страницы](role-based-authorization-cs/_static/image11.png)](role-based-authorization-cs/_static/image10.png)

**Рис. 4**: Только пользователи в роли "Администраторы" могут просматривать защищенные страницы ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image12.png))

Выйдите из системы и войдите в систему как пользователь, который находится в роли "Администраторы". Теперь вы должны иметь возможность просматривать три защищенные страницы.

[![Посетите Tito UsersAndRoles.aspx страницы так как он находится в роли "Администраторы"](role-based-authorization-cs/_static/image14.png)](role-based-authorization-cs/_static/image13.png)

**Рис. 5**: Посетите Tito `UsersAndRoles.aspx` страницы так как он находится в роли "Администраторы" ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image15.png))

> [!NOTE]
> При указании правил авторизации URL-адрес — для роли или пользователи — важно Имейте в виду, что правила, проанализированных один за другим, сверху вниз. Как только соответствие найдено, пользователь будет разрешен или запрещен доступ, в зависимости от того, если соответствие найдено в `<allow>` или `<deny>` элемент. **Если совпадений не найдено, пользователю предоставляется доступ.** Следовательно, если вы хотите ограничить доступ к одной или нескольких учетных записей пользователей, крайне важно использовать `<deny>` элемент как последний элемент в конфигурации авторизации URL-адрес. **Если правила авторизации URL-адрес не включают**`<deny>`**элемент, всем пользователям будет предоставлен доступ.** Более глубокое обсуждение анализируются как правила авторизации URL-адрес, обращаться к «посвящена тому, как `UrlAuthorizationModule` использует правила авторизации, чтобы предоставить или запретить доступ» раздел <a id="_msoanchor_8"> </a> [  *Авторизация на основе пользователя* ](../membership/user-based-authorization-cs.md) руководства.

## <a name="step-2-limiting-functionality-based-on-the-currently-logged-in-users-roles"></a>Шаг 2. Ограничение функций в зависимости от текущего зарегистрированного пользователя роли

Делает авторизации URL-адрес, его можно легко указать грубое авторизации правила этого состояния какие удостоверения разрешены, и какие из них запрещен просмотр определенной страницы (или все страницы в папке и ее вложенных папок). Тем не менее в некоторых случаях нам может потребоваться разрешить всем пользователям посетите страницу, но ограничить функциональные возможности страницы, на основе ролей выполняется посещение пользователей. Возможно, придется Отображение или скрытие данных на основе роли пользователя или предлагают дополнительные возможности для пользователей, принадлежащих к определенной роли.

Можно реализовать таких правил авторизации на основе ролей высокогранулированных декларативно или программно (или через сочетание двух). В следующем разделе будет показано, как для реализации декларативной высокогранулированных авторизации с помощью элемента управления LoginView. После этого мы изучим программные методы. Прежде чем мы рассмотрим применение правил авторизации реализуя более точное, тем не менее, необходимо сначала создать, функциональность которого зависит от роли пользователя, посетив его страницу.

Давайте создадим страницу, которая перечисляет все учетные записи пользователей в системе в элементе управления GridView. GridView будет содержать имя пользователя, адрес электронной почты, Дата последнего входа и комментарии о пользователе каждого пользователя. Помимо отображения сведения о каждом пользователе, GridView, содержащих изменить и удалить возможности. Сначала мы создадим эту страницу с изменением и удалить функциональные возможности, доступные для всех пользователей. В разделах «Использование управления LoginView» и «Программным образом ограничивая функциональные возможности» будет показано, как включить или отключить эти функции, в зависимости от роли выполняется посещение пользователя.

> [!NOTE]
> Мы должны создавать страницы ASP.NET использует элемент управления GridView для отображения учетных записей пользователей. Так как в этом учебном курсе посвящены форм проверки подлинности, авторизации, учетные записи пользователей и ролей я не хочу тратить слишком много времени на обсуждение внутренней работы элемента управления GridView. Хотя этот учебник конкретных пошаговые инструкции по настройке этой страницы, он не подробно рассмотрены почему были внесены те или иные, или у определенных свойств эффекта в выводимых данных. Полное тестирование элемента управления GridView, см. Мой *[работа с данными в ASP.NET 2.0](../../data-access/index.md)* серии руководств.

Сначала откройте `RoleBasedAuthorization.aspx` странице в `Roles` папку. Перетащите элемент управления GridView из страницы в конструкторе и задайте его `ID` для `UserGrid`. Сейчас мы напишем код, который вызывает `Membership.GetAllUsers` метод и привязывает итоговый `MembershipUserCollection` объекта к GridView. `MembershipUserCollection` Содержит `MembershipUser` объект для каждой учетной записи пользователя в системе; `MembershipUser` объекты имеют свойства, такие как `UserName`, `Email`, `LastLoginDate`, и т. д.

Прежде чем мы написать код, который связывает учетные записи пользователей в сетку, давайте сначала определить поля GridView. Смарт-теге элемента GridView, щелкните ссылку «Изменить столбцы», чтобы открыть диалоговое окно поля (см. рис. 6). На этой странице снимите флажок «автоматически создавать поля» в левом нижнем углу. Поскольку мы хотим, чтобы этот GridView, чтобы включить редактирование и удаление возможностей, добавьте поле CommandField и задайте его `ShowEditButton` и `ShowDeleteButton` свойства значение true. Добавьте четыре поля для отображения `UserName`, `Email`, `LastLoginDate`, и `Comment` свойства. Использовать поле BoundField для двух свойств только для чтения (`UserName` и `LastLoginDate`) и CommandField два изменяемых полей (`Email` и `Comment`).

Первый отображались BoundField `UserName` свойство; набор его `HeaderText` и `DataField` свойства «Username». Это поле будут недоступны для изменения, поэтому задать его `ReadOnly` присваивается значение True. Настройка `LastLoginDate` BoundField, задав его `HeaderText` для «Последний вход» и его `DataField` для «LastLoginDate». Давайте отформатируем выходные данные этого типа BoundField, чтобы отображались только дата (а не дату и время). Для этого необходимо задать этот BoundField `HtmlEncode` значение False и его `DataFormatString` свойства "{0:d}«. Также задайте `ReadOnly` присваивается значение True.

Задать `HeaderText` свойства двух полей TemplateField для «Email» и «Комментарий».

[![Поля GridView можно настроить с помощью поля-диалоговое окно](role-based-authorization-cs/_static/image17.png)](role-based-authorization-cs/_static/image16.png)

**Рис. 6**: GridView поля могут быть настроены через поля-диалоговое окно ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image18.png))

Теперь нам нужно определить `ItemTemplate` и `EditItemTemplate` «Email» и «Комментарий» полей TemplateField. Добавьте элемент управления Label Web на каждый `ItemTemplate` s и привязки их `Text` свойства `Email` и `Comment` свойства, соответственно.

Для TemplateField «Email», добавьте текстовое поле с именем `Email` для его `EditItemTemplate` и привязать его `Text` свойства `Email` свойства с помощью двусторонней привязки данных. Добавьте RequiredFieldValidator и RegularExpressionValidator для `EditItemTemplate` чтобы убедиться, что посетителя, изменив свойство электронной почты ввел допустимый адрес электронной почты. TemplateField «Comment», добавьте в многострочном текстовом поле с именем `Comment` для его `EditItemTemplate`. Значение текстового поля `Columns` и `Rows` свойства 40 и 4, соответственно, а затем привязывают его `Text` свойства `Comment` свойства с помощью двусторонней привязки данных.

Настроив эти поля TemplateField, их декларативная разметка должен выглядеть следующим образом:

[!code-aspx[Main](role-based-authorization-cs/samples/sample4.aspx)]

При редактировании или удалении учетной записи пользователя, необходимо знать его `UserName` значение свойства. Значение элемента GridView `DataKeyNames` свойство «Username», чтобы эти сведения можно получить через GridView `DataKeys` коллекции.

Наконец, добавьте элемент управления ValidationSummary на страницу и задайте его `ShowMessageBox` присваивается значение True и его `ShowSummary` значение False. С этими параметрами ValidationSummary появится оповещение на стороне клиента, если пользователь пытается изменить учетную запись пользователя с электронным адресом отсутствует или недопустим.

[!code-aspx[Main](role-based-authorization-cs/samples/sample5.aspx)]

Теперь мы завершили декларативная разметка этой страницы. DAL следующей задачей является привязка набор учетных записей пользователей к GridView. Добавьте метод с именем `BindUserGrid` для `RoleBasedAuthorization.aspx` вспомогательного класса страницы, который привязывает `MembershipUserCollection` возвращаемые `Membership.GetAllUsers` для `UserGrid` GridView. Вызовите этот метод из `Page_Load` обработчик событий при первом посещении страницы.

[!code-csharp[Main](role-based-authorization-cs/samples/sample6.cs)]

Этот код в месте посетите страницу через обозреватель. Как показано на рис. 7, вы должны увидеть GridView, вывод сведений о каждой учетной записи пользователя в системе.

[![UserGrid GridView выводит сведения о каждом пользователе в системе](role-based-authorization-cs/_static/image20.png)](role-based-authorization-cs/_static/image19.png)

**Рис. 7**: `UserGrid` GridView Перечисляет сведения о каждый пользователь в системе ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image21.png))

> [!NOTE]
> `UserGrid` GridView перечисляет всех пользователей в невыгружаемом страничном интерфейс. Этот интерфейс простую сетку не подходит для сценариев, где есть несколько десятков или нескольких пользователей. Один из вариантов — Настройка GridView, чтобы включить разбиение на страницы. `Membership.GetAllUsers` Метод имеет две перегрузки: один, который не принимает никаких входных параметров и возвращает всех пользователей, а другая принимает целочисленные значения для индекса страницы и размера страницы и возвращает только определенное подмножество пользователей. Вторая перегрузка может использоваться для более эффективно разбивка на страницы пользователей, так как он возвращает только точные подмножества учетных записей пользователей вместо *все* из них. Если у вас есть тысячи учетных записей пользователей, рассмотрим интерфейс на основе фильтра, в один из них только этих пользователей, имена которых начинается с выделенного символа, например может потребоваться. [ `Membership.FindUsersByName method` ](https://msdn.microsoft.com/library/system.web.security.membership.findusersbyname.aspx) Идеально подходит для построения интерфейса пользователя на основе фильтра. Мы рассмотрим создание такого интерфейса в дальнейших учебных курсах.

Элемент управления GridView предоставляет встроенной поддержки правки и удаления при привязке элемента управления к элементу управления источником данных правильно настроенные, такие как SqlDataSource и ObjectDataSource. `UserGrid` GridView, тем не менее, есть данные программно привязал; таким образом, мы должны написать код для выполнения этих двух задач. В частности, необходимо создать обработчики событий для элемента GridView `RowEditing`, `RowCancelingEdit`, `RowUpdating`, и `RowDeleting` событий, которые срабатывают при щелчке элемента GridView изменение, Отмена, обновления, или удалить кнопки.

Начните с создания обработчиков событий для элемента GridView `RowEditing`, `RowCancelingEdit`, и `RowUpdating` события и затем добавьте следующий код:

[!code-csharp[Main](role-based-authorization-cs/samples/sample7.cs)]

`RowEditing` И `RowCancelingEdit` обработчики событий, просто задайте GridView `EditIndex` свойство и последующего повторного привязывания, список пользователей, учетных записей в сетке. Интересные вещи в происходит `RowUpdating` обработчик событий. Этот обработчик событий начинает, гарантируя, что данные, является допустимым и затем извлекает `UserName` значение измененного учетную запись из `DataKeys` коллекции. `Email` И `Comment` текстовые поля в двух полей TemplateField `EditItemTemplate` s будут использоваться далее программным способом. Их `Text` свойства содержат отредактированный электронный адрес и комментарий.

Чтобы обновить учетную запись пользователя через API членства, необходимо сначала получить информацию о пользователе, что выполняется через вызов `Membership.GetUser(userName)`. Возвращенный `MembershipUser` объекта `Email` и `Comment` свойства затем обновляются значения, вводимые в два текстовых поля из интерфейса правки. Наконец, эти изменения будут сохранены вместе с вызова [ `Membership.UpdateUser` ](https://msdn.microsoft.com/library/system.web.security.membership.updateuser.aspx). `RowUpdating` Завершает обработчик событий, возврат GridView на его интерфейс до редактирования.

Создайте `RowDeleting` обработчик событий и затем добавьте следующий код:

[!code-csharp[Main](role-based-authorization-cs/samples/sample8.cs)]

Выше обработчик событий начинает с получения `UserName` значение из элемента GridView `DataKeys` коллекции; это `UserName` значение затем передается в класс членства [ `DeleteUser` метод](https://msdn.microsoft.com/library/system.web.security.membership.deleteuser.aspx). `DeleteUser` Метод удаляет учетную запись пользователя из системы, включая членство в связанных данных (например, какие роли пользователь относится к). После удаления пользователя, сетке `EditIndex` устанавливается равным -1 (если пользователь щелкнул Delete, пока другая строка была в режиме редактирования) и `BindUserGrid` вызывается метод.

> [!NOTE]
> Кнопка "Удалить" не требует каких-либо подтверждения от пользователя перед удалением учетной записи пользователя. Я рекомендую добавить определенные виды подтверждение пользователя, чтобы уменьшить вероятность случайного удаления учетной записи. Одна из самых простых способов, чтобы подтвердить действие — через диалоговое окно подтверждения на стороне клиента. Дополнительные сведения об этом приеме см. в разделе [Добавление клиентского подтверждения при Идет удаление](https://asp.net/learn/data-access/tutorial-42-cs.aspx).

Убедитесь, что эта страница работает ожидаемым образом. Вы должны иметь возможность изменить адрес электронной почты любого пользователя и комментарий, а также удалить любой учетной записи пользователя. Так как `RoleBasedAuthorization.aspx` страница доступна для всех пользователей, любой пользователь, — даже анонимного посетители — Эта страница содержит и редактировать и удалять учетные записи пользователей! Давайте обновим эту страницу, чтобы только пользователи в роли «руководители» и «Администраторы могут редактировать адрес электронной почты пользователя и комментарий, и только администраторы могут удалять учетную запись пользователя.

В разделе «Использование управления LoginView» рассматривается использование элемента управления LoginView отображаются инструкции, относящиеся к роли пользователя. Если пользователь в роли "Администраторы" посещает эту страницу, мы покажем инструкции о том, как изменять и удалять пользователей. В роли руководителей по достижении этой странице, мы покажем инструкции по изменению пользователей. И если посетитель анонимна или не находится в роли администраторов или руководители, мы отобразит сообщение о том, что их нельзя изменять или удалять данные учетной записи пользователя. В разделе «Программным образом ограничивая функциональные возможности» мы напишем код, который программно показывает или скрывает кнопки изменения и удаления, на основе роли пользователя.

### <a name="using-the-loginview-control"></a>С помощью элемента управления LoginView

Как мы видели в предыдущих учебных курсах, элемент управления LoginView может использоваться для отображения разных интерфейсов для прошедшего проверку подлинности и анонимных пользователей, но элемент управления LoginView может также использоваться для отображения разную разметку в зависимости от роли пользователя. Давайте использовать элемент управления LoginView, для отображения различные инструкции на основе роли выполняется посещение пользователя.

Начните с добавления LoginView выше `UserGrid` GridView. Как уже указывалось ранее, элемент управления LoginView имеет два встроенных шаблонов: `AnonymousTemplate` и `LoggedInTemplate`. Введите краткое сообщение в эти шаблоны, которые пользователю нельзя изменить или удалить сведения о пользователях.

[!code-aspx[Main](role-based-authorization-cs/samples/sample9.aspx)]

В дополнение к `AnonymousTemplate` и `LoggedInTemplate`, может включать элемент управления LoginView *групп ролей*, которые являются шаблоны конкретной роли. Каждой группы ролей содержит одно свойство, `Roles`, которое указывает, какие роли, группы ролей применяется к. `Roles` Свойство можно задать для одной роли (например, «Администраторы») или разделенный запятыми список ролей (например, «Администраторы, руководители»).

Чтобы управлять групп ролей, щелкните ссылку «Изменить группы ролей» смарт-теге элемента управления на отображение редактора коллекций группы ролей. Добавьте две новые группы ролей. Значение первой группы ролей `Roles` свойство «Администраторы», а для «Руководители» второй.

[![Управление шаблонами конкретных ролей LoginView через редактор коллекции группы ролей](role-based-authorization-cs/_static/image23.png)](role-based-authorization-cs/_static/image22.png)

**Рис. 8**: Управление LoginView конкретной роли шаблонов через группы ролей редактор коллекции ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image24.png))

Нажмите кнопку ОК, чтобы закрыть редактор коллекции группы ролей; При этом обновляется LoginView декларативная разметка для включения `<RoleGroups>` раздел `<asp:RoleGroup>` дочерний элемент для каждой группы ролей определены в редакторе коллекции группы ролей. Кроме того, в раскрывающемся списке «Представления» списка в смарт-теге LoginView — которая изначально в списке только что `AnonymousTemplate` и `LoggedInTemplate` — теперь включает также добавлены группы ролей.

Изменение групп ролей, таким образом, пользователи с ролью руководителями отображаемые инструкции по изменению учетных записей пользователей, а пользователи в роли "Администраторы" отображаются инструкции для редактирования и удаления. После внесения этих изменений декларативная разметка вашей LoginView покажется следующего вида.

[!code-aspx[Main](role-based-authorization-cs/samples/sample10.aspx)]

После внесения этих изменений, сохраните страницу и затем посетите нас через браузер. Во-первых, посетите страницу как анонимный пользователь. Должно быть показано сообщение, «вы вошли в систему. Поэтому нельзя изменить или удалить сведения о пользователях.» Затем войдите в качестве пользователя, прошедшего проверку, но один, который не является ни в роли руководителями и не администраторы. Это время вы увидите сообщение «вы не является членом роли руководителями или Администраторы. Поэтому нельзя изменить или удалить сведения о пользователях.»

Затем войдите как пользователь, являющийся членом роли руководителями. Это время, вы должны увидеть руководителями конкретных ролей сообщения (см. рис. 9). И при входе в качестве пользователя в роль, вы должны увидеть конкретных ролей администраторов сообщения (см. рис. 10) администраторов.

[![Брюс отображается сообщение руководителями конкретных ролей](role-based-authorization-cs/_static/image26.png)](role-based-authorization-cs/_static/image25.png)

**Рис. 9**: Брюс отображается сообщение конкретных ролей руководители ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image27.png))

[![Tito отображается сообщение конкретных ролей администраторов](role-based-authorization-cs/_static/image29.png)](role-based-authorization-cs/_static/image28.png)

**Рис. 10**: Tito отображается сообщение конкретных ролей администраторов ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image30.png))

На снимках экрана, на рис. 9 и 10 show LoginView только выводит один шаблон, даже если применить несколько шаблонов. Брюс и Tito записываются в пользователей, но LoginView отображает только соответствующие группы ролей и не `LoggedInTemplate`. Кроме того Tito принадлежит к роли администраторов и руководителями, но элемент управления LoginView отображает шаблона конкретных ролей, администраторы не Супервизоров один.

Рис. 11 показан рабочий процесс, используемый элементом управления LoginView, чтобы определить, какой шаблон для подготовки к просмотру. Обратите внимание, что если имеется более одной группы ролей, LoginView шаблон визуализирует *первый* группы ролей, который соответствует. Другими словами Если мы помещен руководителями группу ролей в качестве первой группы ролей и администраторов как второй, затем при Tito посещения страницы он бы увидеть руководителями.

[![Элемент управления LoginView рабочего процесса для определения, какой шаблон визуализации](role-based-authorization-cs/_static/image32.png)](role-based-authorization-cs/_static/image31.png)

**Рис. 11**: Элемент управления LoginView рабочего процесса для определения что шаблона для отрисовки ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image33.png))

### <a name="programmatically-limiting-functionality"></a>Программно ограничение функций

Хотя элемент управления LoginView отображает различные инструкции на основе роли пользователя, посещающего страницу, кнопки изменения и отмены остаются видимыми для всех. Нам нужно программное скрытие кнопки изменения и удаления для анонимных пользователей и пользователей, которым назначена роль администраторов ни руководителями. Нам нужно скрыть кнопку Delete для всех, кто не является администратором. Для выполнения этой задачи мы напишем небольшой фрагмент кода, который программным образом ссылается на поля CommandField и редактирование и удаление элементов управления LinkButton и наборов их `Visible` свойства `false`и при необходимости.

Самый простой способ создавать программную ссылку на элементы управления в поле CommandField — преобразуйте его в шаблон. Для этого щелкните ссылку «Изменить столбцы» смарт-теге элемента GridView, выберите из списка текущего поля CommandField и щелкните ссылку «Преобразуйте это поле в TemplateField». Это превращает CommandField в поле TemplateField с `ItemTemplate` и `EditItemTemplate`. `ItemTemplate` Содержит изменение и удаление элементов управления LinkButton при `EditItemTemplate` содержит обновление и Отмена элементов управления LinkButton.

[![Преобразовать CommandField в поле TemplateField](role-based-authorization-cs/_static/image35.png)](role-based-authorization-cs/_static/image34.png)

**Рис. 12**: Преобразовать CommandField в TemplateField ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image36.png))

Обновление, изменение и удаление элементов управления LinkButton в `ItemTemplate`, задавая их `ID` свойства к значениям `EditButton` и `DeleteButton`, соответственно.

[!code-aspx[Main](role-based-authorization-cs/samples/sample11.aspx)]

Каждый раз, когда данные привязываются к GridView, GridView перечисляет записи в его `DataSource` свойства и создает соответствующий `GridViewRow` объекта. Так как каждое `GridViewRow` создается объект `RowCreated` события. Чтобы скрыть кнопки изменения и удаления для неуполномоченных пользователей, нам нужно создать обработчик событий для этого события и создавать программную ссылку на изменение и удаление элементов управления LinkButton, установка их `Visible` свойства соответствующим образом.

Создайте обработчик событий `RowCreated` событие и затем добавьте следующий код:

[!code-csharp[Main](role-based-authorization-cs/samples/sample12.cs)]

Имейте в виду, что `RowCreated` событие запускается для *все* строк GridView, включая заголовок, нижний колонтитул, интерфейс страничного навигатора и т. д. Нам нужно программно сослаться на изменение и удаление элементов управления LinkButton, если мы имеем дело с строку данных не в режиме правки (так как строки в режиме редактирования имеются кнопки "обновления" и "Отмена" вместо изменение и удаление). Эта проверка обрабатывается `if` инструкции.

Если мы имеем дело с строки данных, которая не находится в режиме редактирования, изменение и удаление элементов управления LinkButton указываются и их `Visible` свойства задаются на основании логического значения, возвращаемые методом `User` объекта `IsInRole(roleName)` метод. Объект пользователя ссылается на субъект, созданные `RoleManagerModule`; следовательно, `IsInRole(roleName)` метод использует интерфейс API ролей, чтобы определить, принадлежит ли текущий пользователь *roleName*.

> [!NOTE]
> Можно было бы использовать класс роли напрямую, заменив вызов `User.IsInRole(roleName)` вызовом [ `Roles.IsUserInRole(roleName)` метод](https://msdn.microsoft.com/library/system.web.security.roles.isuserinrole.aspx). Я решил использовать объект principal `IsInRole(roleName)` метод в этом примере так как он является более эффективным, чем напрямую с помощью API ролей. Ранее в этом руководстве мы настроили диспетчер ролей на кэширование ролей пользователя в файле cookie. Это кэшированные данные файла cookie используется только при участника `IsInRole(roleName)` вызывается метод; прямые вызовы API ролей всегда включают в себя обращения к хранилищу ролей. Даже если роли не кэшированы в файле cookie, вызывая объект principal `IsInRole(roleName)` метод обычно более эффективно, поскольку при ее вызове для первый раз во время запроса кэширует результаты. Интерфейс API ролей, с другой стороны, не выполнять кэширование. Так как `RowCreated` событие происходит один раз для каждой строки GridView, с помощью `User.IsInRole(roleName)` включает в себя лишь одного обращения к хранилищу ролей, тогда как `Roles.IsUserInRole(roleName)` требует *N* поездок, где *N* — количество учетных записей пользователей, отображаемое в сетке.

"Изменить" `Visible` свойству `true` значение, если пользователь, посетив эту страницу в роли администраторов или руководители; в противном случае он становится равным `false`. «Удалить» `Visible` свойству `true` только в том случае, если пользователь находится в роли "Администраторы".

Проверьте эту страницу через обозреватель. Если вы посетите страницу как посетитель анонимные или пользователя, не являющегося начальнику или администратор, CommandField пуст; по-прежнему существует, но как тонкие серебряный без изменения или удаления кнопки.

> [!NOTE]
> Можно скрыть CommandField полностью при отличном от администратора и без прав администратора посещении страницы. Оставить этот в качестве упражнения для чтения.

[![Изменить и удалить кнопки скрыты Non-руководителями и пользователи без прав администратора](role-based-authorization-cs/_static/image38.png)](role-based-authorization-cs/_static/image37.png)

**Рис. 13**: Изменить и удалить кнопки скрыты Non-руководителями и пользователи без прав администратора ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image39.png))

При посещении пользователем, к которому принадлежит к роли руководители (но не к роли "Администраторы"), он видит только "Изменить".

[![Несмотря на то доступен для руководителей кнопку Изменить, удалить кнопка скрыта](role-based-authorization-cs/_static/image41.png)](role-based-authorization-cs/_static/image40.png)

**Рис. 14**: Несмотря на то доступен для руководителей кнопку Изменить, удалить кнопка скрыта ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image42.png))

И если посещает администратора, у нее есть доступ к кнопки изменения и удаления.

[![Изменить и удалить кнопок, доступных только для администраторов](role-based-authorization-cs/_static/image44.png)](role-based-authorization-cs/_static/image43.png)

**Рис. 15**: Изменить и удалить кнопок, доступных только для администраторов ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image45.png))

## <a name="step-3-applying-role-based-authorization-rules-to-classes-and-methods"></a>Шаг 3. Применение правил авторизации на основе ролей для классов и методов

На шаге 2, мы ограничили изменение возможности для пользователей в роли «руководители» и «Администраторы и удаление только возможности для администраторов. Это осуществлялось путем скрытия элементов интерфейса пользователя для неавторизованных пользователей через программные методы. Такие меры не гарантируют неавторизованный пользователь не сможет выполнять привилегированные действия. Возможно, элементы пользовательского интерфейса, которые будут добавлены позже или что мы забыли скрыть для неавторизованных пользователей. Или злоумышленник может получить другим способом для получения страницы ASP.NET для выполнения нужного метода.

Чтобы убедиться, что конкретная часть функциональности может быть недоступна для несанкционированного удобно для оформления этого класса или метода с [ `PrincipalPermission` атрибут](https://msdn.microsoft.com/library/system.security.permissions.principalpermissionattribute.aspx). Когда среда выполнения .NET используется класс или выполняет одну из его методов, выполняется проверка того, что текущий контекст безопасности имеет разрешение. `PrincipalPermission` Атрибут предоставляет механизм, через который можно определить эти правила.

Мы рассмотрели применение `PrincipalPermission` атрибут в <a id="_msoanchor_9"> </a> [ *авторизации на основе пользователя* ](../membership/user-based-authorization-cs.md) руководства. В частности, мы узнали, как для оформления элемента GridView `SelectedIndexChanged` и `RowDeleting` обработчик событий, чтобы они может быть выполнена только прошедшие проверку подлинности пользователей и Tito, соответственно. `PrincipalPermission` Атрибут точно так же работает с ролями.

Давайте демонстрируют использование `PrincipalPermission` атрибут для элемента GridView `RowUpdating` и `RowDeleting` обработчики событий для запрещения выполнения несанкционированных пользователей. Нам нужно сделать всего лишь добавить соответствующий атрибут поверх каждое определение функции:

[!code-csharp[Main](role-based-authorization-cs/samples/sample13.cs)]

Атрибут для `RowUpdating` определяет обработчик событий, только пользователи с ролями администраторов или руководители могут выполнять обработчик событий, а в атрибуте `RowDeleting` обработчик событий ограничивает выполнение для пользователей в Администраторы роль.

> [!NOTE]
> `PrincipalPermission` Атрибут представлен как класс в `System.Security.Permissions` пространства имен. Не забудьте добавить `using System.Security.Permissions` инструкция в верхней части файла класса кода для импорта этого пространства имен.

Если каким-то образом без прав администратора пытается выполнить `RowDeleting` обработчик событий или если не контролер или без прав администратора пытается выполнить `RowUpdating` обработчик событий, которые будут вызывать среду выполнения .NET `SecurityException`.

[![Если контекст безопасности не авторизован для выполнения метода, то выдается SecurityException](role-based-authorization-cs/_static/image47.png)](role-based-authorization-cs/_static/image46.png)

**Рис. 16**: Если контекст безопасности не авторизован для выполнения метода, `SecurityException` возникает исключение ([Просмотр полноразмерного изображения](role-based-authorization-cs/_static/image48.png))

В дополнение к страницы ASP.NET многие приложения также имеют архитектуру, которая включает в себя различные уровни, такие как бизнес-логики и уровни доступа к данным. Эти уровни обычно реализуются как библиотеки классов и предоставляют классы и методы для выполнения бизнес-логики и связанные данные функции. `PrincipalPermission` Атрибут полезен для применения правила авторизации для этих уровней, а также.

Дополнительные сведения об использовании `PrincipalPermission` атрибут для определения правил авторизации на классы и методы, см. [Скотт Гатри](https://weblogs.asp.net/scottgu/)на запись в блоге [добавления правила авторизации для бизнеса и слои с помощью `PrincipalPermissionAttributes` ](https://weblogs.asp.net/scottgu/archive/2006/10/04/Tip_2F00_Trick_3A00_-Adding-Authorization-Rules-to-Business-and-Data-Layers-using-PrincipalPermissionAttributes.aspx).

## <a name="summary"></a>Сводка

В этом руководстве мы рассмотрели способы указания грубое и реализуя более точное правил авторизации на основании ролей пользователя. ASP. Функция авторизации URL-адрес NET позволяет разработчику указать, какие удостоверения разрешен или запрещен доступ к какие страницы. Как мы видели в <a id="_msoanchor_10"> </a> [ *авторизации на основе пользователя* ](../membership/user-based-authorization-cs.md) учебника, авторизация URL-адреса, правила могут применяться на основе пользователя по. Они могут также применяться на основе ролей, роли, как мы видели в шаге 1 этого руководства.

Реализуя более точное правила авторизации могут применяться декларативно или программно. На шаге 2 мы рассмотрели с помощью элемента управления LoginView групп ролей функции для отображения разных выходных данных, на основе ролей выполняется посещение пользователей. Мы также рассмотрели способы программно определять, если пользователь принадлежит к определенной роли и как настроить функциональные возможности страницы, соответствующим образом.

Счастливого вам программирования!

### <a name="further-reading"></a>Дополнительные сведения

Дополнительные сведения по темам, обсуждавшимся в этом руководстве см. в следующих ресурсах:

- [Добавление к бизнесу и уровни данных с помощью правил авторизации `PrincipalPermissionAttributes`](https://weblogs.asp.net/scottgu/archive/2006/10/04/Tip_2F00_Trick_3A00_-Adding-Authorization-Rules-to-Business-and-Data-Layers-using-PrincipalPermissionAttributes.aspx)
- [Изучение ASP.NET 2.0 членства, ролей и профиля: Работа с ролями](http://aspnet.4guysfromrolla.com/articles/121405-1.aspx)
- [Список вопросов безопасности для ASP.NET 2.0](https://msdn.microsoft.com/library/ms998375.aspx)
- [Техническая документация по `<roleManager>` элемент](https://msdn.microsoft.com/library/ms164660.aspx)

### <a name="about-the-author"></a>Об авторе

Скотт Митчелл, автор нескольких книг по ASP/ASP.NET и основатель веб-узла 4GuysFromRolla.com, работает с веб-технологиями Microsoft с 1998 года. Скотт — независимый консультант, преподаватель и автор. Его последняя книга —  *[Sams Teach ASP.NET 2.0 in 24 часа](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)*. Скоттом можно связаться по адресу [ mitchell@4guysfromrolla.com ](mailto:mitchell@4guysfromrolla.com) или через его блог по адресу [ http://ScottOnWriting.NET ](http://scottonwriting.net/).

### <a name="special-thanks-to"></a>Особая благодарность

В этой серии руководств пособий рецензировалась многими компетентными редакторами. Лиз Шалок в этом руководстве включают Банерджи Suchi и Терезой Мерфи. Хотите поработать с моих последующих статей для MSDN? Если Да, напишите мне [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)

> [!div class="step-by-step"]
> [Назад](assigning-roles-to-users-cs.md)
> [Вперед](creating-and-managing-roles-vb.md)
