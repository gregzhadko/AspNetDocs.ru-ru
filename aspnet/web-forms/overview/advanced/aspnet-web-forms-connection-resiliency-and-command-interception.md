---
uid: web-forms/overview/advanced/aspnet-web-forms-connection-resiliency-and-command-interception
title: ASP.NET устойчивость подключения веб-форм и перехват команд | Документация Майкрософт
author: Erikre
description: В этом учебнике описывается, как изменить пример приложения для поддержки устойчивости подключения и перехвата команд.
ms.author: riande
ms.date: 03/31/2014
ms.assetid: 6d497001-fa80-4765-b4cc-181fe90b894e
msc.legacyurl: /web-forms/overview/advanced/aspnet-web-forms-connection-resiliency-and-command-interception
msc.type: authoredcontent
ms.openlocfilehash: 95f0b5635c12d5ef88622e5766c1278c6570dd4d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78484236"
---
# <a name="aspnet-web-forms-connection-resiliency-and-command-interception"></a>Устойчивость подключений и перехват команд в веб-формах ASP.NET

по [Эрик Реитан](https://github.com/Erikre)

В этом руководстве вы измените пример приложения Wingtip Toys для поддержки устойчивости подключения и перехвата команд. При включении устойчивости подключения пример приложения Wingtip Toys автоматически повторяет вызовы данных, когда происходят временные ошибки, типичные для облачной среды. Кроме того, при реализации перехвата команд приложение Wingtip Toys будет перехватывать все запросы SQL, отправленные в базу данных, для их записи в журнал или изменения.

> [!NOTE] 
> 
> Этот учебник по веб-формам основан на следующем учебнике по MVC Tom Dykstra):  
> [Устойчивость к подключению и перехват команд с помощью Entity Framework в приложении ASP.NET MVC](../../../mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application.md)

## <a name="what-youll-learn"></a>Из этого руководства вы узнаете, как выполнять такие задачи:

- Как обеспечить устойчивость подключения.
- Как реализовать перехват команд.

## <a name="prerequisites"></a>предварительные требования

Прежде чем начать, убедитесь, что на компьютере установлено следующее программное обеспечение:

- [Microsoft Visual Studio 2013](https://www.microsoft.com/visualstudio/11/downloads#vs) или [Microsoft Visual Studio Express 2013 для Web](https://www.microsoft.com/visualstudio/11/downloads#express-web). .NET Framework устанавливается автоматически.
- Пример проекта Wingtip Toys, который позволяет реализовать функциональные возможности, упомянутые в этом руководстве, в проекте Wingtip Toys. Ниже приведена ссылка на сведения о скачивании.

    - [Начало работы с веб-формами ASP.NET 4.5.1 — Wingtip Toys](https://go.microsoft.com/fwlink/?LinkID=389434&amp;clcid=0x409) (C#)
- Прежде чем приступать к работе с этим руководством, просмотрите связанные серии руководств, [Начало работы с веб-формами ASP.NET 4,5 и Visual Studio 2013](../getting-started/getting-started-with-aspnet-45-web-forms/introduction-and-overview.md). Серия руководств поможет вам ознакомиться с проектом и кодом **WingtipToys** .

## <a name="connection-resiliency"></a>Устойчивость подключения

При развертывании приложения в Windows Azure следует рассмотреть возможность развертывания базы данных в **базе данных SQL** **Windows** Azure, облачной службе базы данных. Ошибки временного подключения обычно чаще возникают при подключении к облачной службе базы данных, чем когда веб-сервер и сервер базы данных напрямую соединяются друг с другом в одном центре обработки данных. Даже если облачный веб-сервер и облачная служба базы данных размещаются в одном центре обработки данных, между ними есть больше сетевых подключений, которые могут иметь проблемы, такие как подсистемы балансировки нагрузки.

Кроме того, облачная служба обычно совместно используется другими пользователями. Это означает, что их скорость реагирования может быть затронута. А доступ к базе данных может регулироваться. Регулирование означает, что служба базы данных создает исключения при попытке доступа к ней чаще, чем разрешено в *соглашение об уровне обслуживания* (SLA).

Многие или большинство проблем с подключением, возникающих при доступе к облачной службе, являются временными, то есть они разрешаются в течение короткого периода времени. Поэтому при попытке выполнить операцию базы данных и получить тип ошибки, которая обычно является временной, можно повторить операцию после короткого ожидания, и операция может быть выполнена успешно. Вы можете предоставить пользователям гораздо больше возможностей, если вы обрабатываете временные ошибки, автоматически повторяя попытку, делая большинство из них невидимыми для клиента. Функция устойчивости подключений в Entity Framework 6 автоматизирует процесс повторного выполнения запросов SQL.

Для конкретной службы базы данных необходимо соответствующим образом настроить функцию устойчивости подключений.

1. Он должен определять, какие исключения, вероятно, будут временными. Необходимо повторить ошибки, вызванные временной потерей подключения к сети, а не ошибки, вызванные ошибками в программе, например.
2. Время между повторными попытками неудачной операции должно дожидаться соответствующего времени. Можно подождать больше времени между попытками пакетной обработки, чем веб-страница в Интернете, где пользователь ожидает ответа.
3. Необходимо повторить необходимое количество раз, прежде чем оно будет выдаваться. Может потребоваться повторить попытку в пакетном процессе, который будет находиться в интерактивном приложении.

Эти параметры можно настроить вручную для любой среды базы данных, поддерживаемой поставщиком Entity Framework.

Чтобы включить устойчивость к подключению, достаточно создать класс в сборке, производной от класса `DbConfiguration`, и в этом классе задать стратегию выполнения базы данных SQL, которая в Entity Framework является еще одним термином для политики повтора.

### <a name="implementing-connection-resiliency"></a>Реализация устойчивости подключений

1. Скачайте и откройте пример приложения веб-форм [WingtipToys](https://go.microsoft.com/fwlink/?LinkID=389434&amp;clcid=0x409) в Visual Studio.
2. В папке *Logic* приложения **WingtipToys** добавьте файл класса с именем *WingtipToysConfiguration.CS*.
3. Замените текст запроса следующим кодом.  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample1.cs)]

Entity Framework автоматически выполняет код, найденный в классе, производном от `DbConfiguration`. Класс `DbConfiguration` можно использовать для задания конфигурации в коде, который в противном случае можно было бы сделать в файле *Web. config* . Дополнительные сведения см. в разделе [EntityFramework Code-based Configuration](https://msdn.microsoft.com/data/jj680699).

1. В папке *Logic* откройте файл *AddProducts.CS* .
2. Добавьте оператор `using` для `System.Data.Entity.Infrastructure`, как показано в желтом тексте:  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample2.cs?highlight=6)]
3. Добавьте блок `catch` в метод `AddProduct`, чтобы `RetryLimitExceededException` был зарегистрирован желтым цветом:   

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample3.cs?highlight=14-15,17-22)]

Добавив исключение `RetryLimitExceededException`, можно обеспечить лучшее ведение журнала или отобразить сообщение об ошибке пользователю, где он может повторить попытку выполнения процесса. При перехвате исключения `RetryLimitExceededException`, вероятнее всего, все ошибки, которые, вероятно, являются временными, будут уже выполнены и завершились несколько раз. Действительное возвращаемое исключение будет заключено в исключение `RetryLimitExceededException`. Кроме того, вы также добавили общий блок catch. Дополнительные сведения об исключении `RetryLimitExceededException` см. в разделе [Entity Frameworkная логика устойчивости и повторных попыток подключения](https://msdn.microsoft.com/data/dn456835).

## <a name="command-interception"></a>Перехват команд

Теперь, когда вы включили политику повтора, как проверить, работает ли она должным образом? Не так просто принудительно выполнять временную ошибку, особенно если вы работаете локально, и вам было бы очень сложно интегрировать фактические временные ошибки в автоматизированный модульный тест. Чтобы протестировать функцию устойчивости подключений, необходим способ перехвата запросов, которые Entity Framework отправляется в SQL Server, и замены SQL Server ответа на тип исключения, который обычно является временным.

Можно также использовать перехват запросов, чтобы реализовать оптимальную методику для облачных приложений: регистрировать задержку и успех или неудачу всех вызовов внешних служб, таких как службы баз данных.

В этом разделе руководства вы будете использовать [*функцию перехвата*](https://msdn.microsoft.com/data/dn469464) Entity Framework как для ведения журнала, так и для моделирования временных ошибок.

### <a name="create-a-logging-interface-and-class"></a>Создание интерфейса и класса ведения журнала

Рекомендуется выполнять ведение журнала, используя [`interface`](https://msdn.microsoft.com/library/ms173156.aspx) , а не вызовы с жестким кодированием `System.Diagnostics.Trace` или класс ведения журнала. Это упрощает изменение механизма ведения журнала в дальнейшем, если вам когда-либо потребуется это сделать. Итак, в этом разделе вы создадите интерфейс ведения журнала и класс для его реализации.

В соответствии с описанной выше процедурой вы скачали и открыли пример приложения **WingtipToys** в Visual Studio.

1. Создайте папку в проекте **WingtipToys** и назовите ее *Logging*.
2. В папке *Logging* создайте файл класса с именем *ILogger.CS* и замените код по умолчанию следующим кодом:  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample4.cs)]

   Интерфейс предоставляет три уровня трассировки для указания относительной важности журналов, и один предназначен для предоставления сведений о задержке для вызовов внешних служб, таких как запросы к базе данных. Методы ведения журнала имеют перегрузки, которые позволяют передавать исключение. Это значит, что сведения об исключении, включая трассировку стека и внутренние исключения, надежно регистрируются классом, реализующим интерфейс, вместо того, чтобы полагаться на него в каждом вызове метода ведения журнала в рамках всего приложения.  
  
   Методы `TraceApi` позволяют контролировать задержку каждого вызова к внешней службе, такой как база данных SQL.
3. В папке *Logging* создайте файл класса с именем *Logger.CS* и замените код по умолчанию следующим кодом:  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample5.cs)]

Для трассировки в реализации используется `System.Diagnostics`. Это встроенная функция .NET, которая позволяет легко создавать и использовать сведения трассировки. Существует много прослушивателей &quot;&quot; можно использовать с трассировкой `System.Diagnostics`, для записи журналов в файлы, например, или для записи их в хранилище BLOB-объектов в Windows Azure. Ознакомьтесь с некоторыми вариантами и ссылками на другие ресурсы, чтобы получить дополнительные сведения об [устранении неполадок веб-сайтов Windows Azure в Visual Studio](https://docs.microsoft.com/azure/app-service-web/web-sites-dotnet-troubleshoot-visual-studio). В этом учебнике будут рассмотрены только журналы в окне **вывода** Visual Studio.

В рабочем приложении можно использовать платформы трассировки, отличные от `System.Diagnostics`, а интерфейс `ILogger` позволяет относительно легко переключиться на другой механизм трассировки, если вы решили это сделать.

### <a name="create-interceptor-classes"></a>Создание классов перехватчиков

Далее предстоит создать классы, которые будут вызываться Entity Framework каждый раз, когда он отправляет запрос в базу данных, один для имитации временных ошибок и один для ведения журнала. Эти классы перехватчика должны быть производными от класса `DbCommandInterceptor`. В них написаны переопределения методов, которые автоматически вызываются при выполнении запроса. В этих методах можно проверить или зарегистрировать запрос, отправляемый в базу данных, а также изменить запрос перед его отправкой в базу данных или вернуть что-либо в Entity Framework, не передавая запрос в базу данных.

1. Чтобы создать класс перехватчика, который будет регистрировать каждый SQL-запрос перед его отправкой в базу данных, создайте файл класса с именем *InterceptorLogging.CS* в папке *Logic* и замените код по умолчанию следующим кодом:  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample6.cs)]

   Для успешных запросов или команд этот код записывает журнал сведений со сведениями о задержке. Для исключений создается журнал ошибок.
2. Чтобы создать класс перехватчика, который будет создавать фиктивные временные ошибки при вводе &quot;Throw&quot; в текстовом поле **Name** на странице с именем *админпаже. aspx*, создайте файл класса с именем *InterceptorTransientErrors.CS* в папке *Logic* и замените код по умолчанию следующим кодом:  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample7.cs)]

    Этот код переопределяет только метод `ReaderExecuting`, который вызывается для запросов, которые могут возвращать несколько строк данных. Если вы хотите проверить устойчивость подключения для других типов запросов, можно также переопределить методы `NonQueryExecuting` и `ScalarExecuting`, как это делает перехватчик ведения журнала.  
  
   Позже вы выполните вход в качестве администратора и щелкните ссылку **Администратор** на верхней панели навигации. Затем на странице *админпаже. aspx* вы добавите продукт с именем &quot;вызовите&quot;. Код создает фиктивное исключение базы данных SQL для ошибки с номером 20, обычно тип является временным. Другие номера ошибок, в настоящее время распознаваемые как временные, — 64, 233, 10053, 10054, 10060, 10928, 10929, 40197, 40501 и 40613, но они могут быть изменены в новых версиях базы данных SQL. Продукт будет переименован в "Трансиентеррорексампле", который можно выполнить в коде файла *InterceptorTransientErrors.CS* .  
  
   Код возвращает исключение, Entity Framework вместо выполнения запроса и передачи результатов. Временное исключение возвращается *четыре* раза, а затем код возвращается к нормальной процедуре передачи запроса в базу данных.

    Так как все заносится в журнал, вы сможете увидеть, что Entity Framework пытается выполнить запрос четыре раза, прежде чем он будет завершен, и единственное различие в приложении заключается в том, что для отображения страницы с результатами запроса требуется больше времени.  
  
   Количество повторных попыток, которое Entity Framework будет доступно для настройки; код указывает четыре раза, так как это значение по умолчанию для политики выполнения базы данных SQL. При изменении политики выполнения также изменяется код, указывающий, сколько раз создаются временные ошибки. Можно также изменить код, чтобы создать больше исключений, чтобы Entity Framework выдаст исключение `RetryLimitExceededException`.
3. В *Global. asax*добавьте следующие операторы using:  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample8.cs)]
4. Затем добавьте выделенные строки в метод `Application_Start`:  

    [!code-csharp[Main](aspnet-web-forms-connection-resiliency-and-command-interception/samples/sample9.cs?highlight=17-20)]

Эти строки кода приводят к тому, что код перехватчика будет выполняться, когда Entity Framework отправляет запросы в базу данных. Обратите внимание, что, поскольку вы создали отдельные классы перехватчиков для моделирования временных ошибок и ведения журнала, вы можете независимо включать и отключать их.   
  
 Перехватчики можно добавлять с помощью метода `DbInterception.Add` в любом месте кода; Он не должен находиться в методе `Application_Start`. Другой вариант, если вы не добавили перехватчики в метод `Application_Start`, должен обновить или добавить класс с именем *WingtipToysConfiguration.CS* и поместить приведенный выше код в конец конструктора класса `WingtipToysConfiguration`.

При помещении этого кода следует избегать выполнения `DbInterception.Add` для одного перехватчика более одного раза или получить дополнительные экземпляры перехватчика. Например, если вы добавите перехватчик записи в журнал дважды, то увидите два журнала для каждого запроса SQL.

Перехватчики выполняются в порядке регистрации (порядок, в котором вызывается метод `DbInterception.Add`). Порядок может быть важен в зависимости от того, что вы делаете в перехватчике. Например, перехватчик может изменить команду SQL, которую он получает в свойстве `CommandText`. Если команда SQL изменилась, следующий перехватчик вернет команду SQL, а не исходную команду SQL.

Вы написали код моделирования временной ошибки таким образом, который позволяет вызывать временные ошибки, вводя другое значение в пользовательском интерфейсе. В качестве альтернативы можно написать код перехватчика, чтобы всегда создавать последовательность временных исключений без проверки конкретного значения параметра. Затем можно добавить перехватчик, только если нужно создать временные ошибки. Однако при этом не добавляйте перехватчик до завершения инициализации базы данных. Иными словами, перед созданием временных ошибок выполните по крайней мере одну операцию с базой данных, например запрос к одному из наборов сущностей. Entity Framework выполняет несколько запросов во время инициализации базы данных и не выполняется в транзакции, поэтому ошибки во время инициализации могут привести к несогласованному состоянию контекста.

## <a name="test-logging-and-connection-resiliency"></a>Ведение журнала тестирования и устойчивость подключения

1. В Visual Studio нажмите клавишу **F5** , чтобы запустить приложение в режиме отладки, а затем войдите в систему как "admin", используя "Pa $ $Word" в качестве пароля.
2. В верхней части панели навигации выберите **Администратор** .
3. Введите новый продукт с именем "Throw" с соответствующим описанием, ценой и файлом изображения.
4. Нажмите кнопку **Добавить продукт** .  
   Вы заметите, что браузер перестает отвечать на несколько секунд, а Entity Framework повторяет запрос несколько раз. Первая повторная попытка происходит очень быстро, а затем время ожидания увеличивается до каждой дополнительной попытки. Этот процесс ожидания перед каждой повторной попыткой называется *экспоненциальной* задержкой.
5. Подождите, пока страница не попытается загрузиться.
6. Чтобы просмотреть выходные данные трассировки, закройте проект и просмотрите окно **вывода** Visual Studio. Окно **вывод** можно найти, выбрав **отладка** -&gt; **Windows** -&gt; **выходные данные**. Возможно, потребуется прокрутить несколько журналов, записанных средством ведения журнала.  
  
   Обратите внимание, что можно увидеть фактические SQL запросы, отправленные в базу данных. Вы увидите некоторые начальные запросы и команды, которые Entity Framework приступить к работе, проверяя версию базы данных и таблицу журнала миграции.   
    ![Окно вывода](aspnet-web-forms-connection-resiliency-and-command-interception/_static/image1.png)   
   Обратите внимание, что этот тест нельзя повторить, пока приложение не будет перезапущено. Если вы хотите иметь возможность проверить устойчивость подключения несколько раз в одном запуске приложения, можно написать код для сброса счетчика ошибок в `InterceptorTransientErrors`.
7. Чтобы увидеть разницу в стратегии выполнения (политика повтора), закомментируйте `SetExecutionStrategy`ную строку в файле *WingtipToysConfiguration.CS* в папке *Logic* , снова запустите страницу **администрирования** в режиме отладки и добавьте продукт с именем &quot;повторно создать&quot;.  
  
   На этот раз отладчик останавливается на первом созданном исключении сразу же после того, как он пытается выполнить запрос в первый раз.  
    ![Отладка-Просмотр сведений](aspnet-web-forms-connection-resiliency-and-command-interception/_static/image2.png)
8. Раскомментируйте `SetExecutionStrategy` строку в файле *WingtipToysConfiguration.CS* .

## <a name="summary"></a>Сводка

В этом учебнике вы узнали, как изменить пример приложения Web Forms для поддержки устойчивости подключения и перехвата команд.

## <a name="next-steps"></a>Next Steps

После проверки устойчивости подключения и перехвата команд в веб-формах ASP.NET просмотрите [асинхронные методы в](../performance-and-caching/using-asynchronous-methods-in-aspnet-45.md)разделе ASP.NET Web Forms в ASP.NET 4,5. В разделе рассматриваются основы создания асинхронного приложения веб-форм ASP.NET с помощью Visual Studio.
