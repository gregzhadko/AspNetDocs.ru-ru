---
uid: whitepapers/whats-new-in-aspnet-45-and-visual-studio-2012
title: Что нового в ASP.NET 4.5 и Visual Studio 2012 Документы Майкрософт
author: rick-anderson
description: В этом документе описаны новые функции и усовершенствования, которые внедряются в ASP.NET 4.5. Он также описывает улучшения, внесенные для веб-разработки ...
ms.author: riande
ms.date: 02/29/2012
ms.assetid: ba1fabb4-31a3-4ebf-8327-41a6bbba6eaf
msc.legacyurl: /whitepapers/whats-new-in-aspnet-45-and-visual-studio-2012
msc.type: content
ms.openlocfilehash: 32fbf7c25b00f3f0796c4c3fdd38ca2a86c89199
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675889"
---
# <a name="whats-new-in-aspnet-45-and-visual-studio-2012"></a>Новые возможности ASP.NET 4.5 и Visual Studio 2012

> В этом документе описаны новые функции и усовершенствования, которые внедряются в ASP.NET 4.5. В нем также описывается улучшение, сделанное для веб-разработки в Visual Studio 2012. Этот документ был первоначально опубликован 29 февраля 2012 года.

- [ASP.NET основные программы выполнения и рамки](#_Toc318097372)

    - [Асинхронно чтение и написание запросов и ответов HTTP](#_Toc318097373)
    - [Улучшения обработки httprequest](#_Toc318097374)
    - [Асинхронно промывка ответ](#_Toc318097375)
    - [Поддержка *ожидания* и *задачи*- на основе асинхронных модулей и обработчиков](#_Toc318097376)
    - [Асинхронные модули HTTP](#_Toc318097377)
    - [Асинхронные обработчики HTTP](#_Toc318097378)
    - [Новые функции проверки ASP.NET запроса](#_Toc318097379)
    - [Отложенная ("ленивая") проверка запроса](#_Toc318097380)
    - [Поддержка непроверенных запросов](#_Toc318097381)
    - [Библиотека AntiXSS](#_Toc318097382)
    - [Поддержка протокола WebSockets](#_Toc318097383)
    - [Комплектация и минификация](#_Toc318097384)
    - [Улучшения производительности для веб-хостинга](#_Toc_perf)

        - [Ключевые факторы производительности](#_Toc_perf_1)
        - [Требования к новым функциям производительности](#_Toc_perf_2)
        - [Обмен общими собраниями](#_Toc_perf_3)
        - [Использование многоъядерной компиляции JIT для более быстрого запуска](#_Toc_perf_4)
        - [Настройка сбора мусора для оптимизации памяти](#_Toc_perf_5)
        - [Предварительная подготовка для веб-приложений](#_Toc_perf_6)
- [ASP.NET веб-формы](#_Toc318097385)

    - [Строго типизированные элементы управления данными](#_Toc318097386)
    - [Привязка модели](#_Toc318097387)

        - [Выбор данных](#_Toc318097388)
        - [Поставщики ценностей](#_Toc318097389)
        - [Фильтрация по значениям из элемента управления](#_Toc318097390)
    - [HTML закодированные выражения связывания данных](#_Toc318097391)
    - [Ненавязчивая проверка](#_Toc318097392)
    - [Обновления HTML5](#_Toc318097393)
- [ASP.NET MVC 4](#_Toc318097394)
- [Веб-страницы ASP.NET 2](#_Toc318097395)
- [Визуальная студия 2012 Релиз Кандидат](#_Toc318097396)

    - [Совместное использование проекта между visual Studio 2010 и Visual Studio 2012 Кандидат на выпуск (совместимость проекта)](#project-compatibility)
    - [Изменения конфигурации в ASP.NET 4.5 шаблоны веб-сайта](#Configuration_Changes_In_ASPNET45_Website_Templates)
    - [Поддержка коренных народов в IIS 7 для ASP.NET routing](#Native_Support_In_IIS7_For_ASPNET_Routine)
    - [Редактор HTML](#_Toc318097397)

        - [Интеллектуальные задачи](#_Toc318097398)
        - [Поддержка WAI-ARIA](#_Toc318097399)
        - [Новые фрагменты HTML5](#_Toc318097400)
        - [Извлечение в управление пользователем](#_Toc318097401)
        - [IntelliSense для кодовых самородков в атрибутах](#_Toc318097402)
        - [Автоматическое переименование тега соответствия при переименовании тега открытия или закрытия](#_Toc318097403)
        - [Поколение обработчиков событий](#_Toc318097404)
        - [Умный отступ](#_Toc318097405)
        - [Завершение оператора автоматического сокращения](#_Toc318097406)
    - [Редактор JavaScript](#_Toc318097407)

        - [Код с изложением](#_Toc318097408)
        - [Соответствие скобки](#_Toc318097409)
        - [Перейти к определению](#_Toc318097410)
        - [Поддержка ECMAScript5](#_Toc318097411)
        - [DOM IntelliSense](#_Toc318097412)
        - [Перегрузки подписи VSDOC](#_Toc318097413)
        - [Неявные ссылки](#_Toc318097414)
    - [редактор CSS](#_Toc318097415)

        - [Завершение оператора автоматического сокращения](#_Toc318097416)
        - [Иерархический отступ.](#_Toc318097417)
        - [CSS хаки поддержки](#_Toc318097418)
        - [Поставщик конкретных схем (-moz-,-webkit)](#_Toc318097419)
        - [Комментируя и некомментируя поддержку](#_Toc318097420)
        - [Выбор цвета](#_Toc318097421)
        - [Фрагменты кода](#_Toc318097422)
        - [Пользовательские регионы](#_Toc318097423)
    - [Инспектор страниц](#_Toc318097424)
    - [Публикация](#_Toc318097425)

        - [Профили публикации](#_Toc318097426)
        - [ASP.NET прекомпиляция и слияние](#_Toc318097427)
- [IIS Express.](#_Toc318097428)
- [Отказ от ответственности](#_Toc318097429)

<a id="_Toc318097372"></a>
## <a name="aspnet-core-runtime-and-framework"></a>ASP.NET основные программы выполнения и рамки

<a id="_Toc318097373"></a>
### <a name="asynchronously-reading-and-writing-http-requests-and-responses"></a>Асинхронно чтение и написание запросов и ответов HTTP

ASP.NET 4 ввел возможность чтения сущности запроса HTTP в качестве потока с помощью метода *HttpRequest.GetBufferlessInputStream.* Этот метод обеспечил потоковое использование доступа к сущности запроса. Тем не менее, он выполнил синхронно, который связал поток на время запроса.

ASP.NET 4.5 поддерживает способность считывать потоки асинхронно на сущности запроса HTTP и способность к асинхронному флешу. ASP.NET 4.5 также дает возможность двабуфера сущность запроса HTTP, которая обеспечивает более легкую интеграцию с обработчиками http-потока, такими как обработчики страниц .aspx и ASP.NET контроллеров MVC.

<a id="_Toc318097374"></a>
#### <a name="improvements-to-httprequest-handling"></a>Улучшения обработки httprequest

Ссылка Stream, возвращенная ASP.NET 4.5 от *HttpRequest.GetBufferlessInputStream* поддерживает как синхронные, так и асинхронные методы чтения. Объект *Stream,* возвращенный из *GetBufferlessInputStream,* теперь реализует методы BeginRead и EndRead. Методы асинхронного *потока* позволяют асинхронно читать сущность запроса кусками, в то время как ASP.NET выпускает текущий поток между каждой итерацией асинхронного цикла чтения.

ASP.NET 4.5 также добавил сопутствующий метод для чтения сущности запроса в буферизированном способе: *HttpRequest.GetBufferedInputStream*. Эта новая перегрузка работает как *GetBufferlessInputStream*, поддерживая как синхронные, так и асинхронные чтения. Однако, как говорится, *GetBufferedInputStream* также копирует байты сущности во ASP.NET внутренние буферы, чтобы модули и обработчики вниз по течению могли по-прежнему получать доступ к сущности запроса. Например, если какой-либо восходящий код в конвейере уже прочитал сущность запроса с помощью *GetBufferedInputStream,* вы все равно можете использовать *HttpRequest.Form* или *HttpRequest.Files.* Это позволяет выполнять асинхронную обработку по запросу (например, потоковая передача большого файла в базу данных), но при этом запускать страницы .aspx и mVC ASP.NET контроллерами.

<a id="_Toc318097375"></a>
#### <a name="asynchronously-flushing-a-response"></a>Асинхронно промывка ответ

Отправка ответов клиенту HTTP может занять значительное время, когда клиент находится далеко или имеет соединение с низкой пропускной способностью. Обычно ASP.NET буферизирует байты ответа по мере их создания приложением. ASP.NET затем выполняет одну операцию отправки начисленных буферов в самом конце обработки запроса.

Если буферизированный ответ большой (например, потоковая передача большого файла клиенту), необходимо периодически вызывать *HttpResponse.Flush,* чтобы отправить буферизированный вывод клиенту и держать использование памяти под контролем. Однако, поскольку *флеш* является синхронным вызовом, итеративное вызов *флеша* по-прежнему потребляет поток на протяжении потенциально длительных запросов.

ASP.NET 4.5 добавляет поддержку для выполнения флешей асинхронно с использованием методов *BeginFlush* и *EndFlush* класса *HttpResponse.* Используя эти методы, можно создавать асинхронные модули и асинхронные обработчики, которые постепенно отправляют данные клиенту без связывания потоков операционной системы. В промежутках между вызовами *BeginFlush* и *EndFlush* ASP.NET выпускает текущий поток. Это существенно сокращает общее количество активных потоков, которые необходимы для поддержки длительных загрузок HTTP.

<a id="_Toc318097376"></a>
### <a name="support-for-await-and-task---based-asynchronous-modules-and-handlers"></a>Поддержка *ожидания* и *задачи* - На основе асинхронных модулей и обработчиков

В .NET Framework 4 введена концепция асинхронного программирования, называемая *задачей.* Задачи представлены типом *задачи* и связанными с ними типами в пространстве имен *System.Threading.Tasks.* Рамочный 4.5 .NET основывается на этом с усовершенствованиями компилятора, которые делают работу с объектами *задач* простой. В рамках .NET 4.5 компиляторы поддерживают два новых ключевых слова: *ожидание* и *async*. *Ожидание* ключевое слово является синтаксической сокращение для указания, что часть кода должна асинхронно ждать на какой-либо другой кусок кода. Ключевое слово *async* представляет собой подсказку, которую можно использовать для обозначения методов в качестве асинхронных методов, основанных на задачах.

Сочетание *ожидания,* *async*и объекта *Задачи* значительно упрощает написание асинхронного кода в .NET 4.5. ASP.NET 4.5 поддерживает эти упрощения новыми AI- и позволяют писать асинхронные модули HTTP и асинхронные обработчики HTTP с помощью новых улучшений компилятора.

<a id="_Toc318097377"></a>
#### <a name="asynchronous-http-modules"></a>Асинхронные модули HTTP

Предположим, что вы хотите выполнять асинхронную работу в методе, который возвращает объект *задачи.* Следующий пример кода определяет асинхронный метод, который делает асинхронный вызов для загрузки домашней страницы Майкрософт. Обратите внимание на использование ключевого слова *async* в подписи метода и *ждать* вызова *DownloadStringTaskAsync*.

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample1.cs)]

Это все, что вам нужно написать - система .NET будет автоматически обрабатывать раскручивание стека вызовов в ожидании завершения загрузки, а также автоматически восстанавливать стек вызовов после загрузки.

Теперь предположим, что вы хотите использовать этот асинхронный метод в асинхронном ASP.NET модуле HTTP. ASP.NET 4.5 включает в себя метод помощника *(EventHandlerAsyncHelper*) и новый тип делегата *(TaskEventHandler*), который можно использовать для интеграции асинхронных методов на основе задач со старой асинхронной моделью программирования, выставленной ASP.NET http. Этот пример показывает, как:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample2.cs)]

<a id="_Toc318097378"></a>
#### <a name="asynchronous-http-handlers"></a>Асинхронные обработчики HTTP

Традиционный подход к написанию асинхронных обработчиков в ASP.NET заключается в реализации интерфейса *IHttpAsyncHandler.* ASP.NET 4.5 вводит асинхронный базовый тип *HttpTaskAsyncHandler,* который можно извлечь из этого, что значительно упрощает написание асинхронных обработчиков.

Тип *HttpTaskAsyncHandler* является абстрактным и требует переопределить метод *ProcessRequestAsync.* Внутренне ASP.NET позаботится об интеграции реверсированной подписи (объект *задачи)* *ProcessRequestAsync* со старой асинхронной моделью программирования, используемой ASP.NET конвейера.

Следующий пример показывает, как можно использовать *задачу* и *ждать* в рамках реализации асинхронного обработчика HTTP:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample3.cs)]

<a id="_Toc318097379"></a>
### <a name="new-aspnet-request-validation-features"></a>Новые функции проверки ASP.NET запроса

По умолчанию ASP.NET выполняет проверку запроса – он изучает запросы на поиск разметки или скрипта в полях, заголовках, файлах cookie и так далее. Если какая-либо из ASP.NET обнаружена, ASP.NET выбрасывает исключение. Это действует как первая линия обороны от потенциальных кросс-сайт сценариев атак.

ASP.NET 4.5 упрощает выборочное чтение непроверенных данных запросов. ASP.NET 4.5 также интегрирует популярную библиотеку AntiXSS, которая ранее была внешней библиотекой.

Разработчики часто запрашивали возможность выборочно отключить проверку запроса для своих приложений. Например, если ваше приложение является программным обеспечением форума, вы можете разрешить пользователям отправлять HTML-форматные публикации и комментарии, но все же убедитесь, что проверка запроса проверяет все остальное.

ASP.NET 4.5 вводит две функции, которые позволяют выборочно работать с непроверенными входными данными: отложенная ("ленивая") проверка запроса и доступ к непроверенным данным запроса.

<a id="_Toc318097380"></a>
#### <a name="deferred-lazy-request-validation"></a>Отложенная ("ленивая") проверка запроса

В ASP.NET 4.5, по умолчанию все данные запроса подлежат проверке запроса. Тем не менее, вы можете настроить приложение для отсрочки проверки запроса до тех пор, пока вы не получите доступ к данным запроса. (Это иногда называют ленивым проверкой запроса, основанной на таких терминах, как ленивая загрузка для определенных сценариев данных.) Вы можете настроить приложение для использования отложенной проверки в файле Web.config, установив атрибут *requestValidationMode* до 4.5 в элементе *httpRUntime,* как в следующем примере:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample4.xml)]

Когда режим проверки запроса установлен до 4.5, проверка запроса запускается только для определенного значения запроса и только при доступе к этому значению. Например, если ваш код получает значение Post\_Request.Form'"forum", проверка запроса вызывается только для этого элемента в сборе форм. Ни один из других элементов коллекции *form* не проверен. В предыдущих версиях ASP.NET проверка запроса была запущена для всей коллекции запросов при доступе к любому элементу коллекции. Новое поведение упрощает для различных компонентов приложения рассмотрение различных фрагментов данных запросов без запуска проверки запроса на других частях.

<a id="_Toc318097381"></a>
#### <a name="support-for-unvalidated-requests"></a>Поддержка непроверенных запросов

Сама по себе проверка отложенного запроса не решает проблему выборочного обхода проверки запроса. Вызов на запрос.Форма "Форум\_пост" по-прежнему вызывает проверку запроса для этого конкретного значения запроса. Тем не менее, вы можете получить доступ к этому полю без запуска проверки, потому что вы хотите разрешить разметку в этом поле.

Чтобы позволить это, ASP.NET 4.5 теперь поддерживает непроверенный доступ к данным запроса. ASP.NET 4.5 включает в себя новое *непроверенное* свойство коллекции в классе *HttpRequest.* Эта коллекция предоставляет доступ ко всем общим значениям данных запросов, таким как *Form,* *QueryString,* *Cookies*и *Url*.

Используя пример форума, чтобы иметь возможность читать непроверенные данные запроса, сначала необходимо настроить приложение для использования нового режима проверки запроса:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample5.xml)]

Затем можно использовать свойство *HttpRequest.unvalidated* для чтения непроверенной формы:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample6.cs)]

> [!WARNING]
> Безопасность - *Используйте непроверенные данные запроса с осторожностью!* ASP.NET 4.5 добавили непроверенные свойства запроса и коллекции, чтобы облегчить доступ к очень конкретным непроверенным данным запроса. Тем не менее, необходимо выполнять пользовательскую проверку на необработанных данных запроса, чтобы гарантировать, что опасный текст не будет отображаться для пользователей.

<a id="_Toc318097382"></a>
### <a name="antixss-library"></a>Библиотека AntiXSS

Из-за популярности библиотеки Microsoft AntiXSS, ASP.NET 4.5 теперь включает в себя основные процедуры кодирования из версии 4.0 этой библиотеки.

Процедуры кодирования реализованы типом *AntiXssEncoder* в новом пространстве имен *System.Web.Security.AntiXss.* Вы можете использовать тип *AntiXssEncoder* непосредственно, позвонив в любой из статических методов кодирования, которые реализованы в типе. Однако самый простой подход к использованию новых процедур anti-XSS — настроить ASP.NET приложение для использования класса *AntiXsSEncoder* по умолчанию. Для этого добавьте следующий атрибут в файл Web.config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample7.xml)]

Когда атрибут *encoderType* устанавливается для использования типа *AntiXssEncoder,* все выходные кодирования в ASP.NET автоматически использует новые процедуры кодирования.

Это части внешней библиотеки AntiXSS, которые были включены в ASP.NET 4.5:

- *HtmlEncode,* *HtmlFormUrlEncode*и *HtmlAttributeEncode*
- *XmlAttributeEncode* и *XmlEncode*
- *UrlEncode* и *UrlPathEncode* (новый)
- *CssEncode*

<a id="_Toc318097383"></a>
### <a name="support-for-websockets-protocol"></a>Поддержка протокола WebSockets

Протокол WebSockets — это сетевой протокол, основанный на стандартах, который определяет, как установить безопасную двунаправленную связь в режиме реального времени между клиентом и сервером через HTTP. Корпорация Майкрософт работала с органами по стандартам IETF и W3C, чтобы помочь определить протокол. Протокол WebSockets поддерживается любым клиентом (не только браузерами), при этом корпорация Майкрософт инвестирует значительные ресурсы, поддерживающие протокол WebSockets, как в клиентские, так и на мобильные операционные системы.

Протокол WebSockets значительно упрощает создание длительных передач данных между клиентом и сервером. Например, писать чат-приложение гораздо проще, потому что можно установить истинную длительную связь между клиентом и сервером. Вам не придется прибегать к обходным пути, таким как периодические опросы или HTTP-длинный опрос, чтобы имитировать поведение гнезда.

ASP.NET 4.5 и IIS 8 включают поддержку WebSockets низкого уровня, что позволяет ASP.NET разработчикам использовать управляемые AIS для асинхронного чтения и записи как строки, так и двоичные данные на объекте WebSockets. Для ASP.NET 4.5 существует новое пространство имен *System.Web.WebSockets,* содержащее типы для работы с протоколом WebSockets.

Клиент браузера устанавливает соединение WebSockets, создавая объект DOM *WebSocket,* который указывает на URL в ASP.NET приложении, как в следующем примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample8.cs)]

Можно создавать конечные точки WebSockets в ASP.NET с помощью любого модуля или обработчика. В предыдущем примере использовался файл .ashx, поскольку файлы .ashx — это быстрый способ создания обработчика.

Согласно протоколу WebSockets, ASP.NET приложение принимает запрос клиента WebSockets, указывая, что запрос должен быть повышен с запроса HTTP GET на запрос WebSockets. Ниже приведен пример:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample9.cs)]

Метод *AcceptWebSocketRequest* принимает делегата функции, поскольку ASP.NET раскручивает текущий запрос HTTP, а затем передает элемент управления делегату функции. Концептуально этот подход аналогичен тому, как вы используете *System.Threading.Thread*, где вы определяете делегата запуска потоков, в котором выполняется фоновая работа.

После того, как ASP.NET и клиент успешно завершили рукопожатие WebSockets, ASP.NET вызывает делегата и приложение WebSockets начинает работать. Следующий пример кода показывает простое приложение эхо, используюво встроенную поддержку WebSockets в ASP.NET:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample10.cs)]

Поддержка в .NET 4.5 для поиска *ключевых* слов и асинхронных операций на основе задач является естественной пригонкой для написания приложений WebSockets. Пример кода показывает, что запрос WebSockets выполняется полностью асинхронно внутри ASP.NET. Приложение ждет асинхронно для сообщения, которое будет отправлено от клиента, позвонив в *ожидании гнезда. ReceiveAsync*. Аналогичным образом, вы можете отправить асинхронное сообщение клиенту, позвонив в *ожидании гнезда. SendAsync*.

В браузере приложение получает сообщения WebSockets через функцию *onmessage.* Чтобы отправить сообщение из браузера, вы называете метод *отправки* типа *WebSocket* DOM, как показано в этом примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample11.cs)]

В будущем мы можем выпустить обновления этой функциональности, которые абстрагируют некоторые низкоуровневые кодирования, которые необходимы в этом выпуске для приложений WebSockets.

<a id="_Toc318097384"></a>
### <a name="bundling-and-minification"></a>Объединение и минификация

Bundling позволяет комбинировать отдельные файлы JavaScript и CSS в пакет, который можно рассматривать как один файл. Minification конденсирует файлы JavaScript и CSS, удаляя пробелы и другие символы, которые не требуются. Эти функции работают с веб-формами, ASP.NET MVC и веб-страницами.

Комплекты создаются с использованием класса Bundle или одного из его детских классов, ScriptBundle и StyleBundle. После настройки экземпляра пакета пакет становится доступным для входящих запросов, просто добавляя его в глобальный экземпляр BundleCollection. В шаблонах по умолчанию конфигурация пакета выполняется в файле BundleConfig. Эта конфигурация по умолчанию создает пакеты для всех основных скриптов и файлов css, используемых шаблонами.

Комплекты ссылаются из нутри представлений, используя один из нескольких возможных методов помощника. Для поддержки визуализации различной разметки для пакета при отладке и выпуске классы ScriptBundle и StyleBundle имеют вспомогательный метод Render. При отладке рендер будет генерировать разметку для каждого ресурса в пакете. При выпуске режиме Render будет генерировать единый элемент разметки для всего пакета. Перегоняние между отладки и режимом выпуска может быть достигнуто путем изменения атрибута отладки элемента компиляции в web.config, как показано ниже:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample12.xml)]

Кроме того, включение или отключение оптимизации может быть установлено непосредственно через свойство BundleTable.EnableОптимизации.

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample13.cs)]

Когда файлы в комплекте, они сначала отсортированы в алфавитном порядке (так они отображаются в **Solution Explorer).** Затем они организованы таким образом, что известные библиотеки и их пользовательские расширения (такие как j'ery, MooTools и Dojo) загружаются в первую очередь. Например, окончательный заказ на комплектацию папки Скриптов, как показано выше, будет:

1. jquery-1.6.2.js
2. jquery-ui.js
3. jquery.tools.js
4. a.js

CSS файлы также сортируются в алфавитном порядке, а затем реорганизованы так, что reset.css и normalize.css прийти перед любым другим файлом. Окончательная сортировка комплектации папки Стилей, показанная выше, будет такой:

1. reset.css
2. content.css
3. forms.css
4. globals.css
5. menu.css
6. styles.css

<a id="_Toc_perf"></a>
### <a name="performance-improvements-for-web-hosting"></a>Улучшения производительности для веб-хостинга

В рамках .NET 4.5 и Windows 8 представлены функции, которые помогут вам добиться значительного повышения производительности для рабочих нагрузок веб-сервера. Это включает в себя сокращение (до 35%) как во время запуска, так и в памяти след веб-хостинга, которые используют ASP.NET.

<a id="_Toc_perf_1"></a>
#### <a name="key-performance-factors"></a>Ключевые факторы производительности

В идеале, все веб-сайты должны быть активными и в памяти, чтобы обеспечить быстрый ответ на следующий запрос, когда он приходит. Факторы, которые могут повлиять на отзывчивость сайта, включают:

- Время, необходимое для перезагрузки сайта после переработки пула приложений. Это время, необходимое для запуска процесса веб-сервера для сайта, когда сборки сайта больше не в памяти. (Сборки платформы все еще в памяти, так как они используются другими сайтами.) Эта ситуация называется "холодный сайт, теплый запуск рамки" или просто "холодный запуск сайта".
- Сколько памяти занимает сайт. Условия для этого "потребление памяти на сайте" или "нераспределенный рабочий набор".

Новые улучшения производительности сосредоточены на обоих этих факторах.

<a id="_Toc_perf_2"></a>
#### <a name="requirements-for-new-performance-features"></a>Требования к новым функциям производительности

Требования к новым функциям можно разбить на следующие категории:

- Улучшения, которые работают на .NET Framework 4.
- Улучшения, требующие возможности .NET Framework 4.5, но могут работать на любой версии Windows.
- Улучшения, доступные только с помощью .NET Framework 4.5, работаемого на Windows 8.

Производительность увеличивается с каждым уровнем улучшения, что вы в состоянии включить.

Некоторые усовершенствования .NET Framework 4.5 используют более широкие функции производительности, применимые и к другим сценариям.

<a id="_Toc_perf_3"></a>
#### <a name="sharing-common-assemblies"></a>Обмен общими собраниями

**Требование**: .NET Framework 4 и Visual Studio 11 Разработчик Предварительный SDK

Различные сайты на сервере часто используют одни и те же сборки помощников (например, сборки из стартового комплекта или образца приложения). Каждый сайт имеет свою собственную копию этих сборок в своем каталоге Бин. Несмотря на то, что объектный код для сборок идентичен, они физически разделены на сборку, поэтому каждая сборка должна быть прочитана отдельно во время запуска холодного сайта и храниться отдельно в памяти.

Новая функция интернирования решает эту проблему и снижает как требования к оперативной памяти, так и время загрузки. Интернирование позволяет Windows хранить одну копию каждой сборки в файловой системе, а отдельные сборки на папках Bin сайта заменяются символическими ссылками на одну копию. Если отдельному сайту требуется отдельная версия сборки, символическое звено заменяется новой версией сборки, и только этот сайт влияет.

Обмен сборками с использованием символических ссылок\_требует нового инструмента под названием aspnet intern.exe, который позволяет создавать и управлять хранилищем интернированных сборок. Она предоставляется в рамках Визуальной студии 11 Разработчик Предварительный SDK. (Однако, он будет работать на системе, которая имеет только .NET Framework 4 установлен, если вы установили последнее [обновление](https://support.microsoft.com/kb/2468871).)

Чтобы убедиться, что все подходящие собрания были интернированы, вы периодически работаете aspnet\_intern.exe (например, один раз в неделю в качестве запланированного задания). Типичное использование заключается в следующем:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample14.cmd)]

Чтобы увидеть все варианты, запустите инструмент без аргументов.

<a id="_Toc_perf_4"></a>
#### <a name="using-multi-core-jit-compilation-for-faster-startup"></a>Использование многоъядерной компиляции JIT для более быстрого запуска

**Требование**: .NET Framework 4.5

Для холодного запуска сайта, не только сборки должны быть прочитаны с диска, но сайт должен быть JIT-компилируется. Для сложного сайта это может добавить значительные задержки. Новый метод общего назначения в системе .NET 4.5 уменьшает эти задержки, распространяя JIT-компиляцию по имеющимся ядрам процессора. Он делает это как можно больше и как можно раньше, используя информацию, собранную во время предыдущих запусков сайта. Эта функциональность реализована методом [System.Runtime.ProfileOptimization.StartProfile.](https://msdn.microsoft.com/library/system.runtime.profileoptimization.startprofile(VS.110).aspx)

JIT-компиляция с использованием нескольких ядер включена по умолчанию в ASP.NET, так что вам не нужно ничего делать, чтобы воспользоваться этой функцией. Если вы хотите отключить эту функцию, сделайте следующую настройку в файле Web.config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample15.xml)]

<a id="_Toc_perf_5"></a>
#### <a name="tuning-garbage-collection-to-optimize-for-memory"></a>Настройка сбора мусора для оптимизации памяти

**Требование**: .NET Framework 4.5

После запуска сайта его использование кучи мусорного коллектора (GC) может быть важным фактором потребления памяти. Как и любой сборщик мусора, в gc.net Framework gc происходит компромисс между временем процессора (частота и значение коллекций) и потреблением памяти (дополнительное пространство, используемое для новых, освобожденных или свободных объектов). Для предыдущих релизов мы предоставили рекомендации о том, как настроить GC для достижения правильного баланса (например, [см. ASP.NET 2.0/3.5 Общая конфигурация хостинга).](https://www.iis.net/learn/web-hosting/web-server-for-shared-hosting/aspnet-20-35-shared-hosting-configuration)

Для .NET Framework 4.5 вместо нескольких автономных настроек доступна настройка конфигурации, определяемая рабочей нагрузкой, которая позволяет использовать все ранее рекомендуемые настройки GC, а также новую настройку, которая обеспечивает дополнительную производительность рабочего набора на сайте.

Для настройки памяти GC добавьте следующие настройки в файл Windows-Microsoft.NET-Framework-v4.0.30319-aspnet.config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample16.xml)]

(Если вы знакомы с предыдущим руководством для изменений aspnet.config, обратите внимание, что эта настройка заменяет старые настройки - например, нет необходимости устанавливать gcServer, gcConcurrent и т.д. Вам не нужно удалять старые настройки.)

<a id="_Toc_perf_6"></a>
#### <a name="prefetching-for-web-applications"></a>Предварительная подготовка для веб-приложений

**Требование**: .NET Framework 4.5 работает на Windows 8

Для нескольких релизов Windows включила технологию, известную как [prefetcher,](http://en.wikipedia.org/wiki/Prefetcher) которая снижает стоимость чтения дисков запуска приложения. Поскольку холодный запуск является проблемой преимущественно для клиентских приложений, эта технология не была включена в Windows Server, который включает в себя только компоненты, которые необходимы для сервера. Prefetching теперь доступен в последней версии Windows Server, где он может оптимизировать запуск отдельных веб-сайтов.

Для Windows Server предпривлекательный не включен по умолчанию. Чтобы включить и настроить предустановку веб-хостинга высокой плотности, запустите следующий набор команд на командной строке:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample17.cmd)]

Затем, чтобы интегрировать prefetcher с ASP.NET приложениями, добавьте следующее в файл Web.config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample18.xml)]

<a id="_Toc318097385"></a>
## <a name="aspnet-web-forms"></a>Веб-формы ASP.NET

<a id="_Toc318097386"></a>
### <a name="strongly-typed-data-controls"></a>Строго типизированные элементы управления данными

В ASP.NET 4.5 веб-формы включают некоторые улучшения для работы с данными. Первым усовершенствованием является сильно набранный элемент управления данными. Для элементов управления Web Forms в предыдущих версиях ASP.NET отображается значение, связанное с данными, с помощью *Eval* и связывающее данные выражение:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample19.aspx)]

Для связывания данных с двусторонним способом используется *Bind:*

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample20.aspx)]

Во время выполнения эти вызовы используют отражение для чтения значения указанного участника, а затем отображают результат в разметке. Такой подход упрощает привязку данных к произвольным, неформированным данным.

Однако такие обязательные выражения, которые имеют обязательную силу данных, не поддерживают такие функции, как IntelliSense для имен членов, навигации (например, Go To Definition) или проверки времени компиляции этих имен.

Для решения этой проблемы ASP.NET 4.5 добавляет возможность декларировать тип данных, к которым обязан элемент управления. Вы делаете это с помощью нового свойства *ItemType.* При установке этого свойства в области обязательных выражений, связывающих данные, доступны две новые набранные переменные: *Элемент* и *BindItem.* Поскольку переменные сильно набраны, вы получаете все преимущества опыта разработки Visual Studio.

Для двусторонних связывающих данных выражений используйте переменную *BindItem:*

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample21.aspx)]

Большинство элементов управления в рамках ASP.NET Web Forms, поддерживающих привязку данных, были обновлены для поддержки свойства *ItemType.*

<a id="_Toc318097387"></a>
### <a name="model-binding"></a>Привязка модели

Привязка к модели расширяет привязку данных в ASP.NET элементы управления Web Forms для работы с доступом к данным, ориентированным на код. Он включает в себя концепции из управления *ObjectDataSource* и от привязки модели в ASP.NET MVC.

<a id="_Toc318097388"></a>
#### <a name="selecting-data"></a>Выбор данных

Чтобы настроить элемент управления данными для использования привязки модели к выбору данных, вы установите свойство *SelectMethod* элемента управления на имя метода в коде страницы. Управление данными вызывает метод в соответствующее время жизненного цикла страницы и автоматически связывает возвращенные данные. Нет необходимости явно вызывать метод *DataBind.*

В следующем примере элемент управления *GridView* настроен на использование метода *GetCategories:*

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample22.aspx)]

В коде страницы создается метод *GetCategories.* Для простой операции выбора метод не нуждается в параметрах и должен вернуть объект *IEnumerable* или *I'E-E..* Если установлено новое свойство *ItemType* (что позволяет сильно напечатать набранные выражения, имеющие обязательную силу данных, как это было объяснено ранее в рамках [сильно набранных](#_Toc318097386) элементов управления данными), то общие версии этих интерфейсов должны быть возвращены - *&lt;IEnumerable&gt; T* или *I'E'E'E,,&lt;&gt;* с параметром *T,* соответствующим типу свойства *ItemType* (например, *I'E'ereable&lt;Category).&gt;*

В следующем примере показан код для метода *GetCategories.* В этом примере используется модель Первой фреймворков Entity С базой данных Northwind. Код гарантирует, что запрос возвращает сведения о связанных продуктах для каждой категории по методу *Включения.* (Это гарантирует, что элемент *TemplateField* в разметке отображает количество продуктов в каждой категории, не требуя [выбора n-1.)](http://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem)

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample23.cs)]

При запуске страницы управление *GridView* автоматически вызывает метод *GetCategories* и отображает возвращенные данные с помощью настроенных полей:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image2.png)

Поскольку выбранный метод возвращает объект *I'E'e,e'e,* управление *GridView* может далее манипулировать запросом перед его выполнением. Например, элемент управления *GridView* может добавлять выражения запросов для сортировки и paging к возвращенному *объекту,* который будет выполнен, прежде чем он будет выполнен, так что эти операции выполняются базовым поставщиком LIN'. В этом случае система Entity Framework гарантирует, что эти операции выполняются в базе данных.

В следующем примере показан элемент управления *GridView,* измененный для сортировки и промывки:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample24.aspx)]

Теперь, когда страница выполняется, элемент управления может убедиться, что отображается только текущая страница данных и что она заказана выбранным столбцом:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image3.png)

Для фильтрации возвращенных данных необходимо добавить параметры в выбранный метод. Эти параметры будут заполняться связыванием модели во время выполнения, и вы можете использовать их для изменения запроса перед возвращением данных.

Например, предположим, что вы хотите позволить пользователям фильтровать продукты, введя ключевое слово в строку запроса. Можно добавить параметр к методу и обновить код, чтобы использовать значение параметра:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample25.cs)]

Этот код включает выражение *Where,* если значение предоставляется для *ключевого слова,* а затем возвращает результаты запроса.

<a id="_Toc318097389"></a>
#### <a name="value-providers"></a>Поставщики ценностей

Предыдущий пример не был конкретным о том, где значение для параметра *ключевого слова* исходит от. Чтобы указать эту информацию, можно использовать атрибут параметра. В этом примере можно использовать класс *queryStringAttribute,* который есть в пространстве имен *System.Web.ModelBinding:*

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample26.cs)]

Это поручает привязке модели, чтобы попытаться связать значение строки запроса с параметром *ключевого слова* во время выполнения. (Это может включать в себя выполнение преобразования типа, хотя это не в данном случае.) Если значение не может быть предоставлено и тип не является недействительным, выбрасывается исключение.

Источники значений для этих методов называются поставщиками значений, а атрибуты параметров, указывающие, какой поставщик значений использовать, называются атрибутами поставщика значений. Веб-формы будут включать поставщиков значений и соответствующие атрибуты для всех типичных источников ввода пользователя в приложении Web Forms, таких как строка запроса, файлы cookie, значения формы, элементы управления, состояние представления, состояние сеанса и свойства профиля. Вы также можете написать пользовательские поставщики значений.

По умолчанию имя параметра используется в качестве ключа для поиска значения в коллекции поставщиков значений. В этом примере код будет искать значение строки запроса, названное ключевым словом (например, s/default.aspx?keyword'chef). Можно указать пользовательский ключ, передав его в качестве аргумента атрибуту параметра. Например, для использования значения переменной строки запроса, названной q, можно сделать это:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample27.cs)]

Если этот метод находится в коде страницы, пользователи могут фильтровать результаты, передавая ключевое слово с помощью строки запроса:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image4.png)

Связывание модели выполняет множество задач, которые в противном случае придется кодировать вручную: чтение значения, проверка нулевого значения, попытка преобразовать его в соответствующий тип, проверка успешности преобразования и, наконец, использование значения в запросе. Привязка модели приводит к гораздо меньшему коду и возможности повторного использования функциональности во всем приложении.

<a id="_Toc318097390"></a>
#### <a name="filtering-by-values-from-a-control"></a>Фильтрация по значениям из элемента управления

Предположим, вы хотите расширить пример, чтобы позволить пользователю выбрать значение фильтра из списка выпадающих. Добавьте в наценку следующий список выпадающих и настройте его на данные другого метода с использованием свойства *SelectMethod:*

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample28.aspx)]

Как правило, элемент *EmptyDataTemplate* также добавляется в управление *GridView,* чтобы элемент управления отображал сообщение, если не найдено соответствующие продукты:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample29.aspx)]

В код страницы добавьте новый метод выбора для списка выпадающих:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample30.cs)]

Наконец, обновите метод *GetProducts* Select, чтобы взять новый параметр, содержащий идентификатор выбранной категории из списка выпадающих:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample31.cs)]

Теперь, когда страница работает, пользователи могут выбрать категорию из списка выпадающих, и контроль *GridView* автоматически перенаправляется, чтобы показать отфильтрованные данные. Это возможно, поскольку связывание модели отслеживает значения параметров для избранных методов и определяет, изменилось ли значение параметра после послеотката. Если это так, то связывание модели заставляет связанный контроль данных повторно привязаться к данным.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image5.png)

<a id="_Toc318097391"></a>
### <a name="html-encoded-data-binding-expressions"></a>HTML закодированные выражения связывания данных

Теперь можно закодировать HTML-кодирование результатов связывающих данных выражений. Добавить толстую кишку (:) до конца префикса &lt;%, который отмечает связывающее данные выражение:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample32.aspx)]

<a id="_Toc318097392"></a>
### <a name="unobtrusive-validation"></a>Ненавязчивая проверка

Теперь можно настроить встроенные элементы управления валидатором, чтобы использовать ненавязчивый JavaScript для логики проверки на стороне клиента. Это значительно уменьшает количество внеесное JavaScript в разметке страницы и уменьшает общий размер страницы. Вы можете настроить ненавязчивый JavaScript для управления валидатором любым из этих способов:

- Глобально, добавляя следующие * &lt;настройки&gt; * в элемент appSettings в файле Web.config: 

    [!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample33.xml)]
- Глобально, установив статическое свойство *System.Web.UI.ValidationSettings.UnobtrusiveValidationMode* на *unobtrusiveValidationMode.WebForms* (обычно в методе *запуска\_приложения* в файле Global.asax).
- Индивидуально для страницы, установив новое свойство *UnobtrusiveValidationMode* класса *Страницы* на *unobtrusiveValidationMode.WebForms*.

<a id="_Toc318097393"></a>
### <a name="html5-updates"></a>Обновления HTML5

Некоторые улучшения были внесены в управление сервером Web Forms, чтобы воспользоваться новыми функциями HTML5:

- Свойство *TextMode* управления *TextBox* было обновлено для поддержки новых типов ввода HTML5, таких как *электронная почта,* *дата*и так далее.
- Теперь управление *FileUpload* поддерживает несколько загрузок файлов из браузеров, поддерживающих эту функцию HTML5.
- Элементы управления валидатором теперь поддерживают проверку входных элементов HTML5.
- Новые элементы HTML5, которые имеют атрибуты, которые представляют URL, теперь поддерживают runat'"server". В результате, вы можете использовать ASP.NET конвенций в URL-путях, таких как &lt;оператор для представления корней приложения (например, видео runat'"server» src''/myVideo.wmv» /&gt;).
- Контроль *UpdatePanel* был исправлен для поддержки размещения вхотвочные поля HTML5.

<a id="_Toc318097394"></a>
## <a name="aspnet-mvc-4"></a>ASP.NET MVC 4

ASP.NET MVC 4 Бета теперь включена в Visual Studio 11 Beta. ASP.NET MVC является основой для разработки высоко проверяемых и обслуживаемых веб-приложений за счет использования шаблона Model-View-Controller (MVC). ASP.NET MVC 4 упрощает создание приложений для мобильного Интернета и включает ASP.NET Web API, который помогает создавать службы HTTP, которые могут охватить любое устройство. Для получения дополнительной информации смотрите [ASP.NET MVC 4 Примечания к выпуску](mvc4-release-notes.md).

<a id="_Toc318097395"></a>
## <a name="aspnet-web-pages-2"></a>Веб-страницы ASP.NET 2

Новые функции включают в себя следующие:

- Новые и обновленные шаблоны сайта.
- Добавление проверки на стороне сервера и клиента с помощью помощника *валидации.*
- Возможность регистрации скриптов с помощью управляющего активами.
- Включение логинов с Facebook и других сайтов с помощью OAuth и OpenID.
- Добавление карт с помощью помощника *Карты.*
- Запуск приложений веб-страниц бок о бок.
- Рендеринг страниц для мобильных устройств.

Для получения дополнительной информации об этих функциях и примерах полностраничного кода [см.](https://go.microsoft.com/fwlink/?LinkID=227824)

<a id="_Toc318097396"></a>
## <a name="visual-web-developer-11-beta"></a>Визуальный веб-разработчик 11 бета-версия

В этом разделе содержится информация об усовершенствованиях для веб-разработки в Visual Web Developer 11 Beta и Visual Studio 2012 Release Candidate.

<a id="project-compatibility"></a>
### <a name="project-sharing-between-visual-studio-2010-and-visual-studio-2012-release-candidate-project-compatibility"></a>Совместное использование проекта между visual Studio 2010 и Visual Studio 2012 Кандидат на выпуск (совместимость проекта)

До Visual Studio 2012 Релиз Кандидат, открытие существующего проекта в новой версии Visual Studio начал Преобразование Мастера. Это заставило обновить содержимое (активы) проекта и решение для новых форматов, которые не были совместимы назад. Поэтому после преобразования вы не смогли открыть проект в старой версии Visual Studio.

Многие клиенты сказали нам, что это был не правильный подход. В Visual Studio 11 Beta мы поддерживаем совместные проекты и решения с Visual Studio 2010 SP1. Это означает, что если вы откроете 2010 проект в Visual Studio 2012 Релиз Кандидат, вы все равно сможете открыть проект в Visual Studio 2010 SP1.

> [!NOTE]
> Несколько типов проектов не могут быть разделены между Visual Studio 2010 SP1 и Visual Studio 2012 Релиз кандидата. К ним относятся некоторые старые проекты (например, проекты mVC 2 ASP.NET) или проекты для специальных целей (например, проекты по настройке).

При открытии визуальной студии 2010 SP1 Web-проект в первый раз в Visual Studio 11 Бета, следующие свойства добавляются в файл проекта:

- ФайлАпмодернфлаги
- ОбновлениеBackupLocation
- OldToolsVersion
- VisualStudioVersion
- VSToolsPath

FileUpgradeFlags, UpgradeBackupLocation и OldToolsVersion используются в процессе обновления файла проекта. Они не влияют на работу с проектом в Visual Studio 2010.

VisualStudioVersion — это новое свойство, используемое MSBuild 4.5, которое указывает на версию Visual Studio для текущего проекта. Поскольку этого свойства не существовало в MSBuild 4.0 (версия MSBuild, которую использует Visual Studio 2010 SP1), мы вводим значение по умолчанию в файл проекта.

Свойство VSToolsPath используется для определения правильного файла .targets для импорта из пути, представленного параметром MSBuildExtensionsPath32.

Есть также некоторые изменения, связанные с элементами импорта. Эти изменения необходимы для того, чтобы поддерживать совместимость между обеими версиями Visual Studio.

> [!NOTE]
> Если проект распределяется между Visual Studio 2010 SP1 и Visual Studio 11 Beta на двух разных компьютерах, и если проект включает локальную базу данных в папке App\_Data, вы должны убедиться, что версия сервера S'L, используемая базой данных, установлена на обоих компьютерах.

<a id="Configuration_Changes_In_ASPNET45_Website_Templates"></a>
### <a name="configuration-changes-in-aspnet-45-website-templates"></a>Изменения конфигурации в ASP.NET 4.5 шаблоны веб-сайта

Следующие изменения были внесены в файл *Web.config* по умолчанию для сайта, который создается с помощью шаблонов веб-сайта в Visual Studio 2012 Release Candidate:

- В `<httpRuntime>` элементе `encoderType` атрибут теперь устанавливается по умолчанию для использования типов AntiXSS, которые были добавлены в ASP.NET. Для получения подробной информации [см.](#_Toc318097382)
- Также в `<httpRuntime>` элементе `requestValidationMode` атрибут установлен на "4.5". Это означает, что по умолчанию проверка запроса настроена на использование отложенной ("ленивой") проверки. Для получения подробной информации [ASP.NET](#_Toc318097379)см.
- Элемент `<modules>` раздела `<system.webServer>` не содержит `runAllManagedModulesForAllRequests` атрибута. (Его значение по умолчанию является ложным.) Это означает, что если вы используете версию IIS 7, которая не была обновлена до SP1, у вас могут возникнуть проблемы с направлением на новом сайте. Для получения дополнительной информации [см. Поддержка коренных народов в IIS 7 для ASP.NET Routing](#Native_Support_In_IIS7_For_ASPNET_Routine).

Эти изменения не влияют на существующие приложения. Тем не менее, они могут представлять разницу в поведении между существующими веб-сайтами и новыми веб-сайтами, которые вы создаете для ASP.NET 4.5 с помощью новых шаблонов.

<a id="Native_Support_In_IIS7_For_ASPNET_Routine"></a>
### <a name="native-support-in-iis-7-for-aspnet-routing"></a>Поддержка коренных народов в IIS 7 для ASP.NET routing

Это не изменение ASP.NET как такового, а изменение шаблонов для новых проектов веб-сайта, которые могут повлиять на вас, если вы работаете над версией IIS 7, в которой не применялось обновление SP1.

В ASP.NET можно добавить следующую настройку конфигурации в приложения для поддержки реаутинга:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample34.xml?highlight=3)]

Когда **runAllManagedModulesForAllRequests** верно, URL, как `http://mysite/myapp/home` идет в ASP.NET, даже если нет *.aspx*, *.mvc*, или аналогичное расширение на URL.

Обновление, которое было сделано для IIS 7 делает **runAllManagedModulesForAllRequests** настройки ненужным и поддерживает ASP.NET разгрома родной. (Для получения информации об обновлении см. статью поддержки Майкрософт [Доступно обновление, которое позволяет определенным обработчикам IIS 7.0 или IIS 7.5 обрабатывать запросы, URL-адреса которых не заканчиваются периодом.)](https://support.microsoft.com/kb/980368)

Если ваш веб-сайт работает на IIS 7 и если IIS был обновлен, вам не нужно устанавливать **runAllManagedModulesForAllRequests** к истине. В самом деле, установка его на истину не рекомендуется, потому что он добавляет ненужные накладные расходы обработки по запросу. Когда эта настройка верна, все запросы, в ключая запросы на *.htm,* *.jpg*и другие статические файлы, также проходят через конвейер ASP.NET запроса.

Если вы создаете новый веб-сайт ASP.NET 4.5 с использованием шаблонов, которые предоставляются в Visual Studio 2012 RC, конфигурация для веб-сайта не включает в себя **настройки runAllManagedModulesForAllRequests.** Это означает, что по умолчанию настройка является ложной.

Если вы запустите веб-сайт на Windows 7 без установки SP1, IIS 7 не будет включать необходимое обновление. Как следствие, routing не будет работать, и вы увидите ошибки. Если у вас есть проблемы, когда routing не работает, вы можете сделать либо следующее:

- Обновление Windows 7 до SP1, который добавит обновление в IIS 7.
- Установите обновление, описанное в статье поддержки Майкрософт, перечисленной ранее.
- Установите **runAllManagedModulesForAllRequests** к истине в файле Web.config этого веб-сайта. Обратите внимание, что это добавит некоторые накладные расходы к запросам.

<a id="_Toc318097397"></a>
### <a name="html-editor"></a>Редактор HTML

<a id="_Toc318097398"></a>
#### <a name="smart-tasks"></a>Интеллектуальные задачи

В представлении Design представлению сложные свойства управления сервером часто связаны с диалоговые поля и мастерами, чтобы упрощать их установку. Например, можно использовать специальное диалоговое окно для добавления источника данных в элемент управления *ретранслятора* или добавления столбцов в управление *GridView.*

Однако этот тип утилиты помощи для сложных свойств не был доступен в представлении Source. Поэтому Visual Studio 11 вводит интеллектуальные задачи для просмотра исходного кода. Интеллектуальные задачи — это контекстно-интеллектуальные ярлыки для широко используемых функций в редакторах СЗ и Visual Basic.

Для ASP.NET управления веб-формами, смарт-задачи отображаются на тегах сервера как маленький глиф, когда точка вставки находится внутри элемента:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image6.png)

Интеллектуальная задача расширяется при нажатии на глиф или нажатии CTRL. (точка), как и в редакторах кода. Затем отображается ярлыки, которые похожи на интеллектуальные задачи в представлении Design.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image7.png)

Например, в «Умной задаче» на предыдущей иллюстрации показаны параметры задач GridView. При выборе столбцов Edit отображается следующее поле диалога:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image8.png)

Заполнение в поле диалога устанавливает те же свойства, которые можно установить в представлении Design. При нажатии OK разметка для управления обновляется новыми настройками:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image9.png)

<a id="_Toc318097399"></a>
#### <a name="wai-aria-support"></a>Поддержка WAI-ARIA

Написание доступных веб-сайтов становится все более важным. [Стандарт доступности WAI-ARIA](http://www.w3.org/WAI/intro/aria) определяет, как разработчики должны писать доступные веб-сайты. Этот стандарт в настоящее время полностью поддерживается в Visual Studio.

Например, атрибут *роли* теперь имеет полный IntelliSense:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image10.png)

Стандарт WAI-ARIA также вводит атрибуты, которые прикрепляются к *арии,* которые позволяют добавлять семантику в документ HTML5. Visual Studio также полностью поддерживает эти *арии атрибуты:*

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image11.png) ![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image12.png)

<a id="_Toc318097400"></a>
#### <a name="new-html5-snippets"></a>Новые фрагменты HTML5

Чтобы сделать его быстрее и проще писать обычно используемые HTML5 разметки, Visual Studio включает в себя ряд фрагментов. Примером может быть фрагмент видео:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image13.png)

Чтобы вызвать фрагмент, нажмите Tab дважды, когда элемент выбран в IntelliSense:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image14.png)

Это производит фрагмент, который можно настроить.

<a id="_Toc318097401"></a>
#### <a name="extract-to-user-control"></a>Извлечение в управление пользователем

На больших веб-страницах может быть хорошей идеей переместить отдельные части в элементы управления пользователем. Эта форма рефакторинга может помочь увеличить читаемость страницы и упростить структуру страницы.

Чтобы сделать это проще, при редактировании страниц Web Forms в представлении Исходного кода теперь можно выбрать текст на странице, нажать на него правой кнопкой мыши, а затем выбрать Extract to User Control:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image2.jpg)

<a id="_Toc318097402"></a>
#### <a name="intellisense-for-code-nuggets-in-attributes"></a>IntelliSense для кодовых самородков в атрибутах

Visual Studio всегда предоставляла IntelliSense для самородков кода сервера на любой странице или элементе управления. Теперь Visual Studio включает intelliSense для наггетсов кода в HTML атрибуты, а также.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image15.png)

Это упрощает создание обязательных для данных выражений:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image16.png)

<a id="_Toc318097403"></a>
#### <a name="automatic-renaming-of-matching-tag-when-you-rename-an-opening-or-closing-tag"></a>Автоматическое переименование тега соответствия при переименовании тега открытия или закрытия

Если вы переименуете элемент HTML (например, вы измените тег *div* на тег *заголовка),* соответствующий тег открытия или закрытия также изменяется в режиме реального времени.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image17.png)

Это помогает избежать ошибки, когда вы забыли изменить тег закрытия или изменить неправильный.

<a id="_Toc318097404"></a>
#### <a name="event-handler-generation"></a>Поколение обработчиков событий

Visual Studio теперь включает в себя функции в представлении Source, чтобы помочь вам написать обработчики событий и связать их вручную. При редактировании имени события в представлении Source &lt;IntelliSense отображает Создать новое событие,&gt;которое создаст обработчик событий в коде страницы с правильной подписью:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image3.jpg)

По умолчанию обработчик событий будет использовать идентификатор элемента управления для имени метода обработки событий:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image4.jpg)

В результате обработчик событий будет выглядеть следующим образом (в данном случае, в C ):

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image18.png)

<a id="_Toc318097405"></a>
#### <a name="smart-indent"></a>Умный отступ

При нажатии Enter внутри пустого элемента HTML редактор поместит точку вставки в нужное место:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image19.png)

При нажатии Введите в этом месте, тег закрытия перемещается вниз и отступом в соответствии с тегом открытия. Точка вставки также отступом:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image20.png)

<a id="_Toc318097406"></a>
#### <a name="auto-reduce-statement-completion"></a>Завершение оператора автоматического сокращения

Список IntelliSense в Visual Studio теперь фильтрует на основе того, что вы вводите так, что он отображает только соответствующие параметры:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image21.png)

IntelliSense также фильтрирует на основе титульного случая отдельных слов в списке IntelliSense. Например, при вводе "dl", отображаются как dl, так и asp:DataList:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image22.png)

Эта функция позволяет быстрее получить завершение оператора для известных элементов.

<a id="_Toc318097407"></a>
### <a name="javascript-editor"></a>редактор JavaScript

Редактор JavaScript в Visual Studio 2012 Кандидат на выпуск является совершенно новым, и это значительно улучшает опыт работы с JavaScript в Visual Studio.

<a id="_Toc318097408"></a>
#### <a name="code-outlining"></a>Структура кода

Области с изложением теперь автоматически создаются для всех функций, что позволяет свернуть части файла, которые не имеют значения для текущего фокуса.

<a id="_Toc318097409"></a>
#### <a name="brace-matching"></a>Соответствие скобок

Когда вы кладете точку вставки на скобку открытия или закрытия, редактор выделяет соответствующую точку.

<a id="_Toc318097410"></a>
#### <a name="go-to-definition"></a>Перейти к определению

Команда «Перейти к определению» позволяет перейти к источнику для функции или переменной.

<a id="_Toc318097411"></a>
#### <a name="ecmascript5-support"></a>Поддержка ECMAScript5

Редактор поддерживает новый синтаксис и AI в ECMAScript5, последней версии стандарта, описывающий язык JavaScript.

<a id="_Toc318097412"></a>
#### <a name="dom-intellisense"></a>DOM IntelliSense

IntelliSense для DOM AIS был улучшен, с поддержкой многих новых HTML5 AIS, включая *запросSelector,* DOM Storage, кросс-документ обмена сообщениями, и *холст*. DOM IntelliSense теперь управляется одним простым файлом JavaScript, а не определением библиотеки родного типа. Это упрощает расширение или замену.

<a id="_Toc318097413"></a>
#### <a name="vsdoc-signature-overloads"></a>Перегрузки подписи VSDOC

Подробные комментарии IntelliSense теперь могут быть объявлены для отдельных перегрузок функций JavaScript с помощью нового * &lt;&gt; * элемента подписи, как показано в этом примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample35.cs)]

<a id="_Toc318097414"></a>
#### <a name="implicit-references"></a>Неявные ссылки

Теперь вы можете добавить файлы JavaScript в центральный список, который будет косвенно включен в список файлов, которые любой данный файл JavaScript или блокировать ссылки, то есть вы получите IntelliSense за его содержание. Например, вы можете добавить файлы j'ery в центральный список файлов, и вы получите IntelliSense для функций j'ery в &lt;любом&gt;блоке JavaScript файла, независимо от того, ссылались ли вы на него явно (использование /// ссылка / ) или нет.

<a id="_Toc318097415"></a>
### <a name="css-editor"></a>редактор CSS

<a id="_Toc318097416"></a>
#### <a name="auto-reduce-statement-completion"></a>Завершение оператора автоматического сокращения

Список IntelliSense для CSS теперь фильтрирует на основе свойств CSS и значений, поддерживаемых выбранной схемой.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image23.png)

IntelliSense также поддерживает поиск случаев названия:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image24.png)

<a id="_Toc318097417"></a>
#### <a name="hierarchical-indentation"></a>Иерархические отступы

Редактор CSS использует отступы для отображения иерархических правил, что дает представление о том, как логически организованы каскадные правила. В следующем примере #list селектора является каскадным ребенком списка и поэтому отступом.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image25.png)

Следующий пример показывает более сложное наследование:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image26.png)

Отступ правила определяется его родительскими правилами. Иерархический отступ включен по умолчанию, но вы можете отключить его поле диалога опционов (Инструменты, Параметры из панели меню):

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image27.png)

<a id="_Toc318097418"></a>
#### <a name="css-hacks-support"></a>CSS хаки поддержки

Анализ сотен реальных файлов CSS показывает, что CSS хаки очень распространены, и теперь Visual Studio поддерживает наиболее широко используемые из них. Эта поддержка включает в себя IntelliSense\*и проверки\_звезды ( ) и подчеркнуть ( ) собственности хаки:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image28.png)

Типичные взломы селектора также поддерживаются таким образом, что иерархические отступы сохраняются даже тогда, когда они применяются. Типичный селектор рубить используется для целевой Internet Explorer 7 является prepend селектор * \*с: первый ребенок HTML*html . Использование этого правила будет поддерживать иерархические отступы:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image29.png)

<a id="_Toc318097419"></a>
#### <a name="vendor-specific-schemas--moz---webkit"></a>Поставщик конкретных схем (-moz-, -webkit)

CSS3 представляет множество свойств, которые были реализованы различными браузерами в разное время. Это ранее заставило разработчиков кодировать для определенных браузеров с помощью синтаксиса для конкретных поставщиков. Эти свойства, специфичные для браузера, теперь включены в IntelliSense.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image30.png)

<a id="_Toc318097420"></a>
#### <a name="commenting-and-uncommenting-support"></a>Комментируя и некомментируя поддержку

Теперь вы можете комментировать и не комментировать правила CSS, используя те же ярлыки, которые вы используете в редакторе кода (Ctrl-K, C для комментариев и Ctrl-K, вы без комментариев).

<a id="_Toc318097421"></a>
#### <a name="color-picker"></a>Выбор цвета

В предыдущих версиях Visual Studio, IntelliSense для цветовых атрибутов состоял из выпадающего списка названных значений цвета. Этот список был заменен полнофункциональным сборщиком цветов.

При вводе цветового значения сборщик цветов отображается автоматически и представляет список ранее использованных цветов с последующей цветовой палитрой по умолчанию. Вы можете выбрать цвет с помощью мыши или клавиатуры.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image31.png)

Список может быть расширен в полный сборщик цветов. Сборщик позволяет управлять альфа-каналом, автоматически преобразовывая любой цвет в RGBA при перемещении непрозрачности ползунка:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image32.png)

<a id="_Toc318097422"></a>
#### <a name="snippets"></a>Фрагменты кода

Фрагменты в редакторе CSS упрощают и упрощают создание стилей кросс-браузера. Многие свойства CSS3, требующие настройки браузера, теперь свернуты в фрагменты.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image33.png)

Фрагменты CSS поддерживают расширенные сценарии (например, медиа-запросы CSS3), вводя на символ(в списке IntelliSense).

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image34.png)

При выборе @media значения и нажатии вкладке редактор CSS вставляет следующий фрагмент:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image5.jpg)

Как и в обитах для кода, вы можете создать свои собственные фрагменты CSS.

<a id="_Toc318097423"></a>
#### <a name="custom-regions"></a>Пользовательские регионы

Названные области кода, которые уже доступны в редакторе кода, теперь доступны для редактирования CSS. Это позволяет легко группировать связанные блоки стиля.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image35.png)

При обрушении региона отображается название региона:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image36.png)

<a id="_Toc318097424"></a>
### <a name="page-inspector"></a>Инспектор страниц

Page Inspector — это инструмент, который отображает веб-страницу (HTML, Web Forms, ASP.NET MVC или веб-страницы) в IDE Visual Studio и позволяет изучить как исходный код, так и полученный выход. Для ASP.NET страниц Page Inspector позволяет определить, какой код сервера создал HTML-разметку, которая отображается в браузере.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image37.png)

Для получения дополнительной информации о Page Inspector, пожалуйста, ознакомьтесь со следующими учебниками:

- Использование Page Inspector в [ASP.NET MVC](../mvc/overview/views/using-page-inspector-in-aspnet-mvc.md)
- Использование Page Inspector в [ASP.NET веб-формах](../web-forms/overview/getting-started/using-page-inspector-in-a-visual-studio-11-beta-web-forms-project.md)

<a id="_Toc318097425"></a>
### <a name="publishing"></a>Публикация

<a id="_Toc318097426"></a>
#### <a name="publish-profiles"></a>Профили публикации

В Visual Studio 2010 публикация информации для проектов веб-приложений не хранится в управлении версиями и не предназначена для обмена информацией с другими пользователями. В Visual Studio 2012 Кандидат релиз, формат публикации профиля был изменен. Это был командный артефакт, и теперь его легко использовать из построений на основе MSBuild. Информация о конфигурации сборки находится в диалоговом окне Publish, так что вы можете легко переключать конфигурации сборки перед публикацией.

Профили публикаций хранятся в папке PublishProfiles. Расположение папки зависит от того, какой язык программирования вы используете:

- С: Свойства(ПубликацияПрофили
- Визуальный базовый: Мой проект »ПубликацияПрофили

Каждый профиль — это файл MSBuild. Во время публикации этот файл импортируется в файл MSBuild проекта. В Visual Studio 2010, если вы хотите внести изменения в процесс публикации или упаковки, вы должны поместить свои настройки в файл под названием **ProjectName**.wpp.targets. Это по-прежнему поддерживается, но теперь вы можете поместить свои настройки в сам профиль публикации. Таким образом, настройки будут использоваться только для этого профиля.

Теперь вы также можете использовать опубликовать профили из MSBuild. Для этого используйте следующую команду при построении проекта:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample36.cmd)]

Значение project.csproj — это путь проекта, а ProfileName — это название профиля для публикации. Кроме того, вместо того, чтобы передавать имя профиля для свойства *PublishProfile,* вы можете пройти полный путь к профилю публикации.

<a id="_Toc318097427"></a>
#### <a name="aspnet-precompilation-and-merge"></a>ASP.NET прекомпиляция и слияние

Для проектов веб-приложений кандидат в выпуск Visual Studio 2012 добавляет опцию на странице свойств пакета/публикации веб-данных, которая позволяет предварительно компиляции и объединению содержимого вашего сайта при публикации или упаковке проекта. Чтобы увидеть эти параметры, нажмите правой кнопкой мыши проекта в Solution Explorer, выберите Свойства, а затем выберите страницу свойства пакета/публикации. Следующая иллюстрация показывает Precompile это приложение перед публикацией опции.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image6.jpg)

Когда эта опция выбрана, Visual Studio предварительно компилирует приложение всякий раз, когда вы публикуете или упаковываете веб-приложение. Если вы хотите контролировать, как сайт предварительно компилируется или как сборки объединяются, нажмите кнопку Advanced, чтобы настроить эти параметры.

<a id="_Toc318097428"></a>
### <a name="iis-express"></a>IIS Express.

Веб-сервер по умолчанию для тестирования веб-проектов в Visual Studio теперь IIS Express. Сервер разработки Visual Studio по-прежнему является опцией для локального веб-сервера во время разработки, но IIS Express теперь является рекомендуемым сервером. Опыт использования IIS Express в Visual Studio 11 Beta очень похож на использование его в Visual Studio 2010 SP1.

<a id="_Toc318097429"></a>
## <a name="disclaimer"></a>Отказ от ответственности

Это предварительный документ, он может быть существенно изменен до выхода окончательного коммерческого выпуска описанного здесь программного обеспечения.

Информация, содержащаяся в этом документе, являет собой текущее представление корпорации Майкрософт о вопросах, которые обсуждались на момент публикации. Поскольку корпорация Майкрософт должна реагировать на изменение рыночных условий, эта информация не должна рассматриваться как обязательство корпорации Майкрософт. Корпорация Майкрософт не может гарантировать достоверность информации, предоставленной после момента публикации.

Данный технический документ предназначен только для ознакомительных целей. МАЙКРОСОФТ НЕ ПРЕДОСТАВЛЯЕТ НИКАКИХ ГАРАНТИЙ, ЯВНЫХ ИЛИ ПРЕДУСМОТРЕННЫХ ЗАКОНОДАТЕЛЬСТВОМ, ОТНОСИТЕЛЬНО СВЕДЕНИЙ, СОДЕРЖАЩИХСЯ В ДАННОМ ДОКУМЕНТЕ.

Ответственность за соблюдение всех авторских прав и прав на интеллектуальную собственность целиком и полностью несет пользователь. Без ограничения авторских прав ни одна из частей этого документа не может быть воспроизведена, сохранена или использована в системах поиска либо передана в любой форме, любыми способами (электронными, механическими, в виде фотокопии, в виде записи или любыми другими) и для любых целей без письменного разрешения корпорации Майкрософт.

Корпорация Майкрософт может иметь патенты, патентные заявки, охраняемые товарные знаки, авторские или другие права на интеллектуальную собственность применительно к содержимому этого документа. Без письменного разрешения корпорации Майкрософт данный документ не дает лицензии на эти патенты, охраняемые товарные знаки, авторские права и другую интеллектуальную собственность.

Если не указано иное, пример компании, организации, продукты, доменные имена, адреса электронной почты, логотипы, люди, места и события, изображенные здесь, являются фиктивными, и никаких связей с какой-либо реальной компании, организации, продукта, доменного имени, адреса электронной почты, логотипа, лица, места или события предназначены или должны быть выведены.

© Корпорация Майкрософт (Microsoft Corporation), 2012. Все права защищены.

Microsoft и Windows являются охраняемыми товарными знаками корпорации Майкрософт в США и других странах.

Названия фактических компаний и продуктов, упомянутые здесь, могут являться охраняемыми товарными знаками соответствующих владельцев.
