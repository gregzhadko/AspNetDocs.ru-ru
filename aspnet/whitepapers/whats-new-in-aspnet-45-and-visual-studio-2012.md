---
uid: whitepapers/whats-new-in-aspnet-45-and-visual-studio-2012
title: Новые возможности в ASP.NET 4,5 и Visual Studio 2012 | Документация Майкрософт
author: rick-anderson
description: В этом документе описаны новые функции и усовершенствования, появившиеся в ASP.NET 4,5. Кроме того, здесь описываются усовершенствования, вносимые в веб-разработку...
ms.author: riande
ms.date: 02/29/2012
ms.assetid: ba1fabb4-31a3-4ebf-8327-41a6bbba6eaf
msc.legacyurl: /whitepapers/whats-new-in-aspnet-45-and-visual-studio-2012
msc.type: content
ms.openlocfilehash: 32fbf7c25b00f3f0796c4c3fdd38ca2a86c89199
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78422736"
---
# <a name="whats-new-in-aspnet-45-and-visual-studio-2012"></a>Новые возможности ASP.NET 4.5 и Visual Studio 2012

> В этом документе описаны новые функции и усовершенствования, появившиеся в ASP.NET 4,5. В нем также описываются усовершенствования веб-разработки в Visual Studio 2012. Этот документ был первоначально опубликован 29 февраля 2012 г.

- [ASP.NET Core среды выполнения и платформы](#_Toc318097372)

    - [Асинхронное чтение и запись HTTP-запросов и ответов](#_Toc318097373)
    - [Усовершенствования обработки HttpRequest](#_Toc318097374)
    - [Асинхронный сброс ответа](#_Toc318097375)
    - [Поддержка асинхронных модулей и обработчиков в *ожидании* и на основе *задач*](#_Toc318097376)
    - [Асинхронные модули HTTP](#_Toc318097377)
    - [Асинхронные обработчики HTTP](#_Toc318097378)
    - [Новые функции проверки запросов ASP.NET](#_Toc318097379)
    - [Отложенная ("ленивая") Проверка запроса](#_Toc318097380)
    - [Поддержка непроверенных запросов](#_Toc318097381)
    - [Библиотека Антикссс](#_Toc318097382)
    - [Поддержка протокола WebSockets](#_Toc318097383)
    - [Объединение и минификация](#_Toc318097384)
    - [Повышение производительности при веб-размещении](#_Toc_perf)

        - [Ключевые факторы производительности](#_Toc_perf_1)
        - [Требования к новым функциям производительности](#_Toc_perf_2)
        - [Совместное использование общих сборок](#_Toc_perf_3)
        - [Использование многоядерной JIT-компиляции для ускорения запуска](#_Toc_perf_4)
        - [Настройка сбора мусора для оптимизации памяти](#_Toc_perf_5)
        - [Упреждающая выборка для веб-приложений](#_Toc_perf_6)
- [Веб-формы ASP.NET](#_Toc318097385)

    - [Строго типизированные элементы управления данными](#_Toc318097386)
    - [Привязка модели](#_Toc318097387)

        - [Выбор данных](#_Toc318097388)
        - [Поставщики значений](#_Toc318097389)
        - [Фильтрация по значениям из элемента управления](#_Toc318097390)
    - [Выражения привязки данных в кодировке HTML](#_Toc318097391)
    - [Ненавязчивая проверка](#_Toc318097392)
    - [Обновления HTML5](#_Toc318097393)
- [ASP.NET MVC 4](#_Toc318097394)
- [Веб-страницы ASP.NET 2](#_Toc318097395)
- [Версия-кандидат Visual Studio 2012](#_Toc318097396)

    - [Совместное использование проектов в Visual Studio 2010 и версии-кандидате Visual Studio 2012 (совместимость проектов)](#project-compatibility)
    - [Изменения конфигурации в шаблонах веб-сайта ASP.NET 4,5](#Configuration_Changes_In_ASPNET45_Website_Templates)
    - [Собственная поддержка в IIS 7 для маршрутизации ASP.NET](#Native_Support_In_IIS7_For_ASPNET_Routine)
    - [Редактор HTML](#_Toc318097397)

        - [Интеллектуальные задачи](#_Toc318097398)
        - [ОЖИДАТЬ-поддержка ARIA](#_Toc318097399)
        - [Новые фрагменты HTML5](#_Toc318097400)
        - [Извлечь в пользовательский элемент управления](#_Toc318097401)
        - [IntelliSense для кусочки кода в атрибутах](#_Toc318097402)
        - [Автоматическое переименование совпадающего тега при переименовании открывающего или закрывающего тега](#_Toc318097403)
        - [Создание обработчика событий](#_Toc318097404)
        - [Интеллектуальный отступ](#_Toc318097405)
        - [Автоматическое сокращение завершения операторов](#_Toc318097406)
    - [Редактор JavaScript](#_Toc318097407)

        - [Структурирование кода](#_Toc318097408)
        - [Парные фигурные скобки](#_Toc318097409)
        - [Перейти к определению](#_Toc318097410)
        - [Поддержка ECMAScript5](#_Toc318097411)
        - [IntelliSense DOM](#_Toc318097412)
        - [Перегрузки сигнатур ВСДОК](#_Toc318097413)
        - [Неявные ссылки](#_Toc318097414)
    - [Редактор CSS](#_Toc318097415)

        - [Автоматическое сокращение завершения операторов](#_Toc318097416)
        - [Иерархические отступы.](#_Toc318097417)
        - [Поддержка хакеров CSS](#_Toc318097418)
        - [Схемы, зависящие от поставщика (-MOZ-,-WebKit)](#_Toc318097419)
        - [Поддержка комментирования и раскомментирования](#_Toc318097420)
        - [Палитра цветов](#_Toc318097421)
        - [Фрагменты кода](#_Toc318097422)
        - [Пользовательские регионы](#_Toc318097423)
    - [Инспектор страниц](#_Toc318097424)
    - [Публикация](#_Toc318097425)

        - [Профили публикации](#_Toc318097426)
        - [Предварительная компиляция и слияние ASP.NET](#_Toc318097427)
- [IIS Express](#_Toc318097428)
- [Заявление об отказе](#_Toc318097429)

<a id="_Toc318097372"></a>
## <a name="aspnet-core-runtime-and-framework"></a>ASP.NET Core среды выполнения и платформы

<a id="_Toc318097373"></a>
### <a name="asynchronously-reading-and-writing-http-requests-and-responses"></a>Асинхронное чтение и запись HTTP-запросов и ответов

В ASP.NET 4 появилась возможность чтения сущности HTTP-запроса в виде потока с помощью метода *HttpRequest. жетбуфферлессинпутстреам* . Этот метод предоставил потоковый доступ к сущности запроса. Однако он выполнялся синхронно, что привязывает поток к длительности запроса.

ASP.NET 4,5 поддерживает возможность асинхронного чтения потоков в сущности HTTP-запроса, а также возможность асинхронного сброса. ASP.NET 4,5 также предоставляет возможность двойной буферизации сущности HTTP-запроса, которая обеспечивает более простую интеграцию с подчиненными обработчиками HTTP, такими как ASPX-обработчики страниц и контроллеры MVC ASP.NET.

<a id="_Toc318097374"></a>
#### <a name="improvements-to-httprequest-handling"></a>Усовершенствования обработки HttpRequest

Ссылка на поток, возвращаемая функцией ASP.NET 4,5 из *HttpRequest. жетбуфферлессинпутстреам* , поддерживает как синхронные, так и асинхронные методы чтения. Объект *Stream* , возвращаемый из *жетбуфферлессинпутстреам* , теперь реализует методы BeginRead и EndRead. Асинхронные методы *потока* позволяют асинхронно считывать сущность запроса в фрагментах, в то время как ASP.NET освобождает текущий поток между каждой итерацией асинхронного цикла чтения.

ASP.NET 4,5 также добавил вспомогательный метод для чтения сущности запроса в буферизованном виде: *HttpRequest. GetBufferedInputStream*. Эта новая перегрузка работает так же, как *жетбуфферлессинпутстреам*, поддерживающая синхронные и асинхронные операции чтения. Однако при чтении *GetBufferedInputStream* также копирует байты сущности в внутренние буферы ASP.NET, чтобы нисходящие модули и обработчики могли обращаться к сущности запроса. Например, если некоторый вышестоящий код в конвейере уже прочитал сущность запроса с помощью *GetBufferedInputStream*, можно по-прежнему использовать *HttpRequest. Form* или *HttpRequest. Files*. Это позволяет выполнять асинхронную обработку запроса (например, потоковая передача большого файла в базу данных), но после этого все равно запускаются ASPX-страницы и контроллеры ASP.NET MVC.

<a id="_Toc318097375"></a>
#### <a name="asynchronously-flushing-a-response"></a>Асинхронный сброс ответа

Отправка ответов клиенту HTTP может занять значительное время, когда клиент выходит из него или имеет подключение с низкой пропускной способностью. Обычно ASP.NET помещает байты ответов по мере их создания приложением. Затем ASP.NET выполняет одну операцию отправки начисленных буферов в самом конце обработки запроса.

Если буферный ответ большой (например, потоковая передача большого файла клиенту), необходимо периодически вызывать *HttpResponse. Flush* для отправки буферизованных выходных данных клиенту и сохранения использования памяти под контролем. Однако, поскольку *Сброс* является синхронным вызовом, последовательный вызов операции *flush* по-прежнему потребляет поток на время потенциально долго выполняющихся запросов.

ASP.NET 4,5 добавляет поддержку асинхронного выполнения операций записи с помощью методов *бегинфлуш* и *ендфлуш* класса *HttpResponse* . С помощью этих методов можно создавать асинхронные модули и асинхронные обработчики, которые выполняют добавочную отправку данных клиенту без прерывания потоков операционной системы. В между вызовами *бегинфлуш* и *ендфлуш* ASP.NET освобождает текущий поток. Это значительно сокращает общее число активных потоков, необходимых для поддержки длительных Скачиваний HTTP.

<a id="_Toc318097376"></a>
### <a name="support-for-await-and-task---based-asynchronous-modules-and-handlers"></a>Поддержка асинхронных модулей и обработчиков в *ожидании* и на основе *задач*

В .NET Framework 4 появилась концепция асинхронного программирования, называемая *задачей*. Задачи представлены типом *задачи* и связанными типами в пространстве имен *System. Threading. Tasks* . .NET Framework 4,5 построены на этом с помощью усовершенствований компилятора, которые делают работу с объектами *задач* простыми. В .NET Framework 4,5 компиляторы поддерживают два новых ключевых слова: *await* и *Async*. Ключевое слово *await* — это сокращенная синтаксическая форма, указывающая, что фрагмент кода должен асинхронно ожидать какой-либо другой фрагмент кода. Ключевое слово *Async* представляет указание, которое можно использовать для пометки методов как асинхронных методов, основанных на задачах.

Сочетание *await*, *Async*и объекта *Task* значительно упрощает написание асинхронного кода в .NET 4,5. ASP.NET 4,5 поддерживает эти упрощения с помощью новых API, которые позволяют создавать асинхронные HTTP-модули и асинхронные обработчики HTTP с помощью новых улучшений компилятора.

<a id="_Toc318097377"></a>
#### <a name="asynchronous-http-modules"></a>Асинхронные модули HTTP

Предположим, что необходимо выполнять асинхронную работу в методе, который возвращает объект *Task* . В следующем примере кода определяется асинхронный метод, который выполняет асинхронный вызов для загрузки домашней страницы Майкрософт. Обратите внимание на использование ключевого слова *Async* в сигнатуре метода и вызове *await* в *довнлоадстрингтаскасинк*.

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample1.cs)]

Это все, что вам нужно написать — .NET Framework будет автоматически выполнять очистку стека вызовов при ожидании завершения загрузки, а также автоматически восстанавливать стек вызовов после скачивания.

Теперь предположим, что вы хотите использовать этот асинхронный метод в асинхронном HTTP-модуле ASP.NET. ASP.NET 4,5 включает вспомогательный метод (*евенсандлертаскасинчелпер*) и новый тип делегата (*таскевенсандлер*), который можно использовать для интеграции асинхронных методов на основе задач с более старой моделью асинхронного программирования, предоставляемой конвейером ASP.NET HTTP. В этом примере показано, как:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample2.cs)]

<a id="_Toc318097378"></a>
#### <a name="asynchronous-http-handlers"></a>Асинхронные обработчики HTTP

Традиционным подходом к написанию асинхронных обработчиков в ASP.NET является реализация интерфейса *IHttpAsyncHandler* . В ASP.NET 4,5 появился асинхронный базовый тип *хттптаскасинчандлер* , который можно наследовать от, что значительно упрощает написание асинхронных обработчиков.

Тип *хттптаскасинчандлер* является абстрактным и требует переопределения метода *процессрекуестасинк* . Внутренне ASP.NET берет на себя интеграцию возвращаемой сигнатуры (объект *задачи* ) *процессрекуестасинк* с устаревшей моделью асинхронного программирования, используемой конвейером ASP.NET.

В следующем примере показано, как можно использовать *Task* и *await* в рамках реализации асинхронного обработчика http:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample3.cs)]

<a id="_Toc318097379"></a>
### <a name="new-aspnet-request-validation-features"></a>Новые функции проверки запросов ASP.NET

По умолчанию ASP.NET выполняет проверку запроса — он проверяет запросы на поиск разметки или скрипта в полях, заголовках, файлах cookie и т. д. При обнаружении такого объекта ASP.NET создает исключение. Это является первой линией защиты от потенциальных атак с использованием межсайтовых сценариев.

ASP.NET 4,5 позволяет легко выборочно считывать непроверенные данные запроса. ASP.NET 4,5 также интегрирует популярную библиотеку Антикссс, которая ранее была внешней библиотекой.

Разработчикам часто предлагается возможность выборочно отключить проверку запросов для своих приложений. Например, если приложение является программным обеспечением на форуме, можно разрешить пользователям отправлять сообщения и комментарии на форуме в формате HTML, но убедиться, что проверка запроса проверяет все остальное.

В ASP.NET 4,5 появились две функции, упрощающие выборочную работу с непроверенными входными данными: отложенная ("ленивая") Проверка запроса и доступ к непроверенным данным запроса.

<a id="_Toc318097380"></a>
#### <a name="deferred-lazy-request-validation"></a>Отложенная ("ленивая") Проверка запроса

В ASP.NET 4,5 по умолчанию все данные запроса подчиняются проверке запроса. Однако можно настроить приложение на откладывание проверки запросов до фактического доступа к данным запроса. (Иногда это называется отложенной проверкой запросов, основанной на таких терминах, как отложенная загрузка для определенных сценариев данных.) Вы можете настроить приложение для использования отложенной проверки в файле Web. config, задав для атрибута *рекуествалидатионмоде* значение 4,5 в элементе *httpRUntime* , как показано в следующем примере:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample4.xml)]

Если для режима проверки запроса задано значение 4,5, проверка запроса активируется только для конкретного значения запроса и только тогда, когда код обращается к этому значению. Например, если код получает значение запроса. Форма ["Forum\_Post"], проверка запроса вызывается только для этого элемента в коллекции форм. Никакие другие элементы в коллекции *форм* не проверяются. В предыдущих версиях ASP.NET проверка запроса была активирована для всей коллекции запросов при обращении к любому элементу в коллекции. Новое поведение позволяет различным компонентам приложения просматривать различные части данных запроса, не запуская проверку запросов на других частях.

<a id="_Toc318097381"></a>
#### <a name="support-for-unvalidated-requests"></a>Поддержка непроверенных запросов

Только отложенная проверка запроса не решает проблему выборочного обхода проверки запросов. Вызов запроса. Form ["форума\_Post"] по-прежнему активирует проверку запросов для этого конкретного значения запроса. Однако может потребоваться получить доступ к этому полю, не запуская проверку, так как вы хотите разрешить разметку в этом поле.

Чтобы это сделать, ASP.NET 4,5 теперь поддерживает непроверенный доступ к данным запроса. ASP.NET 4,5 включает в себя новое свойство *непроверенной* коллекции в классе *HttpRequest* . Эта коллекция предоставляет доступ ко всем общим значениям запроса, таким как *форма*, *строка запроса*, *файлы cookie*и *URL-адрес*.

Используя пример на форуме для чтения непроверенных данных запроса, сначала необходимо настроить приложение для использования нового режима проверки запроса:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample5.xml)]

Затем можно использовать свойство *HttpRequest. unvalidateed* для чтения непроверенного значения формы:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample6.cs)]

> [!WARNING]
> Безопасность — *Используйте непроверенные данные запроса с осторожностью!* ASP.NET 4,5 добавил непроверенные свойства запроса и коллекции, чтобы упростить доступ к очень конкретным непроверенным данным запроса. Тем не менее необходимо выполнить пользовательскую проверку данных необработанных запросов, чтобы предотвратить визуализацию опасного текста для пользователей.

<a id="_Toc318097382"></a>
### <a name="antixss-library"></a>Библиотека Антикссс

Из-за популярности библиотеки Microsoft Антикссс ASP.NET 4,5 теперь включает основные подпрограммы кодирования из версии 4,0 этой библиотеки.

Подпрограммы кодирования реализуются типом *AntiXssEncoder* в новом пространстве имен *System. Web. Security. антикссс* . Тип *AntiXssEncoder* можно использовать напрямую, вызвав любой из методов статического кодирования, реализованных в типе. Однако самым простым подходом к использованию новых подпрограмм защиты от XSS является настройка приложения ASP.NET для использования класса *AntiXssEncoder* по умолчанию. Для этого добавьте в файл Web. config следующий атрибут:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample7.xml)]

Если для атрибута *енкодертипе* задано использование типа *AntiXssEncoder* , вся кодировка вывода в ASP.NET автоматически использует новые подпрограммы кодирования.

Это части внешней библиотеки Антикссс, которые были включены в ASP.NET 4,5:

- *HtmlEncode*, *хтмлформурленкоде*и *хтмлаттрибутинкоде*
- *Ксмлаттрибутинкоде* и *ксмленкоде*
- *UrlEncode* и *урлпасенкоде* (новое)
- *кссенкоде*

<a id="_Toc318097383"></a>
### <a name="support-for-websockets-protocol"></a>Поддержка протокола WebSockets

Протокол WebSockets — это сетевой протокол на основе стандартов, который определяет, как установить безопасное, двунаправленное взаимодействие в режиме реального времени между клиентом и сервером по протоколу HTTP. Корпорация Майкрософт работает с основными стандартами IETF и W3C, чтобы помочь определить протокол. Протокол WebSockets поддерживается любым клиентом (а не только браузерами), при этом Корпорация Майкрософт вкладывает значительные ресурсы, поддерживающие протокол WebSocket, в клиентской и мобильной операционных системах.

Протокол WebSockets значительно упрощает создание длительно выполняемых операций передачи данных между клиентом и сервером. Например, написание приложения для разговора гораздо проще, поскольку можно установить долгосрочное соединение между клиентом и сервером. Для имитации поведения сокета не нужно повлиять на такие обходные пути, как периодические опросы или длительный опрос HTTP.

ASP.NET 4,5 и IIS 8 включают поддержку низкоуровневых соединений WebSocket, позволяя разработчикам ASP.NET использовать управляемые API для асинхронного чтения и записи строковых и двоичных данных в объекте WebSockets. Для ASP.NET 4,5 существует новое пространство имен *System. Web. WebSockets* , которое содержит типы для работы с протоколом WebSockets.

Клиент браузера устанавливает соединение *WebSocket* , создавая объект DOM, указывающий на URL-адрес в приложении ASP.NET, как показано в следующем примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample8.cs)]

Конечные точки WebSocket можно создавать в ASP.NET с помощью любого типа модуля или обработчика. В предыдущем примере использовался ASHX-файл, поскольку файлы. ASHX — это быстрый способ создания обработчика.

В соответствии с протоколом WebSocket приложение ASP.NET принимает запрос клиентов WebSocket, указывая, что запрос должен быть обновлен из HTTP-запроса GET к запросу WebSockets. Ниже приведен пример:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample9.cs)]

Метод *акцептвебсоккетрекуест* принимает делегат функции, поскольку ASP.NET очищает текущий HTTP-запрос, а затем передает управление делегату функции. Концептуально этот подход аналогичен использованию *System. Threading. Thread*, где определяется делегат запуска потока, в котором выполняется фоновая работа.

После того как ASP.NET и клиент успешно завершили подтверждение соединений WebSocket, ASP.NET вызывает делегат, и приложение WebSockets начнет работать. В следующем примере кода показано простое приложение Echo, которое использует встроенную поддержку WebSockets в ASP.NET:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample10.cs)]

Поддержка в .NET 4,5 для ключевого слова *await* и асинхронных операций на основе задач является естественным соответствием для написания приложений WebSocket. В примере кода показано, что запрос WebSockets выполняется полностью асинхронно внутри ASP.NET. Приложение ожидает асинхронного сообщения о том, что сообщение отправляется из клиента путем вызова метода *await Socket. ReceiveAsync*. Аналогичным образом можно отправить асинхронное сообщение клиенту, вызвав *await сокет. SendAsync*.

В браузере приложение получает сообщения WebSocket через функцию *onmessage* . Чтобы отправить сообщение из браузера, вызовите метод *Send* типа DOM *WebSocket* , как показано в следующем примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample11.cs)]

В будущем мы можем выпустить обновления этой функции, которые не являются частью кода нижнего уровня, который необходим в этом выпуске для приложений WebSocket.

<a id="_Toc318097384"></a>
### <a name="bundling-and-minification"></a>Объединение и минификация

Объединение позволяет объединить отдельные файлы JavaScript и CSS в пакет, который можно рассматривать как один файл. Минификации сжимает файлы JavaScript и CSS, удаляя пробелы и другие ненужные символы. Эти функции работают с веб-формами, ASP.NET MVC и веб-страницами.

Пакеты создаются с помощью класса пакета или одного из его дочерних классов, Скриптбундле и Стилебундле. После настройки экземпляра пакета пакет становится доступным для входящих запросов, просто добавляя его в глобальный экземпляр Бундлеколлектион. В шаблонах по умолчанию конфигурация пакета выполняется в файле Бундлеконфиг. Эта конфигурация по умолчанию создает пакеты для всех основных скриптов и файлов CSS, используемых шаблонами.

К пакетам можно обращаться из представлений с помощью одного из двух возможных вспомогательных методов. Чтобы обеспечить поддержку отрисовки разметки для пакета в режиме отладки и выпуска, классы Скриптбундле и Стилебундле имеют вспомогательный метод визуализации. В режиме отладки Render создает разметку для каждого ресурса в пакете. В режиме выпуска Render создает один элемент разметки для всего пакета. Переключение между режимами отладки и выпуска может быть выполнено путем изменения атрибута debug элемента compilation в файле Web. config, как показано ниже:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample12.xml)]

Кроме того, включение или отключение оптимизации можно задать непосредственно через свойство Бундлетабле. Енаблеоптимизатионс.

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample13.cs)]

При объединении файлов они сначала сортируются в алфавитном порядке (то, как они отображаются в **Обозреватель решений**). Затем они упорядочиваются таким образом, чтобы известные библиотеки и их пользовательские расширения (например, jQuery, Мутулс и Dojo) загружались первыми. Например, окончательный порядок объединения папки Scripts (скрипты), как показано выше, будет следующим:

1. жкуери-1.6.2. js
2. жкуери-УИ. js
3. jQuery. Tools. js
4. a. js

Файлы CSS также сортируются в алфавитном порядке, а затем реорганизуются так, чтобы файл Reset. CSS и нормализация. CSS наступил перед любым другим файлом. Окончательная сортировка объединения стилей, показанных выше, будет следующей:

1. Сброс. CSS
2. Content. CSS
3. Forms. CSS
4. Globals. CSS
5. Menu. CSS
6. Styles. CSS

<a id="_Toc_perf"></a>
### <a name="performance-improvements-for-web-hosting"></a>Повышение производительности при веб-размещении

.NET Framework 4,5 и Windows 8 предоставляют функции, которые могут помочь добиться значительного повышения производительности рабочих нагрузок веб-сервера. Сюда входит сокращение (до 35%) как в момент запуска, так и в памяти, занимаемой веб-сайтами размещения, использующими ASP.NET.

<a id="_Toc_perf_1"></a>
#### <a name="key-performance-factors"></a>Ключевые факторы производительности

В идеале все веб-сайты должны быть активны и находиться в памяти, чтобы обеспечить быстрое реагирование на следующий запрос, когда он поступает. Факторы, которые могут повлиять на скорость реагирования сайта, включают:

- Время, необходимое для перезапуска сайта после очистки пула приложений. Это время, необходимое для запуска процесса веб-сервера для сайта, когда сборки сайта больше не находятся в памяти. (Сборки платформы по-прежнему находятся в памяти, так как они используются другими сайтами.) Такая ситуация называется «холодный сайт», «горячий запуск» или «холодный запуск сайта».
- Объем памяти, занимаемой сайтом. Условия для этого: "потребление памяти на сайте" или "необщий рабочий набор".

Новые улучшения производительности сосредоточены на обоих этих факторах.

<a id="_Toc_perf_2"></a>
#### <a name="requirements-for-new-performance-features"></a>Требования к новым функциям производительности

Требования к новым функциям можно разделить на следующие категории:

- Улучшения, выполняемые на .NET Framework 4.
- Улучшения, требующие .NET Framework 4,5, но могут выполняться в любой версии Windows.
- Улучшения, доступные только с .NET Framework 4,5, работающими в Windows 8.

Повышение производительности с каждым уровнем улучшения, который вы можете включить.

Некоторые улучшения .NET Framework 4,5 используют преимущества более широких функций производительности, которые также применяются к другим сценариям.

<a id="_Toc_perf_3"></a>
#### <a name="sharing-common-assemblies"></a>Совместное использование общих сборок

**Требование**: .NET Framework 4 и Visual Studio 11 Developer Preview SDK

Разные сайты на сервере часто используют одни и те же вспомогательные сборки (например, сборки из начального набора или примера приложения). Каждый сайт имеет собственную копию этих сборок в каталоге bin. Несмотря на то, что объектный код для сборок идентичен, они являются физически отдельными сборками, поэтому каждую сборку необходимо отдельно считывать во время холодного запуска сайта и хранить в памяти отдельно.

Новая функция интернирования решает эту неэффективность и сокращает объем ОЗУ и время загрузки. Интернирование позволяет Windows удерживать единственную копию каждой сборки в файловой системе, а отдельные сборки в папках bin заменяются символической ссылкой на одну копию. Если для отдельного сайта требуется отдельная версия сборки, символьная ссылка заменяется новой версией сборки и затрагивается только этот сайт.

Для совместного использования сборок с символьными ссылками требуется новое средство с именем ASPNET\_интернирован. exe, которое позволяет создавать и администрировать хранилище интернированных сборок. Он предоставляется в составе пакета SDK для разработчиков Visual Studio 11 Developer Preview. (Однако он будет работать в системе, где установлена только .NET Framework 4, предполагая, что вы установили Последнее [Обновление](https://support.microsoft.com/kb/2468871).)

Чтобы убедиться, что все подходящие сборки были интернированы, вы запускаете ASPNET\_InterNIC. exe периодически (например, раз в неделю как запланированную задачу). Типичное использование выглядит следующим образом:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample14.cmd)]

Чтобы просмотреть все параметры, запустите средство без аргументов.

<a id="_Toc_perf_4"></a>
#### <a name="using-multi-core-jit-compilation-for-faster-startup"></a>Использование многоядерной JIT-компиляции для ускорения запуска

**Требование**: .NET Framework 4,5

Для запуска холодного сайта не только нужно считывать сборки с диска, но и сайт должен быть JIT-скомпилирован. Для сложного сайта это может добавить значительные задержки. Новый метод общего назначения в .NET Framework 4,5 сокращает эти задержки за счет распределения JIT-компиляции между доступными ядрами процессора. Она делает это как можно раньше, используя сведения, собранные во время предыдущих запусков сайта. Эта функция реализована методом [System. Runtime. профилеоптимизатион. StartProfile](https://msdn.microsoft.com/library/system.runtime.profileoptimization.startprofile(VS.110).aspx) .

JIT-компиляция с использованием нескольких ядер включена по умолчанию в ASP.NET, поэтому для использования этой функции не нужно ничего делать. Если вы хотите отключить эту функцию, сделайте следующий параметр в файле Web. config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample15.xml)]

<a id="_Toc_perf_5"></a>
#### <a name="tuning-garbage-collection-to-optimize-for-memory"></a>Настройка сбора мусора для оптимизации памяти

**Требование**: .NET Framework 4,5

После запуска сайта использование кучи сборщика мусора (GC) может быть важным фактором в потреблении памяти. Как и любой сборщик мусора, .NET Framework GC обеспечивает компромиссы между временем ЦП (частотой и значимостью коллекций) и потреблением памяти (дополнительное пространство, используемое для новых, освобожденных или свободных объектов). В предыдущих выпусках мы предоставили рекомендации по настройке GC для достижения правильного баланса (например, см. раздел [Конфигурация общего размещения ASP.NET 2.0/3.5](https://www.iis.net/learn/web-hosting/web-server-for-shared-hosting/aspnet-20-35-shared-hosting-configuration)).

Для .NET Framework 4,5 вместо нескольких автономных параметров доступен параметр конфигурации, определяемый рабочей нагрузкой, который включает все ранее Рекомендуемые параметры GC, а также новую настройку, обеспечивающую дополнительную производительность для каждого сайта. Рабочий набор.

Чтобы включить настройку памяти GC, добавьте следующий параметр в файл Windows\Microsoft.NET\Framework\v4.0.30319\aspnet.config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample16.xml)]

(Если вы знакомы с предыдущими инструкциями по внесению изменений в файл ASPNET. config, обратите внимание, что этот параметр заменяет старые параметры, например, нет необходимости устанавливать gcServer, gcConcurrent и т. д. Удалять старые параметры не требуется.)

<a id="_Toc_perf_6"></a>
#### <a name="prefetching-for-web-applications"></a>Упреждающая выборка для веб-приложений

**Требование**: .NET Framework 4,5 под Windows 8

В нескольких выпусках Windows включила технологию, известную как [Предварительная выборка](http://en.wikipedia.org/wiki/Prefetcher) , которая сокращает затраты на чтение с диска при запуске приложения. Поскольку холодный запуск — это проблема, которая в основном используется для клиентских приложений, эта технология не включена в Windows Server, которая включает в себя только те компоненты, которые необходимы для сервера. Предварительная выборка теперь доступна в последней версии Windows Server, где она может оптимизировать запуск отдельных веб-сайтов.

Для Windows Server предвыборка не включена по умолчанию. Чтобы включить и настроить предварительную выборку для веб-размещения с высокой плотностью, выполните следующий набор команд в командной строке:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample17.cmd)]

Затем, чтобы интегрировать предзагрузку с приложениями ASP.NET, добавьте в файл Web. config следующее:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample18.xml)]

<a id="_Toc318097385"></a>
## <a name="aspnet-web-forms"></a>Веб-формы ASP.NET

<a id="_Toc318097386"></a>
### <a name="strongly-typed-data-controls"></a>Строго типизированные элементы управления данными

В ASP.NET 4,5 веб-формы содержат некоторые улучшения для работы с данными. Первое улучшение — это строго типизированные элементы управления данными. Для элементов управления веб-форм в предыдущих версиях ASP.NET вы отображаете значение с привязкой к данным с помощью *eval* и выражения привязки данных:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample19.aspx)]

Для двусторонней привязки данных используется *BIND*:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample20.aspx)]

Во время выполнения эти вызовы используют отражение для считывания значения указанного элемента, а затем отображают результат в разметке. Такой подход упрощает привязку данных к произвольным, нефигурным данным.

Однако такие выражения привязки данных не поддерживают такие функции, как IntelliSense для имен членов, Навигация (например, переход к определению) или проверка во время компиляции для этих имен.

Для решения этой проблемы в ASP.NET 4,5 добавлена возможность объявления типа данных, к которым привязан элемент управления. Это делается с помощью нового свойства *ItemType* . При задании этого свойства в области выражений привязки данных будут доступны две новые типизированные переменные: *Item* и *биндитем*. Так как переменные строго типизированы, вы получаете все преимущества разработки Visual Studio.

Для двусторонних выражений привязки данных используйте переменную *биндитем* :

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample21.aspx)]

Большинство элементов управления в инфраструктуре веб-форм ASP.NET, которые поддерживают привязку данных, были обновлены для поддержки свойства *ItemType* .

<a id="_Toc318097387"></a>
### <a name="model-binding"></a>Привязка модели

Привязка модели расширяет привязку данных в элементах управления веб-форм ASP.NET для работы с доступом к данным, ориентированным на код. Он включает основные понятия из элемента управления *ObjectDataSource* и из привязки модели в ASP.NET MVC.

<a id="_Toc318097388"></a>
#### <a name="selecting-data"></a>Выбор данных

Чтобы настроить элемент управления данными для использования привязки модели для выбора данных, присвойте свойству *SelectMethod* элемента управления имя метода в коде страницы. Элемент управления данными вызывает метод в соответствующее время в жизненном цикле страницы и автоматически привязывает возвращенные данные. Нет необходимости в явном вызове метода *DataBind* .

В следующем примере элемент управления *GridView* настроен для использования метода с именем *Categories*:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample22.aspx)]

Метод *Categories* создается в коде страницы. Для простой операции Select метод не требует параметров и должен возвращать объект *IEnumerable* или *IQueryable* . Если для нового свойства *ItemType* задано значение (которое позволяет использовать строго типизированные выражения привязки данных, как описано выше в разделе [строго типизированные элементы управления данными](#_Toc318097386) ), следует возвращать универсальные версии этих интерфейсов — *IEnumerable&lt;T&gt;* или *IQueryable&lt;t&gt;* с параметром *t* , соответствующим типу свойства *ItemType* (например, *&lt;категории IQueryable* &gt;).

В следующем примере показан код для метода *Categories* . В этом примере используется модель Code First Entity Framework с образцом базы данных Northwind. Код гарантирует, что запрос возвращает сведения о связанных продуктах для каждой категории с помощью метода *include* . (Это гарантирует, что элемент *TemplateField* в разметке отображает количество продуктов в каждой категории без необходимости в [n + 1 SELECT](http://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem).)

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample23.cs)]

При запуске страницы элемент управления *GridView* автоматически вызывает метод *Categories* и отображает возвращенные данные с помощью настроенных полей:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image2.png)

Поскольку метод Select возвращает объект *IQueryable* , элемент управления *GridView* может дополнительно манипулировать запросом перед его выполнением. Например, элемент управления *GridView* может добавлять выражения запроса для сортировки и разбиения на страницы в возвращаемый объект *IQueryable* перед выполнением, чтобы эти операции выполнялись базовым поставщиком LINQ. В этом случае Entity Framework обеспечит выполнение этих операций в базе данных.

В следующем примере показан элемент управления *GridView* , измененный для сортировки и разбиения на страницы:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample24.aspx)]

Теперь при запуске страницы элемент управления может убедиться, что отображается только текущая страница данных, и что она упорядочена по выбранному столбцу:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image3.png)

Чтобы отфильтровать возвращаемые данные, необходимо добавить параметры в метод Select. Эти параметры будут заполняться привязкой модели во время выполнения, и их можно использовать для изменения запроса перед возвратом данных.

Например, предположим, что вы хотите разрешить пользователям фильтровать продукты, введя ключевое слово в строке запроса. Можно добавить параметр в метод и обновить код для использования значения параметра:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample25.cs)]

Этот код включает выражение *WHERE* , если для *ключевого слова* указано значение, а затем возвращает результаты запроса.

<a id="_Toc318097389"></a>
#### <a name="value-providers"></a>Поставщики значений

В предыдущем примере не было указано, откуда поступило значение параметра *ключевого слова* . Чтобы указать эти сведения, можно использовать атрибут параметра. В этом примере можно использовать класс *куеристрингаттрибуте* , который находится в пространстве имен *System. Web. моделбиндинг* :

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample26.cs)]

Это инструктирует привязку модели, чтобы попытаться привязать значение из строки запроса к параметру *ключевого слова* во время выполнения. (Это может привести к выполнению преобразования типов, хотя в данном случае это не так.) Если значение не может быть указано и тип не допускает значения NULL, возникает исключение.

Источники значений для этих методов называются поставщиками значений, а атрибуты параметров, указывающие, какой поставщик значений следует использовать, называются атрибутами поставщика значений. Веб-формы будут включать поставщиков значений и соответствующие атрибуты для всех типовых источников вводимых пользователем данных в приложении веб-форм, таких как строка запроса, файлы cookie, значения форм, элементы управления, состояние представления, состояние сеанса и свойства профиля. Кроме того, можно создавать пользовательские поставщики значений.

По умолчанию имя параметра используется в качестве ключа для поиска значения в коллекции поставщиков значений. В этом примере код будет искать значение строки запроса с именем ключевого слова (например, ~/дефаулт.аспкс? keyword = Chef). Можно указать пользовательский ключ, передав его в качестве аргумента в атрибут Parameter. Например, чтобы использовать значение переменной строки запроса с именем q, можно сделать следующее:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample27.cs)]

Если этот метод находится в коде страницы, пользователи могут отфильтровать результаты, передав ключевое слово с помощью строки запроса:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image4.png)

Привязка модели выполняет множество задач, которые в противном случае пришлось бы передать коду вручную: считывание значения, проверка значения NULL, попытка преобразовать его в соответствующий тип, проверка успешности преобразования и, наконец, использование значения в Выбор. Привязка модели приводит к гораздо меньшему объему кода и позволяет повторно использовать функции приложения.

<a id="_Toc318097390"></a>
#### <a name="filtering-by-values-from-a-control"></a>Фильтрация по значениям из элемента управления

Предположим, вы хотите расширить пример, чтобы позволить пользователю выбрать значение фильтра из раскрывающегося списка. Добавьте в разметку следующий раскрывающийся список и настройте его для получения данных из другого метода, используя свойство *SelectMethod* :

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample28.aspx)]

Обычно в элемент управления *GridView* также добавляется элемент *емптидататемплате* , чтобы элемент управления отображал сообщение, если соответствующие продукты не найдены:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample29.aspx)]

В коде страницы добавьте новый метод Select для раскрывающегося списка:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample30.cs)]

Наконец, обновите метод Select для *продуктов* , чтобы создать новый параметр, содержащий идентификатор выбранной категории из раскрывающегося списка:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample31.cs)]

Теперь при выполнении страницы пользователи могут выбрать категорию из раскрывающегося списка, а элемент управления *GridView* автоматически повторно привязывается для отображения отфильтрованных данных. Это возможно, поскольку привязка модели отслеживает значения параметров для методов Select и определяет, изменилось ли какое-либо значение параметра после обратной передачи. В этом случае привязка модели заставляет связанный элемент управления данными повторно выполнить привязку к данным.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image5.png)

<a id="_Toc318097391"></a>
### <a name="html-encoded-data-binding-expressions"></a>Выражения привязки данных в кодировке HTML

Теперь можно кодировать результат выражений привязки данных в формате HTML. Добавьте двоеточие (:) в конец префикса &lt;% #, который помечает выражение привязки данных:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample32.aspx)]

<a id="_Toc318097392"></a>
### <a name="unobtrusive-validation"></a>Ненавязчивая проверка

Теперь можно настроить встроенные проверяющие элементы управления, чтобы использовать ненавязчивый код JavaScript для логики проверки на стороне клиента. Это значительно сокращает объем кода JavaScript, отображаемого в разметке страницы, и уменьшает общий размер страницы. Можно настроить ненавязчивый JavaScript для проверяющих элементов управления одним из следующих способов:

- Глобально, добавив следующий параметр в элемент *&lt;appSettings&gt;* в файле Web. config: 

    [!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample33.xml)]
- Глобально, установив свойство статического свойства *System. Web. UI. ValidationSettings. унобтрусивевалидатионмоде* в *унобтрусивевалидатионмоде. WebForms* (обычно в *приложении\_запуск* в файле Global. asax).
- Отдельно для страницы, задав новое свойство *унобтрусивевалидатионмоде* класса *Page* равным *унобтрусивевалидатионмоде. WebForms*.

<a id="_Toc318097393"></a>
### <a name="html5-updates"></a>Обновления HTML5

Некоторые усовершенствования были внесены в серверные элементы управления Web Forms, чтобы воспользоваться преимуществами новых возможностей HTML5:

- Свойство *TextMode* элемента управления *TextBox* Обновлено для поддержки новых типов входных данных HTML5, таких как *Электронная почта*, *DateTime*и т. д.
- Элемент управления *FileUpload* теперь поддерживает несколько отправок файлов из браузеров, поддерживающих эту функцию HTML5.
- Проверяющие элементы управления теперь поддерживают проверку элементов ввода HTML5.
- Новые элементы HTML5 с атрибутами, представляющими URL-адрес, теперь поддерживают runat = "Server". В результате можно использовать соглашения ASP.NET в URL-путях, например оператор ~ для представления корня приложения (например, &lt;Video runat = "Server" src = "~/Мивидео.ВМВ"/&gt;).
- Элемент управления *UpdatePanel* зафиксирован для поддержки отправки полей ввода HTML5.

<a id="_Toc318097394"></a>
## <a name="aspnet-mvc-4"></a>ASP.NET MVC 4

Бета-версия ASP.NET MVC 4 теперь включена в бета-версию Visual Studio 11. ASP.NET MVC — это платформа для разработки веб-приложений с высокой степенью тестирования и поддержкой, используя шаблон Model-View-Controller (MVC). ASP.NET MVC 4 позволяет легко создавать приложения для мобильных веб-приложений и включает веб-API ASP.NET, которые помогают создавать службы HTTP, которые могут обращаться к любому устройству. Дополнительные сведения см. в [заметках о Выпуске ASP.NET MVC 4](mvc4-release-notes.md).

<a id="_Toc318097395"></a>
## <a name="aspnet-web-pages-2"></a>Веб-страницы ASP.NET 2

К новым функциям относятся следующие.

- Новые и обновленные шаблоны сайтов.
- Добавление проверки на стороне сервера и клиента с помощью вспомогательного метода *проверки* .
- Возможность регистрации скриптов с помощью диспетчера активов.
- Включение имен входа из Facebook и других сайтов с помощью OAuth и OpenID Connect.
- Добавление карт с помощью вспомогательного метода *Maps* .
- Параллельное выполнение приложений веб-страниц.
- Подготовка страниц для мобильных устройств.

Дополнительные сведения об этих функциях и примерах полного кода см. в разделе [Основные возможности бета-версии Web Pages 2](https://go.microsoft.com/fwlink/?LinkID=227824).

<a id="_Toc318097396"></a>
## <a name="visual-web-developer-11-beta"></a>Бета-версия Visual Web Developer 11

В этом разделе содержатся сведения об улучшениях для веб-разработки в Visual Web Developer 11 бета-версии и Visual Studio 2012 Release Candidate.

<a id="project-compatibility"></a>
### <a name="project-sharing-between-visual-studio-2010-and-visual-studio-2012-release-candidate-project-compatibility"></a>Совместное использование проектов в Visual Studio 2010 и версии-кандидате Visual Studio 2012 (совместимость проектов)

До версии-кандидата Visual Studio 2012, открывающей существующий проект в более новой версии Visual Studio, запустил мастер преобразования. Это принудительно обновляет содержимое (активы) проекта и решения до новых форматов, которые не поддерживали обратную совместимость. Поэтому после преобразования не удалось открыть проект в более старой версии Visual Studio.

Многие клиенты сообщили нам, что это не правильный подход. В бета-версии Visual Studio 11 теперь поддерживается совместное использование проектов и решений с Visual Studio 2010 с пакетом обновления 1 (SP1). Это означает, что если вы откроете проект 2010 в версии-кандидате Visual Studio 2012, вы по-прежнему сможете открыть проект в Visual Studio 2010 с пакетом обновления 1 (SP1).

> [!NOTE]
> Несколько типов проектов не могут совместно использоваться Visual Studio 2010 с пакетом обновления 1 (SP1) и версией-кандидатом Visual Studio 2012. К ним относятся некоторые старые проекты (например, проекты ASP.NET MVC 2) или проекты для специальных целей (например, проекты установки).

При открытии веб-проекта Visual Studio 2010 с пакетом обновления 1 (SP1) в первый раз в бета-версии Visual Studio 11 в файл проекта добавляются следующие свойства:

- филеупградефлагс
- упградебаккуплокатион
- олдтулсверсион
- VisualStudioVersion
- встулспас

Филеупградефлагс, Упградебаккуплокатион и Олдтулсверсион используются процессом, который обновляет файл проекта. Они не влияют на работу с проектом в Visual Studio 2010.

VisualStudioVersion — это новое свойство, используемое MSBuild 4,5, которое указывает версию Visual Studio для текущего проекта. Поскольку это свойство не существует в MSBuild 4,0 (версия MSBuild, используемая в Visual Studio 2010 SP1), мы добавляем значение по умолчанию в файл проекта.

Свойство Встулспас используется для определения правильного импортируемого файла. targets из пути, представленного параметром MSBuildExtensionsPath32.

Существуют также некоторые изменения, связанные с элементами импорта. Эти изменения необходимы для обеспечения совместимости обеих версий Visual Studio.

> [!NOTE]
> Если проект совместно используется Visual Studio 2010 с пакетом обновления 1 (SP1) и бета-версией Visual Studio 11 на двух разных компьютерах, и если проект содержит локальную базу данных в папке приложения\_данных, необходимо убедиться, что версия SQL Server, используемая базой данных, установлена на обоих компьютерах.

<a id="Configuration_Changes_In_ASPNET45_Website_Templates"></a>
### <a name="configuration-changes-in-aspnet-45-website-templates"></a>Изменения конфигурации в шаблонах веб-сайта ASP.NET 4,5

В файл *Web. config* по умолчанию для сайта, созданного с помощью шаблонов веб-сайтов в версии-кандидате Visual Studio 2012, были внесены следующие изменения:

- В элементе `<httpRuntime>` атрибут `encoderType` теперь по умолчанию задан для использования типов Антикссс, добавленных в ASP.NET. Дополнительные сведения см. в разделе [Библиотека антикссс](#_Toc318097382).
- Кроме того, в элементе `<httpRuntime>` атрибут `requestValidationMode` имеет значение "4,5". Это означает, что по умолчанию проверка запросов настроена на использование отложенной (отложенной) проверки. Дополнительные сведения см. в разделе [новые функции проверки запросов ASP.NET](#_Toc318097379).
- Элемент `<modules>` раздела `<system.webServer>` не содержит атрибута `runAllManagedModulesForAllRequests`. (Значение по умолчанию — false.) Это означает, что при использовании версии IIS 7, которая не была обновлена до с пакетом обновления 1 (SP1), могут возникнуть проблемы с маршрутизацией на новом сайте. Дополнительные сведения см. [в разделе Встроенная поддержка в IIS 7 для маршрутизации ASP.NET](#Native_Support_In_IIS7_For_ASPNET_Routine).

Эти изменения не влияют на существующие приложения. Однако они могут представлять разницу в поведении между существующими веб-сайтами и новыми веб-сайтами, созданными для ASP.NET 4,5, с помощью новых шаблонов.

<a id="Native_Support_In_IIS7_For_ASPNET_Routine"></a>
### <a name="native-support-in-iis-7-for-aspnet-routing"></a>Собственная поддержка в IIS 7 для маршрутизации ASP.NET

Это не является изменением ASP.NET, но в шаблонах для новых проектов веб-сайтов, которые могут повлиять на работу при работе с версией IIS 7, к которой не применено обновление с пакетом обновления 1 (SP1).

В ASP.NET можно добавить следующий параметр конфигурации в приложения для поддержки маршрутизации:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample34.xml?highlight=3)]

Если **runAllManagedModulesForAllRequests** имеет значение true, URL-адрес, например `http://mysite/myapp/home`, переходит к ASP.NET, даже если в URL-адресе нет *ASPX*, *MVC*или аналогичного расширения.

Обновление, выполненное в IIS 7, делает параметр **runAllManagedModulesForAllRequests** ненужным и поддерживает маршрутизацию ASP.NET изначально. (Сведения об обновлении см. в служба поддержки Майкрософт статье [Доступно обновление, которое позволяет определенным обработчикам iis 7,0 или iis 7,5 обрабатывали запросы, URL-адреса которых не заканчиваются точкой](https://support.microsoft.com/kb/980368).)

Если ваш веб-сайт работает в IIS 7 и если службы IIS были обновлены, не нужно устанавливать **runAllManagedModulesForAllRequests** в значение true. На самом деле, установка значения true не рекомендуется, так как при запросе добавляются ненужные издержки на обработку. Если этот параметр имеет значение true, все запросы, включая файлы для *. htm*, *. jpg*и других статических файлов, также проходят через конвейер запросов ASP.NET.

При создании нового веб-сайта ASP.NET 4,5 с помощью шаблонов, предоставляемых в Visual Studio 2012 RC, конфигурация веб-сайта не включает параметр **runAllManagedModulesForAllRequests** . Это означает, что по умолчанию параметр имеет значение false.

Если затем запустить веб-сайт в Windows 7 без установленного пакета обновления 1 (SP1), то IIS 7 не будет включать необходимое обновление. Как следствие, маршрутизация не будет работать, и вы увидите ошибки. При возникновении проблем, когда маршрутизация не работает, можно выполнить следующие действия.

- Обновите Windows 7 до с пакетом обновления 1 (SP1), что приведет к добавлению обновления в IIS 7.
- Установите обновление, описанное в приведенной выше статье служба поддержки Майкрософт.
- Задайте для **runAllManagedModulesForAllRequests** значение true в файле Web. config этого веб-сайта. Обратите внимание, что это приведет к дополнительным издержкам на запросы.

<a id="_Toc318097397"></a>
### <a name="html-editor"></a>Редактор HTML

<a id="_Toc318097398"></a>
#### <a name="smart-tasks"></a>Интеллектуальные задачи

В представление конструирования сложные свойства серверных элементов управления часто имеют связанные диалоговые окна и мастера, чтобы упростить их задание. Например, специальное диалоговое окно можно использовать для добавления источника данных к элементу управления *Repeater* или добавления столбцов в элемент управления *GridView* .

Однако этот тип справки по пользовательскому интерфейсу для сложных свойств не был доступен в представлении исходного кода. Поэтому в Visual Studio 11 появились Интеллектуальные задачи для представления исходного кода. Интеллектуальные задачи — это контекстно-зависимые сочетания клавиш для часто C# используемых функций в редакторах и Visual Basic.

Для элементов управления веб-форм ASP.NET Интеллектуальные задачи отображаются в тегах сервера как небольшие глифы, если точка вставки находится внутри элемента:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image6.png)

Быстрые действия разворачивается при щелчке глифа или нажатии клавиш CTRL +. (точка), как и в редакторах кода. Затем в представление конструирования отображаются ярлыки, аналогичные смарт-задачам.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image7.png)

Например, Быстрые действия на предыдущем рисунке показывает параметры задач GridView. При выборе изменить столбцы отображается следующее диалоговое окно:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image8.png)

Заполнение диалогового окна задает те же свойства, которые можно задать в представление конструирования. При нажатии кнопки ОК разметка элемента управления обновляется новыми параметрами:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image9.png)

<a id="_Toc318097399"></a>
#### <a name="wai-aria-support"></a>ОЖИДАТЬ-поддержка ARIA

Написание доступных веб-сайтов становится все более важным. [Стандарт специальных возможностей ожидать-ARIA](http://www.w3.org/WAI/intro/aria) определяет, как разработчики должны писать доступные веб-сайты. Теперь этот стандарт полностью поддерживается в Visual Studio.

Например, атрибут *Role* теперь имеет полную IntelliSense:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image10.png)

В стандарте ожидать-ARIA также появились атрибуты с префиксом *ARIA* , позволяющие добавить семантику в документ HTML5. Visual Studio также полностью поддерживает следующие атрибуты *ARIA* :

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image11.png) ![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image12.png)

<a id="_Toc318097400"></a>
#### <a name="new-html5-snippets"></a>Новые фрагменты HTML5

Чтобы ускорить и упростить написание часто используемой разметки HTML5, Visual Studio включает несколько фрагментов кода. Пример фрагмента видео:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image13.png)

Чтобы вызвать фрагмент, дважды нажмите клавишу TAB, если элемент выбран в IntelliSense:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image14.png)

При этом создается фрагмент кода, который можно настроить.

<a id="_Toc318097401"></a>
#### <a name="extract-to-user-control"></a>Извлечь в пользовательский элемент управления

В больших веб-страницах рекомендуется перемещать отдельные фрагменты в пользовательские элементы управления. Эта форма рефакторинга может помочь повысить удобочитаемость страницы и упростить ее структуру.

Чтобы упростить это, при редактировании страниц веб-форм в представлении исходного кода можно выбрать текст на странице, щелкнуть его правой кнопкой мыши и выбрать пункт извлечь в пользовательский элемент управления:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image2.jpg)

<a id="_Toc318097402"></a>
#### <a name="intellisense-for-code-nuggets-in-attributes"></a>IntelliSense для кусочки кода в атрибутах

Visual Studio всегда предоставляет IntelliSense для кусочки кода на стороне сервера на любой странице или элементе управления. Теперь Visual Studio включает IntelliSense для кусочки кода в HTML-атрибутах.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image15.png)

Это упрощает создание выражений привязки данных.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image16.png)

<a id="_Toc318097403"></a>
#### <a name="automatic-renaming-of-matching-tag-when-you-rename-an-opening-or-closing-tag"></a>Автоматическое переименование совпадающего тега при переименовании открывающего или закрывающего тега

При переименовании HTML-элемента (например, при изменении тега *div* на тег *заголовка* ) соответствующий открывающий или закрывающий тег также изменяется в режиме реального времени.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image17.png)

Это помогает избежать ошибки, когда вы забываете изменить закрывающий тег или изменить другой.

<a id="_Toc318097404"></a>
#### <a name="event-handler-generation"></a>Создание обработчика событий

Visual Studio теперь включает в себя функции в представлении исходного кода, помогающие создавать обработчики событий и привязывать их вручную. При изменении имени события в представлении исходного кода IntelliSense отображает &lt;создать новое событие&gt;, которое создает обработчик событий в коде страницы с правильной сигнатурой:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image3.jpg)

По умолчанию обработчик событий будет использовать идентификатор элемента управления для имени метода обработки событий:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image4.jpg)

Результирующий обработчик событий будет выглядеть следующим образом (в данном случае в C#):

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image18.png)

<a id="_Toc318097405"></a>
#### <a name="smart-indent"></a>Интеллектуальный отступ

При нажатии клавиши Ввод внутри пустого HTML-элемента редактор поместит точку вставки в нужное место:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image19.png)

При нажатии клавиши Ввод в этом расположении закрывающий тег перемещается вниз и смещается с отступом, чтобы соответствовать открывающему тегу. Точка вставки также имеет отступ:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image20.png)

<a id="_Toc318097406"></a>
#### <a name="auto-reduce-statement-completion"></a>Автоматическое сокращение завершения операторов

Теперь список IntelliSense в Visual Studio фильтруется на основе введенных данных, чтобы отображались только соответствующие параметры:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image21.png)

IntelliSense также фильтрует, основываясь на вариантах заголовков отдельных слов в списке IntelliSense. Например, если ввести "DL", отобразятся как DL, так и ASP: DataList:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image22.png)

Эта функция позволяет быстрее получить завершение операторов для известных элементов.

<a id="_Toc318097407"></a>
### <a name="javascript-editor"></a>редактор JavaScript

Редактор JavaScript в версии-кандидате Visual Studio 2012 полностью новый, и он значительно улучшает работу с JavaScript в Visual Studio.

<a id="_Toc318097408"></a>
#### <a name="code-outlining"></a>Структура кода

Теперь области структуры автоматически создаются для всех функций, что позволяет сворачивать части файла, не соответствующие текущему фокусу.

<a id="_Toc318097409"></a>
#### <a name="brace-matching"></a>Соответствие скобок

При помещении точки вставки на открывающую или закрывающую фигурную скобку в редакторе выделяется соответствующий элемент.

<a id="_Toc318097410"></a>
#### <a name="go-to-definition"></a>Перейти к определению

Команда Перейти к определению позволяет перейти к источнику функции или переменной.

<a id="_Toc318097411"></a>
#### <a name="ecmascript5-support"></a>Поддержка ECMAScript5

Редактор поддерживает новый синтаксис и API-интерфейсы в ECMAScript5, последнюю версию стандарта, описывающую язык JavaScript.

<a id="_Toc318097412"></a>
#### <a name="dom-intellisense"></a>IntelliSense DOM

Улучшена технология IntelliSense для API DOM с поддержкой многих новых API HTML5, включая *куериселектор*, хранилище DOM, Обмен сообщениями между документами и *холст*. IntelliSense DOM теперь управляется одним простым файлом JavaScript, а не определением собственной библиотеки типов. Это упрощает расширение или замену.

<a id="_Toc318097413"></a>
#### <a name="vsdoc-signature-overloads"></a>Перегрузки сигнатур ВСДОК

Подробные комментарии IntelliSense теперь можно объявить для отдельных перегрузок функций JavaScript с помощью нового элемента *&gt;сигнатуры&lt;* , как показано в следующем примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample35.cs)]

<a id="_Toc318097414"></a>
#### <a name="implicit-references"></a>Неявные ссылки

Теперь можно добавлять файлы JavaScript в Центральный список, который будет неявно включаться в список файлов, заданных в файлах JavaScript или ссылках на блоки, что означает, что IntelliSense будет использоваться для его содержимого. Например, можно добавить файлы jQuery в главный список файлов, и вы получите функцию IntelliSense для функций jQuery в любом блоке файла JavaScript независимо от того, была ли ссылка указана явно (с помощью///&lt;ссылки/&gt;).

<a id="_Toc318097415"></a>
### <a name="css-editor"></a>редактор CSS

<a id="_Toc318097416"></a>
#### <a name="auto-reduce-statement-completion"></a>Автоматическое сокращение завершения операторов

Список IntelliSense для CSS теперь фильтруется на основе свойств и значений CSS, поддерживаемых выбранной схемой.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image23.png)

IntelliSense также поддерживает поиск по регистру заголовков:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image24.png)

<a id="_Toc318097417"></a>
#### <a name="hierarchical-indentation"></a>Иерархические отступы

Редактор CSS использует отступы для отображения иерархических правил, что дает общие сведения о логически организованных каскадных правилах. В следующем примере #list селектор — это каскадный дочерний элемент списка, поэтому он имеет отступ.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image25.png)

В следующем примере показано более сложное наследование:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image26.png)

Отступы правила определяются его родительскими правилами. Иерархические отступы включены по умолчанию, но ее можно отключить в диалоговом окне "Параметры" (сервис, параметры из строки меню):

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image27.png)

<a id="_Toc318097418"></a>
#### <a name="css-hacks-support"></a>Поддержка хакеров CSS

Анализ сотен реальных файлов CSS показывает, что взломы CSS очень распространены, и теперь Visual Studio поддерживает наиболее широко используемые. Эта поддержка включает технологию IntelliSense и проверку хакеров (\*) и подчеркивания (\_):

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image28.png)

Также поддерживаются стандартные атаки селектора, чтобы иерархические отступы поддерживались даже при их применении. Типичное хакерское средство выбора, используемое для Internet Explorer 7, заключается в начале селектора с *\*: First-Child + HTML*. С помощью этого правила будут поддерживаться иерархические отступы:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image29.png)

<a id="_Toc318097419"></a>
#### <a name="vendor-specific-schemas--moz---webkit"></a>Схемы, зависящие от поставщика (-MOZ-,-WebKit)

CSS3 вводит множество свойств, которые были реализованы различными браузерами в разное время. Это ранее требовало от разработчиков кода для конкретных браузеров с помощью синтаксиса для конкретного поставщика. Эти свойства, относящиеся к браузеру, теперь включены в IntelliSense.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image30.png)

<a id="_Toc318097420"></a>
#### <a name="commenting-and-uncommenting-support"></a>Поддержка комментирования и раскомментирования

Теперь можно закомментировать и раскомментировать правила CSS с помощью тех же сочетаний клавиш, которые используются в редакторе кода (Ctrl + K, C для комментирования и CTRL + K, чтобы раскомментировать).

<a id="_Toc318097421"></a>
#### <a name="color-picker"></a>Выбор цвета

В предыдущих версиях Visual Studio IntelliSense для атрибутов, связанных с цветом, состояла из раскрывающегося списка именованных значений цвета. Этот список был заменен полнофункциональным компонентом выбора цвета.

При вводе значения цвета средство выбора цвета отображается автоматически и отображает список ранее использованных цветов, за которыми следует палитра цветов по умолчанию. Цвет можно выбрать с помощью мыши или клавиатуры.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image31.png)

Список можно расширить в палитру полного выбора цвета. Средство выбора позволяет управлять альфа-каналом, автоматически преобразуя любой цвет в RGBA при перемещении ползунка Opacity (непрозрачность).

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image32.png)

<a id="_Toc318097422"></a>
#### <a name="snippets"></a>Фрагменты кода

Фрагменты кода в редакторе CSS упрощают и ускоряют создание стилей в разных браузерах. Многие свойства CSS3, для которых требуются параметры браузера, теперь были перенесены в фрагменты кода.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image33.png)

Фрагменты кода CSS поддерживают расширенные сценарии (например, CSS3-запросы к носителю), вводя символ "at" (@), который показывает список IntelliSense.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image34.png)

При выборе @media значение и нажатии клавиши Tab редактор CSS вставляет следующий фрагмент кода:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image5.jpg)

Как и в случае с фрагментами кода, можно создавать собственные фрагменты CSS.

<a id="_Toc318097423"></a>
#### <a name="custom-regions"></a>Пользовательские регионы

Именованные области кода, которые уже доступны в редакторе кода, теперь доступны для редактирования CSS. Это позволяет легко группировать связанные блоки стилей.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image35.png)

При сворачивании региона отображается имя области:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image36.png)

<a id="_Toc318097424"></a>
### <a name="page-inspector"></a>Инспектор страниц

Инспектор страниц — это средство, которое отображает веб-страницу (HTML, веб-формы, ASP.NET MVC или веб-страницы) в интегрированной среде разработки Visual Studio и позволяет изучать как исходный код, так и результирующий результат. Для страниц ASP.NET Инспектор страниц позволяет определить, какой код на стороне сервера создал HTML-разметку, отображаемую в браузере.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image37.png)

Дополнительные сведения о Инспектор страниц см. в следующих учебниках:

- Использование Инспектор страниц в [ASP.NET MVC](../mvc/overview/views/using-page-inspector-in-aspnet-mvc.md)
- Использование Инспектор страниц в [веб-формах ASP.NET](../web-forms/overview/getting-started/using-page-inspector-in-a-visual-studio-11-beta-web-forms-project.md)

<a id="_Toc318097425"></a>
### <a name="publishing"></a>Публикация

<a id="_Toc318097426"></a>
#### <a name="publish-profiles"></a>Профили публикации

В Visual Studio 2010 сведения о публикации для проектов веб-приложений не хранятся в системе управления версиями и не предназначены для совместного использования с другими пользователями. В версии-кандидате Visual Studio 2012 был изменен формат профиля публикации. Он был создан артефактом команды, и теперь его можно легко использовать из сборок на основе MSBuild. Сведения о конфигурации сборки находятся в диалоговом окне Публикация, что позволяет легко переключать конфигурации сборки перед публикацией.

Профили публикации хранятся в папке PublishProfiles Расположение папки зависит от используемого языка программирования:

- C#: Пропертиес\публишпрофилес
- Visual Basic: My Прожект\публишпрофилес

Каждый профиль является файлом MSBuild. Во время публикации этот файл импортируется в файл MSBuild проекта. В Visual Studio 2010, если необходимо внести изменения в процесс публикации или упаковки, необходимо поместить настройки в файл с именем **имяПроекта**. wpp. targets. Это все еще поддерживается, но теперь вы можете поместить настройки в сам профиль публикации. Таким образом, настройки будут использоваться только для этого профиля.

Теперь можно также использовать профили публикации из MSBuild. Для этого используйте следующую команду при сборке проекта:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample36.cmd)]

Значение Project. csproj — это путь к проекту, а fileName — имя профиля для публикации. Вместо того, чтобы передавать имя профиля для свойства *PublishProfile* , можно передать полный путь к профилю публикации.

<a id="_Toc318097427"></a>
#### <a name="aspnet-precompilation-and-merge"></a>Предварительная компиляция и слияние ASP.NET

Для проектов веб-приложений Visual Studio 2012 Release Candidate добавляет параметр на странице Пакет/Публикация веб-свойств, который позволяет выполнять предварительную компиляцию и слияние содержимого сайта при публикации или упаковке проекта. Чтобы просмотреть эти параметры, щелкните правой кнопкой мыши проект в обозреватель решений, выберите пункт Свойства, а затем щелкните страницу Пакет/Публикация веб-свойства. На следующем рисунке показано, как выполнить предварительную компиляцию этого приложения перед публикацией.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image6.jpg)

Если выбран этот параметр, Visual Studio выполняет предварительную компиляцию приложения при каждой публикации или упаковке веб-приложения. Если требуется управлять предварительной компиляцией сайта или слиянием сборок, нажмите кнопку Дополнительно, чтобы настроить эти параметры.

<a id="_Toc318097428"></a>
### <a name="iis-express"></a>IIS Express.

Веб-сервер по умолчанию для тестирования веб-проектов в Visual Studio теперь IIS Express. Visual Studio Development Server по-прежнему является вариантом для локального веб-сервера во время разработки, но теперь рекомендуемым сервером является IIS Express. Опыт использования IIS Express в бета-версии Visual Studio 11 очень похож на его использование в Visual Studio 2010 с пакетом обновления 1 (SP1).

<a id="_Toc318097429"></a>
## <a name="disclaimer"></a>Отказ от ответственности

Это предварительный документ, он может быть существенно изменен до выхода окончательного коммерческого выпуска описанного здесь программного обеспечения.

Информация, содержащаяся в этом документе, являет собой текущее представление корпорации Майкрософт о вопросах, которые обсуждались на момент публикации. Поскольку корпорация Майкрософт должна реагировать на изменение рыночных условий, эта информация не должна рассматриваться как обязательство корпорации Майкрософт. Корпорация Майкрософт не может гарантировать достоверность информации, предоставленной после момента публикации.

Данный технический документ предназначен только для ознакомительных целей. МАЙКРОСОФТ НЕ ПРЕДОСТАВЛЯЕТ НИКАКИХ ГАРАНТИЙ, ЯВНЫХ ИЛИ ПРЕДУСМОТРЕННЫХ ЗАКОНОДАТЕЛЬСТВОМ, ОТНОСИТЕЛЬНО СВЕДЕНИЙ, СОДЕРЖАЩИХСЯ В ДАННОМ ДОКУМЕНТЕ.

Ответственность за соблюдение всех авторских прав и прав на интеллектуальную собственность целиком и полностью несет пользователь. Без ограничения авторских прав ни одна из частей этого документа не может быть воспроизведена, сохранена или использована в системах поиска либо передана в любой форме, любыми способами (электронными, механическими, в виде фотокопии, в виде записи или любыми другими) и для любых целей без письменного разрешения корпорации Майкрософт.

Корпорация Майкрософт может иметь патенты, патентные заявки, охраняемые товарные знаки, авторские или другие права на интеллектуальную собственность применительно к содержимому этого документа. Без письменного разрешения корпорации Майкрософт данный документ не дает лицензии на эти патенты, охраняемые товарные знаки, авторские права и другую интеллектуальную собственность.

Если не указано иное, примеры компаний, организаций, продуктов, доменных имен, адресов электронной почты, логотипов, людей, мест и событий являются вымышленными и без связи с реальными компаниями, организациями, продуктами, именами доменов, электронной почтой. адрес, Эмблема, лицо, место или событие должны быть выведены на случай.

© Корпорация Майкрософт (Microsoft Corporation), 2012. Все права защищены.

Microsoft и Windows являются охраняемыми товарными знаками корпорации Майкрософт в США и других странах.

Названия фактических компаний и продуктов, упомянутые здесь, могут являться охраняемыми товарными знаками соответствующих владельцев.
