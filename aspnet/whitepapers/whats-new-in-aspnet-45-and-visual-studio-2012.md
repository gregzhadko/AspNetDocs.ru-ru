---
uid: whitepapers/whats-new-in-aspnet-45-and-visual-studio-2012
title: Новые возможности в ASP.NET 4.5 и Visual Studio 2012 | Документация Майкрософт
author: rick-anderson
description: В этом документе описываются новые функции и усовершенствования, появившиеся в ASP.NET 4.5. Здесь также описываются усовершенствования, внесенные для разработки веб-приложений...
ms.author: riande
ms.date: 02/29/2012
ms.assetid: ba1fabb4-31a3-4ebf-8327-41a6bbba6eaf
msc.legacyurl: /whitepapers/whats-new-in-aspnet-45-and-visual-studio-2012
msc.type: content
ms.openlocfilehash: 5f50721b6f263b9cb025f5fa57c923dadeddcd28
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59410595"
---
# <a name="whats-new-in-aspnet-45-and-visual-studio-2012"></a>Новые возможности ASP.NET 4.5 и Visual Studio 2012

> В этом документе описываются новые функции и усовершенствования, появившиеся в ASP.NET 4.5. Здесь также описываются усовершенствования, внесенные для веб-разработки в Visual Studio 2012. В этом документе была опубликована в 29 февраля 2012 г.


- [Среда выполнения ASP.NET Core и платформы](#_Toc318097372)

    - [Асинхронное чтение и запись HTTP-запросы и ответы](#_Toc318097373)
    - [Улучшения в обработке запроса HttpRequest](#_Toc318097374)
    - [Асинхронно списания ответа](#_Toc318097375)
    - [Поддержка *await* и *задачи*-основе асинхронных модулей и обработчиков](#_Toc318097376)
    - [Асинхронные модули HTTP](#_Toc318097377)
    - [Асинхронные обработчики HTTP](#_Toc318097378)
    - [Новые возможности проверки запроса ASP.NET](#_Toc318097379)
    - [Отложенная проверка запросов («неспешная»)](#_Toc318097380)
    - [Поддержка непроверенных запросов](#_Toc318097381)
    - [AntiXSS Library](#_Toc318097382)
    - [Поддержка протокола WebSockets](#_Toc318097383)
    - [Объединение и минификация](#_Toc318097384)
    - [Повышение производительности для размещения веб-сайтов](#_Toc_perf)

        - [Факторы производительности](#_Toc_perf_1)
        - [Требования для новых функций повышения производительности](#_Toc_perf_2)
        - [Совместное использование общих сборок](#_Toc_perf_3)
        - [С помощью JIT-компиляция многоядерными процессорами для ускорения запуска](#_Toc_perf_4)
        - [Помощник по настройке сбора мусора для оптимизации для памяти](#_Toc_perf_5)
        - [Предварительная выборка для веб-приложений](#_Toc_perf_6)
- [Веб-формы ASP.NET](#_Toc318097385)

    - [Строго типизированные элементы управления данными](#_Toc318097386)
    - [Привязка модели](#_Toc318097387)

        - [Выбор данных](#_Toc318097388)
        - [Поставщики значений](#_Toc318097389)
        - [Фильтрация по значениям из элемента управления](#_Toc318097390)
    - [Выражения привязки данных в кодировке HTML](#_Toc318097391)
    - [Малозаметная проверка](#_Toc318097392)
    - [Обновления HTML5](#_Toc318097393)
- [ASP.NET MVC 4](#_Toc318097394)
- [Веб-страницы ASP.NET 2](#_Toc318097395)
- [Visual Studio 2012 Release Candidate](#_Toc318097396)

    - [Проект, общего для Visual Studio 2010 и Visual Studio 2012 Release Candidate (совместимость проектов)](#project-compatibility)
    - [Изменения конфигурации в шаблонах ASP.NET 4.5 веб-сайта](#Configuration_Changes_In_ASPNET45_Website_Templates)
    - [Встроенная поддержка в службах IIS 7 для маршрутизации ASP.NET](#Native_Support_In_IIS7_For_ASPNET_Routine)
    - [Редактор HTML](#_Toc318097397)

        - [Смарт-задачи](#_Toc318097398)
        - [Поддержку ARIA ВАЙ](#_Toc318097399)
        - [Новые фрагменты кода HTML5](#_Toc318097400)
        - [Извлечь в пользовательский элемент управления](#_Toc318097401)
        - [IntelliSense для фрагментами кода в атрибутах](#_Toc318097402)
        - [Автоматическое переименование соответствующих тегов при переименовании открывающего или закрывающего тега](#_Toc318097403)
        - [Создание обработчика событий](#_Toc318097404)
        - [Автоматический отступ](#_Toc318097405)
        - [Уточнение завершение операторов](#_Toc318097406)
    - [редактор JavaScript](#_Toc318097407)

        - [Структура кода](#_Toc318097408)
        - [Парные фигурные скобки](#_Toc318097409)
        - [Перейти к определению](#_Toc318097410)
        - [Поддержка ECMAScript5](#_Toc318097411)
        - [DOM IntelliSense](#_Toc318097412)
        - [Сигнатура перегрузки VSDOC](#_Toc318097413)
        - [Неявные ссылки](#_Toc318097414)
    - [редактор CSS](#_Toc318097415)

        - [Уточнение завершение операторов](#_Toc318097416)
        - [Иерархические отступы.](#_Toc318097417)
        - [Поддержка CSS-фильтров](#_Toc318097418)
        - [Конкретные схемы поставщика (- moz-- webkit)](#_Toc318097419)
        - [Поддержка комментирования и раскомментирования](#_Toc318097420)
        - [Палитра цветов](#_Toc318097421)
        - [Фрагменты кода](#_Toc318097422)
        - [Настраиваемые области](#_Toc318097423)
    - [Инспектор страниц](#_Toc318097424)
    - [Публикация](#_Toc318097425)

        - [Профили публикации](#_Toc318097426)
        - [ASP.NET предварительной компиляции и слияния](#_Toc318097427)
- [IIS Express](#_Toc318097428)
- [Отказ от ответственности](#_Toc318097429)

<a id="_Toc318097372"></a>
## <a name="aspnet-core-runtime-and-framework"></a>Среда выполнения ASP.NET Core и платформы

<a id="_Toc318097373"></a>
### <a name="asynchronously-reading-and-writing-http-requests-and-responses"></a>Асинхронное чтение и запись HTTP-запросы и ответы

ASP.NET 4 появилась возможность читать сущность запроса HTTP, в виде потока с помощью *HttpRequest.GetBufferlessInputStream* метод. Этот метод предоставлен потоковый доступ к сущности запроса. Тем не менее она выполнена синхронно, который заняты, поток на время запроса.

ASP.NET 4.5 поддерживает возможность чтения потоков асинхронно на сущность запроса HTTP, а также возможность очистки асинхронно. ASP.NET 4.5 также дает возможность двойной буфера сущность запроса HTTP, которая обеспечивает простую интеграцию с подчиненными обработчиков HTTP, такие как обработчики страницы .aspx и ASP.NET MVC контроллеры.

<a id="_Toc318097374"></a>
#### <a name="improvements-to-httprequest-handling"></a>Улучшения в обработке запроса HttpRequest

Справочник по Stream, возвращенный ASP.NET 4.5 из *HttpRequest.GetBufferlessInputStream* поддерживает синхронные и асинхронные методы для чтения. *Stream* объект, возвращенный из *GetBufferlessInputStream* теперь реализует методы BeginRead и EndRead. Асинхронный *Stream* методы позволяют асинхронного чтения сущности запроса в виде фрагментов, хотя ASP.NET освобождает текущий поток между каждой итерации цикла асинхронного чтения.

ASP.NET 4.5 добавил вспомогательный метод для чтения в виде буферизованных сущности запроса: *HttpRequest.GetBufferedInputStream*. Это новая перегрузка работает подобно *GetBufferlessInputStream*, поддерживающий синхронные и асинхронные операции чтения. Тем не менее, как его считывает, *GetBufferedInputStream* также копирует байты сущности в ASP.NET внутренние буферы подчиненных модулей и обработчиков можно по-прежнему получить доступ к сущности запроса. Например, если некоторые вышестоящий источник кода в конвейере уже считано сущности запроса с помощью *GetBufferedInputStream*, вы можете продолжать использовать *HttpRequest.Form* или *HttpRequest.Files*. Это позволяет выполнять асинхронную обработку запроса (например, потоковая передача передачи больших файлов в базе данных), но по-прежнему используют ASPX-страницы и MVC ASP.NET controllers впоследствии.

<a id="_Toc318097375"></a>
#### <a name="asynchronously-flushing-a-response"></a>Асинхронно списания ответа

Отправка ответов на HTTP-клиента может занять значительное время, когда клиент находится далеко или характеризуется низкой пропускной способностью. Обычно ASP.NET помещает в буфер байтов ответов при их создании приложением. ASP.NET выполняет одной операции отправки начисленные буферов в самом конце обработки запроса.

Если буфер от ответа имеет большой размер (например, потоковая передача больших файлов на клиенте), должен периодически вызывать *HttpResponse.Flush* для отправки буферизованный выходной клиенту и поддерживать использование памяти в системе управления. Тем не менее так как *Flush* является синхронным вызовом, итеративного вызова *Flush* по-прежнему использует поток, в течение потенциально длительных запросов.

ASP.NET 4.5 добавлена поддержка выполнения удалений в асинхронном режиме с помощью *BeginFlush* и *EndFlush* методы *HttpResponse* класса. С помощью этих методов, можно создать асинхронных модулей и асинхронных обработчиков, которые постепенно отправке данных клиенту без прерывания потоков операционной системы. В диапазоне от *BeginFlush* и *EndFlush* вызовы, ASP.NET освобождает текущий поток. Это значительно уменьшает общее число активных потоков, которые необходимы для поддержки загрузки длительные HTTP.

<a id="_Toc318097376"></a>
### <a name="support-for-await-and-task---based-asynchronous-modules-and-handlers"></a>Поддержка *await* и *задачи* -основе асинхронных модулей и обработчиков

.NET Framework 4 появилась асинхронного программирования концепция, называемая *задачи*. Задачи представляются *задачи* типа и связанных типов в *System.Threading.Tasks* пространства имен. .NET Framework 4.5 допускает это с помощью компилятора улучшения, которые делают работу с *задачи* простой объектов. В .NET Framework 4.5, компиляторы поддерживают два новых ключевых слов: *await* и *async*. *Await* ключевое слово является синтаксическое сокращение, которое указывает, которого фрагмент кода асинхронно ожидает на другие части кода. *Async* ключевое слово представляет подсказку, которая позволяет пометить методы как асинхронные методы на основе задач.

Сочетание *await*, *async*и *задачи* объекта значительно упрощает написание асинхронного кода в .NET 4.5. ASP.NET 4.5 поддерживает этих упрощений, с помощью новых API, позволяющие выполнять запись асинхронных модулей и обработчиков HTTP с помощью новых улучшений компилятора.

<a id="_Toc318097377"></a>
#### <a name="asynchronous-http-modules"></a>Асинхронные модули HTTP

Предположим, что вы хотите выполнять работу асинхронно, в метод, возвращающий *задачи* объекта. В следующем примере кода определяет асинхронный метод, который делает асинхронный вызов, чтобы загрузить домашнюю страницу Microsoft. Обратите внимание на использование *async* ключевое слово в сигнатуре метода и *await* вызов *DownloadStringTaskAsync*.

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample1.cs)]

Это все же придется создавать — .NET Framework автоматически обработает очистить стек вызовов во время ожидания завершения загрузки, а также автоматически восстановить стек вызовов, после завершения загрузки.

Теперь предположим, что вы хотите использовать этот асинхронный метод в асинхронный модуль ASP.NET HTTP. ASP.NET 4.5 включает вспомогательный метод (*EventHandlerTaskAsyncHelper*) и новый тип делегата (*TaskEventHandler*), можно использовать для интеграции асинхронные методы на основе задач с более старой версии асинхронную модель программирования, предоставляемые в конвейер ASP.NET HTTP. В этом примере показано как:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample2.cs)]

<a id="_Toc318097378"></a>
#### <a name="asynchronous-http-handlers"></a>Асинхронные обработчики HTTP

Традиционный подход к написанию асинхронных обработчиков в ASP.NET является реализация *IHttpAsyncHandler* интерфейс. В ASP.NET 4.5 представлено *HttpTaskAsyncHandler* асинхронной базовый тип, который можно унаследовать, что делает его намного легче записать асинхронных обработчиков.

*HttpTaskAsyncHandler* тип является абстрактным и нужно обязательно заменить *ProcessRequestAsync* метод. Внутри ASP.NET берет на себя, как интегрировать возвращаемого значения сигнатуры ( *задачи* объекта) из *ProcessRequestAsync* с более старой модели асинхронного программирования используются конвейером ASP.NET.

В следующем примере показано, как можно использовать *задачи* и *await* как часть реализации асинхронного обработчика HTTP:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample3.cs)]

<a id="_Toc318097379"></a>
### <a name="new-aspnet-request-validation-features"></a>Новые возможности проверки запроса ASP.NET

По умолчанию ASP.NET выполняет проверку запросов, он проверяет запросы для поиска разметка или сценарий в поля, заголовки, файлы cookie и т. д. При обнаружении любого ASP.NET создает исключение. Это действует в качестве первой линии обороны против потенциальных атак с использованием межузловых сценариев.

ASP.NET 4.5 позволяет выборочно чтения непроверенных данных запросов. ASP.NET 4.5 также интегрируется популярных AntiXSS библиотеку, которая ранее называлась внешней библиотеки.

Разработчики часто просят возможность выборочно отключить проверку запросов для своих приложений. Например если приложение является веб-форум, можно разрешить пользователям отправлять сообщения на форуме в формате HTML и комментарии, но по-прежнему убедитесь, что проверка запросов проверяет, все остальное.

ASP.NET 4.5 включает две новые функции, которые упрощают выборочно опишете непроверенные входные данные: Отложенная проверка запросов («неспешная»), а также к непроверенных данных запроса.

<a id="_Toc318097380"></a>
#### <a name="deferred-lazy-request-validation"></a>Отложенная проверка запросов («неспешная»)

В ASP.NET 4.5 по умолчанию данные всех запросов подчиняется проверки запроса. Тем не менее можно настроить приложение отложить проверку запросов, пока вы фактически доступа к данным запроса. (Это иногда называется проверку отложенной запросов, на основе условий, таких как отложенная загрузка для определенных сценариев данных.) Можно настроить приложение для использования отложенной проверки в файле Web.config, задав *requestValidationMode* атрибут 4.5 в *httpRUntime* элемент, как показано в следующем примере:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample4.xml)]

При режиме проверки запроса имеет значение 4.5, проверка запроса инициируется только для конкретного запроса значения, и только в том случае, когда код обращается к это значение. Например, если код возвращает значение Request.Form["forum\_блога"], проверка запроса вызывается только для этого элемента в коллекции форм. Ни один из других элементов в *формы* коллекции проверяются. В предыдущих версиях ASP.NET проверка запроса было активировано для всего запроса коллекции, когда осуществлялся доступ любой элемент в коллекции. Новое поведение упрощает для разных компонентов приложения рассмотрим различные части данных запроса без активации проверки запросов на другие элементы.

<a id="_Toc318097381"></a>
#### <a name="support-for-unvalidated-requests"></a>Поддержка непроверенных запросов

Только проверка отложенных запросов не решает проблему выборочно пропустить проверку запроса. Вызов Request.Form["forum\_блога"] по-прежнему триггеры запрос проверки для этого значения конкретного запроса. Тем не менее вы можете обращаться к этому полю, не активируя проверку, так как вы хотите разрешить разметки в этом поле.

Для этого ASP.NET 4.5 поддерживает непроверенные доступ к данным запроса. ASP.NET 4.5 включает новую *Unvalidated* свойство коллекции в *HttpRequest* класса. Эта коллекция предоставляет доступ ко всем из общих значений данных запроса, например *формы*, *QueryString*, *файлы cookie*, и *URL-адрес*.

Используя пример форум, чтобы иметь возможность чтения непроверенных данных запросов, необходимо сначала настроить приложение для использования нового режима проверки запроса:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample5.xml)]

Затем можно использовать *HttpRequest.Unvalidated* свойство для чтения значения непроверенных форм:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample6.cs)]


> [!WARNING]
> Безопасность — *непроверенных данных запроса следует использовать с осторожностью!* ASP.NET 4.5 добавлены свойства непроверенных запросов и коллекций, чтобы упростить доступ к очень специфических непроверенных данных запроса. Тем не менее по-прежнему необходимо выполнить пользовательскую проверку на необработанные запросы данных, чтобы убедиться, что опасный текст не отображается для пользователей.


<a id="_Toc318097382"></a>
### <a name="antixss-library"></a>AntiXSS Library

Из-за популярности библиотеки AntiXSS Microsoft ASP.NET 4.5 теперь включает в себя базовые процедуры кодирования из версии 4.0 этой библиотеки.

Процедуры кодирования реализуются *AntiXssEncoder* типа в новом *System.Web.Security.AntiXss* пространства имен. Можно использовать *AntiXssEncoder* тип напрямую путем вызова любого из статических методов кодирования, которые реализованы в типе. Тем не менее, для использования новой процедуры anti-XSS проще всего настроить приложение ASP.NET для использования *AntiXssEncoder* класс по умолчанию. Чтобы сделать это, добавьте следующий атрибут в файл Web.config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample7.xml)]

Когда *encoderType* атрибут настроен на использование *AntiXssEncoder* типа, все выходные данные в ASP.NET кодировку автоматически использует новые подпрограммы кодировки.

Ниже приведены некоторые части внешние библиотеки AntiXSS, которые могут быть включены в ASP.NET 4.5.

- *HtmlEncode*, *HtmlFormUrlEncode*, и *HtmlAttributeEncode*
- *XmlAttributeEncode* и *XmlEncode*
- *UrlEncode* и *UrlPathEncode* (новое)
- *CssEncode*

<a id="_Toc318097383"></a>
### <a name="support-for-websockets-protocol"></a>Поддержка протокола WebSockets

Протокол WebSockets — на основе стандартов сетевой протокол, определяющий способ установления безопасной, в режиме реального времени двунаправленный обмен данными между клиентом и сервером по протоколу HTTP. Майкрософт сотрудничает с комитетами стандартов W3C и IETF, чтобы помочь определить протокол. Поддержку протокола WebSockets поддерживается любым клиентом (не только браузеры), с инвестиционной значительное количество ресурсов, поддержка протокола WebSockets клиента и мобильные операционные системы Майкрософт.

Протокола WebSockets значительно облегчает создание данных длительных передач между клиентом и сервером. Например написание приложения для разговоров на гораздо проще, так как можно установить значение true, соединение выполняющейся длительное время между клиентом и сервером. У вас нет к обходные пути, например периодически опрашивает или продолжительным опросом HTTP для моделирования поведения сокета.

ASP.NET 4.5 и IIS 8 поддерживает низкоуровневые WebSockets, позволяя разработчикам ASP.NET для использования управляемых интерфейсов API для асинхронного чтения и записи строки и двоичные данные в объекте WebSockets. Для ASP.NET 4.5, доступна новая *System.Web.WebSockets* пространство имен, содержащее типы для работы с протоколом WebSockets.

Веб-клиент устанавливает соединение WebSockets, создав DOM *WebSocket* объект, который указывает на URL-адрес в приложении ASP.NET, как показано в следующем примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample8.cs)]

Можно создать конечные точки WebSockets в ASP.NET с помощью любого вида модуля или обработчика. В предыдущем примере использовался файле с расширением .ashx, так как ASHX-файлы — это быстрый способ создать обработчик.

В соответствии с протоколом WebSockets приложения ASP.NET принимает запрос клиента WebSockets, указывая, что запрос должно быть обновлено с помощью запроса HTTP GET к запросу WebSocket. Ниже приведен пример:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample9.cs)]

*AcceptWebSocketRequest* метод принимает делегат функции, так как ASP.NET, освобождает текущего HTTP-запроса и затем передает управление делегат функции. Концептуально этот подход аналогичен использованию *System.Threading.Thread*, где можно определить делегат начала потока, в которой фоновые выполняются.

После успешно завершена подтверждения WebSockets, ASP.NET и клиента, ASP.NET вызывает делегат и началом выполнения приложения WebSockets. В следующем примере кода показано это простое echo приложение, которое использует встроенную поддержку WebSockets в ASP.NET:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample10.cs)]

Поддержка в .NET 4.5 для *await* ключевое слово и асинхронные операции на основе задач является естественным образом подходят для написания приложений WebSockets. В примере кода показано, что запросу WebSocket выполняется полностью асинхронно внутри ASP.NET. Приложение асинхронно ожидает получения сообщения, отправляемые с клиента путем вызова *await сокета. ReceiveAsync*. Точно так же, можно отправить асинхронное сообщение клиенту путем вызова *await сокета. SendAsync*.

В браузере, приложение получает сообщения WebSockets с помощью *onmessage* функции. Чтобы отправить сообщение из браузера, необходимо вызвать *отправки* метод *WebSocket* DOM типа, как показано в следующем примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample11.cs)]

В будущем мы может выпускать обновления к этой функции, что абстрактный сейчас некоторые низкоуровневые кодировки, то есть необходимые в этом выпуске для WebSockets приложения.

<a id="_Toc318097384"></a>
### <a name="bundling-and-minification"></a>Объединение и минификация

Объединение позволяет объединить отдельные файлы JavaScript и CSS в пакет, который может рассматриваться как один файл. Минификация, объединяя файлов JavaScript и CSS, удаляя пробелы и другие символы, которые не требуются. Эти функции работают с веб-форм ASP.NET MVC и веб-страниц.

Пакеты создаются с помощью класс пакета или одного из его дочерних классов, ScriptBundle и StyleBundle. После настройки экземпляра пакета, пакета доступны на входящие запросы, просто добавляя ее в глобальный экземпляр BundleCollection. В шаблоны по умолчанию в файле BundleConfig выполняется конфигурацию пакета. Эта конфигурация создает пакеты для всех основных сценариев и файлов css, используемые в шаблонах.

Пакеты ссылаются в пределах представления с помощью одного из возможных вспомогательных методов. Чтобы обеспечить поддержку визуализации различные разметки для пакета, когда в режиме отладки и режиме выпуска, ScriptBundle и StyleBundle классы имеют вспомогательный метод, визуализации. При работе в режиме отладки, Render создает разметку для каждого ресурса в пакете. В режиме выпуска, Render создает элемент одной разметки для всего пакета. Переключение между отладочной и окончательной режим можно сделать путем изменения атрибута отладки элемента компиляции в файле web.config, как показано ниже:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample12.xml)]

Кроме того Включение или отключение оптимизации можно задать непосредственно через свойство BundleTable.EnableOptimizations.

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample13.cs)]

Когда файлы объединены, они сначала сортируются в алфавитном порядке (способ их отображения в **обозревателе решений**). Затем организованы так, что известные библиотеки и свои пользовательские расширения (например, jQuery, MooTools и Dojo) загружались первыми. Например будет конечного порядка для объединения в папку Scripts, как показано выше:

1. jquery-1.6.2.js
2. jquery-ui.js
3. jquery.tools.js
4. a.js

CSS-файлы также сортируются по алфавиту и реорганизовать, так что reset.css и normalize.css предшествуют любой другой файл. Окончательный сортировки объединение указанной выше папки стили будет это:

1. reset.css
2. Content.CSS
3. Forms.CSS
4. Globals.CSS
5. Menu.CSS
6. Styles.CSS

<a id="_Toc_perf"></a>
### <a name="performance-improvements-for-web-hosting"></a>Повышение производительности для размещения веб-сайтов

.NET Framework 4.5 и Windows 8 представлены функции, которые могут помочь вам в достижении увеличению производительности односекционных рабочие нагрузки веб сервера. Сюда входят сокращение (до 35%) в обоих время запуска и в памяти, занимаемой web размещение сайтов, использующих ASP.NET.

<a id="_Toc_perf_1"></a>
#### <a name="key-performance-factors"></a>Факторы производительности

В идеале все веб-сайтов должен быть активен, и в памяти, чтобы обеспечить быстрый ответ на следующий запрос, каждый раз, когда речь идет. Факторы, которые могут повлиять на скорость реагирования сайта:

- Время, необходимое для сайта, необходимость в перезагрузке после пул приложений запускается повторно. Это время, необходимое для запуска процесса веб-сервера для сайта, когда сборки сайта находятся в памяти. (Сборки платформы, по-прежнему в памяти, так как они используются для других сайтов.) Это называется «холодного сайт, «горячего» резервирования framework запуска» или просто «холодного сайта запуска.»
- Объем памяти, который занимает сайта. Для этого условий «потребление памяти каждого сайта» или «без предоставления общего доступа рабочего набора.»

Новые усовершенствования производительности сосредоточиться на оба этих фактора.

<a id="_Toc_perf_2"></a>
#### <a name="requirements-for-new-performance-features"></a>Требования для новых функций повышения производительности

Требования для новых функций можно разделить на следующие категории:

- Улучшения, которые выполняются на платформе .NET Framework 4.
- Улучшения, которые требуют .NET Framework 4.5, но можно запустить в любой версии Windows.
- Улучшения, доступные только с .NET Framework 4.5 на Windows 8.

Производительность увеличивается с каждым уровнем, улучшение, которое можно включить.

Некоторые усовершенствования .NET Framework 4.5 воспользоваться преимуществами более широкие возможности для повышения производительности, которые применяются к другие сценарии.

<a id="_Toc_perf_3"></a>
#### <a name="sharing-common-assemblies"></a>Совместное использование общих сборок

**Требование**: .NET Framework 4 и Visual Studio 11 Developer Preview пакета SDK

Разные сайты на сервере часто используют те же вспомогательные сборки (например, сборки из starter kit или образец приложения). Каждый сайт имеет свою собственную копию этих сборок в каталоге Bin. Несмотря на то, что идентичен объектный код для сборки, они физически отдельные сборки, чтобы каждая сборка имеет для чтения во время запуска "холодных" сайта отдельно и хранится отдельно в памяти.

Новые функциональные возможности interning решает подобную неэффективность и снижает требования к оперативной памяти и нагрузки времени. Изоляция позволяет Windows хранить одну копию каждой сборки в файловой системе и отдельные сборки в папке Bin узла будут заменены с символьными ссылками на единственную копию. Если отдельного узла должен distinct версию сборки, символьную ссылку заменяется новой версии сборки и влияет только с этого сайта.

Совместное использование сборок с помощью символические ссылки требуется новое средство, с именем aspnet\_intern.exe, который позволяет создавать и управлять ими хранилище интернировано сборок. Он предоставляется в составе Visual Studio 11 Developer Preview SDK. (Тем не менее, он будет работать в системе, которая имеет только платформа .NET Framework 4, при условии, что установлена последняя версия [обновление](https://support.microsoft.com/kb/2468871).)

Чтобы убедиться, что все соответствующие сборки были начал работать, вы запустите aspnet\_intern.exe периодически (например, один раз в неделю по расписанию). Обычно используется следующим образом:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample14.cmd)]

Чтобы просмотреть все параметры, запустите средство без аргументов.

<a id="_Toc_perf_4"></a>
#### <a name="using-multi-core-jit-compilation-for-faster-startup"></a>С помощью JIT-компиляция многоядерными процессорами для ускорения запуска

**Требование**: .NET Framework 4.5

Для сайта холодного запуска не только для чтения с диска у сборки, но сайт должен быть JIT-компиляции. Для сложных сайта это может оказаться значительным задержкам. Новый многоцелевая методика в .NET Framework 4.5 позволяет сократить эти задержки, распределяя JIT-компиляции между доступных ядер процессора. Это достигается столь большой и как можно раньше, используя сведения, собранные во время предыдущего запускает веб-узла. Эта функция реализуется [System.Runtime.ProfileOptimization.StartProfile](https://msdn.microsoft.com/library/system.runtime.profileoptimization.startprofile(VS.110).aspx) метод.

Использование нескольких ядер с JIT-компиляции включена по умолчанию в ASP.NET, поэтому не нужно ничего делать, чтобы воспользоваться преимуществами этой функции. Если вы хотите отключить эту функцию, внесите следующий параметр в файле Web.config.

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample15.xml)]

<a id="_Toc_perf_5"></a>
#### <a name="tuning-garbage-collection-to-optimize-for-memory"></a>Помощник по настройке сбора мусора для оптимизации для памяти

**Требование**: .NET Framework 4.5

После запуска сайта, его использование кучи мусора (GC) может быть значительную роль в используемой памяти. Как и любому сборщику мусора сборщик Мусора .NET Framework делает компромиссы между время ЦП (частота и значимость коллекций) и потребление памяти (дополнительное пространство для новых, освобожденные или освобождения удается объектов). Для предыдущих выпусков, представлены рекомендации по настройке глобального Каталога, чтобы достичь правильного баланса (например, см. в разделе [ASP.NET 2.0 и 3.5 настройки общего пользования размещение](https://www.iis.net/learn/web-hosting/web-server-for-shared-hosting/aspnet-20-35-shared-hosting-configuration)).

Для .NET Framework 4.5, вместо нескольких параметров автономного, определяемые рабочей нагрузки Конфигурация доступна, позволяет использовать все ранее рекомендуемые параметры сборки Мусора, а также новый помощник по настройке, обеспечивает дополнительную производительность для каждого сайта рабочий набор.

Чтобы включить помощник по настройке памяти сборщика Мусора, добавьте следующий параметр в файле Windows\Microsoft.NET\Framework\v4.0.30319\aspnet.config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample16.xml)]

(Если вы знакомы с рекомендациями предыдущих изменений aspnet.config, обратите внимание, что этот параметр заменяет старые параметры — например, нет необходимости задать gcServer, gcConcurrent и т. д. У вас нет для удаления старых параметров.)

<a id="_Toc_perf_6"></a>
#### <a name="prefetching-for-web-applications"></a>Предварительная выборка для веб-приложений

**Требование**: .NET Framework 4.5 на Windows 8

На протяжении нескольких версий Windows включает в себя технологии, которая называется [ОС](http://en.wikipedia.org/wiki/Prefetcher) , снижает затраты считывания с диска на запуск приложения. Так как холодный запуск зависит от проблемы преимущественно для клиентских приложений, эта технология не был включен в Windows Server, которая включает в себя только компоненты, которые необходимы для сервера. Предварительная выборка доступна в последней версии Windows Server, где его можно оптимизировать запуска отдельных веб-сайтах.

Для Windows Server ОС не включена по умолчанию. Чтобы включить и настроить ОС для размещения в сети с высокой плотностью, выполните следующий набор команд в командной строке:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample17.cmd)]

Чтобы интегрировать ОС с приложениями ASP.NET, добавьте следующее в файл Web.config:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample18.xml)]

<a id="_Toc318097385"></a>
## <a name="aspnet-web-forms"></a>Веб-формы ASP.NET

<a id="_Toc318097386"></a>
### <a name="strongly-typed-data-controls"></a>Строго типизированные элементы управления данными

В ASP.NET 4.5 веб-форм содержит ряд улучшений для работы с данными. Первое нововведение является строго типизированные элементы управления данными. Для элементов управления веб-форм в предыдущих версиях ASP.NET, отобразить значение с привязкой к данным с помощью *Eval* и выражение привязки данных:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample19.aspx)]

Для двусторонней привязки данных, используйте *привязать*:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample20.aspx)]

Во время выполнения этих вызовов использовать отражение для чтения значения указанного элемента и затем отображают результаты в разметке. Такой подход упрощает для привязки данных к unshaped произвольных данных.

Тем не менее выражения привязки данных этого типа не поддерживают такие функции, как IntelliSense для имен членов, навигации (например, перейти к определению) или проверка для этих имен во время компиляции.

Чтобы устранить эту проблему, ASP.NET 4.5 добавляет возможность объявлять тип данных, элемент управления, привязанный к данных. Это делается с помощью нового *ItemType* свойство. Когда это свойство задано, две новые типизированные переменные доступны в рамках выражения привязки данных: *Элемент* и *BindItem*. Поскольку переменные являются строго типизированными, вы получаете все преимущества средства разработки Visual Studio.


Выражения привязки данных, используйте *BindItem* переменной:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample21.aspx)]


Большинство элементов управления в платформе веб-форм ASP.NET, которые поддерживают привязку данных были обновлены для поддержки *ItemType* свойство.

<a id="_Toc318097387"></a>
### <a name="model-binding"></a>Привязка модели

Привязка модели расширяет возможности привязки данных в элементах управления веб-форм ASP.NET для работы с доступом к данным, ориентированный на код. Он включает в себя концепции из *ObjectDataSource* управления и из привязки модели в ASP.NET MVC.

<a id="_Toc318097388"></a>
#### <a name="selecting-data"></a>Выбор данных

Чтобы настроить элемент управления данные для использования привязки модели для выбора данных, значение элемента управления *SelectMethod* имя метода в код страницы. Элемент управления данными вызывает метод в соответствующее время жизненного цикла страницы и автоматически связывает возвращаемых данных. Нет необходимости явно вызвать *DataBind* метод.

В следующем примере *GridView* управления настроен на использование метода с именем *GetCategories*:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample22.aspx)]

Создании *GetCategories* метод в код страницы. Для простой операции выбора, метод не требуется задавать параметры и должен возвращать *IEnumerable* или *IQueryable* объекта. Если новый *ItemType* свойству (что обеспечивает строго типизированным выражения привязки данных, как описано в разделе [строго типизированные элементы управления данными](#_Toc318097386) ранее), универсальные версии этих интерфейсов должны быть возвращены — *IEnumerable&lt;T&gt;*  или *IQueryable&lt;T&gt;*, с помощью *T* параметр, совпадающим с типом *ItemType* свойства (например, *IQueryable&lt;категории&gt;*).

В следующем примере показано код *GetCategories* метод. В этом примере используется модель Entity Framework Code First с образцом базы данных "Борей". Код гарантирует, что запрос возвращает сведения о ее использовании связанные продукты для каждой категории посредством *Include* метод. (Это гарантирует, что *TemplateField* элемент в разметке отображает количество продуктов в каждой категории без необходимости [n + 1 выберите](http://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem).)

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample23.cs)]

При запуске страницы, *GridView* контролирующие вызовы, *GetCategories* метод автоматически и отображает возвращаемые данные, используя настроенный поля:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image2.png)

Поскольку метод select возвращает *IQueryable* объекта, *GridView* управления можно расширить спектр операций запроса перед его выполнением. Например *GridView* управления можно добавить выражения запросов сортировки и разбиения по страницам, к возвращенному *IQueryable* объекта до его выполнения, таким образом, чтобы эти операции выполняются с основной Поставщик LINQ. В этом случае Entity Framework будет убедитесь, что эти операции выполняются в базе данных.

В следующем примере показан *GridView* изменить элемент управления, чтобы разрешить сортировку и разбиение по страницам:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample24.aspx)]

Теперь при запуске страницы, элемент управления можно убедитесь, что отображается только текущей страницы данных, и упорядочен по выбранному столбцу:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image3.png)

Для фильтрации возвращаемых данных, параметры нужно добавить к методу select. Эти параметры будет взят из привязки модели во время выполнения, и их можно использовать для изменения запроса перед возвратом данные.

Например предположим, что нужно сообщить пользователям фильтрации продуктов по ключевому слову в строке запроса. Можно добавить параметр в метод и обновить код, чтобы использовать значение параметра:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample25.cs)]

Этот код включает *где* выражения, если значение предоставляется для *ключевое слово* и затем возвращает результаты запроса.

<a id="_Toc318097389"></a>
#### <a name="value-providers"></a>Поставщики значений

Предыдущий пример не уникальна, о том, где значение *ключевое слово* параметр получен. Чтобы указать эти сведения, можно использовать атрибут параметра. Например, можно использовать *QueryStringAttribute* класс в *System.Web.ModelBinding* пространство имен:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample26.cs)]

Это указывает, что привязка модели к попытке привязать значение из строки запроса для *ключевое слово* параметра во время выполнения. (Это может вызвать выполнение преобразования типа, несмотря на то, что это не так в этом случае.) Если не может быть указано значение и тип не допускает значения NULL, создается исключение.

Источники значений для этих методов, называются поставщиков значений, а атрибуты параметров, которые указывают, какой поставщик значений для использования, называются атрибуты поставщика значения. Веб-форм будет включать поставщиков значений и соответствующих атрибутов для всех типичных источников данных, введенных пользователем в приложении Web Forms, такие как строка запроса, файлы cookie, значения формы, элементы управления, состояние представления, состояние сеанса и свойства профиля. Можно также написать пользовательские поставщики значений.

По умолчанию имя параметра используется как ключ для поиска значения в коллекции поставщиков значений. В примере, код будет искать значение строки запроса с именем ключевого слова (например, ~ / default.aspx?keyword=chef). Пользовательский ключ можно указать, передав его в качестве аргумента атрибут parameter. Например чтобы использовать значение переменной строки запроса с именем q, это можно сделать:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample27.cs)]

Если этот метод в коде страницы, пользователи могут фильтровать результаты, передав ключевое слово в строке запроса:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image4.png)

Привязка модели выполняет множество задач, которые в противном случае пришлось бы кодировать вручную: считывания значения, проверки на наличие значения null, попытка преобразовать его к соответствующему типу, проверка, успешно ли выполнено преобразование и наконец, использование значения в запрос. Привязка моделей, результаты в гораздо меньше кода и возможность повторного использования функциональности в приложении.

<a id="_Toc318097390"></a>
#### <a name="filtering-by-values-from-a-control"></a>Фильтрация по значениям из элемента управления

Предположим, что вы хотите расширить пример, чтобы позволить пользователю выбирать значения фильтра из раскрывающегося списка. Добавьте перечисленные ниже раскрывающегося списка в разметку и настройте его для получения данных из другой метод с помощью *SelectMethod* свойство:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample28.aspx)]

Обычно необходимо также добавить *EmptyDataTemplate* элемент *GridView* управления таким образом, чтобы элемент управления будет отображать сообщение при обнаружении отсутствия подходящих продуктов:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample29.aspx)]

В коде страницы добавьте новый Выбор метода для раскрывающегося списка.

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample30.cs)]

Наконец, обновите *GetProducts* выберите метод, чтобы использовать новый параметр, содержащий идентификатор выбранной категории в раскрывающемся списке:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample31.cs)]

Теперь при запуске страницы пользователи могут выбрать категорию из раскрывающегося списка и *GridView* управления автоматически повторно привязанные отображать отфильтрованные данные. Это возможно, так как привязка модели отслеживает значения параметров для методов select и обнаруживает, изменился ли все значения параметров после обратной передачи. Если Да, привязка модели заставляет элемент управления связанные данные, чтобы повторно привязать к данным.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image5.png)

<a id="_Toc318097391"></a>
### <a name="html-encoded-data-binding-expressions"></a>Выражения привязки данных в кодировке HTML

Вы можете теперь HTML-кодирование результат выражения привязки данных. Добавьте двоеточие (:) в конец &lt;префикс % #, который помечает выражения привязки данных:

[!code-aspx[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample32.aspx)]

<a id="_Toc318097392"></a>
### <a name="unobtrusive-validation"></a>Малозаметная проверка

Теперь можно настроить встроенным элементам управления использовать малозаметный JavaScript для логики проверки на стороне клиента. Это значительно сокращает объем кода JavaScript, отображаемый в разметке страницы и сокращает общий размер страницы. Ненавязчивый JavaScript для проверяющих элементов управления можно настроить в любом из следующих способов:

- Глобально, добавив следующий параметр *&lt;appSettings&gt;* в файле Web.config: 

    [!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample33.xml)]
- Глобально путем задания статического *System.Web.UI.ValidationSettings.UnobtrusiveValidationMode* свойства *UnobtrusiveValidationMode.WebForms* (обычно в *приложения \_Запустить* метод в файле Global.asax).
- По отдельности для страницы, задав новое *UnobtrusiveValidationMode* свойство *страницы* класс *UnobtrusiveValidationMode.WebForms*.

<a id="_Toc318097393"></a>
### <a name="html5-updates"></a>Обновления HTML5

Некоторые улучшения были внесены веб-форм серверные элементы управления, чтобы воспользоваться преимуществами новых возможностей HTML5:

- *TextMode* свойство *TextBox* управления была обновлена для поддержки новых типов входных данных HTML5 как *электронной почты*, *datetime*, и т. д.
- *FileUpload* управления теперь поддерживает, отправка нескольких файлов из браузеров, поддерживающих эту технологию HTML5.
- Проверяющие элементы управления теперь поддержка проверки HTML5 входных элементов.
- Новые элементы HTML5, имеющие атрибуты, представляющие URL-адрес теперь поддерживает runat = «server». Таким образом, можно использовать соглашения об ASP.NET в пути URL-адрес, например ~ оператора для представления корневой каталог приложения (например, &lt;видео runat = «server» src="~/myVideo.wmv» /&gt;).
- *UpdatePanel* управления была устранена для поддержки полей ввода учета HTML5.

<a id="_Toc318097394"></a>
## <a name="aspnet-mvc-4"></a>ASP.NET MVC 4

Бета-версию 4 ASP.NET MVC в состав Visual Studio 11 Beta. ASP.NET MVC — это платформа для разработки веб-приложений, легко тестируемых и простым в обслуживании за счет использования шаблона Model-View-Controller (MVC). ASP.NET MVC 4 позволяет легко создавать мобильные веб-приложений и включает в себя веб-API ASP.NET, которая поможет вам создавать службы HTTP могут получить доступ для любого устройства. Дополнительные сведения см. в разделе [заметки о выпуске ASP.NET MVC 4](mvc4-release-notes.md).

<a id="_Toc318097395"></a>
## <a name="aspnet-web-pages-2"></a>Веб-страницы ASP.NET 2

Новые возможности:

- Шаблоны новых и обновленных узлов.
- Добавление на стороне сервера и проверки на стороне клиента с помощью *проверки* вспомогательный.
- Возможность зарегистрировать скрипты, с помощью диспетчера ресурсов.
- Включение имена входа из Facebook, а также других узлов, с помощью OAuth и OpenID.
- Добавление сопоставляется с помощью *сопоставляет* вспомогательный.
- Запуск веб-страниц приложений side-by-side.
- Подготовка к просмотру страниц для мобильных устройств.

Дополнительные сведения об этих функциях и примеры кода в режиме полностраничного см. в разделе [лучшие возможности бета-версия 2 веб-страниц](https://go.microsoft.com/fwlink/?LinkID=227824).

<a id="_Toc318097396"></a>
## <a name="visual-web-developer-11-beta"></a>Бета-версия Visual Web Developer 11

Этот раздел содержит сведения об улучшениях для веб-разработки в Visual Web Developer 11 Beta и Visual Studio 2012 Release Candidate.

<a id="project-compatibility"></a>
### <a name="project-sharing-between-visual-studio-2010-and-visual-studio-2012-release-candidate-project-compatibility"></a>Проект, общего для Visual Studio 2010 и Visual Studio 2012 Release Candidate (совместимость проектов)

До Visual Studio 2012 Release Candidate открытии существующего проекта в более новой версии Visual Studio запускается мастер преобразования. Это принудительно обновления содержимого (активы) проект и решение для новых форматов, не обладает обратной совместимостью. Таким образом после преобразования вы не удалось открыть проект в более старой версии Visual Studio.

Многие клиенты, пользующихся что это не правильного подхода. В Visual Studio 11 Beta мы теперь поддерживают совместное использование проектов и решений с помощью Visual Studio 2010 с пакетом обновления 1. Это означает, что при открытии проекта 2010 в Visual Studio 2012 Release Candidate, по-прежнему можно открыть проект в Visual Studio 2010 с пакетом обновления 1.

> [!NOTE]
> Несколько типов проектов не могут совместно с пакетом обновления 1 для Visual Studio 2010 и Visual Studio 2012 Release Candidate. К ним относятся некоторые старые проекты (таких как проекты ASP.NET MVC 2) или проекты для особых целей (например, проекты установки).

При открытии проекта Visual Studio 2010 SP1 Web в первый раз, в Visual Studio 11 Beta в файл проекта добавляются следующие свойства:

- FileUpgradeFlags
- UpgradeBackupLocation
- OldToolsVersion
- VisualStudioVersion
- VSToolsPath

FileUpgradeFlags UpgradeBackupLocation и OldToolsVersion используются процессом, который обновляет файл проекта. Они не оказывают влияния на работе с проектом в Visual Studio 2010.

VisualStudioVersion является новое свойство, используемые MSBuild 4.5, который указывает версию Visual Studio для текущего проекта. Так как это свойство не существует в MSBuild 4.0 (версии MSBuild, который использует Visual Studio 2010 с пакетом обновления 1), мы внедрить значение по умолчанию в файле проекта.

Свойство VSToolsPath используется для определения правильного TARGETS-файла для импорта из пути, представляемого параметром MSBuildExtensionsPath32.

Кроме того, существуют также некоторые изменения, связанные с элементами импорта. Эти изменения необходимы для поддержки совместимости между обе версии Visual Studio.

> [!NOTE]
> Если проект совместно с пакетом обновления 1 для Visual Studio 2010 и Visual Studio 11 Beta на двух разных компьютерах, и в том случае, если проект включает локальную базу данных в приложении\_папку данных, убедитесь, что версия SQL Server, используемые базой данных установить на обоих компьютерах.

<a id="Configuration_Changes_In_ASPNET45_Website_Templates"></a>
### <a name="configuration-changes-in-aspnet-45-website-templates"></a>Изменения конфигурации в шаблонах ASP.NET 4.5 веб-сайта

По умолчанию были внесены следующие изменения *Web.config* файл для сайта, которая была создана с помощью шаблонов веб-сайта в Visual Studio 2012 Release Candidate:

- В `<httpRuntime>` элемент, `encoderType` атрибут теперь имеет значение по умолчанию для использования AntiXSS типов, которые были добавлены к ASP.NET. Дополнительные сведения см. в разделе [AntiXSS Library](#_Toc318097382).
- Кроме того, в `<httpRuntime>` элемент, `requestValidationMode` атрибут имеет значение «4.5». Это означает, что по умолчанию проверка запросов настроен на использование отложенной проверки («неспешная»). Дополнительные сведения см. в разделе [новые функции проверки запросов ASP.NET](#_Toc318097379).
- `<modules>` Элемент `<system.webServer>` раздел не содержит `runAllManagedModulesForAllRequests` атрибута. (Значение по умолчанию — false.) Это означает, что если вы используете версию IIS 7, который не был обновлен до SP1, возможно, есть проблемы с маршрутизацией на новом сайте. Дополнительные сведения см. в разделе [встроенную поддержку в IIS 7 для маршрутизации ASP.NET](#Native_Support_In_IIS7_For_ASPNET_Routine).

Эти изменения не влияют на существующие приложения. Тем не менее они может представлять различие в поведении между существующих веб-сайтов и новых веб-сайтов, созданному для ASP.NET 4.5 с помощью новых шаблонов.

<a id="Native_Support_In_IIS7_For_ASPNET_Routine"></a>
### <a name="native-support-in-iis-7-for-aspnet-routing"></a>Встроенная поддержка в службах IIS 7 для маршрутизации ASP.NET

Это не изменение ASP.NET таким образом, за исключением изменения в шаблонах для новых проектов веб-сайта, которые могут повлиять на вас при работе версия IIS 7, который не был применен пакет обновления 1.

В ASP.NET можно добавить следующий параметр конфигурации для приложений для поддержки маршрутизации:

[!code-xml[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample34.xml?highlight=3)]

Когда **runAllManagedModulesForAllRequests** равно "true", "URL-адресу вида `http://mysite/myapp/home` переходит к ASP.NET, несмотря на то, что существует не *.aspx*, *MVC было связано*, или аналогичное расширение на URL-АДРЕС.

Обновления, которые были выполнены для IIS 7 делает **runAllManagedModulesForAllRequests** Установка ненужных и поддерживает ASP.NET, маршрутизация в собственном коде. (Сведения об обновлении см. в статье технической поддержки Майкрософт [обновление доступно, что позволяет определенным обработчикам служб IIS 7.0 или IIS 7.5 обрабатывать запросы URL-адреса которых не оканчиваются точкой](https://support.microsoft.com/kb/980368).)

Если веб-сайт работает в службах IIS 7 и если IIS был обновлен, не нужно задать **runAllManagedModulesForAllRequests** значение true. На самом деле задать ему значение true не рекомендуется, так как он добавляет ненужные накладные расходы для обработки запроса. Если этот параметр имеет значение true, все запросы, включая *.htm*, *.jpg*, и другие статические файлы, также проходят через конвейер запросов ASP.NET.

При создании нового ASP.NET 4.5 веб-сайт с помощью шаблонов, предоставляемых в Visual Studio 2012 RC, не поддерживает конфигурацию для веб-сайт **runAllManagedModulesForAllRequests** параметр. Это означает, что по умолчанию параметр имеет значение false.

Если вы запустите веб-сайта в Windows 7 без пакета обновления 1 установлен, IIS 7 не будет содержать необходимое обновление. Как следствие маршрутизация не будет работать, и вы увидите ошибки. Если у вас есть проблема где маршрутизации не работает, можно сделать либо следующее:

- Обновите Windows 7 с пакетом обновления 1, в который будет добавлять обновления в среде IIS 7.
- Установите обновление, описанное в статье технической поддержки Майкрософт, перечисленные ранее.
- Задайте **runAllManagedModulesForAllRequests** значение true в файле Web.config этого веб-сайта. Обратите внимание на то, что запросы будут добавлены дополнительные издержки.

<a id="_Toc318097397"></a>
### <a name="html-editor"></a>Редактор HTML

<a id="_Toc318097398"></a>
#### <a name="smart-tasks"></a>Смарт-задачи

В режиме конструктора сложных свойств серверных элементов управления часто связаны диалоговые окна и мастера, чтобы упростить процесс их настройки. Например, можно использовать специальные диалоговое окно для добавления источника данных в *Repeater* управления или добавить столбцы к *GridView* элемента управления.

Тем не менее этот тип Справка по пользовательскому Интерфейсу для сложных свойств, не было доступно в представлении источника. Таким образом Visual Studio 11 представлена смарт-тегов для представления источников. Смарт-задачи являются контекстно ярлыки для часто используемых функций в редакторах C# и Visual Basic.

Для элементов управления веб-форм ASP.NET, быстрые действия отображаются в серверных тэгов как глиф небольшой когда точка вставки находится внутри элемента:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image6.png)

Смарт-задачи разворачивается при щелкните глиф или нажмите клавиши CTRL +. (точка), как в редакторах кода. Затем он отобразит сочетания клавиш, которые похожи на смарт-задачи, в режиме конструктора.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image7.png)

Например смарт-задачи на предыдущем рисунке показаны параметры задачи GridView. Если изменить столбцы, отображается следующее диалоговое окно:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image8.png)

Заполнение диалогового окна задает те же свойства можно задать в конструкторе. При нажатии кнопки "ОК", разметки для элемента управления обновляется с новыми параметрами:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image9.png)

<a id="_Toc318097399"></a>
#### <a name="wai-aria-support"></a>Поддержку ARIA ВАЙ

Написание доступен веб-сайтов становится все более важной. [ВАЙ ARIA расширенного доступа](http://www.w3.org/WAI/intro/aria) определяет, как разработчики должны создавать доступен веб-сайтов. Этот стандарт теперь полностью поддерживается в Visual Studio.

Например *роли* атрибут теперь имеет полную поддержку технологии IntelliSense:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image10.png)

Стандарт ARIA ВАЙ также представлены атрибуты, которые начинаются с префикса *aria -* , которые позволяют добавить в документ HTML5 семантику. Visual Studio также полностью поддерживает следующие *aria -* атрибуты:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image11.png) ![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image12.png)

<a id="_Toc318097400"></a>
#### <a name="new-html5-snippets"></a>Новые фрагменты кода HTML5

Чтобы сделать его быстрее и проще создавать часто используемые разметку HTML5, Visual Studio включает ряд фрагментов кода. Например, видео фрагмент кода:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image13.png)

Чтобы вызвать фрагмент кода, нажмите клавишу Tab дважды в том случае, когда элемент выбран в IntelliSense:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image14.png)

Этот сценарий создает фрагмент кода, который можно настроить.

<a id="_Toc318097401"></a>
#### <a name="extract-to-user-control"></a>Извлечь в пользовательский элемент управления

В больших веб-страницы может быть хорошей идеей для перемещения отдельных фрагментов в пользовательские элементы управления. Эта форма рефакторинга может помочь повысить удобство чтения страницы и может упростить структуру страницы.

Чтобы облегчить эту задачу, при редактировании страницы веб-форм в представлении источника, может теперь выделите текст на странице, щелкните его правой кнопкой мыши и выберите извлечение в пользовательский элемент управления:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image2.jpg)

<a id="_Toc318097402"></a>
#### <a name="intellisense-for-code-nuggets-in-attributes"></a>IntelliSense для фрагментами кода в атрибутах

Visual Studio всегда предоставила IntelliSense фрагментами кода на стороне сервера в любой страницы или элемента управления. Теперь Visual Studio включает в себя IntelliSense для фрагментами кода в атрибутах HTML также.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image15.png)

Это упрощает создание выражения привязки данных:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image16.png)

<a id="_Toc318097403"></a>
#### <a name="automatic-renaming-of-matching-tag-when-you-rename-an-opening-or-closing-tag"></a>Автоматическое переименование соответствующих тегов при переименовании открывающего или закрывающего тега

При переименовании элемента HTML (например, можно изменить *div* тег, который будет *заголовок* тега), соответствующий Открытие или закрытие тега также изменяется в режиме реального времени.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image17.png)

Это позволяет избежать ошибок, где вы забыли изменить закрывающего тега или другой.

<a id="_Toc318097404"></a>
#### <a name="event-handler-generation"></a>Создание обработчика событий

Visual Studio теперь включает функции в представлении источника, которые помогут написать обработчики событий и привязывать их вручную. Если вы изменяете имя события в режиме исходного кода, IntelliSense отображает &lt;создать новое событие&gt;, который создает обработчик событий в код страницы, имеет правильную сигнатуру:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image3.jpg)

По умолчанию обработчик событий будет использовать идентификатор элемента управления для имени метода обработки событий:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image4.jpg)

Итоговый обработчик событий будет выглядеть следующим образом (в этом случае в C#):

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image18.png)

<a id="_Toc318097405"></a>
#### <a name="smart-indent"></a>Автоматический отступ

При нажатии клавиши ВВОД внутри пустой HTML-элемент, редактор будет поместить курсор в нужном месте:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image19.png)

При нажатии клавиши ВВОД в этом расположении, закрывающий тег перемещен вниз и отступ соответствует открывающему тегу. Также будет перемещена точка вставки:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image20.png)

<a id="_Toc318097406"></a>
#### <a name="auto-reduce-statement-completion"></a>Уточнение завершение операторов

Список IntelliSense в Visual Studio теперь фильтры, основанные на тип, который будет размещать только сведения о параметрах:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image21.png)

IntelliSense также фильтры, основанные на заглавные буквы каждого слова в списке IntelliSense. Например при вводе «dl» список рассылки и asp: DataList, отображаются:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image22.png)

Эта функция позволяет быстрее получить завершение операторов с известные элементы.

<a id="_Toc318097407"></a>
### <a name="javascript-editor"></a>редактор JavaScript

Редактор JavaScript в Visual Studio 2012 Release Candidate является абсолютно новым и значительно повышает возможности работы с использованием JavaScript в Visual Studio.

<a id="_Toc318097408"></a>
#### <a name="code-outlining"></a>Структура кода

Теперь областей структуры автоматически создаются для всех функций, что позволяет свернуть части файла, не относящиеся к вашей текущего фокуса.

<a id="_Toc318097409"></a>
#### <a name="brace-matching"></a>Парные фигурные скобки

При помещении курсора на открывающую или закрывающую фигурную скобку, соответствующий одному выделяется в редакторе.

<a id="_Toc318097410"></a>
#### <a name="go-to-definition"></a>Перейти к определению

Команда определения перехода, можно перейти к источнику для функции или переменной.

<a id="_Toc318097411"></a>
#### <a name="ecmascript5-support"></a>Поддержка ECMAScript5

Редактор поддерживает новый синтаксис и API-интерфейсы в ECMAScript5, последнюю версию standard, который содержит сведения о языке JavaScript.

<a id="_Toc318097412"></a>
#### <a name="dom-intellisense"></a>DOM IntelliSense

IntelliSense для интерфейсов API модели DOM был улучшен, с поддержкой для многих новых интерфейсов API HTML5 в том числе *querySelector*, хранилище DOM, обмен сообщениями, между документами и *холст*. Средства IntelliSense DOM теперь управляются по одной простой файл JavaScript, а не с определением библиотеки собственного типа. Это позволяет легко расширить или заменить.

<a id="_Toc318097413"></a>
#### <a name="vsdoc-signature-overloads"></a>Сигнатура перегрузки VSDOC

Подробные комментарии IntelliSense теперь могут быть объявлены для отдельных перегрузки для функций JavaScript с помощью нового *&lt;подпись&gt;* элемента, как показано в следующем примере:

[!code-csharp[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample35.cs)]

<a id="_Toc318097414"></a>
#### <a name="implicit-references"></a>Неявные ссылки

Файлы JavaScript теперь можно добавить в список центра, неявно включается в список файлов, что заданный JavaScript файла или блок ссылки, то есть вы получите IntelliSense за их содержимое. Например, можно добавить файлы jQuery центра список файлов, и вы получите IntelliSense для функции jQuery в любой файл, блок JavaScript ли ссылка на явно (с помощью / / / &lt;ссылку /&gt;) или нет.

<a id="_Toc318097415"></a>
### <a name="css-editor"></a>редактор CSS

<a id="_Toc318097416"></a>
#### <a name="auto-reduce-statement-completion"></a>Уточнение завершение операторов

Список IntelliSense для CSS теперь фильтры, основанные на свойства CSS и значения, поддерживаемые выбранной схеме.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image23.png)

IntelliSense также поддерживает заголовок вариантов поиска:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image24.png)

<a id="_Toc318097417"></a>
#### <a name="hierarchical-indentation"></a>Иерархические отступы

Редактор CSS использует отступа для отображения иерархические правила, которая предоставляет общие сведения о том, как правила каскадных логически организованы. В следующем примере #list селектор каскадных потомком списка и поэтому отображается с отступом.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image25.png)

В следующем примере показано более сложные наследования:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image26.png)

Отступ правила определяется его родительского правила. Иерархические отступы включен по умолчанию, но его можно отключить в диалоговом окне Параметры (Сервис, параметры в строке меню):

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image27.png)

<a id="_Toc318097418"></a>
#### <a name="css-hacks-support"></a>Поддержка CSS-фильтров

Анализ сотни файлов CSS реальных показывает CSS-фильтров очень распространены, что теперь поддерживает наиболее широко используемых в Visual Studio. Эта поддержка включает технологии IntelliSense и проверки типа "звезда" (\*) и символ подчеркивания (\_) свойство взлома:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image28.png)

Типичный селектор взлома, также поддерживаются таким образом, чтобы иерархические отступы сохраняется, даже в том случае, когда они применяются. Типичный селектор взлома использованы для работы с Internet Explorer 7 является спереди селектора с  *\*: первый дочерний + html*. С помощью этого правила будет поддерживать иерархические отступы:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image29.png)

<a id="_Toc318097419"></a>
#### <a name="vendor-specific-schemas--moz---webkit"></a>Конкретные схемы поставщика (- moz-, - webkit)

CSS3 предоставляет множество свойств, которые были реализованы в разных браузерах в разное время. Ранее это принудительно разработчикам создавать код для конкретных браузеров с помощью синтаксиса от конкретных поставщиков. Эти свойства в конкретном браузере теперь включены в IntelliSense.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image30.png)

<a id="_Toc318097420"></a>
#### <a name="commenting-and-uncommenting-support"></a>Поддержка комментирования и раскомментирования

Теперь можно добавить комментарии и раскомментируйте правила CSS, используя те же клавиш, используемых в редакторе кода (сочетание клавиш Ctrl + K, C, чтобы комментарий и Ctrl + K, вам раскомментируйте).

<a id="_Toc318097421"></a>
#### <a name="color-picker"></a>Палитра цветов

В предыдущих версиях Visual Studio IntelliSense для атрибутов, связанные с цветом состоял из раскрывающегося списка значений именованный цвет. Этот список был заменен классом полнофункциональный палитру.

Когда вы вводите значение цвета, палитра цветов автоматически отображается и представляет список ранее использованных цветов, следуют палитра цветов по умолчанию. Можно выбрать цвет с помощью мыши или клавиатуры.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image31.png)

Список можно разделить на полный палитра. Средство выбора позволяет управлять альфа-канал автоматически преобразование любой цвет в RGBA, при перемещении ползунка непрозрачности:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image32.png)

<a id="_Toc318097422"></a>
#### <a name="snippets"></a>Фрагменты кода

Фрагменты кода в редакторе CSS позволяют упростить и ускорить создание стилей обозреватели. Многие свойства CSS3, требующих параметры браузера теперь были отменены в фрагменты кода.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image33.png)

Фрагменты CSS поддерживают расширенные сценарии (например, медиа-запросами CSS3), введя в символ (@), который показывает список IntelliSense.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image34.png)

При выборе @media значение и нажмите клавишу Tab, редактор CSS вставляет следующий фрагмент кода:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image5.jpg)

С помощью фрагментов кода для кода, можно создать собственные фрагменты кода CSS.

<a id="_Toc318097423"></a>
#### <a name="custom-regions"></a>Настраиваемые области

С именем области кода, которые уже доступны в редакторе кода, теперь доступны для редактирования CSS. Это позволяет легко группировать стиля, связанных с блоками.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image35.png)

Если область свернута он отображает имя региона:

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image36.png)

<a id="_Toc318097424"></a>
### <a name="page-inspector"></a>Инспектор страниц

Инспектор страниц — это средство, которое отображает веб-страницы (HTML, Web Forms, ASP.NET MVC или веб-страниц) в Интегрированной среде разработки Visual Studio и позволяет изучить исходный код и конечного результата. Для страниц ASP.NET инспектор страниц позволяет определить, какие серверным кодом была создана HTML-разметка, отображаемая в браузере.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image37.png)

Дополнительные сведения о инспектор страниц можно найти в следующих руководствах:

- Использование инспектора страниц в [ASP.NET MVC](../mvc/overview/views/using-page-inspector-in-aspnet-mvc.md)
- Использование инспектора страниц в [веб-форм ASP.NET](../web-forms/overview/getting-started/using-page-inspector-in-a-visual-studio-11-beta-web-forms-project.md)

<a id="_Toc318097425"></a>
### <a name="publishing"></a>Публикация

<a id="_Toc318097426"></a>
#### <a name="publish-profiles"></a>Профили публикации

В Visual Studio 2010 сведения о публикации проектов веб-приложений не хранится в системе управления версиями и не предназначен для совместного использования с другими пользователями. В Visual Studio 2012 Release Candidate был изменен формат профиль публикации. Он был сделан артефакта team, и теперь проще использовать из сборок, основанные на MSBuild. Сведения о конфигурации сборки — в диалоговом окне публикации, таким образом, можно легко переключить конфигурации построения перед публикацией.

Публикация профилей хранятся в папке PublishProfiles. Расположение папки зависит от используемого языка программирования:

- C#: Properties\PublishProfiles
- Visual Basic: Мои Project\PublishProfiles

Каждый профиль представляет собой файл MSBuild. Во время публикации, этот файл импортируется в файле проекта MSBuild. В Visual Studio 2010, если вы хотите внести изменения в процесс публикации или пакета, необходимо установить настройки в файле с именем **имя_проекта**. wpp.targets. Это по-прежнему поддерживается, но теперь настройки можно поместить в самом профиле. Таким образом, настройки будут использоваться только для этого профиля.

Теперь можно также использование таких профилей из MSBuild. Чтобы сделать это, используйте следующую команду, при построении проекта:

[!code-console[Main](whats-new-in-aspnet-45-and-visual-studio-2012/samples/sample36.cmd)]

Значение project.csproj является путь к проекту, и Имя_профиля — это имя профиля для публикации. Кроме того, вместо того чтобы передавать имя профиля для *PublishProfile* свойство, можно передать в полный путь к профилю публикации.

<a id="_Toc318097427"></a>
#### <a name="aspnet-precompilation-and-merge"></a>ASP.NET предварительной компиляции и слияния

Для проектов веб-приложений Visual Studio 2012 Release Candidate добавляет параметр на странице свойств упаковки/публикации Web, позволяющий предварительной компиляции и объединить содержимое своего сайта, при публикации или проект пакета. Чтобы просмотреть эти параметры, щелкните правой кнопкой мыши проект в обозревателе решений и выберите Свойства выберите упаковка и публикация веб-страницы свойств. На следующем рисунке Precompile это приложение перед публикацией параметр.

![](whats-new-in-aspnet-45-and-visual-studio-2012/_static/image6.jpg)

Если этот параметр выбран, Visual Studio выполняет предварительную компиляцию приложения при публикации или пакет веб-приложения. Если вы хотите управлять как предварительная компиляция сайта или как слияние сборок, нажмите кнопку «Дополнительно», чтобы настроить эти параметры.

<a id="_Toc318097428"></a>
### <a name="iis-express"></a>IIS Express

Веб-сервер по умолчанию, для тестирования веб-проектов в Visual Studio — теперь IIS Express. Visual Studio Development Server может по-прежнему использоваться для локального веб-сервера во время разработки, но теперь IIS Express является рекомендуемым сервером. Процедура использования IIS Express в Visual Studio 11 Beta очень так же, как в Visual Studio 2010 с пакетом обновления 1.

<a id="_Toc318097429"></a>
## <a name="disclaimer"></a>Отказ от ответственности

Это предварительный документ, он может быть существенно изменен до выхода окончательного коммерческого выпуска описанного здесь программного обеспечения.

Сведения, содержащиеся в этом документе, отражают представление корпорации Майкрософт по описанным здесь вопросам на дату публикации. Поскольку корпорация Майкрософт должна реагировать на изменяющиеся рыночные условия, данный документ не должен интерпретироваться как обязательство со стороны Майкрософт, и корпорация Майкрософт не может гарантировать точность любой информации, представленной после даты публикации.

Данный технический документ предназначен только для ознакомительных целей. МАЙКРОСОФТ НЕ ПРЕДОСТАВЛЯЕТ НИКАКИХ ГАРАНТИЙ, ЯВНЫХ ИЛИ ПРЕДУСМОТРЕННЫХ ЗАКОНОДАТЕЛЬСТВОМ, ОТНОСИТЕЛЬНО СВЕДЕНИЙ, СОДЕРЖАЩИХСЯ В ДАННОМ ДОКУМЕНТЕ.

Ответственность за соблюдение всех авторских прав и прав на интеллектуальную собственность целиком и полностью несет пользователь. Ни одна из частей этого документа не может быть воспроизведена, сохранена или использована в системах поиска или передана в любой форме, любыми способами (электронными, механическими, в виде фотокопии, в виде записи или любыми другими) и для любых целей без соблюдения ограничений авторских прав и письменного разрешения корпорации Майкрософт.

В настоящем документе могут упоминаться запатентованные или патентуемые технологии, товарные знаки, авторские права или другие права интеллектуальной собственности корпорации Майкрософт. Если иного явно не указано в письменном лицензионном соглашении корпорации Майкрософт, данный документ не предоставляет лицензии на эти патенты, товарные знаки, авторские права или другие права интеллектуальной собственности.

Если не указано иное, примеры компаний, организаций, продукты, доменные имена, адреса электронной почты, логотипы, люди, места и события упоминающиеся названия являются вымышленными и сходство с реальными предприятиями, организации, продукта, доменное имя, адрес электронной почты адрес эмблемы, лица и события являются случайными и непреднамеренными.

© Корпорация Майкрософт (Microsoft Corporation), 2012. Все права защищены.

Microsoft и Windows являются охраняемыми товарными знаками корпорации Майкрософт в США и других странах.

Названия фактических компаний и продуктов, упомянутые здесь, могут являться охраняемыми товарными знаками соответствующих владельцев.
