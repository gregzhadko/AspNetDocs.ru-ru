---
uid: whitepapers/aspnet4/overview
title: Общие сведения о веб-разработке ASP.NET 4 и Visual Studio 2010 | Документация Майкрософт
author: rick-anderson
description: В этом документе представлен обзор многих новых функций для ASP.NET, которые включены в the.NET Framework 4 и Visual Studio 2010.
ms.author: riande
ms.date: 02/10/2010
ms.assetid: d7729af4-1eda-4ff2-8b61-dbbe4fc11d10
msc.legacyurl: /whitepapers/aspnet4
msc.type: content
ms.openlocfilehash: ecde48f6bd88ee5f569bfeb8b70c26a50bc869c2
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78511434"
---
# <a name="aspnet-4-and-visual-studio-2010-web-development-overview"></a>Общие сведения о веб-разработке в ASP.NET 4 и Visual Studio 2010

> В этом документе представлен обзор многих новых функций для ASP.NET, которые включены в the.NET Framework 4 и Visual Studio 2010.
> 
> [Загрузить этот технический документ](https://download.microsoft.com/download/7/1/A/71A105A9-89D6-4201-9CC5-AD6A3B7E2F22/ASP_NET_4_and_Visual_Studio_2010_Web_Development_Overview.pdf)

**Contents**

**[Основные службы](#0.2__Toc253429238 "_Toc253429238")**  
[Рефакторинг файла Web. config](#0.2__Toc253429239 "_Toc253429239")  
[Расширяемое кэширование вывода](#0.2__Toc253429240 "_Toc253429240")  
[Автоматический запуск веб-приложений](#0.2__Toc253429241 "_Toc253429241")  
[Окончательное перенаправление страницы](#0.2__Toc253429242 "_Toc253429242")  
[Сжатие состояния сеанса](#0.2__Toc253429243 "_Toc253429243")  
[Расширение диапазона допустимых URL-адресов](#0.2__Toc253429244 "_Toc253429244")  
[Расширяемая проверка запросов](#0.2__Toc253429245 "_Toc253429245")  
[Кэширование объектов и расширяемость кэширования объектов](#0.2__Toc253429246 "_Toc253429246")  
[Расширяемость кодирования HTML, URL-адреса и заголовка HTTP](#0.2__Toc253429247 "_Toc253429247")  
[Мониторинг производительности отдельных приложений в одном рабочем процессе](#0.2__Toc253429248 "_Toc253429248")  
[Настройка для различных версий](#0.2__Toc253429249 "_Toc253429249")

**[Приложениях](#0.2__Toc253429250 "_Toc253429250")**  
[jQuery, поставляемый с веб-формами и MVC](#0.2__Toc253429251 "_Toc253429251")  
[Поддержка сети доставки содержимого](#0.2__Toc253429252 "_Toc253429252")  
[Явные скрипты ScriptManager](#0.2__Toc253429253 "_Toc253429253")

**[Веб-формы](#0.2__Toc253429256 "_Toc253429256")**  
[Установка тегов META с помощью свойств Page. кратко и Page. Метадескриптион](#0.2__Toc253429257 "_Toc253429257")  
[Включение состояния представления для отдельных элементов управления](#0.2__Toc253429258 "_Toc253429258")  
[Изменения возможностей браузера](#0.2__Toc253429259 "_Toc253429259")  
[Маршрутизация в ASP.NET 4](#0.2__Toc253429260 "_Toc253429260")  
[Настройка идентификаторов клиентов](#0.2__Toc253429261 "_Toc253429261")  
[Сохранение выбора строк в элементах управления данными](#0.2__Toc253429262 "_Toc253429262")  
[Элемент управления диаграммы ASP.NET](#0.2__Toc253429263 "_Toc253429263")  
[Фильтрация данных с помощью элемента управления элемента](#0.2__Toc253429264 "_Toc253429264")  
[Выражения кода в кодировке HTML](#0.2__Toc253429265 "_Toc253429265")  
[Изменения в шаблоне проекта](#0.2__Toc253429266 "_Toc253429266")  
[Усовершенствования CSS](#0.2__Toc253429267 "_Toc253429267")  
[Скрытие элементов div вокруг скрытых полей](#0.2__Toc253429268 "_Toc253429268")  
[Отрисовка внешней таблицы для шаблонных элементов управления](#0.2__Toc253429269 "_Toc253429269")  
[Улучшения элемента управления ListView](#0.2__Toc253429270 "_Toc253429270")  
[Улучшения элементов управления CheckBoxList и RadioButtonList](#0.2__Toc253429271 "_Toc253429271")  
[Улучшения элемента управления Menu](#0.2__Toc253429272 "_Toc253429272")  
[Элементы управления Wizard и CreateUserWizard 56](#0.2__Toc253429273 "_Toc253429273")

**[ASP.NET MVC](#0.2__Toc253429274 "_Toc253429274")**  
[Поддержка областей](#0.2__Toc253429275 "_Toc253429275")  
[Поддержка проверки атрибутов в заметках данных](#0.2__Toc253429276 "_Toc253429276")  
[Шаблоны вспомогательных функций](#0.2__Toc253429277 "_Toc253429277")

**[платформа динамических данных](#0.2__Toc253429278 "_Toc253429278")**  
[Включение платформа динамических данных для существующих проектов](#0.2__Toc253429279 "_Toc253429279")  
[Декларативный синтаксис элемента управления DynamicDataManager](#0.2__Toc253429280 "_Toc253429280")  
[Шаблоны сущностей](#0.2__Toc253429281 "_Toc253429281")  
[Новые шаблоны полей для URL-адресов и адресов электронной почты](#0.2__Toc253429282 "_Toc253429282")  
[Создание ссылок с помощью элемента управления DynamicHyperLink](#0.2__Toc253429283 "_Toc253429283")  
[Поддержка наследования в модели данных](#0.2__Toc253429284 "_Toc253429284")  
[Поддержка связей "многие ко многим" (только Entity Framework)](#0.2__Toc253429285 "_Toc253429285")  
[Новые атрибуты для управления отображением и поддержкой перечислений](#0.2__Toc253429286 "_Toc253429286")  
[Улучшенная поддержка фильтров](#0.2__Toc253429287 "_Toc253429287")

**[Усовершенствования веб-разработки в Visual Studio 2010](#0.2__Toc253429288 "_Toc253429288")**  
[Улучшенная совместимость с CSS](#0.2__Toc253429289 "_Toc253429289")  
[Фрагменты кода HTML и JavaScript](#0.2__Toc253429290 "_Toc253429290")  
[Усовершенствования IntelliSense в JavaScript](#0.2__Toc253429291 "_Toc253429291")

**[Развертывание веб-приложений с помощью Visual Studio 2010](#0.2__Toc253429292 "_Toc253429292")**  
[Веб-упаковка](#0.2__Toc253429293 "_Toc253429293")  
[Преобразование web. config](#0.2__Toc253429294 "_Toc253429294")  
[Развертывание базы данных](#0.2__Toc253429295 "_Toc253429295")  
[Публикация одним щелчком для веб-приложений](#0.2__Toc253429296 "_Toc253429296")  
[Ресурсы](#0.2__Toc253429297 "_Toc253429297")

**[Заявление об отказе](#0.2__Toc253429298 "_Toc253429298")**

<a id="0.2__Toc224729018"></a><a id="0.2__Toc253429238"></a><a id="0.2__Toc243304612"></a>

## <a name="core-services"></a>Основные службы

В ASP.NET 4 введен ряд функций, которые улучшают основные ASP.NET службы, такие как кэширование вывода и хранилище состояний сеанса.

<a id="0.2__Toc243304613"></a><a id="0.2__Toc253429239"></a><a id="0.2__Toc224729019"></a>

### <a name="webconfig-file-refactoring"></a>Рефакторинг файла Web. config

Файл `Web.config`, содержащий конфигурацию веб-приложения, значительно увеличился за последние несколько выпусков .NET Framework по мере добавления новых функций, таких как AJAX, маршрутизация и интеграция с IIS 7. Это усложняет настройку или запуск новых веб-приложений без таких средств, как Visual Studio. В .NET Framework 4 основные элементы конфигурации были перемещены в файл `machine.config`, и теперь приложения наследуют эти параметры. Это позволяет использовать файл `Web.config` в приложениях ASP.NET 4 либо быть пустым, либо должен содержать только следующие строки, которые указывают версию платформы, для которой предназначено приложение, в Visual Studio:

[!code-xml[Main](overview/samples/sample1.xml)]

<a id="0.2__Toc253429240"></a><a id="0.2__Toc243304614"></a>

### <a name="extensible-output-caching"></a>Расширяемое кэширование вывода

С момента выпуска ASP.NET 1,0, кэширование выходных данных позволило разработчикам сохранять сформированные выходные данные страниц, элементов управления и HTTP-ответов в памяти. В последующих веб-запросах ASP.NET может быстрее обслуживать содержимое, получая созданные выходные данные из памяти вместо повторного создания выходных данных с нуля. Однако этот подход имеет ограничение — сгенерированное содержимое всегда должно храниться в памяти, а на серверах, на которых наблюдается интенсивный объем трафика, память, потребляемая кэшем вывода, может конкурировать с требованиями к памяти из других частей веб-приложения.

ASP.NET 4 добавляет точку расширения в кэширование вывода, позволяющую настроить один или несколько пользовательских поставщиков кэша вывода. Поставщики кэша вывода могут использовать любой механизм хранения для сохранения содержимого HTML. Это позволяет создавать пользовательские поставщики кэша вывода для различных механизмов сохранения, которые могут включать локальные или удаленные диски, облачное хранилище и механизмы распределенного кэша.

Пользовательский поставщик кэша вывода создается как класс, производный от нового типа *System. Web. Caching. OutputCacheProvider* . Затем можно настроить поставщик в файле `Web.config` с помощью подраздела "новые *поставщики* " элемента *OutputCache* , как показано в следующем примере:

[!code-xml[Main](overview/samples/sample2.xml)]

По умолчанию в ASP.NET 4 все HTTP-ответы, отображаемые страницы и элементы управления используют кэш вывода в памяти, как показано в предыдущем примере, где атрибут *defaultProvider* имеет значение аспнетинтерналпровидер. Вы можете изменить используемый по умолчанию поставщик кэша вывода для веб-приложения, указав другое имя поставщика для *defaultProvider*.

Кроме того, можно выбрать разные поставщики кэша вывода для каждого элемента управления и для каждого запроса. Самый простой способ выбрать другого поставщика кэша вывода для различных пользовательских веб-элементов управления — это сделать декларативно с помощью нового атрибута *providerName* в директиве Control, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample3.aspx)]

Указание другого поставщика кэша вывода для HTTP-запроса требует немного больше усилий. Вместо декларативного указания поставщика необходимо переопределить новый метод *жетаупуткачепровидернаме* в файле `Global.asax`, чтобы программно указать, какой поставщик использовать для конкретного запроса. В приведенном ниже примере показано, как это сделать.

[!code-csharp[Main](overview/samples/sample4.cs)]

С добавлением расширения поставщика кэша вывода в ASP.NET 4 теперь можно попытаться более агрессивно и более интеллектуальные стратегии кэширования вывода для веб-сайтов. Например, теперь можно кэшировать «10 основных» страниц сайта в памяти, при этом кэшируются страницы, получающие меньший объем трафика на диске. Кроме того, можно кэшировать каждое изменение в зависимости от отображаемой страницы, но использовать распределенный кэш таким образом, чтобы потребление памяти было разгружаться из интерфейсных веб-серверов.

<a id="0.2__Toc224729020"></a><a id="0.2__Toc253429241"></a><a id="0.2__Toc243304615"></a>

### <a name="auto-start-web-applications"></a>Автоматический запуск веб-приложений

Некоторым веб-приложениям необходимо загружать большие объемы данных или выполнять дорогостоящую обработку инициализации перед обслуживанием первого запроса. В более ранних версиях ASP.NET для таких ситуаций пришлось бы разработать пользовательские подходы для «пробуждения» приложения ASP.NET, а затем запустить код инициализации во время работы *приложения\_загрузки* в файле `Global.asax`.

Новая функция масштабируемости *, которая* напрямую обращается к этому сценарию, доступна, если ASP.NET 4 работает в IIS 7,5 на Windows Server 2008 R2. Функция автоматического запуска предоставляет управляемый подход к запуску пула приложений, инициализации приложения ASP.NET и последующему принятию HTTP-запросов.

> [!NOTE] 
> 
> Модуль прогрева приложения IIS для IIS 7,5
> 
> Группа IIS выпустила первую бета-версию модуля прогрева приложения для IIS 7,5. Это делает все приложения еще проще, чем было описано ранее. Вместо написания пользовательского кода необходимо указать URL-адреса ресурсов для выполнения, прежде чем веб-приложение будет принимать запросы от сети. Это прогрев происходит во время запуска службы IIS (если пул приложений IIS был настроен как *алвайсруннинг*) и при повторном запуске рабочего процесса IIS. Во время перезапуска старый рабочий процесс IIS по-прежнему будет выполнять запросы до тех пор, пока вновь порожденный рабочий процесс не будет полностью включен, чтобы приложения не выполняли перерывы или другие проблемы, связанные с непростыми кэшами. Обратите внимание, что этот модуль работает с любой версией ASP.NET, начиная с версии 2,0.
> 
> Дополнительные сведения см. в разделе [Application прогрев](https://www.iis.net/extensions/applicationwarmup%20on%20the%20IIS.net) на веб-сайте IIS.NET. Пошаговое руководство, в котором показано, как использовать функцию прогрева, см. в разделе [Начало работы с помощью модуля прогрева приложений IIS 7,5](https://www.iis.net/learn/manage) на веб-сайте IIS.NET.

Чтобы использовать функцию автоматического запуска, администратор IIS задает автоматический запуск пула приложений в IIS 7,5, используя следующую конфигурацию в файле `applicationHost.config`:

[!code-xml[Main](overview/samples/sample5.xml)]

Поскольку один пул приложений может содержать несколько приложений, вы указываете, что отдельные приложения будут автоматически запускаться с помощью следующей конфигурации в файле `applicationHost.config`:

[!code-xml[Main](overview/samples/sample6.xml)]

При холодном запуске сервера IIS 7,5 или при перезапуске отдельного пула приложений IIS 7,5 использует сведения из файла `applicationHost.config`, чтобы определить, какие веб-приложения должны быть запущены автоматически. Для каждого приложения, помеченного для автоматического запуска, IIS 7.5 отправляет запрос в ASP.NET 4 для запуска приложения в состоянии, в течение которого приложение временно не принимает HTTP-запросы. Когда он находится в этом состоянии, ASP.NET создает экземпляр типа, определенного атрибутом *сервицеаутостартпровидер* (как показано в предыдущем примере), и вызывает его открытую точку входа.

Вы создаете управляемый тип автоматического запуска с необходимой точкой входа, реализуя интерфейс *ипроцесшостпрелоадклиент* , как показано в следующем примере:

[!code-csharp[Main](overview/samples/sample7.cs)]

После выполнения кода инициализации в методе *предварительной загрузки* и возврата методом приложение ASP.NET готово к обработке запросов.

Благодаря добавлению автоматического запуска в IIS 0,5 и ASP.NET 4 теперь у вас есть четко определенный подход к выполнению ресурсоемких инициализаций приложений перед обработкой первого HTTP-запроса. Например, можно использовать новую функцию автоматического запуска для инициализации приложения, а затем сообщить подсистеме балансировки нагрузки о том, что приложение инициализировано и готово к приему трафика HTTP.

<a id="0.2__Toc224729021"></a><a id="0.2__Toc253429242"></a><a id="0.2__Toc243304616"></a>

### <a name="permanently-redirecting-a-page"></a>Окончательное перенаправление страницы

Обычно веб-приложения позволяют перемещать страницы и другое содержимое по времени, что может привести к накоплению устаревших ссылок в поисковых системах. В ASP.NET разработчики традиционно обрабатывали запросы к старым URL-адресам, используя метод *Response. Redirect* для пересылки запроса на новый URL-адрес. Однако метод *перенаправления* выдает ответ HTTP 302, найденный (временный перенаправление), что приводит к появлению дополнительного кругового пути HTTP, когда пользователи пытаются получить доступ к старым URL-адресам.

ASP.NET 4 добавляет новый вспомогательный метод *редиректперманент* , который позволяет легко выдавать ошибки HTTP 301, которые перемещают безвозвратные ответы, как показано в следующем примере:

[!code-csharp[Main](overview/samples/sample8.cs)]

Поисковые системы и другие агенты пользователей, которые распознают постоянные перенаправления, сохраняют новый URL-адрес, связанный с содержимым, что позволяет избежать ненужного кругового пути, сделанного браузером для временных перенаправлений.

<a id="0.2__Toc224729022"></a><a id="0.2__Toc253429243"></a><a id="0.2__Toc243304617"></a>

### <a name="shrinking-session-state"></a>Сжатие состояния сеанса

ASP.NET предоставляет два варианта по умолчанию для хранения состояния сеанса в веб-ферме: поставщик состояния сеанса, который вызывает сервер внешнего состояния сеанса и поставщик состояний сеанса, который хранит данные в Microsoft SQL Server базе данных. Так как оба варианта предполагают хранение сведений о состоянии вне рабочего процесса веб-приложения, необходимо сериализовать состояние сеанса перед его отправкой в удаленное хранилище. В зависимости от объема информации, которую разработчик сохраняет в состоянии сеанса, размер сериализованных данных может быть довольно большим.

В ASP.NET 4 появился новый вариант сжатия для обоих типов необработанных поставщиков состояний сеансов. Если параметр конфигурации *компрессионенаблед* , показанный в следующем примере, имеет значение *true*, ASP.NET будет сжимать (и распаковывать) сериализованное состояние сеанса с помощью класса .NET Framework *System. IO. Compression. GZipStream* .

[!code-xml[Main](overview/samples/sample9.xml)]

С помощью простого добавления нового атрибута в файл `Web.config` приложения с запасными циклами ЦП на веб-серверах могут значительно сократить размер сериализованных данных состояния сеанса.

<a id="0.2__Toc253429244"></a><a id="0.2__Toc243304618"></a>

### <a name="expanding-the-range-of-allowable-urls"></a>Расширение диапазона допустимых URL-адресов

В ASP.NET 4 появились новые возможности для увеличения размера URL-адресов приложений. Предыдущие версии ASP.NET с ограниченными длинами URL-пути — 260 символов, основанных на ограничении пути к файлам NTFS. В ASP.NET 4 вы можете увеличить (или уменьшить) это ограничение, подходящее для ваших приложений, используя два новых атрибута конфигурации *httpRuntime* . В следующем примере показаны эти новые атрибуты.

[!code-xml[Main](overview/samples/sample10.xml)]

Чтобы разрешить более длинные или короткие пути (часть URL-адреса, не включающую протокол, имя сервера и строку запроса), измените атрибут *[максурлленгс](https://msdn.microsoft.com/library/system.web.configuration.httpruntimesection.maxurllength.aspx)* . Чтобы разрешить более длинные или более короткие строки запроса, измените значение атрибута *[макскуеристрингленгс](https://msdn.microsoft.com/library/system.web.configuration.httpruntimesection.maxquerystringlength.aspx)* .

ASP.NET 4 также позволяет настроить символы, используемые при проверке символов URL-адреса. Когда ASP.NET находит недопустимый символ в части пути URL-адреса, он отклоняет запрос и выдает ошибку HTTP 400. В предыдущих версиях ASP.NET проверки символов URL-адреса были ограничены фиксированным набором символов. В ASP.NET 4 можно настроить набор допустимых символов с помощью нового атрибута *рекуестпасинвалидчарактерс* элемента конфигурации *httpRuntime* , как показано в следующем примере:

[!code-xml[Main](overview/samples/sample11.xml)]

По умолчанию атрибут *рекуестпасинвалидчарактерс* определяет восемь символов как недопустимые. (В строке, назначенной *рекуестпасинвалидчарактерс* по умолчанию, символы "меньше чем" (&lt;), "больше" (&gt;) и амперсанд (&amp;) кодируются, так как `Web.config`ный файл является XML-файлом.) При необходимости можно настроить набор недопустимых символов.

> [!NOTE]
> Примечание. ASP.NET 4 всегда отклоняет пути URL-адресов, которые содержат символы в диапазоне от 0x00 до 0x1F, так как они являются недопустимыми символами URL-адреса, как определено в RFC 2396 IETF ([http://www.ietf.org/rfc/rfc2396.txt](http://www.ietf.org/rfc/rfc2396.txt)). В версиях Windows Server, работающих под управлением IIS 6 или более поздней версии, драйвер устройства протокола HTTP. sys автоматически отклоняет URL-адреса с этими символами.

<a id="0.2__Toc253429245"></a><a id="0.2__Toc243304619"></a>

### <a name="extensible-request-validation"></a>Расширяемая проверка запросов

Проверка запроса ASP.NET ищет входящие данные HTTP-запроса для строк, которые обычно используются в атаках межсайтовых сценариев (XSS). Если обнаружены потенциальные строки XSS, то при проверке запроса помечается подозрительная строка и возвращается ошибка. Встроенная проверка запросов возвращает ошибку только при обнаружении наиболее распространенных строк, используемых в атаках XSS. Предыдущие попытки сделать проверку XSS более агрессивными привели к тому, что слишком много ложных срабатываний. Однако клиентам может потребоваться проверка запросов, которая более агрессивна, или наоборот, может потребоваться намеренно ослабить проверки XSS для конкретных страниц или для запросов конкретного типа.

В ASP.NET 4 функция проверки запросов стала расширяемой, чтобы можно было использовать настраиваемую логику проверки запросов. Чтобы расширить проверку запросов, создайте класс, производный от нового типа *System. Web. util. рекуествалидатор* , и настройте приложение (в разделе *httpRuntime* файла `Web.config`), чтобы использовать пользовательский тип. В следующем примере показано, как настроить пользовательский класс проверки запроса.

[!code-xml[Main](overview/samples/sample12.xml)]

Для нового атрибута *рекуествалидатионтипе* требуется стандартная строка идентификатора типа .NET Framework, указывающая класс, который предоставляет настраиваемую проверку запросов. Для каждого запроса ASP.NET вызывает пользовательский тип для обработки каждой части входящих данных HTTP-запроса. Входящий URL-адрес, все заголовки HTTP (файлы cookie и пользовательские заголовки) и текст сущности доступны для проверки с помощью класса проверки пользовательского запроса, как показано в следующем примере:

[!code-csharp[Main](overview/samples/sample13.cs)]

Для случаев, когда не нужно проверять часть входящих HTTP-данных, класс запроса-проверки может вернуться к выполнению проверки запроса ASP.NET по умолчанию, просто вызвав *base. Исвалидрекуестстринг.*

<a id="0.2__Toc253429246"></a><a id="0.2__Toc243304620"></a>

### <a name="object-caching-and-object-caching-extensibility"></a>Кэширование объектов и расширяемость кэширования объектов

С момента первого выпуска ASP.NET включал в себя мощный кэш объектов в памяти (*System. Web. Caching. Cache*). Реализация кэша настолько популярна, что она использовалась в приложениях, не являющихся веб-приложениями. Однако Windows Forms или WPF-приложение неудобно включать ссылку на `System.Web.dll` только для того, чтобы иметь возможность использовать кэш объектов ASP.NET.

Чтобы сделать кэширование доступным для всех приложений, .NET Framework 4 вводит новую сборку, новое пространство имен, некоторые базовые типы и конкретную реализацию кэширования. Новая сборка `System.Runtime.Caching.dll` содержит новый API кэширования в пространстве имен *System. Runtime. Caching* . Пространство имен содержит два основных набора классов:

- Абстрактные типы, предоставляющие основу для создания любых типов пользовательских реализаций кэша.
- Конкретная реализация кэша объектов в памяти (класс *System. Runtime. Caching. MemoryCache* ).

Новый класс *MemoryCache* тесно моделируется в кэше ASP.NET и использует большую часть внутренней логики обработчика кэша с ASP.NET. Хотя интерфейсы API общедоступного кэширования в *System. Runtime. Caching* были обновлены для поддержки разработки пользовательских кэшей, если вы использовали объект *кэша* ASP.NET, вы увидите привычные концепции в новых API.

Подробное обсуждение нового класса *MemoryCache* и поддержки базовых API-интерфейсов потребовало бы всего документа. Однако в следующем примере показано, как работает новый API кэша. Пример был написан для Windows Forms приложения без какой-либо зависимости от `System.Web.dll`.

[!code-csharp[Main](overview/samples/sample14.cs)]

<a id="0.2__Toc253429247"></a><a id="0.2__Toc243304621"></a>

### <a name="extensible-html-url-and-http-header-encoding"></a>Расширяемость кодирования HTML, URL-адреса и заголовка HTTP

В ASP.NET 4 можно создавать пользовательские подпрограммы кодирования для следующих стандартных задач кодирования текста:

- Кодировка HTML.
- Кодирование URL-адреса.
- Кодировка атрибута HTML.
- Кодирование исходящих заголовков HTTP.

Вы можете создать пользовательский кодировщик, производный от нового типа *System. Web. util. хттпенкодер* , а затем настроив ASP.NET для использования пользовательского типа в разделе *httpRuntime* файла `Web.config`, как показано в следующем примере:

[!code-xml[Main](overview/samples/sample15.xml)]

После настройки пользовательского кодировщика ASP.NET автоматически вызывает пользовательскую реализацию кодирования, когда вызываются открытые методы кодирования классов *System. Web. HttpUtility* или *System. Web. HttpServerUtility* . Это позволяет одной части группы разработки веб-разработчиков создать пользовательский кодировщик, реализующий агрессивную кодировку символов, а остальная часть группы разработки веб-приложений продолжит использовать общедоступные интерфейсы API кодирования ASP.NET. Централизованная настройка пользовательского кодировщика в элементе *httpRuntime* гарантирует, что все вызовы кодирования текста из общедоступных api кодирования ASP.NET направляются через пользовательский кодировщик.

<a id="0.2__Toc253429248"></a><a id="0.2__Toc243304622"></a>

### <a name="performance-monitoring-for-individual-applications-in-a-single-worker-process"></a>Мониторинг производительности отдельных приложений в одном рабочем процессе

Чтобы увеличить количество веб-сайтов, которые могут размещаться на одном сервере, многие из поставщиков услуг размещения запускают несколько приложений ASP.NET в одном рабочем процессе. Однако если несколько приложений используют один общий рабочий процесс, администраторам сервера сложно обнаружить отдельное приложение, в котором возникают проблемы.

ASP.NET 4 использует новые функции мониторинга ресурсов, представленные средой CLR. Чтобы включить эту функцию, в файл конфигурации `aspnet.config` можно добавить следующий фрагмент XML-кода конфигурации.

[!code-xml[Main](overview/samples/sample16.xml)]

> [!NOTE]
> Обратите внимание, что файл `aspnet.config` находится в каталоге, где установлен .NET Framework. Это не `Web.config` файл.

После включения функции *аппдомаинресаурцемониторинг* в категории производительности "приложения ASP.NET" доступны два новых счетчика производительности: *% управляемое процессорное время* и *используемая управляемая память*. Оба этих счетчика производительности используют новую функцию управления ресурсами доменного приложения CLR для мониторинга предполагаемого времени ЦП и использования управляемой памяти отдельными ASP.NET приложениями. В результате, благодаря ASP.NET 4 администраторы получают более детализированное представление о потреблении ресурсов отдельными приложениями, работающими в одном рабочем процессе.

<a id="0.2__Toc253429249"></a><a id="0.2__Toc243304623"></a>

### <a name="multi-targeting"></a>Нацеливание на несколько версий

Можно создать приложение, предназначенное для конкретной версии .NET Framework. В ASP.NET 4 новый атрибут в элементе *compilation* файла `Web.config` позволяет ориентироваться на .NET Framework 4 и более поздних версий. Если явным образом указать .NET Framework 4 и включить в файл `Web.config` дополнительные элементы, такие как записи для *System. CodeDom*, эти элементы должны быть правильными для .NET Framework 4. (Если вы явно не нацеливание на .NET Framework 4, Целевая платформа выводится из-за отсутствия записи в файле `Web.config`.)

В следующем примере показано использование атрибута *targetFramework* в элементе *compilation* файла `Web.config`.

[!code-xml[Main](overview/samples/sample17.xml)]

Обратите внимание на следующие особенности для конкретной версии .NET Framework:

- В пуле приложений .NET Framework 4 система сборки ASP.NET предполагает, что .NET Framework 4 в качестве целевого объекта, если файл `Web.config` не содержит атрибут *targetFramework* или если отсутствует файл `Web.config`. (Может потребоваться внести изменения в код приложения, чтобы сделать его запущенным в .NET Framework 4).
- Если включить атрибут *targetFramework* и элемент *System. codeDom* определен в файле `Web.config`, этот файл должен содержать правильные записи для .NET Framework 4.
- Если для предварительной компиляции приложения используется команда *компилятора aspnet\_* (например, в среде сборки), необходимо использовать правильную версию команды *компилятора ASPNET\_* для целевой платформы. Используйте компилятор, поставляемый с .NET Framework 2,0 (%WINDIR%\Microsoft.NET\Framework\v2.0.50727) для компиляции для .NET Framework 3,5 и более ранних версий. Используйте компилятор, входящий в состав .NET Framework 4, для компиляции приложений, созданных с помощью этой платформы, или с помощью более поздних версий.
- Во время выполнения компилятор использует последние сборки платформы, установленные на компьютере (и, следовательно, в GAC). Если обновление для платформы будет выполнено позже (например, установлена гипотетическая версия 4,1), вы сможете использовать функции в более новой версии платформы, несмотря на то, что атрибут *targetFramework* предназначен для более ранней версии (например, 4,0). (Однако во время разработки в Visual Studio 2010 или при использовании команды *компилятора aspnet\_* использование новых функций платформы приведет к ошибкам компилятора).

<a id="0.2__Toc224729023"></a><a id="0.2__Toc253429250"></a><a id="0.2__Toc243304624"></a>

## <a name="ajax"></a>Ajax

<a id="0.2__Toc253429251"></a><a id="0.2__Toc243304625"></a>

### <a name="jquery-included-with-web-forms-and-mvc"></a>jQuery, поставляемый с веб-формами и MVC

Шаблоны Visual Studio для веб-форм и MVC включают библиотеку jQuery с открытым кодом. При создании нового веб-сайта или проекта создается папка Scripts, содержащая три следующих файла:

- Жкуери-1.4.1. js — это версия библиотеки jQuery, доступная для восприятия и унминифиед.
- Жкуери-14,1. min. js — версия минифицированные библиотеки jQuery.
- Жкуери-1.4.1-всдок. js — файл документации IntelliSense для библиотеки jQuery.

Включите версию унминифиед jQuery во время разработки приложения. Включите минифицированные версию jQuery для рабочих приложений.

Например, на следующей странице веб-форм показано, как можно использовать jQuery, чтобы изменить цвет фона для элементов управления TextBox ASP.NET на желтый, если они находятся в фокусе.

[!code-aspx[Main](overview/samples/sample18.aspx)]

<a id="0.2__Toc253429252"></a><a id="0.2__Toc243304626"></a>

### <a name="content-delivery-network-support"></a>Поддержка сети доставки содержимого

Сеть доставки содержимого (CDN) Microsoft AJAX позволяет легко добавлять сценарии ASP.NET AJAX и jQuery в веб-приложения. Например, можно приступить к использованию библиотеки jQuery, просто добавив тег `<script>` на страницу, который указывает на Ajax.microsoft.com следующим образом:

[!code-html[Main](overview/samples/sample19.html)]

Используя преимущества сети Microsoft Ajax CDN, можно значительно повысить производительность приложений Ajax. Содержимое CDN Microsoft AJAX кэшируется на серверах, расположенных по всему миру. Кроме того, эта сеть позволяет браузерам повторно использовать файлы JavaScript для веб-сайтов, размещенных в разных доменах.

Сеть доставки содержимого Microsoft Ajax поддерживает протокол SSL (HTTPS), если необходимо обслуживать веб-страницу с помощью SSL.

Реализуйте откат, если сеть CDN недоступна. Проверьте резервный вариант.

Дополнительные сведения о сети CDN Microsoft AJAX см. на следующем веб-сайте:

[https://www.asp.net/ajaxlibrary/CDN.ashx](../../ajax/cdn/overview.md)

ScriptManager ASP.NET поддерживает сеть CDN Microsoft AJAX. Просто установив одно свойство, свойство Енаблекдн, можно получить все файлы JavaScript ASP.NET Framework из CDN:

[!code-aspx[Main](overview/samples/sample20.aspx)]

После установки для свойства Енаблекдн значения true платформа ASP.NET будет получать все файлы JavaScript платформы ASP.NET из CDN, включая все файлы JavaScript, используемые для проверки и UpdatePanel. Установка этого свойства может существенно повлиять на производительность веб-приложения.

Путь CDN для собственных файлов JavaScript можно задать с помощью атрибута веб – ресурса. Новое свойство Кднпас указывает путь к сети CDN, используемой, если для свойства Енаблекдн задано значение true:

[!code-csharp[Main](overview/samples/sample21.cs)]

<a id="0.2__Toc253429253"></a><a id="0.2__Toc243304627"></a>

### <a name="scriptmanager-explicit-scripts"></a>Явные скрипты ScriptManager

В прошлом, если вы использовали ASP.NET Скриптманжер, необходимо было загрузить всю монолитную библиотеку ASP.NET AJAX. Используя преимущества нового свойства ScriptManager. Ажаксфрамеворкмоде, можно точно контролировать, какие компоненты библиотеки ASP.NET AJAX загружаются, и загружать только необходимые компоненты библиотеки ASP.NET AJAX.

Свойству ScriptManager. Ажаксфрамеворкмоде можно присвоить следующие значения:

- Enabled (включено) — указывает, что элемент управления ScriptManager автоматически включает файл скрипта MicrosoftAjax. js, который представляет собой объединенный файл скрипта для каждого сценария основной платформы (поведение прежних версий).
- Disabled — указывает, что все функции скриптов Microsoft AJAX отключены и элемент управления ScriptManager не ссылается на какие-либо скрипты автоматически.
- Явное — указывает, что вы явно включаете ссылки на скрипты в отдельный файл скрипта основной среды, который требуется вашей странице, и включает ссылки на зависимости, необходимые для каждого файла скрипта.

Например, если свойству Ажаксфрамеворкмоде присвоить значение EXPLICIT, можно указать необходимые скрипты ASP.NET компонентов AJAX:

[!code-aspx[Main](overview/samples/sample22.aspx)]

<a id="0.2__The_DataView_Control"></a><a id="0.2__The_DataContext_and"></a><a id="0.2__Refactoring_the_Microsoft"></a><a id="0.2__Toc224729032"></a><a id="0.2__Toc253429256"></a><a id="0.2__Toc243304630"></a>

## <a name="web-forms"></a>Веб-формы

Веб-формы — это основная функция в ASP.NET с момента выпуска ASP.NET 1,0. В этой области для ASP.NET 4 были внесены многие улучшения, включая следующие:

- Возможность задавать теги *meta* .
- Более полный контроль состояния представления.
- Более простые способы работы с возможностями браузера.
- Поддержка использования ASP.NET маршрутизации с помощью веб-форм.
- Более полный контроль над создаваемыми идентификаторами.
- Возможность сохранения выбранных строк в элементах управления данными.
- Больший контроль над визуализированным HTML в элементах управления *FormView* и *ListView* .
- Поддержка фильтрации элементов управления источниками данных.

<a id="0.2__Toc224729033"></a><a id="0.2__Toc253429257"></a><a id="0.2__Toc243304631"></a>

### <a name="setting-meta-tags-with-the-pagemetakeywords-and-pagemetadescription-properties"></a>Установка тегов META с помощью свойств Page. кратко и Page. Метадескриптион

ASP.NET 4 добавляет два свойства в класс *страницы* , *кратко* и *метадескриптион*. Эти два свойства представляют соответствующие *meta* -Теги на странице, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample23.aspx)]

Эти два свойства работают так же, как и свойство *Title* страницы. Они следуют следующим правилам:

1. Если в элементе *head* нет *meta* -тегов, соответствующих именам свойств (то есть Name = "keywords" для *Page. кратко* и Name = "Description" для *Page. метадескриптион*, что означает, что эти свойства не были заданы), теги *meta* будут добавлены на страницу при подготовке к просмотру.
2. Если с этими именами уже есть теги *meta* , эти свойства выступают как методы get и Set для содержимого существующих тегов.

Эти свойства можно задать во время выполнения, что позволяет получать содержимое из базы данных или другого источника, что позволяет динамически задавать теги, чтобы описать конкретную страницу.

Можно также задать *Ключевые слова* и свойства *описания* в директиве *@ Page* в верхней части разметки страницы Web Forms, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample24.aspx)]

Это переопределит содержимое тега *meta* (если таковое имеется), уже объявленное на странице.

Содержимое тега *meta* Description используется для улучшения предварительных версий списка поиска в Google. (Дополнительные сведения см. в разделе [улучшение фрагментов с помощью Meta Description преобразование](https://googlewebmastercentral.blogspot.com/2007/09/improve-snippets-with-meta-description.html) в центре блогов Google.) Google и Windows Live Search не используют содержимое ключевых слов для чего-либо, но другие поисковые системы могут. Дополнительные сведения см. в разделе [рекомендации по ключевым словам meta](http://www.searchengineguide.com/richard-ball/meta-keywords-a.php) на веб-сайте руководств поисковых систем.

Эти новые свойства являются простой функцией, но они сохраняют вас от необходимости добавлять их вручную или писать собственный код для создания тегов *meta* .

<a id="0.2__Toc224729034"></a><a id="0.2__Toc253429258"></a><a id="0.2__Toc243304632"></a>

### <a name="enabling-view-state-for-individual-controls"></a>Включение состояния представления для отдельных элементов управления

По умолчанию состояние представления включено для страницы, в результате чего каждый элемент управления на странице потенциально сохраняет состояние представления, даже если оно не требуется для приложения. Данные состояния представления включаются в разметку, формируемую страницей, и увеличивают время, затрачиваемое на отправку страницы клиенту и обратное их размещение. Хранение большего состояния представления, чем необходимо, может привести к значительному снижению производительности. В более ранних версиях ASP.NET разработчики могли отключить состояние просмотра для отдельных элементов управления, чтобы уменьшить размер страницы, но это было необходимо сделать явным образом для отдельных элементов управления. В ASP.NET 4 элементы управления веб-сервера включают свойство *виевстатемоде* , которое позволяет отключать состояние просмотра по умолчанию, а затем включать его только для тех элементов управления, которые нуждаются в этой странице.

Свойство *виевстатемоде* принимает перечисление, которое имеет три значения: *Enabled*, *disabled*и *inherit*. *Enabled* включает состояние представления для этого элемента управления и для всех дочерних элементов управления, для которых задано *наследование* или не задано ничего. *Disabled* отключает состояние представления, а *inherit* указывает, что элемент управления использует параметр *виевстатемоде* из родительского элемента управления.

В следующем примере показано, как работает свойство *виевстатемоде* . Разметка и код для элементов управления на следующей странице содержит значения для свойства *виевстатемоде* :

[!code-aspx[Main](overview/samples/sample25.aspx)]

Как видите, код отключает состояние просмотра для элемента управления PlaceHolder1. Дочерний элемент управления Label1 наследует это значение свойства (*inherit* является значением по умолчанию для *виевстатемоде* для элементов управления) и поэтому не сохраняет состояние представления. В элементе управления PlaceHolder2 параметр *виевстатемоде* имеет значение *Enabled*, поэтому ярлык2 наследует это свойство и сохранит состояние представления. При первой загрузке страницы свойство *Text* обоих элементов управления *Label* устанавливается в строку "[DynamicValue]".

Результатом этих настроек является то, что когда страница загружается в первый раз, в браузере отображаются следующие выходные данные:

Отключенные `: [DynamicValue]`

Включено:`[DynamicValue]`

Однако после обратной передачи отображаются следующие выходные данные:

Отключенные `: [DeclaredValue]`

Включено:`[DynamicValue]`

Элемент управления Label1 (у которого значение *виевстатемоде* задано как *disabled*) не сохранил значение, которое было задано в коде. Однако состояние элемента управления ярлык2 (для *которого* задано значение *Enabled*) сохранилось.

Можно также задать *виевстатемоде* в директиве *@ Page* , как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample26.aspx)]

Класс *страницы* — это просто другой элемент управления; Он выступает в качестве родительского элемента управления для всех остальных элементов управления на странице. Значение по умолчанию *Виевстатемоде* *включено* для экземпляров *страницы*. Поскольку элементы управления по умолчанию *наследуют*, элементы управления наследуют значение *включенного* свойства, если только не задано значение *виевстатемоде* на уровне страницы или элемента управления.

Значение свойства *виевстатемоде* определяет, поддерживается ли состояние представления только в том случае, если свойство *EnableViewState* имеет значение *true*. Если свойство *EnableViewState* имеет значение *false*, состояние представления не будет поддерживаться, даже если для *виевстатемоде* задано значение *Enabled*.

Хорошим использованием этой функции является использование элементов управления *ContentPlaceHolder* на главных страницах, где можно установить *Виевстатемоде* в значение *disabled* для главной страницы, а затем включить ее по отдельности для элементов управления *ContentPlaceHolder* , которые в свою очередь содержат элементы управления, требующие состояния просмотра.

<a id="0.2__Toc224729035"></a><a id="0.2__Toc253429259"></a><a id="0.2__Toc243304633"></a>

### <a name="changes-to-browser-capabilities"></a>Изменения возможностей браузера

ASP.NET определяет возможности браузера, которые пользователь использует для просмотра сайта, с помощью функции, которая называется « *возможности браузера*». Возможности браузера представлены объектом *хттпбровсеркапабилитиес* (предоставленным свойством *request. browser* ). Например, можно использовать объект *хттпбровсеркапабилитиес* , чтобы определить, поддерживает ли тип и версия текущего браузера конкретную версию JavaScript. Также можно использовать объект *хттпбровсеркапабилитиес* , чтобы определить, поступил ли запрос с мобильного устройства.

Объект *хттпбровсеркапабилитиес* управляется набором файлов определения браузера. Эти файлы содержат сведения о возможностях определенных браузеров. В ASP.NET 4 эти файлы определения браузера были обновлены и содержат сведения о недавно появившихся браузерах и устройствах, таких как Google Chrome, исследование в смартфонах с движением BlackBerry и Apple iPhone.

В следующем списке показаны новые файлы определения браузера:

- *BlackBerry. browser*
- *хром. browser*
- *Default. browser*
- *браузер Firefox. browser*
- *шлюз. browser*
- *универсальный. browser*
- *IE. browser*
- *иемобиле. browser*
- *iPhone. browser*
- *Opera. browser*
- *Safari. browser*

#### <a name="using-browser-capabilities-providers"></a>Использование поставщиков возможностей браузера

В ASP.NET версии 3,5 с пакетом обновления 1 (SP1) можно определить возможности браузера следующими способами.

- На уровне компьютера вы создаете или обновляете `.browser` XML-файл в следующей папке:

- [!code-console[Main](overview/samples/sample27.cmd)]

- Определив возможности браузера, выполните следующую команду из командной строки Visual Studio, чтобы перестроить сборку возможностей браузера и добавить ее в глобальный кэш сборок:

- [!code-console[Main](overview/samples/sample28.cmd)]

- Для отдельного приложения вы создаете файл `.browser` в папке `App_Browsers` приложения.

Для этих подходов требуется изменить XML-файлы, а для изменений на уровне компьютера необходимо перезапустить приложение после запуска процесса ASPNET\_регбровсерс. exe.

ASP.NET 4 включает в себя функцию, называемую *поставщиками возможностей браузера*. Как видно из названия, это позволяет создать поставщик, который, в свою очередь, позволяет использовать собственный код для определения возможностей браузера.

На практике разработчики часто не определяют возможности пользовательского браузера. Файлы браузера трудно обновлять, процесс их обновления довольно сложен, а синтаксис XML для `.browser` файлов может быть сложным для использования и определения. Что сделает этот процесс намного проще, если существовал общий синтаксис определения браузера или база данных, содержащая актуальные определения браузера или даже веб-службу для такой базы данных. Новая функция поставщиков возможностей браузера делает эти сценарии возможными и практичными для сторонних разработчиков.

Существует два основных подхода к использованию новой функции поставщика возможностей браузера ASP.NET 4: расширение возможностей определения возможностей браузера ASP.NET или его замена. В следующих разделах описано, как заменить функциональность, а затем расширить ее.

#### <a name="replacing-the-aspnet-browser-capabilities-functionality"></a>Замена возможностей возможностей браузера ASP.NET

Чтобы полностью заменить функциональность определения возможностей браузера ASP.NET, выполните следующие действия.

1. Создайте класс поставщика, производный от *хттпкапабилитиеспровидер* , который переопределяет метод *жетбровсеркапабилитиес* , как показано в следующем примере: 

    [!code-csharp[Main](overview/samples/sample29.cs)]

    Код в этом примере создает новый объект *хттпбровсеркапабилитиес* , указывая только возможность с именем Browser и устанавливая эту возможность в микустомбровсер.
2. Зарегистрируйте поставщик в приложении. 

    Чтобы использовать поставщик с приложением, необходимо добавить атрибут *поставщика* в раздел *browserCaps* в файлах `Web.config` или `Machine.config`. (Атрибуты поставщика можно также определить в элементе *Location* для определенных каталогов в приложении, например в папке для конкретного мобильного устройства.) В следующем примере показано, как задать атрибут *provider* в файле конфигурации:

    [!code-xml[Main](overview/samples/sample30.xml)]

    Другим способом регистрации нового определения возможностей браузера является использование кода, как показано в следующем примере:

    [!code-csharp[Main](overview/samples/sample31.cs)]

    Этот код должен выполняться в событии *приложения\_Start* файла `Global.asax`. Любое изменение класса *бровсеркапабилитиеспровидер* должно происходить перед выполнением любого кода в приложении, чтобы убедиться, что кэш остается в допустимом состоянии для разрешенного объекта *хттпкапабилитиесбасе* .

#### <a name="caching-the-httpbrowsercapabilities-object"></a>Кэширование объекта Хттпбровсеркапабилитиес

В предыдущем примере есть одна проблема, которая заключается в том, что код будет выполняться каждый раз при вызове пользовательского поставщика для получения объекта *хттпбровсеркапабилитиес* . Это может происходить несколько раз во время каждого запроса. В этом примере код для поставщика не выполняет много действий. Однако если код пользовательского поставщика выполняет значительную работу, чтобы получить объект *хттпбровсеркапабилитиес* , это может повлиять на производительность. Чтобы предотвратить это, можно кэшировать объект *хттпбровсеркапабилитиес* . Выполните следующие действия.

1. Создайте класс, производный от *хттпкапабилитиеспровидер*, как в следующем примере: 

    [!code-csharp[Main](overview/samples/sample32.cs)]

    В примере код создает ключ кэша путем вызова пользовательского метода Буилдкачекэй и получает продолжительность кэширования путем вызова пользовательского метода Жеткачетиме. Затем код добавляет разрешенный объект *хттпбровсеркапабилитиес* в кэш. Объект можно получить из кэша и повторно использовать при последующих запросах, использующих настраиваемый поставщик.
2. Зарегистрируйте поставщик в приложении, как описано в предыдущей процедуре.

#### <a name="extending-aspnet-browser-capabilities-functionality"></a>Расширение возможностей возможностей браузера ASP.NET

В предыдущем разделе было описано, как создать новый объект *хттпбровсеркапабилитиес* в ASP.NET 4. Можно также расширить функциональные возможности обозревателя ASP.NET, добавив новые определения возможностей браузера в те, которые уже находятся в ASP.NET. Это можно сделать без использования определений браузера XML. В следующей процедуре показано, как это делать.

1. Создайте класс, производный от *хттпкапабилитиесевалуатор* и переопределяющий метод *жетбровсеркапабилитиес* , как показано в следующем примере: 

    [!code-csharp[Main](overview/samples/sample33.cs)]

    В этом коде сначала используется функция возможностей браузера ASP.NET, чтобы попытаться опознать браузер. Однако если браузер не определен на основе сведений, определенных в запросе (то есть если свойство *Browser* объекта *хттпбровсеркапабилитиес* является строкой "Unknown"), код вызывает настраиваемый поставщик (мибровсеркапабилитиесевалуатор) для идентификации браузера.
2. Зарегистрируйте поставщик в приложении, как описано в предыдущем примере.

#### <a name="extending-browser-capabilities-functionality-by-adding-new-capabilities-to-existing-capabilities-definitions"></a>Расширение функциональности возможностей браузера путем добавления новых возможностей к существующим определениям возможностей

Помимо создания пользовательского поставщика определений браузера и динамического создания новых определений браузеров, можно расширить существующие определения браузера с помощью дополнительных возможностей. Это позволяет использовать определение, близкое к желаемому, но в нем не хватает нескольких возможностей. Для этого выполните следующие действия.

1. Создайте класс, производный от *хттпкапабилитиесевалуатор* и переопределяющий метод *жетбровсеркапабилитиес* , как показано в следующем примере: 

    [!code-csharp[Main](overview/samples/sample34.cs)]

    Код в примере расширяет существующий класс ASP.NET *хттпкапабилитиесевалуатор* и получает объект *хттпбровсеркапабилитиес* , соответствующий текущему определению запроса, с помощью следующего кода:

    [!code-csharp[Main](overview/samples/sample35.cs)]

    Затем код может добавить или изменить возможность для этого браузера. Существует два способа указания новой возможности браузера:

    - Добавьте пару "ключ-значение" в объект *IDictionary* , предоставляемый свойством *capabilities* объекта *хттпкапабилитиесбасе* . В предыдущем примере код добавляет возможность с именем Мультисенсорная и значением *true*.
    - Установка существующих свойств объекта *хттпкапабилитиесбасе* . В предыдущем примере код устанавливает для свойства *frames* значение *true*. Это свойство представляет собой просто метод доступа для объекта *IDictionary* , предоставляемого свойством *capabilities* . 

        > [!NOTE]
        > Примечание. Эта модель применяется к любому свойству *хттпбровсеркапабилитиес*, включая адаптеры элементов управления.
2. Зарегистрируйте поставщик в приложении, как описано в предыдущей процедуре.

<a id="0.2__Toc224729036"></a><a id="0.2__Toc253429260"></a><a id="0.2__Toc243304634"></a>

### <a name="routing-in-aspnet-4"></a>Маршрутизация в ASP.NET 4

В ASP.NET 4 добавлена встроенная поддержка для использования маршрутизации с помощью веб-форм. Маршрутизация позволяет настроить приложение для приема URL-адресов запросов, которые не сопоставляются с физическими файлами. Вместо этого можно использовать маршрутизацию для определения URL-адресов, которые являются значимыми для пользователей и которые могут помочь в оптимизации поисковой системы (SEO) для вашего приложения. Например, URL-адрес страницы, отображающей категории продуктов в существующем приложении, может выглядеть, как в следующем примере:

[!code-console[Main](overview/samples/sample36.cmd)]

Используя маршрутизацию, можно настроить приложение на прием следующего URL-адреса для отображения той же информации:

[!code-console[Main](overview/samples/sample37.cmd)]

Маршрутизация была доступна начиная с ASP.NET 3,5 с пакетом обновления 1 (SP1). (Пример использования маршрутизации в ASP.NET 3,5 с пакетом обновления 1 (SP1) см. в записи об [использовании маршрутизации с веб-формами](http://haacked.com/archive/2008/03/11/using-routing-with-webforms.aspx "Заголовок этой записи.") в блоге Фил Хаак.) Однако ASP.NET 4 включает некоторые функции, упрощающие использование маршрутизации, включая следующие:

- Класс *пажераутехандлер* , который является простым обработчиком HTTP, который используется при определении маршрутов. Класс передает данные на страницу, к которой направляется запрос.
- Новые свойства *HttpRequest. RequestContext* и *Page. RouteData* (это прокси-сервер для объекта *HttpRequest. RequestContext. RouteData* ). Эти свойства упрощают доступ к информации, передаваемой из маршрута.
- Следующие новые построители выражений, определенные в *System. Web. Compilation. раутеурлекспрессионбуилдер* и *System. Web. Compilation. раутевалуикспрессионбуилдер*:
- *RouteUrl*, который предоставляет простой способ создания URL-адреса, соответствующего URL-адресу маршрута в серверном элементе управления ASP.NET.
- *RouteValue*, который предоставляет простой способ извлечения информации из объекта *раутеконтекст* .
- Класс *раутепараметер* , который упрощает передачу данных, содержащихся в объекте *раутеконтекст* , в запрос для элемента управления источника данных (аналогично [*формпараметер*](https://msdn.microsoft.com/library/system.web.ui.webcontrols.formparameter.aspx)).

#### <a name="routing-for-web-forms-pages"></a>Маршрутизация для страниц веб-форм

В следующем примере показано, как определить маршрут веб-форм с помощью нового метода *маппажерауте* класса *Route* :

[!code-csharp[Main](overview/samples/sample38.cs)]

В ASP.NET 4 появился метод *маппажерауте* . Следующий пример эквивалентен определению Сеарчрауте, показанному в предыдущем примере, но использует класс *пажераутехандлер* .

[!code-csharp[Main](overview/samples/sample39.cs)]

Код в примере сопоставляет маршрут с физической страницей (в первом маршруте для `~/search.aspx`). Первое определение маршрута также указывает, что параметр с именем searchterm должен быть извлечен из URL-адреса и передан на страницу.

Метод *маппажерауте* поддерживает следующие перегрузки метода:

- *Маппажерауте (строка routeName, строка routeUrl, строка physicalFile, bool Чеккфисикалурлакцесс)*
- *Маппажерауте (строка routeName, строка routeUrl, строка physicalFile, bool Чеккфисикалурлакцесс, значения по умолчанию для Раутевалуедиктионари)*
- *Маппажерауте (строка routeName, строка routeUrl, строка physicalFile, bool Чеккфисикалурлакцесс, значения по умолчанию раутевалуедиктионари, ограничения Раутевалуедиктионари)*

Параметр *чеккфисикалурлакцесс* указывает, должен ли маршрут проверять разрешения безопасности для физической страницы, к которой выполняется маршрутизация (в данном случае это Search. aspx), и разрешения для входящего URL-адреса (в данном случае это поиск/{searchterm}). Если значение *чеккфисикалурлакцесс* равно *false*, будут проверяться только разрешения входящего URL-адреса. Эти разрешения определяются в файле `Web.config` с помощью следующих параметров:

[!code-xml[Main](overview/samples/sample40.xml)]

В примере конфигурации отказано в доступе к физической странице `search.aspx` для всех пользователей, за исключением тех, которые входят в роль администратора. Если параметр *чеккфисикалурлакцесс* имеет значение *true* (по умолчанию), доступ к URL-адресу/СЕАРЧ/{сеарчтерм} разрешен только пользователям с правами администратора, так как физический Поиск страницы. aspx ограничен только пользователями этой роли. Если для *чеккфисикалурлакцесс* задано *значение false* и сайт настроен, как показано в предыдущем примере, всем прошедшим проверку подлинности пользователям будет разрешен доступ к URL-адресу/СЕАРЧ/{сеарчтерм}.

#### <a name="reading-routing-information-in-a-web-forms-page"></a>Чтение сведений о маршрутизации на странице веб-форм

В коде физической страницы веб-форм можно получить доступ к информации, извлеченной из URL-адреса (или другой информации, добавленной другим объектом в объект *RouteData* ) с помощью двух новых свойств: *HttpRequest. RequestContext* и *Page. RouteData*. (*Page. RouteData* заключает *HttpRequest. RequestContext. RouteData*.) В следующем примере показано, как использовать *Page. RouteData*.

[!code-csharp[Main](overview/samples/sample41.cs)]

Код извлекает значение, переданное для параметра searchterm, как определено ранее в примере маршрута. Рассмотрим следующий URL-адрес запроса:

[!code-console[Main](overview/samples/sample42.cmd)]

При выполнении этого запроса слово «Скотт» будет подготовлено к просмотру на странице `search.aspx`.

#### <a name="accessing-routing-information-in-markup"></a>Доступ к сведениям о маршрутизации в разметке

Метод, описанный в предыдущем разделе, показывает, как получить данные маршрута в коде на странице веб-форм. Можно также использовать выражения в разметке, которые предоставляют доступ к одной и той же информации. Построители выражений — это мощный и изящный способ работы с декларативным кодом. (Дополнительные сведения см. в записи [самостоятельного выражения с пользовательскими построителями выражений](http://haacked.com/archive/2006/11/29/Express_Yourself_With_Custom_Expression_Builders.aspx) в блоге по Фил Хаак.)

ASP.NET 4 содержит два новых построителей выражений для маршрутизации веб-форм. В следующем примере показано, как использовать их.

[!code-aspx[Main](overview/samples/sample43.aspx)]

В этом примере выражение *RouteUrl* используется для определения URL-адреса, основанного на параметре маршрута. Это избавляет от необходимости жестко кодировать полный URL-адрес в разметку и позволяет изменить структуру URL-адреса позже, не требуя изменения этой ссылки.

На основе маршрута, определенного ранее, эта разметка создает следующий URL-адрес:

[!code-console[Main](overview/samples/sample44.cmd)]

ASP.NET автоматически работает с правильным маршрутом (то есть создает правильный URL-адрес) на основе входных параметров. В выражение можно также включить имя маршрута, которое позволяет указать маршрут для использования.

В следующем примере показано, как использовать выражение *RouteValue* .

[!code-aspx[Main](overview/samples/sample45.aspx)]

Когда выполняется страница, содержащая этот элемент управления, в метке отображается значение «Скотт».

Выражение *RouteValue* упрощает использование данных маршрута в разметке и позволяет избежать необходимости работать с более сложным синтаксисом Page. RouteData ["x"] в разметке.

#### <a name="using-route-data-for-data-source-control-parameters"></a>Использование данных маршрута для параметров элемента управления источниками данных

Класс *раутепараметер* позволяет указать данные маршрута в качестве значения параметра для запросов в элементе управления источниками данных. Он [работает во многом подобно](https://msdn.microsoft.com/library/system.web.ui.webcontrols.formparameter.aspx) классу, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample46.aspx)]

В этом случае значение параметра маршрута searchterm будет использоваться для параметра @companyname в инструкции *SELECT* .

<a id="0.2__Toc224729037"></a><a id="0.2__Toc253429261"></a><a id="0.2__Toc243304635"></a>

### <a name="setting-client-ids"></a>Настройка идентификаторов клиентов

Новое свойство *ClientIDMode* предназначено для долгосрочной проблемы в ASP.NET, а именно о том, как элементы управления создают атрибут *ID* для элементов, которые они отображают. Знание атрибута *ID* для отображаемых элементов важно, если приложение включает клиентский скрипт, который ссылается на эти элементы.

Атрибут *ID* в HTML, отображаемый для серверных веб-элементов управления, создается на основе свойства *ClientID* элемента управления. До ASP.NET 4 алгоритм создания атрибута *ID* из свойства *ClientID* присоединяет контейнер именования (если таковой имеется) с идентификатором и в случае повторяющихся элементов управления (как в элементах управления данными) для добавления префикса и порядкового номера. Хотя в этом случае всегда гарантировано, что идентификаторы элементов управления на странице уникальны, алгоритм привел к тому, что идентификаторы управления не были прогнозируемыми и, следовательно, трудно ссылаться в клиентском скрипте.

Новое свойство *ClientIDMode* позволяет точно указать, как идентификатор клиента создается для элементов управления. Свойство *ClientIDMode* можно задать для любого элемента управления, в том числе для страницы. Возможны следующие параметры:

- *AutoID* — это эквивалентно алгоритму создания значений свойств *ClientID* , которые использовались в более ранних версиях ASP.NET.
- *Static* — указывает, что значение *ClientID* будет таким же, как идентификатор, без сцепления идентификаторов родительских контейнеров именования. Это может быть полезно в пользовательских веб-элементах управления. Поскольку пользовательский веб-элемент управления может размещаться на разных страницах и в различных контейнерных элементах управления, может быть трудно написать клиентский скрипт для элементов управления, использующих алгоритм *AutoID* , поскольку нельзя предсказать, какие значения идентификаторов будут использоваться.
- *Прогнозируемый* — этот параметр предназначен главным образом для использования в элементах управления данными, использующих повторяющиеся шаблоны. Он объединяет свойства идентификатора контейнеров именования элемента управления, но созданные значения *ClientID* не содержат строк, таких как "ктлкскскс". Этот параметр работает совместно со свойством *ClientIDRowSuffix* элемента управления. Для свойства *ClientIDRowSuffix* задается имя поля данных, а значение этого поля используется в качестве суффикса для созданного значения *ClientID* . Обычно в качестве значения *ClientIDRowSuffix* используется первичный ключ записи данных.
- *Inherit* — этот параметр является поведением по умолчанию для элементов управления; Он указывает, что создание идентификатора элемента управления совпадает с его родителем.

Свойство *ClientIDMode* можно задать на уровне страницы. Это определяет значение *ClientIDMode* по умолчанию для всех элементов управления на текущей странице.

Значение *ClientIDMode* по умолчанию на уровне страницы — *AutoID*, а значение *ClientIDMode* по умолчанию на уровне элемента управления — *inherit*. В результате, если вы не задаете это свойство в любом месте кода, все элементы управления будут по умолчанию использовать алгоритм *AutoID* .

Значение уровня страницы задается в директиве *@ Page* , как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample47.aspx)]

Можно также задать значение *ClientIDMode* в файле конфигурации либо на уровне компьютера (компьютера), либо на уровне приложения. Он определяет параметр *ClientIDMode* по умолчанию для всех элементов управления во всех страницах приложения. Если задать значение на уровне компьютера, он определяет параметр *ClientIDMode* по умолчанию для всех веб-сайтов на этом компьютере. В следующем примере показан параметр *ClientIDMode* в файле конфигурации:

[!code-xml[Main](overview/samples/sample48.xml)]

Как отмечалось ранее, значение свойства *ClientID* является производным от контейнера именования для родителя элемента управления. В некоторых сценариях, например при использовании главных страниц, элементы управления могут использовать идентификаторы, подобные приведенным в следующем отображенном HTML-коде:

[!code-html[Main](overview/samples/sample49.html)]

Хотя элемент *input* , показанный в разметке (из элемента управления *TextBox* ), является только двумя контейнерами именования на странице (вложенные элементы управления *ContentPlaceHolder* ), из-за обработки главных страниц конечный результат представляет собой идентификатор элемента управления, подобный следующему:

[!code-console[Main](overview/samples/sample50.cmd)]

Этот идентификатор гарантированно уникален на странице, но не обязательно должен быть длинным для большинства целей. Представьте, что необходимо уменьшить длину отображаемого идентификатора и получить больший контроль над способом создания идентификатора. (Например, необходимо исключить префиксы "ктлкскскс".) Самый простой способ добиться этого — задать свойство *ClientIDMode* , как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample51.aspx)]

В этом примере свойство *ClientIDMode* имеет значение *static* для самого внешнего элемента *намингпанел* и для него задано значение *Predict* для внутреннего элемента *намингконтрол* . Эти параметры приводят к следующей разметке (остальная часть страницы и Главная страница считаются теми же, что и в предыдущем примере):

[!code-html[Main](overview/samples/sample52.html)]

*Статический* параметр влияет на сброс иерархии именования для всех элементов управления внутри внешнего элемента *намингпанел* и за исключением идентификаторов *ContentPlaceHolder* и *MasterPage* из созданного идентификатора. (Атрибут *Name* отображаемых элементов не изменяется, поэтому обычные функции ASP.NET сохранены для событий, состояния представления и т. д.) Побочный результат сброса иерархии имен заключается в том, что даже если вы перемещаете разметку для элементов *намингпанел* в другой элемент управления *ContentPlaceHolder* , отображаемые идентификаторы клиентов остаются неизменными.

> [!NOTE]
> Обратите внимание, что вы должны убедиться, что отображаемые идентификаторы элементов управления являются уникальными. Если это не так, это может привести к нарушению функциональных возможностей, требующих уникальных идентификаторов для отдельных элементов HTML, таких как функция Client *Document. getElementById* .

#### <a name="creating-predictable-client-ids-in-data-bound-controls"></a>Создание прогнозируемых идентификаторов клиентов в элементах управления с привязкой к данным

Значения *ClientID* , которые создаются для элементов управления в элементе управления списка с привязкой к данным, могут быть длинными и непредсказуемыми. Функция *ClientIDMode* позволяет получить более полный контроль над созданием этих идентификаторов.

Разметка в следующем примере включает элемент управления *ListView* :

[!code-aspx[Main](overview/samples/sample53.aspx)]

В предыдущем примере свойства *ClientIDMode* и *ровклиентидровсуффикс* задаются в разметке. Свойство *ClientIDRowSuffix* может использоваться только в элементах управления с привязкой к данным, и его поведение зависит от того, какой элемент управления используется. Ниже приведены различия.

- Элемент управления *GridView* — можно указать имя одного или нескольких столбцов в источнике данных, которые объединяются во время выполнения для создания идентификаторов клиентов. Например, если задать для *ровклиентидровсуффикс* значение "ProductName, ProductID", идентификаторы элементов управления для отображаемых элементов будут иметь следующий формат:

- [!code-console[Main](overview/samples/sample54.cmd)]

- Элемент управления *ListView* — можно указать один столбец в источнике данных, добавляемый к идентификатору клиента. Например, если задать для *ClientIDRowSuffix* значение "ProductName", то отображаемые идентификаторы элементов управления будут выглядеть следующим образом:

- [!code-console[Main](overview/samples/sample55.cmd)]

- В этом случае конец 1 является производным от идентификатора продукта текущего элемента данных.

- Элемент управления *Repeater* — этот элемент управления не поддерживает свойство *ClientIDRowSuffix* . В элементе управления *Repeater* используется индекс текущей строки. При использовании ClientIDMode = "прогнозируемый" с элементом управления *Repeater* создаются идентификаторы клиентов, имеющие следующий формат:

- [!code-console[Main](overview/samples/sample56.cmd)]

- Замыкающий 0 — это индекс текущей строки.

Элементы управления *FormView* и *DetailsView* не отображают несколько строк, поэтому они не поддерживают свойство *ClientIDRowSuffix* .

<a id="0.2__Toc224729038"></a><a id="0.2__Toc253429262"></a><a id="0.2__Toc243304636"></a>

### <a name="persisting-row-selection-in-data-controls"></a>Сохранение выбора строк в элементах управления данными

Элементы управления *GridView* и *ListView* позволяют пользователям выбрать строку. В предыдущих версиях ASP.NET выбор был основан на индексе строки на странице. Например, если выбрать третий элемент на странице 1, а затем перейти на страницу 2, выбирается третий элемент на этой странице.

Сохраненный выбор изначально поддерживается только в платформа динамических данных проектах в .NET Framework 3,5 с пакетом обновления 1 (SP1). Если эта функция включена, текущий выбранный элемент основывается на ключе данных элемента. Это означает, что если выбрать третью строку на странице 1 и перейти на страницу 2, на странице 2 ничего не выделено. При переходе назад на страницу 1 Третья строка остается выбранной. Сохраняемый выбор теперь поддерживается для элементов управления *GridView* и *ListView* во всех проектах с помощью свойства *енаблеперсистедселектион* , как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample57.aspx)]

<a id="0.2__Toc253429263"></a><a id="0.2__Toc243304637"></a>

### <a name="aspnet-chart-control"></a>Элемент управления диаграммы ASP.NET

Элемент управления *диаграммы* ASP.net расширяет предложения визуализации данных в .NET Framework. С помощью элемента управления *диаграммы* можно создавать страницы ASP.NET, имеющие интуитивно понятные и визуально привлекательные диаграммы для сложного статистического или финансового анализа. Элемент управления " *диаграмма* ASP.NET" появился в качестве надстройки для выпуска .NET Framework версии 3,5 с пакетом обновления 1 (SP1) и является частью выпуска .NET Framework 4.

Элемент управления включает следующие функции:

- 35 различных типов диаграмм.
- Неограниченное количество областей диаграммы, заголовков, условных обозначений и заметок.
- Широкий спектр параметров внешнего вида для всех элементов диаграммы.
- Трехмерная поддержка большинства типов диаграмм.
- Метки смарт-данных, которые могут автоматически помещаться вокруг точек данных.
- Полосковые линии, разрывы шкалы и логарифмическое масштабирование.
- Более 50 финансовых и статистических формул для анализа данных и преобразования данных.
- Простая привязка и обработка данных диаграммы.
- Поддержка общих форматов данных, таких как даты, время и валюта.
- Поддержка интерактивной настройки, управляемой событиями, включая события щелчка клиента с помощью AJAX.
- Управление состоянием.
- Двоичные потоки.

На следующих рисунках показаны примеры финансовых диаграмм, создаваемых элементом управления диаграммы ASP.NET.

<a id="0.2_graphic17"></a>![](overview/_static/image1.png)

Рис. 2. Примеры элементов управления диаграммы ASP.NET

Чтобы получить дополнительные примеры использования элемента управления диаграммы ASP.NET, Скачайте пример кода на странице «образцы» [для элементов управления диаграммы Microsoft](https://go.microsoft.com/fwlink/?LinkId=128300) на веб-сайте MSDN. Дополнительные примеры содержимого сообщества можно найти на [форуме по элементу управления диаграммой](https://go.microsoft.com/fwlink/?LinkId=128713).

#### <a name="adding-the-chart-control-to-an-aspnet-page"></a>Добавление элемента управления диаграммы на страницу ASP.NET

В следующем примере показано, как добавить элемент управления *диаграммы* на страницу ASP.NET с помощью разметки. В этом примере элемент управления *диаграммы* создает гистограмму для статических точек данных.

[!code-aspx[Main](overview/samples/sample58.aspx)]

#### <a name="using-3-d-charts"></a>Использование трехмерных диаграмм

Элемент управления *Chart* содержит коллекцию *чартареас* , которая может содержать объекты *ChartArea* , определяющие характеристики областей диаграммы. Например, чтобы использовать трехмерную диаграмму для области диаграммы, используйте свойство *Area3DStyle* , как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample59.aspx)]

На рисунке ниже показана трехмерная диаграмма с четырьмя рядами типа *линейчатой* диаграммы.

<a id="0.2_graphic18"></a>![](overview/_static/image2.png)

Рисунок 3:3-D линейчатая диаграмма

#### <a name="using-scale-breaks-and-logarithmic-scales"></a>Использование разрывов шкалы и логарифмических шкал

Разрывы шкалы и логарифмические шкалы — это два дополнительных способа добавления в диаграмму более изощренных возможностей. Эти функции относятся к каждой оси в области диаграммы. Например, чтобы использовать эти функции на основной оси Y области диаграммы, используйте свойства *Axis. логарифмический* и *ScaleBreakStyle* в объекте *ChartArea* . В следующем фрагменте кода показано, как использовать разрывы шкалы на основной оси Y.

[!code-aspx[Main](overview/samples/sample60.aspx)]

На рисунке ниже показана ось Y с включенными разрывами шкалы.

<a id="0.2_graphic19"></a>![](overview/_static/image3.png)

Рис. 4. разрывы шкалы

<a id="0.2__QueryExtender"></a><a id="0.2__Toc224729041"></a><a id="0.2__Toc253429264"></a><a id="0.2__Toc243304638"></a>

### <a name="filtering-data-with-the-queryextender-control"></a>Фильтрация данных с помощью элемента управления элемента

Очень распространенной задачей для разработчиков, создающих управляемые данными веб-страницы, является фильтрация данных. Это традиционно было выполнено путем создания предложений *WHERE* в элементах управления источниками данных. Этот подход может быть сложным, и в некоторых случаях синтаксис *WHERE* не позволяет воспользоваться всеми возможностями базовой базы данных.

Чтобы упростить фильтрацию, в ASP.NET 4 был добавлен новый элемент управления *элемента* . Этот элемент управления может быть добавлен к элементам управления *EntityDataSource* или *LinqDataSource* для фильтрации данных, возвращаемых этими элементами управления. Поскольку элемент управления *элемента* основан на LINQ, фильтр применяется к серверу базы данных до отправки данных на страницу, что приводит к очень эффективным операциям.

Элемент управления *элемента* поддерживает различные параметры фильтра. В следующих разделах описываются эти параметры и приводятся примеры их использования.

#### <a name="search"></a>Поиск

Для параметра поиска элемент управления *элемента* выполняет поиск в указанных полях. В следующем примере элемент управления использует текст, который был указан в элементе управления Текстбокссеарч, и ищет его содержимое в `ProductName` и `Supplier.CompanyName` столбцы в данных, возвращаемых из элемента управления *LinqDataSource* .

[!code-aspx[Main](overview/samples/sample61.aspx)]

#### <a name="range"></a>Диапазон

Параметр range аналогичен параметру поиска, но указывает пару значений для определения диапазона. В следующем примере элемент управления *элемента* ищет столбец `UnitPrice` в данных, возвращаемых элементом управления *LinqDataSource* . Диапазон считывается из элементов управления Текстбоксфром и Текстбоксто на странице.

[!code-aspx[Main](overview/samples/sample62.aspx)]

#### <a name="propertyexpression"></a>PropertyExpression

Параметр выражения свойства позволяет определить сравнение со значением свойства. Если результатом вычисления выражения является *true*, то возвращаются анализируемые данные. В следующем примере элемент управления *элемента* фильтрует данные, сравнивая данные в столбце `Discontinued` со значением из элемента управления чеккбоксдисконтинуед на странице.

[!code-aspx[Main](overview/samples/sample63.aspx)]

#### <a name="customexpression"></a>кустомекспрессион

Наконец, можно указать пользовательское выражение для использования с элементом управления *элемента* . Этот параметр позволяет вызвать функцию на странице, которая определяет логику настраиваемого фильтра. В следующем примере показано, как декларативно указать пользовательское выражение в элементе управления *элемента* .

[!code-aspx[Main](overview/samples/sample64.aspx)]

В следующем примере показана пользовательская функция, которая вызывается элементом управления *элемента* . В этом случае вместо использования запроса к базе данных, включающего предложение *WHERE* , код использует запрос LINQ для фильтрации данных.

[!code-csharp[Main](overview/samples/sample65.cs)]

В этих примерах показано только одно выражение, используемое в элементе управления *элемента* за раз. Однако в элемент управления *элемента* можно включить несколько выражений.

<a id="0.2__Toc253429265"></a><a id="0.2__Toc243304639"></a>

### <a name="html-encoded-code-expressions"></a>Выражения кода в кодировке HTML

Некоторые сайты ASP.NET (особенно с ASP.NET MVC) сильно полагаются на использование `<%`= `expression %>` синтаксис (часто именуемый Code кусочки) для записи некоторого текста в ответ. При использовании выражений кода можно легко забыть HTML-кодировать текст, если текст поступает из пользовательского ввода, он может оставлять страницы открытыми для атаки с помощью XSS (межсайтовых сценариев).

В ASP.NET 4 представлен следующий новый синтаксис для выражений кода:

[!code-aspx[Main](overview/samples/sample66.aspx)]

При записи в ответ этот синтаксис по умолчанию использует кодировку HTML. Это новое выражение фактически преобразуется в следующее:

[!code-aspx[Main](overview/samples/sample67.aspx)]

Например, &lt;%: Request ["UserInput"]%&gt; выполняет кодирование HTML для значения *request ["UserInput"]* .

Целью этой функции является возможность заменить все экземпляры старого синтаксиса новым синтаксисом, чтобы не приходилось выбирать на каждом шаге, который следует использовать. Однако бывают случаи, в которых выводимый текст предназначен для HTML или уже закодирован. в этом случае это может привести к удвоенному кодированию.

В таких случаях в ASP.NET 4 появился новый интерфейс *ихтмлстринг*, а также конкретная реализация *хтмлстринг*. Экземпляры этих типов позволяют указать, что возвращаемое значение уже закодировано правильно (или просматривается иным образом) для отображения в виде HTML, поэтому значение не должно повторно кодироваться в формате HTML. Например, следующее не должно быть (и не является) в кодировке HTML:

[!code-aspx[Main](overview/samples/sample68.aspx)]

Вспомогательные методы ASP.NET MVC 2 были обновлены для работы с этим новым синтаксисом, поэтому они не кодируются двойным кодированием, но только при использовании ASP.NET 4. Этот новый синтаксис не работает при запуске приложения с помощью ASP.NET 3,5 с пакетом обновления 1 (SP1).

Помните, что это не гарантирует защиту от атак XSS. Например, HTML-код, использующий значения атрибутов, которые не заключены в кавычки, может содержать вводимые пользователем данные, которые по-прежнему являются уязвимыми. Обратите внимание, что выходные данные элементов управления ASP.NET и ASP.NETs вспомогательные методы MVC всегда содержат значения атрибутов в кавычках, что является рекомендуемым подходом.

Аналогичным образом, этот синтаксис не выполняет кодирование JavaScript, например, при создании строки JavaScript на основе вводимых пользователем данных.

<a id="0.2__Toc253429266"></a><a id="0.2__Toc243304640"></a>

### <a name="project-template-changes"></a>Изменения в шаблоне проекта

В более ранних версиях ASP.NET при использовании Visual Studio для создания нового проекта веб-сайта или проекта веб-приложения итоговые проекты содержат только страницу Default. aspx, файл `Web.config` по умолчанию и папку `App_Data`, как показано на следующем рисунке.

<a id="0.2_graphic1A"></a>![](overview/_static/image4.png)

Visual Studio также поддерживает пустой тип проекта веб-сайта, который не содержит ни одного файла, как показано на следующем рисунке:

<a id="0.2_graphic1B"></a>![](overview/_static/image5.png)

В результате для начинающих существует очень небольшое руководство по созданию рабочего веб-приложения. Таким образом, в ASP.NET 4 появились три новых шаблона: один для пустого проекта веб-приложения и по одному для веб-приложения и проекта веб-узла.

#### <a name="empty-web-application-template"></a>Шаблон пустого веб-приложения

Как видно из названия, шаблон пустого веб-приложения является разворачивающимся проектом веб-приложения. Этот шаблон проекта выбирается из диалогового окна Новый проект Visual Studio, как показано на следующем рисунке.

[![](overview/_static/image7.png)](overview/_static/image6.png)

([Щелкните, чтобы просмотреть изображение с полным размером](overview/_static/image8.png))

При создании пустого веб-приложения ASP.NET Visual Studio создает следующий макет папки:

<a id="0.2_graphic1D"></a>![](overview/_static/image9.png)

Это похоже на пустой макет веб-узла из более ранних версий ASP.NET с одним исключением. В Visual Studio 2010 пустое веб-приложение и пустые проекты веб-сайтов содержат следующий минимальный `Web.config` файл, который содержит сведения, используемые Visual Studio для определения платформы, для которой предназначен проект.

<a id="0.2_graphic1E"></a>![](overview/_static/image10.png)

Без этого свойства *targetFramework* Visual Studio по умолчанию будет нацелено на .NET Framework 2,0, чтобы сохранить совместимость при открытии старых приложений.

#### <a name="web-application-and-web-site-project-templates"></a>Шаблоны проектов веб-приложений и веб-сайтов

Два других новых шаблона проектов, поставляемых с Visual Studio 2010, содержат значительные изменения. На следующем рисунке показан макет проекта, который создается при создании нового проекта веб-приложения. (Макет для проекта веб-сайта практически идентичен.)

- <a id="0.2_graphic1F"></a>![](overview/_static/image11.png)

Проект содержит несколько файлов, которые не были созданы в более ранних версиях. Кроме того, в новом проекте веб-приложения настраивается базовая функциональность членства, что позволяет быстро приступить к защите доступа к новому приложению. По этой причине файл `Web.config` для нового проекта включает записи, используемые для настройки членства, ролей и профилей. В следующем примере показан файл `Web.config` для нового проекта веб-приложения. (В данном случае *roleManager* отключен.)

[![](overview/_static/image13.png)](overview/_static/image12.png)

([Щелкните, чтобы просмотреть изображение с полным размером](overview/_static/image14.png))

Проект также содержит второй файл `Web.config` в каталоге `Account`. Второй файл конфигурации предоставляет способ защиты доступа к странице ChangePassword. aspx для пользователей, не вошедших в систему. В следующем примере показано содержимое второго файла `Web.config`.

![](overview/_static/image15.png)

Страницы, созданные по умолчанию в новых шаблонах проектов, также содержат больше содержимого, чем в предыдущих версиях. Проект содержит главную страницу по умолчанию и файл CSS, а страница по умолчанию (Default. aspx) по умолчанию настроена на использование главной страницы. В результате при первом запуске веб-приложения или веб-сайта страница по умолчанию (Главная) уже работает. На самом деле он похож на страницу по умолчанию, которая отображается при запуске нового приложения MVC.

[![](overview/_static/image17.png)](overview/_static/image16.png)

([Щелкните, чтобы просмотреть изображение с полным размером](overview/_static/image18.png))

Цель этих изменений в шаблонах проектов — предоставить руководство по началу создания нового веб-приложения. В случае семантической корректной разметки, совместимой с XHTML 1,0, и с макетом, заданным с помощью CSS, страницы в шаблонах представляют собой рекомендации по созданию веб-приложений ASP.NET 4. Страницы по умолчанию также имеют макет с двумя столбцами, который можно легко настроить.

Например, предположим, что для нового веб-приложения необходимо изменить некоторые цвета и вставить логотип компании вместо логотипа приложения My ASP.NET. Для этого создайте новый каталог в разделе `Content` для хранения изображения логотипа:

<a id="0.2_graphic23"></a>![](overview/_static/image19.png)

Чтобы добавить изображение на страницу, откройте файл `Site.Master`, найдите место, где определен текст приложения My ASP.NET, и замените его на элемент *Image* , для которого в качестве атрибута *src* задано новое изображение логотипа, как показано в следующем примере:

[![](overview/_static/image21.png)](overview/_static/image20.png)

([Щелкните, чтобы просмотреть изображение с полным размером](overview/_static/image22.png))

Затем можно перейти в файл Site. CSS и изменить определения классов CSS, чтобы изменить цвет фона страницы, а также заголовок.

В результате этих изменений можно отобразить настроенную домашнюю страницу с минимальными усилиями:

[![](overview/_static/image24.png)](overview/_static/image23.png)

([Щелкните, чтобы просмотреть изображение с полным размером](overview/_static/image25.png))

<a id="0.2__Toc253429267"></a><a id="0.2__Toc243304641"></a>

### <a name="css-improvements"></a>Усовершенствования CSS

Одной из основных областей работы в ASP.NET 4 было помощь в визуализации HTML, совместимого с последними стандартами HTML. Сюда входят изменения в том, как ASP.NET веб-серверные элементы управления используют стили CSS.

#### <a name="compatibility-setting-for-rendering"></a>Параметр совместимости для подготовки к просмотру

По умолчанию, когда веб-приложение или веб-сайт предназначен для .NET Framework 4, атрибуту *контролрендерингкомпатибилитиверсион* элемента *pages* присваивается значение «4,0». Этот элемент определен в файле `Web.config` на уровне компьютера, и по умолчанию применяется ко всем приложениям ASP.NET 4:

[!code-xml[Main](overview/samples/sample69.xml)]

Значение для *контролрендерингкомпатибилити* — это строка, которая позволяет создавать новые определения версий в будущих выпусках. В текущем выпуске для этого свойства поддерживаются следующие значения:

- "3.5". Этот параметр указывает устаревшую отрисовку и разметку. Разметка, отображаемая элементами управления, обеспечивает обратную совместимость в 100%, а параметр свойства *ксхтмлконформанце* учитывается.
- "4.0". Если свойство имеет этот параметр, серверные веб-элементы управления ASP.NET выполняют следующие действия:
- Свойство *ксхтмлконформанце* всегда обрабатывается как "умеренное". В результате элементы управления визуализируют разметку XHTML 1,0.
- Отключение элементов управления, не являющихся входными данными, больше не отображает недопустимые стили.
- элементы *div* вокруг скрытых полей теперь являются стилями, поэтому они не влияют на созданные пользователем правила CSS.
- Элементы управления Menu отображают разметку, которая семантически верна и соответствует правилам специальных возможностей.
- Элементы управления проверки не отображают встроенные стили.
- Элементы управления, которые ранее отрисовывает границу = "0" (элементы управления, производные от элемента управления *таблицы* ASP.NET и элемента управления *Image* ASP.NET), больше не отображают этот атрибут.

#### <a name="disabling-controls"></a>Отключение элементов управления

В ASP.NET 3,5 с пакетом обновления 1 (SP1) и более ранних версиях платформа визуализирует атрибут *disabled* в разметке HTML для любого элемента управления, для которого свойство *Enabled* установлено в *значение false*. Однако в соответствии со спецификацией HTML 4,01 этот атрибут должен иметь только *входные* элементы.

В ASP.NET 4 можно присвоить свойству *контролрендерингкомпатибилитиверсион* значение "3,5", как показано в следующем примере:

[!code-xml[Main](overview/samples/sample70.xml)]

Разметку для элемента управления *Label* можно создать следующим образом, что отключает элемент управления:

[!code-aspx[Main](overview/samples/sample71.aspx)]

Элемент управления " *Метка* " выводит следующий код HTML:

[!code-html[Main](overview/samples/sample72.html)]

В ASP.NET 4 можно установить *контролрендерингкомпатибилитиверсион* в значение "4,0". В этом случае только элементы управления, которые визуализируют *входные* элементы, будут отображать *отключенный* атрибут, если свойство *Enabled* элемента управления имеет значение *false*. Элементы управления, которые не отображают HTML-элементы *ввода* , вместо этого отображают атрибут *класса* , ссылающийся на класс CSS, который можно использовать для определения отключенного вида элемента управления. Например, элемент управления *Label* , показанный в предыдущем примере, создаст следующую разметку:

[!code-html[Main](overview/samples/sample73.html)]

Значение по умолчанию для класса, указанного для этого элемента управления, — "Аспнетдисаблед". Однако это значение по умолчанию можно изменить, задав статическое свойство static *дисабледксскласс* класса *WebControl* . Для разработчиков элементов управления поведение, используемое для конкретного элемента управления, также может быть определено с помощью свойства *суппортсдисабледаттрибуте* .

<a id="0.2__Toc253429268"></a><a id="0.2__Toc243304642"></a>

### <a name="hiding-div-elements-around-hidden-fields"></a>Скрытие элементов div вокруг скрытых полей

ASP.NET 2,0 и более поздние версии визуализируют скрытые поля, связанные с системой (например, *скрытый* элемент, используемый для хранения сведений о состоянии представления) в элементе *div* , чтобы соответствовать стандарту XHTML. Однако это может привести к проблеме, когда правило CSS влияет на элементы *div* на странице. Например, это может привести к появлению однопиксельной линии на странице вокруг скрытых элементов *div* . В ASP.NET 4 элементы *div* , которые заключают скрытые поля, созданные ASP.NET, добавляют ссылку на класс CSS, как показано в следующем примере:

[!code-html[Main](overview/samples/sample74.html)]

Затем можно определить класс CSS, который применяется только к *скрытым* элементам, создаваемым ASP.NET, как показано в следующем примере:

[!code-css[Main](overview/samples/sample75.css)]

<a id="0.2__Toc253429269"></a><a id="0.2__Toc243304643"></a>

### <a name="rendering-an-outer-table-for-templated-controls"></a>Отрисовка внешней таблицы для шаблонных элементов управления

По умолчанию следующие элементы управления веб-сервера ASP.NET, поддерживающие шаблоны, автоматически упаковываются во внешнюю таблицу, которая используется для применения встроенных стилей:

- *C*
- *Имя входа*
- *пассвордрековери*
- *ChangePassword;*
- *Мастер*
- *CreateUserWizard*

В эти элементы управления было добавлено новое свойство с именем *RenderOuterTable* , позволяющее удалить внешнюю таблицу из разметки. Например, рассмотрим следующий пример элемента управления *FormView* :

[!code-aspx[Main](overview/samples/sample76.aspx)]

Эта разметка отображает следующие выходные данные на странице, в том числе HTML-таблицу:

[!code-html[Main](overview/samples/sample77.html)]

Чтобы предотвратить визуализацию таблицы, можно задать свойство *RenderOuterTable* элемента управления *FormView* , как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample78.aspx)]

В предыдущем примере отображаются следующие выходные данные без элементов *Table*, *tr*и *TD* :

> Содержимое

Это улучшение позволяет упростить стиль стиля содержимого элемента управления с помощью CSS, поскольку элемент управления не визуализирует непредвиденные Теги.

> [!NOTE]
> Обратите внимание, что это изменение отключает поддержку функции автоформатирования в конструкторе Visual Studio 2010, поскольку больше нет элемента *Table* , который может размещать атрибуты стиля, созданные с помощью параметра автоматического форматирования.

<a id="0.2__Toc253429270"></a><a id="0.2__Toc243304644"></a>

### <a name="listview-control-enhancements"></a>Улучшения элемента управления ListView

Элемент управления *ListView* стал проще в использовании в ASP.NET 4. В более ранней версии элемента управления требовалось указать шаблон макета, содержащий серверный элемент управления с известным ИДЕНТИФИКАТОРом. В следующей разметке показан типичный пример использования элемента управления *ListView* в ASP.NET 3,5.

[!code-aspx[Main](overview/samples/sample79.aspx)]

В ASP.NET 4 для элемента управления *ListView* не требуется шаблон макета. Разметка, показанная в предыдущем примере, может быть заменена следующей разметкой:

[!code-aspx[Main](overview/samples/sample80.aspx)]

<a id="0.2__Toc253429271"></a><a id="0.2__Toc243304645"></a>

### <a name="checkboxlist-and-radiobuttonlist-control-enhancements"></a>Улучшения элементов управления CheckBoxList и RadioButtonList

В ASP.NET 3,5 можно указать макет для *CheckBoxList* и *RadioButtonList* , используя следующие два параметра:

- *Flow*. Элемент управления визуализирует элементы *span* , чтобы они содержали его содержимое.
- *Таблица*. Элемент управления визуализирует элемент *Table* для хранения его содержимого.

В следующем примере показана разметка для каждого из этих элементов управления.

[!code-aspx[Main](overview/samples/sample81.aspx)]

По умолчанию элементы управления отображают HTML, как показано ниже:

[!code-html[Main](overview/samples/sample82.html)]

Поскольку эти элементы управления содержат списки элементов для визуализации семантически правильного кода HTML, они должны визуализировать свое содержимое с помощью элементов списка HTML (*Li*). Это упрощает для пользователей, которые читают веб-страницы с помощью вспомогательной технологии, и упрощает стиль элементов управления с помощью CSS.

В ASP.NET 4 элементы управления *CheckBoxList* и *RadioButtonList* поддерживают следующие новые значения для свойства *репеатлайаут* :

- *OrderedList* — содержимое подготавливается к просмотру в виде элементов *Li* в элементе *OL* .
- *Шаблонах unorderedlist* — содержимое подготавливается к просмотру в виде элементов *Li* в элементе *UL* .

В следующем примере показано, как использовать эти новые значения.

[!code-aspx[Main](overview/samples/sample83.aspx)]

Приведенная выше разметка создает следующий код HTML:

[!code-html[Main](overview/samples/sample84.html)]

> [!NOTE]
> Примечание. Если задать для *репеатлайаут* значение *OrderedList* или *шаблонах unorderedlist*, свойство *RepeatDirection* больше не будет использоваться и вызовет исключение во время выполнения, если свойство было задано в разметке или коде. Свойство не будет иметь значения, так как визуальный макет этих элементов управления определяется с помощью CSS.

<a id="0.2__Toc253429272"></a><a id="0.2__Toc243304646"></a>

### <a name="menu-control-improvements"></a>Улучшения элемента управления Menu

До ASP.NET 4 элемент управления *Menu* отрисовывает ряд HTML-таблиц. Это усложняет применение стилей CSS за пределами встроенных свойств и также не соответствует стандартам специальных возможностей.

В ASP.NET 4 элемент управления теперь отображает HTML с помощью семантической разметки, состоящей из неупорядоченного списка и элементов списка. В следующем примере показана разметка на странице ASP.NET для элемента управления *Menu* .

[!code-aspx[Main](overview/samples/sample85.aspx)]

При отрисовке страницы элемент управления создает следующий код HTML (для ясности не был указан фрагмент кода *OnClick* ):

[!code-html[Main](overview/samples/sample86.html)]

Помимо улучшений отрисовки, Навигация с помощью клавиатуры в меню была улучшена благодаря управлению фокусом. Когда элемент управления *Menu* получает фокус, для навигации по элементам можно использовать клавиши со стрелками. Теперь элемент управления Menu (« *меню»* ) также присоединяет доступные широкие роли и атрибуты Интернет-приложений (ARIA)[,](http://www.w3.org/TR/wai-aria-practices/#menu "Меню с рекомендациями по ARIA")использова для улучшения специальных возможностей.

Стили для элемента управления Menu отображаются в блоке style в верхней части страницы, а не в строке с готовыми элементами HTML. Если вы хотите получить полный контроль над стилями элемента управления, можно установить новое свойство *инклудестилеблокк* в *значение false*, в этом случае блок style не будет выдаваться. Одним из способов использования этого свойства является использование функции автоматического форматирования в конструкторе Visual Studio для установки внешнего вида меню. Затем можно запустить страницу, открыть источник страницы, а затем скопировать готовый блок стиля во внешний файл CSS. В Visual Studio отмените стиль и задайте для *инклудестилеблокк* значение *false*. В результате внешний вид меню определяется с помощью стилей во внешней таблице стилей.

<a id="0.2__Toc253429273"></a><a id="0.2__Toc243304647"></a>

### <a name="wizard-and-createuserwizard-controls"></a>Мастер и элементы управления CreateUserWizard

*Мастер* ASP.NET и элементы управления *CreateUserWizard* поддерживают шаблоны, позволяющие определить HTML-код, который они отображают. (*CreateUserWizard* является производным от *мастера*.) В следующем примере показана разметка для полностью шаблонного элемента управления *CreateUserWizard* :

[!code-aspx[Main](overview/samples/sample87.aspx)]

Элемент управления визуализирует HTML-код, аналогичный следующему:

[!code-html[Main](overview/samples/sample88.html)]

В ASP.NET 3,5 с пакетом обновления 1 (SP1), хотя вы можете изменить содержимое шаблона, вы по-прежнему имеете ограниченный контроль над выходными данными элемента управления *Wizard* . В ASP.NET 4 можно создать шаблон *LayoutTemplate* и вставить элементы управления *PlaceHolder* (с помощью зарезервированных имен), чтобы указать, как должен отображаться *элемент управления мастера* . Это показано в следующем примере:

[!code-aspx[Main](overview/samples/sample89.aspx)]

Пример содержит следующие именованные заполнители в элементе *LayoutTemplate* :

- *хеадерплацехолдер* — во время выполнения это заменяется содержимым элемента *HeaderTemplate* .
- *сидебарплацехолдер* — во время выполнения это заменяется содержимым элемента *SideBarTemplate* .
- *визардстепплацехолдер* — во время выполнения это заменяется содержимым элемента *визардстептемплате* .
- *навигатионплацехолдер* — во время выполнения это заменяется любыми заданными вами шаблонами навигации.

Разметка в примере, в которой используются заполнители, отображает следующий HTML (без содержимого, фактически определенного в шаблонах):

[!code-html[Main](overview/samples/sample90.html)]

Единственный HTML, который теперь не является определяемым пользователем, — это элемент *span* . (Мы предполагаем, что в будущих выпусках даже элемент *span* не будет визуализирован.) Теперь вы получаете полный контроль над содержимым, созданным элементом управления *мастера* .

<a id="0.2_dyndata"></a><a id="0.2__Toc253429274"></a><a id="0.2__Toc243304648"></a><a id="0.2__Toc224729042"></a>

## <a name="aspnet-mvc"></a>ASP.NET MVC 3

ASP.NET MVC впервые появился в качестве надстройки для ASP.NET 3,5 с пакетом обновления 1 (SP1) в марте 2009. Visual Studio 2010 включает ASP.NET MVC 2, который включает в себя новые функции и возможности.

<a id="0.2__Toc253429275"></a>

### <a name="areas-support"></a>Поддержка областей

Области позволяют группировать контроллеры и представления в разделы крупного приложения с относительным уровнем изоляции от других разделов. Каждая область может быть реализована как отдельный проект ASP.NET MVC, на который затем может ссылаться основное приложение. Это помогает управлять сложностью при создании большого приложения и упрощает совместную работу нескольких групп в одном приложении.

<a id="0.2__Toc253429276"></a>

### <a name="data-annotation-attribute-validation-support"></a>Поддержка проверки атрибутов в заметках данных

Атрибуты *примечаний* позволяют присоединить логику проверки к модели с помощью атрибутов метаданных. Атрибуты *примечаний* появились в ASP.NET платформа динамических данных в ASP.NET 3,5 с пакетом обновления 1 (SP1). Эти атрибуты были интегрированы в связыватель модели по умолчанию и предоставляют управляемые метаданными средства для проверки вводимых пользователем данных.

<a id="0.2__Toc253429277"></a>

### <a name="templated-helpers"></a>Шаблоны вспомогательных функций

Шаблонные вспомогательные методы позволяют автоматически связывать шаблоны правки и вывода с типами данных. Например, можно использовать вспомогательный метод шаблона, чтобы указать, что элемент пользовательского интерфейса средства выбора даты автоматически визуализируется для значения *System. DateTime* . Это похоже на шаблоны полей в ASP.NET платформа динамических данных.

Вспомогательные методы *HTML. едиторфор* и *HTML. DisplayFor* имеют встроенную поддержку визуализации стандартных типов данных, а также сложных объектов с несколькими свойствами. Они также настраивают отрисовку, позволяя применять атрибуты аннотации данных, такие как *DisplayName* и *скаффолдколумн* , к объекту *ViewModel* .

Часто требуется настроить вывод вспомогательных функций пользовательского интерфейса, а также получить полный контроль над созданными данными. Вспомогательные методы *HTML. едиторфор* и *HTML. DisplayFor* поддерживают это с помощью механизма шаблонов, который позволяет определять внешние шаблоны, которые могут переопределять и контролировать отображаемые выходные данные. Шаблоны можно отрисовывать по отдельности для класса.

<a id="0.2__Toc253429278"></a><a id="0.2__Toc243304649"></a>

## <a name="dynamic-data"></a>динамические данные

Платформа динамических данных был представлен в выпуске .NET Framework 3,5 с пакетом обновления 1 (SP1) в середине 2008. Эта функция предоставляет множество улучшений для создания приложений на основе данных, включая следующие:

- Интерфейс RAD для быстрого создания веб-сайта, управляемого данными.
- Автоматическая проверка, основанная на ограничениях, определенных в модели данных.
- Возможность легко изменять разметку, создаваемую для полей в элементах управления *GridView* и *DetailsView* , с помощью шаблонов полей, которые являются частью проекта платформа динамических данных.

> [!NOTE]
> Примечание. Дополнительные сведения см. в [документации по платформа динамических данных](https://msdn.microsoft.com/library/cc488545.aspx) в библиотеке MSDN.

Для ASP.NET 4 платформа динамических данных был усовершенствован, чтобы предоставить разработчикам еще больше возможностей для быстрого создания веб-узлов, управляемых данными.

<a id="0.2__Toc253429279"></a><a id="0.2__Toc243304650"></a>

### <a name="enabling-dynamic-data-for-existing-projects"></a>Включение платформа динамических данных для существующих проектов

Платформа динамических данных функции, поставляемые в .NET Framework 3,5 с пакетом обновления 1 (SP1), добавлены следующие новые функции:

- Шаблоны полей — предоставляют шаблоны на основе типов данных для элементов управления с привязкой к данным. Шаблоны полей предоставляют более простой способ настройки вида элементов управления данными, чем использование полей шаблона для каждого поля.
- Проверка — платформа динамических данных позволяет использовать атрибуты в классах данных для указания проверки распространенных сценариев, таких как обязательные поля, проверка диапазона, проверка типов, сопоставление шаблонов с помощью регулярных выражений и пользовательская проверка. Проверка обеспечивается элементами управления данными.

Однако для этих функций предъявляются следующие требования.

- Уровень доступа к данным должен быть основан на Entity Framework или LINQ to SQL.
- Единственными элементами управления источниками данных, поддерживаемыми для этих функций, являются элементы управления *EntityDataSource* или *LinqDataSource* .
- Функции, необходимые для веб-проекта, созданного с помощью платформа динамических данных или платформа динамических данных шаблонов сущностей, для получения всех файлов, необходимых для поддержки этой функции.

Основной целью поддержки платформа динамических данных в ASP.NET 4 является включение новых функций платформа динамических данных для любого приложения ASP.NET. В следующем примере показана разметка для элементов управления, которые могут использовать преимущества платформа динамических данных функциональных возможностей на существующей странице.

[!code-aspx[Main](overview/samples/sample91.aspx)]

В коде для страницы необходимо добавить следующий код, чтобы включить поддержку платформа динамических данных для этих элементов управления:

[!code-csharp[Main](overview/samples/sample92.cs)]

Когда элемент управления *GridView* находится в режиме редактирования, платформа динамических данных автоматически проверяет правильность вводимых данных в соответствующем формате. Если это не так, выводится сообщение об ошибке.

Эта функция также предоставляет другие преимущества, например возможность указывать значения по умолчанию для режима вставки. Без платформа динамических данных для реализации значения по умолчанию для поля необходимо присоединиться к событию, определить элемент управления (с помощью *финдконтрол*) и задать его значение. В ASP.NET 4 вызов *енаблединамикдата* поддерживает второй параметр, который позволяет передавать значения по умолчанию для любого поля объекта, как показано в следующем примере:

[!code-csharp[Main](overview/samples/sample93.cs)]

<a id="0.2__Toc224729043"></a><a id="0.2__Toc253429280"></a><a id="0.2__Toc243304651"></a>

### <a name="declarative-dynamicdatamanager-control-syntax"></a>Декларативный синтаксис элемента управления DynamicDataManager

Элемент управления *DynamicDataManager* был усовершенствован, поэтому его можно настроить декларативно, как и большинство элементов управления в ASP.NET, а не только в коде. Разметка для элемента управления *DynamicDataManager* выглядит как в следующем примере:

[!code-aspx[Main](overview/samples/sample94.aspx)]

Эта разметка включает платформа динамических данныхное поведение для элемента управления GridView1, на который указывает ссылка в разделе " *элементы управления* " элемента управления *DynamicDataManager* .

<a id="0.2__Toc224729044"></a><a id="0.2__Toc253429281"></a><a id="0.2__Toc243304652"></a>

### <a name="entity-templates"></a>Шаблоны сущностей

Шаблоны сущностей предлагают новый способ настройки макета данных без необходимости создавать пользовательскую страницу. Шаблоны страниц используют элемент управления *FormView* (вместо элемента управления *DetailsView* , который используется в шаблонах страниц в более ранних версиях платформа динамических данных) и элемент управления *DynamicControl* для отрисовки шаблонов сущностей. Это обеспечивает более полный контроль над разметкой, отображаемой платформа динамических данных.

В следующем списке показан новый макет каталога проекта, содержащий шаблоны сущностей.

[!code-console[Main](overview/samples/sample95.cmd)]

Каталог `EntityTemplate` содержит шаблоны для отображения объектов модели данных. По умолчанию объекты подготавливаются к просмотру с помощью шаблона `Default.ascx`, который предоставляет разметку, которая выглядит так же, как разметка, созданная элементом управления *DetailsView* , используемой платформа динамических данных в ASP.NET 3,5 с пакетом обновления 1 (SP1). В следующем примере показана разметка для элемента управления `Default.ascx`.

[!code-aspx[Main](overview/samples/sample96.aspx)]

Шаблоны по умолчанию можно изменять для изменения внешнего вида и поведения всего сайта. Существуют шаблоны для операций вывода, редактирования и вставки. Новые шаблоны можно добавлять на основе имени объекта данных, чтобы изменить внешний вид всего одного типа объекта. Например, можно добавить следующий шаблон:

[!code-console[Main](overview/samples/sample97.cmd)]

Шаблон может содержать следующую разметку:

[!code-aspx[Main](overview/samples/sample98.aspx)]

Новые шаблоны сущностей отображаются на странице с помощью нового элемента управления *DynamicControl* . Во время выполнения этот элемент управления заменяется содержимым шаблона сущности. В следующей разметке показан элемент управления *FormView* в шаблоне страницы `Detail.aspx`, который использует шаблон сущности. Обратите внимание на элемент *DynamicControl* в разметке.

[!code-aspx[Main](overview/samples/sample99.aspx)]

<a id="0.2__Toc224729045"></a><a id="0.2__Toc253429282"></a><a id="0.2__Toc243304653"></a>

### <a name="new-field-templates-for-urls-and-email-addresses"></a>Новые шаблоны полей для URL-адресов и адресов электронной почты

В ASP.NET 4 появились два новых встроенных шаблона полей: `EmailAddress.ascx` и `Url.ascx`. Эти шаблоны используются для полей, которые помечены как *EmailAddress* или *URL-адрес* с атрибутом *DataType* . Для объектов *EmailAddress* поле отображается как гиперссылка, созданная с помощью протокола *mailto:* . Когда пользователь щелкнул ссылку, он открывает почтовый клиент пользователя и создает каркас сообщения. Объекты, типизированные как *URL-адреса* , отображаются как обычные гиперссылки.

В следующем примере показано, как будут помечены поля.

[!code-csharp[Main](overview/samples/sample100.cs)]

<a id="0.2__Toc224729046"></a><a id="0.2__Toc253429283"></a><a id="0.2__Toc243304654"></a>

### <a name="creating-links-with-the-dynamichyperlink-control"></a>Создание ссылок с помощью элемента управления DynamicHyperLink

Платформа динамических данных использует новую функцию маршрутизации, добавленную в .NET Framework 3,5 с пакетом обновления 1 (SP1), для управления URL-адресами, которые конечные пользователи видят при доступе к веб-сайту. Новый элемент управления *DynamicHyperLink* упрощает создание ссылок на страницы на платформа динамических данных сайте. В следующем примере показано, как использовать элемент управления *DynamicHyperLink* :

[!code-aspx[Main](overview/samples/sample101.aspx)]

Эта разметка создает ссылку, которая указывает на страницу списка для `Products`ной таблицы на основе маршрутов, определенных в файле `Global.asax`. Элемент управления автоматически использует имя таблицы по умолчанию, на которой основана платформа динамических данных страница.

<a id="0.2__Toc224729047"></a><a id="0.2__Toc253429284"></a><a id="0.2__Toc243304655"></a>

### <a name="support-for-inheritance-in-the-data-model"></a>Поддержка наследования в модели данных

Entity Framework и LINQ to SQL поддерживают наследование в моделях данных. Примером может быть база данных с `InsurancePolicy` таблицей. Он также может содержать `CarPolicy` и `HousePolicy` таблицы с теми же полями, что и `InsurancePolicy`, а затем добавлять дополнительные поля. Платформа динамических данных были изменены, чтобы понять унаследованные объекты в модели данных и поддерживать формирование шаблонов для наследуемых таблиц.

<a id="0.2__Toc224729048"></a><a id="0.2__Toc253429285"></a><a id="0.2__Toc243304656"></a>

### <a name="support-for-many-to-many-relationships-entity-framework-only"></a>Поддержка связей "многие ко многим" (только Entity Framework)

Entity Framework имеет широкую поддержку связей "многие ко многим" между таблицами, которая реализуется путем предоставления связи в виде коллекции объекта *сущности* . Добавлены новые шаблоны полей `ManyToMany.ascx` и `ManyToMany_Edit.ascx`, обеспечивающие поддержку отображения и редактирования данных, участвующих в связях «многие ко многим».

<a id="0.2__Toc224729049"></a><a id="0.2__Toc253429286"></a><a id="0.2__Toc243304657"></a>

### <a name="new-attributes-to-control-display-and-support-enumerations"></a>Новые атрибуты для управления отображением и поддержкой перечислений

*Дисплайаттрибуте* был добавлен для предоставления дополнительного контроля над отображением полей. Атрибут *DisplayName* в более ранних версиях платформа динамических данных позволял изменить имя, которое будет использоваться в качестве заголовка поля. Новый класс *дисплайаттрибуте* позволяет задать дополнительные параметры для отображения поля, например порядок, в котором отображается поле, а также указать, будет ли поле использоваться в качестве фильтра. Атрибут также предоставляет независимый контроль над именем, используемым для меток в элементе управления *GridView* , имя, используемое в элементе управления *DetailsView* , текст справки для поля и знак, используемый для поля (если поле допускает ввод текста).

Добавлен класс *енумдататипеаттрибуте* , позволяющий сопоставлять поля с перечислениями. При применении этого атрибута к полю указывается тип перечисления. Платформа динамических данных использует новый шаблон поля `Enumeration.ascx` для создания пользовательского интерфейса для отображения и редактирования значений перечисления. Шаблон сопоставляет значения из базы данных с именами в перечислении.

<a id="0.2__Toc224729050"></a><a id="0.2__Toc253429287"></a><a id="0.2__Toc243304658"></a>

### <a name="enhanced-support-for-filters"></a>Улучшенная поддержка фильтров

Платформа динамических данных 1,0 поставляется со встроенными фильтрами для логических столбцов и столбцов внешнего ключа. Фильтры не позволяли указывать, отображаются ли они или в каком порядке они отображались. Новый атрибут *дисплайаттрибуте* решает эти проблемы, позволяя контролировать, отображается ли столбец в качестве фильтра и в каком порядке он будет отображаться.

Дополнительное улучшение заключается в том, что поддержка фильтрации была[переписана для использования новой](#0.2__QueryExtender "_QueryExtender") функции веб-форм. Это позволяет создавать фильтры, не требуя знания элементов управления источниками данных, с которыми будут использоваться фильтры. Помимо этих расширений, фильтры также были включены в элементы управления шаблонами, что позволяет добавлять новые. Наконец, упомянутый выше класс *дисплайаттрибуте* позволяет переопределять фильтр по умолчанию так же, как *UIHint* позволяет переопределять шаблон поля по умолчанию для столбца.

<a id="0.2__Toc224729051"></a><a id="0.2__Toc253429288"></a><a id="0.2__Toc243304659"></a>

## <a name="visual-studio-2010-web-development-improvements"></a>Усовершенствования веб-разработки в Visual Studio 2010

Веб-разработка в Visual Studio 2010 была улучшена для обеспечения большей совместимости с CSS, повышения производительности с помощью фрагментов кода разметки HTML и ASP.NET и нового динамического IntelliSense JavaScript.

<a id="0.2__Toc224729052"></a><a id="0.2__Toc253429289"></a><a id="0.2__Toc243304660"></a>

### <a name="improved-css-compatibility"></a>Улучшенная совместимость с CSS

В Visual Studio 2010 был обновлен конструктор Visual Web Developer для улучшения соответствия стандартам CSS 2,1. Конструктор лучше сохраняет целостность исходного кода HTML и является более надежным, чем в предыдущих версиях Visual Studio. Помимо прочего, улучшены архитектурные улучшения, которые улучшат будущие улучшения отрисовки, макета и обслуживания.

<a id="0.2__Toc224729053"></a><a id="0.2__Toc253429290"></a><a id="0.2__Toc243304661"></a>

### <a name="html-and-javascript-snippets"></a>Фрагменты кода HTML и JavaScript

В редакторе HTML функция IntelliSense Auto завершает имена тегов. Функция IntelliSense выполняет автоматическое заполнение всех тегов и многое другое. В Visual Studio 2010 фрагменты IntelliSense поддерживаются для JavaScript наряду C# с Visual Basic, которые поддерживались в более ранних версиях Visual Studio.

Visual Studio 2010 включает более 200 фрагментов кода, которые помогают в автоматическом заполнении стандартных тегов ASP.NET и HTML, включая необходимые атрибуты (например, runat = "Server") и общие атрибуты, характерные для тега (например, *ID*, *DataSourceID*, *ControlToValidate*и *Text*).

Вы можете скачать дополнительные фрагменты кода или написать собственные фрагменты кода, которые инкапсулируют блоки разметки, используемые вами или вашей командой для выполнения общих задач.

<a id="0.2__Toc224729054"></a><a id="0.2__Toc253429291"></a><a id="0.2__Toc243304662"></a>

### <a name="javascript-intellisense-enhancements"></a>Усовершенствования IntelliSense в JavaScript

В Visual 2010 технология JavaScript IntelliSense была переработана, чтобы обеспечить более широкие возможности редактирования. IntelliSense теперь распознает объекты, которые были динамически созданы такими методами, как *регистернамеспаце* , и аналогичными методами, используемыми другими платформами JavaScript. Улучшена производительность для анализа больших библиотек сценариев и отображения IntelliSense с минимальной задержкой обработки или без нее. Совместимость значительно увеличилась для поддержки практически всех библиотек сторонних производителей и поддержки различных стилей программирования. Комментарии к документации теперь анализируются при вводе и немедленно используются технологией IntelliSense.

<a id="0.2__Toc224729055"></a><a id="0.2__Toc253429292"></a><a id="0.2__Toc243304663"></a>

## <a name="web-application-deployment-with-visual-studio-2010"></a>Развертывание веб-приложений с помощью Visual Studio 2010

При развертывании веб-приложения ASP.NET разработчики часто сталкиваются с такими проблемами:

- Для развертывания на общем сайте размещения требуются такие технологии, как FTP, которые могут быть слишком длительными. Кроме того, необходимо вручную выполнять такие задачи, как выполнение скриптов SQL для настройки базы данных, и необходимо изменить параметры IIS, такие как Настройка папки виртуального каталога в качестве приложения.
- В среде предприятия, помимо развертывания файлов веб-приложений, администраторы часто должны изменять файлы конфигурации ASP.NET и параметры IIS. Для запуска базы данных приложения администраторы баз данных должны выполнить ряд сценариев SQL. Такие установки требуют интенсивного выполнения операций, и их необходимо тщательно задокументировать.

Visual Studio 2010 включает в себя технологии, которые устраняют эти проблемы и позволяют без проблем развертывать веб-приложения. Одной из этих технологий является средство веб-развертывания IIS (MsDeploy. exe).

Функции веб-развертывания в Visual Studio 2010 включают в себя следующие основные области:

- Веб-упаковка
- Преобразование web. config
- Развертывание базы данных
- Публикация одним щелчком для веб-приложений

Следующие разделы содержат сведения об этих функциях.

<a id="0.2__Toc224729056"></a><a id="0.2__Toc253429293"></a><a id="0.2__Toc243304664"></a>

### <a name="web-packaging"></a>Веб-упаковка

Visual Studio 2010 использует средство MSDeploy для создания сжатого файла (ZIP) для приложения, который называется *веб-пакетом*. Файл пакета содержит метаданные о приложении, а также следующее содержимое:

- Параметры IIS, включая параметры пула приложений, параметры страницы ошибок и т. д.
- Реальное веб-содержимое, которое включает веб-страницы, пользовательские элементы управления, статическое содержимое (изображения и HTML-файлы) и т. д.
- SQL Server схемы и данные баз данных.
- Сертификаты безопасности, компоненты для установки в глобальном кэше сборок, параметры реестра и т. д.

Веб-пакет можно скопировать на любой сервер, а затем установить вручную с помощью диспетчера служб IIS. Кроме того, для автоматического развертывания пакет можно установить с помощью команд командной строки или с помощью API-интерфейсов развертывания.

Visual Studio 2010 предоставляет встроенные задачи и целевые объекты MSBuild для создания веб-пакетов. Дополнительные сведения см. в разделе [Обзор развертывания проекта веб-приложения ASP.NET](https://msdn.microsoft.com/library/dd394698%28VS.100%29.aspx) на веб-сайте MSDN и [10 + 20 причин, по которым следует создать веб-пакет](http://vishaljoshi.blogspot.com/2009/07/10-20-reasons-why-you-should-create-web.html) в блоге Вишал Джоши.

<a id="0.2__Toc224729057"></a><a id="0.2__Toc253429294"></a><a id="0.2__Toc243304665"></a>

### <a name="webconfig-transformation"></a>Преобразование web. config

Для развертывания веб-приложений в Visual Studio 2010 введено [Преобразование XML-документов (xdt)](http://vishaljoshi.blogspot.com/2009/03/web-deployment-webconfig-transformation_23.html), которое позволяет преобразовать файл `Web.config` из параметров разработки в параметры рабочей среды. Параметры преобразования указываются в файлах преобразования с именами `web.debug.config`, `web.release.config`и т. д. (Имена этих файлов соответствуют конфигурациям MSBuild.) Файл преобразования включает только изменения, которые необходимо внести в развернутый файл `Web.config`. Изменения задаются с помощью простого синтаксиса.

В следующем примере показана часть файла `web.release.config`, которая может быть создана для развертывания конфигурации выпуска. Ключевое слово Replace в примере указывает, что во время развертывания узел *ConnectionString* в файле `Web.config` будет заменен значениями, перечисленными в примере.

[!code-xml[Main](overview/samples/sample102.xml)]

Дополнительные сведения см. в статье [синтаксис преобразования Web. config для развертывания проекта веб-приложения](https://msdn.microsoft.com/library/dd465326%28VS.100%29.aspx) на <a id="0.2_a"></a> веб-сайте MSDN и[веб-развертывании: преобразование web. config](http://vishaljoshi.blogspot.com/2009/03/web-deployment-webconfig-transformation_23.html) в блоге Вишал Джоши.

<a id="0.2__Toc224729058"></a><a id="0.2__Toc253429295"></a><a id="0.2__Toc243304666"></a>

### <a name="database-deployment"></a>Развертывание базы данных

Пакет развертывания Visual Studio 2010 может включать зависимости от SQL Server баз данных. В рамках определения пакета вы предоставляете строку подключения для базы данных источника. При создании веб-пакета Visual Studio 2010 создает скрипты SQL для схемы базы данных и (необязательно) для данных, а затем добавляет их в пакет. Можно также предоставить пользовательские скрипты SQL и указать последовательность, в которой они должны выполняться на сервере. Во время развертывания вы предоставляете строку подключения, соответствующую целевому серверу. Затем процесс развертывания использует эту строку подключения для выполнения скриптов, которые создают схему базы данных и добавляют данные.

Кроме того, с помощью публикации одним щелчком можно настроить развертывание для публикации базы данных непосредственно при публикации приложения на удаленном общем сайте. Дополнительные сведения см. в статье [как развернуть базу данных с проектом веб-приложения](https://msdn.microsoft.com/library/dd465343%28VS.100%29.aspx) на веб-сайте MSDN и в разделе [развертывание базы данных с помощью VS 2010](http://vishaljoshi.blogspot.com/2009/03/web-deployment-webconfig-transformation_23.html) в блоге по Вишал Джоши.

<a id="0.2__Toc224729059"></a><a id="0.2__Toc253429296"></a><a id="0.2__Toc243304667"></a>

### <a name="one-click-publish-for-web-applications"></a>Публикация одним щелчком для веб-приложений

Visual Studio 2010 также позволяет использовать службу удаленного управления IIS для публикации веб-приложения на удаленном сервере. Вы можете создать профиль публикации для учетной записи размещения или для тестовых серверов или промежуточных серверов. Каждый профиль может безопасно сохранять соответствующие учетные данные. Затем можно выполнить развертывание на любом из целевых серверов одним щелчком мыши, используя веб-панель инструментов публикации одним щелчком. В Visual Studio 2010 можно также выполнить публикацию с помощью командной строки MSBuild. Это позволяет настроить среду сборки группы для включения публикации в модель непрерывной интеграции.

Дополнительные сведения см. в разделе [как развернуть проект веб-приложения с помощью портала публикации и веб-развертывание](https://msdn.microsoft.com/library/dd465337%28VS.100%29.aspx) на веб-сайте MSDN и веб-узла [1. Щелкните ОПУБЛИКОВАТЬ с помощью VS 2010](http://vishaljoshi.blogspot.com/2009/05/web-1-click-publish-with-vs-2010.html) в блоге по Вишал Джоши. Чтобы просмотреть видеопрезентации о развертывании веб-приложений в Visual Studio 2010, ознакомьтесь с разделом [VS 2010 для предварительного просмотра веб-разработчиков](http://vishaljoshi.blogspot.com/2008/12/vs-2010-for-web-developer-previews.html) в блоге по Вишал Джоши.

<a id="0.2__Toc224729060"></a><a id="0.2__Toc253429297"></a><a id="0.2__Toc243304668"></a>

### <a name="resources"></a>Ресурсы

Следующие веб-сайты содержат дополнительные сведения о ASP.NET 4 и Visual Studio 2010.

- [ASP.NET 4](https://msdn.microsoft.com/library/ee532866%28VS.100%29.aspx) — официальная документация по ASP.NET 4 на веб-сайте MSDN.
- [https://www.asp.net/](https://www.asp.net/) — собственный веб-сайт команды ASP.NET.
- [https://www.asp.net/dynamicdata/](https://msdn.microsoft.com/library/cc488545.aspx) и [ASP.NET платформа динамических данных карту содержимого](https://msdn.microsoft.com/library/cc488545%28VS.100%29.aspx) — сетевые ресурсы на сайте группы ASP.NET и официальная документация по ASP.NET платформа динамических данных.
- [https://www.asp.net/ajax/](../../ajax/index.md) — основной веб-ресурс для разработки AJAX ASP.NET.
- [https://blogs.msdn.com/webdevtools/](https://blogs.msdn.com/webdevtools/) — блог группы разработчиков Visual Web Developer, который содержит сведения о функциях visual Studio 2010.
- [ASP.NET Web Stack](https://github.com/aspnet/AspNetWebStack) — основной веб-ресурс для предварительных выпусков ASP.NET.

<a id="0.2__Toc224729061"></a><a id="0.2__Toc253429298"></a><a id="0.2__Toc243304669"></a>

## <a name="disclaimer"></a>Отказ от ответственности

Это предварительный документ, он может быть существенно изменен до выхода окончательного коммерческого выпуска описанного здесь программного обеспечения.

Информация, содержащаяся в этом документе, являет собой текущее представление корпорации Майкрософт о вопросах, которые обсуждались на момент публикации. Поскольку корпорация Майкрософт должна реагировать на изменение рыночных условий, эта информация не должна рассматриваться как обязательство корпорации Майкрософт. Корпорация Майкрософт не может гарантировать достоверность информации, предоставленной после момента публикации.

Данный технический документ предназначен только для ознакомительных целей. МАЙКРОСОФТ НЕ ПРЕДОСТАВЛЯЕТ НИКАКИХ ГАРАНТИЙ, ЯВНЫХ ИЛИ ПРЕДУСМОТРЕННЫХ ЗАКОНОДАТЕЛЬСТВОМ, ОТНОСИТЕЛЬНО СВЕДЕНИЙ, СОДЕРЖАЩИХСЯ В ДАННОМ ДОКУМЕНТЕ.

Ответственность за соблюдение всех авторских прав и прав на интеллектуальную собственность целиком и полностью несет пользователь. Без ограничения авторских прав ни одна из частей этого документа не может быть воспроизведена, сохранена или использована в системах поиска либо передана в любой форме, любыми способами (электронными, механическими, в виде фотокопии, в виде записи или любыми другими) и для любых целей без письменного разрешения корпорации Майкрософт.

Корпорация Майкрософт может иметь патенты, патентные заявки, охраняемые товарные знаки, авторские или другие права на интеллектуальную собственность применительно к содержимому этого документа. Без письменного разрешения корпорации Майкрософт данный документ не дает лицензии на эти патенты, охраняемые товарные знаки, авторские права и другую интеллектуальную собственность.

Если не указано иное, примеры компаний, организаций, продуктов, доменных имен, адресов электронной почты, логотипов, людей, мест и событий являются вымышленными и без связи с реальными компаниями, организациями, продуктами, именами доменов, электронной почтой. адрес, Эмблема, лицо, место или событие должны быть выведены на случай.

© 2009 Корпорация Майкрософт. Все права защищены.

Microsoft и Windows являются охраняемыми товарными знаками корпорации Майкрософт в США и других странах.

Названия фактических компаний и продуктов, упомянутые здесь, могут являться охраняемыми товарными знаками соответствующих владельцев.
