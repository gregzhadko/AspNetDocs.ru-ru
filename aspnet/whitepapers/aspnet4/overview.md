---
uid: whitepapers/aspnet4/overview
title: ASP.NET 4 и Visual Studio 2010 Web Общие сведения о разработке | Документация Майкрософт
author: rick-anderson
description: Этот документ содержит обзор многих новых функций для ASP.NET, которые включены в.NET Framework 4 и в Visual Studio 2010.
ms.author: riande
ms.date: 02/10/2010
ms.assetid: d7729af4-1eda-4ff2-8b61-dbbe4fc11d10
msc.legacyurl: /whitepapers/aspnet4
msc.type: content
ms.openlocfilehash: 0991ce5c866aa9e31ef23812e953d9ee10dda3d1
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59409724"
---
# <a name="aspnet-4-and-visual-studio-2010-web-development-overview"></a>Общие сведения о веб-разработке в ASP.NET 4 и Visual Studio 2010

> Этот документ содержит обзор многих новых функций для ASP.NET, которые включены в.NET Framework 4 и в Visual Studio 2010.
> 
> [Скачайте этот технический документ](https://download.microsoft.com/download/7/1/A/71A105A9-89D6-4201-9CC5-AD6A3B7E2F22/ASP_NET_4_and_Visual_Studio_2010_Web_Development_Overview.pdf)


**Описание**

**[Основные службы](#0.2__Toc253429238 "_Toc253429238")**  
[Файл Web.config рефакторинг](#0.2__Toc253429239 "_Toc253429239")  
[Расширяемое кэширование вывода](#0.2__Toc253429240 "_Toc253429240")  
[Автоматический запуск веб-приложений](#0.2__Toc253429241 "_Toc253429241")  
[Окончательное перемещение страницы](#0.2__Toc253429242 "_Toc253429242")  
[Сжатие состояния сеанса](#0.2__Toc253429243 "_Toc253429243")  
[Расширяя диапазон допустимых URL-адресов](#0.2__Toc253429244 "_Toc253429244")  
[Расширяемая проверка запросов](#0.2__Toc253429245 "_Toc253429245")  
[Кэширование объектов и расширяемость кэширования объектов](#0.2__Toc253429246 "_Toc253429246")  
[Расширяемая HTML, URL-адреса и кодировку заголовка HTTP](#0.2__Toc253429247 "_Toc253429247")  
[Мониторинг производительности для отдельных приложений в одном рабочем процессе](#0.2__Toc253429248 "_Toc253429248")  
[Multi-Targeting](#0.2__Toc253429249 "_Toc253429249")

**[Ajax](#0.2__Toc253429250 "_Toc253429250")**  
[jQuery в комплекте с Web Forms и MVC](#0.2__Toc253429251 "_Toc253429251")  
[Поддержка сети доставки содержимого](#0.2__Toc253429252 "_Toc253429252")  
[Явные сценарии ScriptManager](#0.2__Toc253429253 "_Toc253429253")

**[Веб-формы](#0.2__Toc253429256 "_Toc253429256")**  
[Параметр метатегов с Page.MetaKeywords и свойствами Page.MetaDescription](#0.2__Toc253429257 "_Toc253429257")  
[Включение состояния представления для отдельных элементов управления](#0.2__Toc253429258 "_Toc253429258")  
[Изменения в возможностях обозревателя](#0.2__Toc253429259 "_Toc253429259")  
[Маршрутизация в ASP.NET 4](#0.2__Toc253429260 "_Toc253429260")  
[Установка клиентских идентификаторов](#0.2__Toc253429261 "_Toc253429261")  
[Сохранение выбора строки в элементах управления данными](#0.2__Toc253429262 "_Toc253429262")  
[Элемент управления диаграммы для ASP.NET](#0.2__Toc253429263 "_Toc253429263")  
[Фильтрация данных с помощью элемента управления](#0.2__Toc253429264 "_Toc253429264")  
[Выражения кода в кодировке HTML](#0.2__Toc253429265 "_Toc253429265")  
[Изменение шаблонов проектов](#0.2__Toc253429266 "_Toc253429266")  
[Усовершенствования CSS](#0.2__Toc253429267 "_Toc253429267")  
[Скрытие элементов вокруг скрытые поля div](#0.2__Toc253429268 "_Toc253429268")  
[Подготовка к просмотру внешняя таблица шаблонных элементов управления](#0.2__Toc253429269 "_Toc253429269")  
[Улучшенные элементы управления ListView](#0.2__Toc253429270 "_Toc253429270")  
[CheckBoxList и улучшенные элементы управления RadioButtonList](#0.2__Toc253429271 "_Toc253429271")  
[Усовершенствования управления меню](#0.2__Toc253429272 "_Toc253429272")  
[Мастера и элементы управления CreateUserWizard 56](#0.2__Toc253429273 "_Toc253429273")

**[ASP.NET MVC](#0.2__Toc253429274 "_Toc253429274")**  
[Поддержка областей](#0.2__Toc253429275 "_Toc253429275")  
[Поддержка проверки заметок к данным атрибута](#0.2__Toc253429276 "_Toc253429276")  
[Шаблонизированные вспомогательные объекты](#0.2__Toc253429277 "_Toc253429277")

**[Динамические данные](#0.2__Toc253429278 "_Toc253429278")**  
[Включение платформы динамических данных для существующих проектов](#0.2__Toc253429279 "_Toc253429279")  
[Синтаксис декларативной элемента управления DynamicDataManager](#0.2__Toc253429280 "_Toc253429280")  
[Шаблоны сущностей с](#0.2__Toc253429281 "_Toc253429281")  
[Новые шаблоны полей для URL-адреса и адреса электронной почты](#0.2__Toc253429282 "_Toc253429282")  
[Создание связей с элементом управления DynamicHyperLink](#0.2__Toc253429283 "_Toc253429283")  
[Поддержка наследования в модели данных](#0.2__Toc253429284 "_Toc253429284")  
[Поддержка связей многие ко многим (только платформа Entity Framework)](#0.2__Toc253429285 "_Toc253429285")  
[Новые атрибуты для управления отображением и поддержки перечислений](#0.2__Toc253429286 "_Toc253429286")  
[Улучшенная поддержка фильтры](#0.2__Toc253429287 "_Toc253429287")

**[Усовершенствования разработки Visual Studio 2010 к Web](#0.2__Toc253429288 "_Toc253429288")**  
[Улучшенная совместимость с CSS](#0.2__Toc253429289 "_Toc253429289")  
[HTML и JavaScript фрагменты](#0.2__Toc253429290 "_Toc253429290")  
[Усовершенствования IntelliSense для JavaScript](#0.2__Toc253429291 "_Toc253429291")

**[Веб-развертывание приложения с помощью Visual Studio 2010](#0.2__Toc253429292 "_Toc253429292")**  
[Веб-упаковки](#0.2__Toc253429293 "_Toc253429293")  
[Преобразования Web.config](#0.2__Toc253429294 "_Toc253429294")  
[Развертывание базы данных](#0.2__Toc253429295 "_Toc253429295")  
[Публикация одним щелчком для веб-приложений](#0.2__Toc253429296 "_Toc253429296")  
[Resources](#0.2__Toc253429297 "_Toc253429297")

**[Заявление об отказе](#0.2__Toc253429298 "_Toc253429298")**

<a id="0.2__Toc224729018"></a><a id="0.2__Toc253429238"></a><a id="0.2__Toc243304612"></a>

## <a name="core-services"></a>Базовые службы

ASP.NET 4 появилось несколько функций, делающих службы ASP.NET core, такие как кэширование вывода и хранения состояния сеанса.

<a id="0.2__Toc243304613"></a><a id="0.2__Toc253429239"></a><a id="0.2__Toc224729019"></a>

### <a name="webconfig-file-refactoring"></a>Файл Web.config рефакторинга

`Web.config` Файл, содержащий конфигурацию для веб-приложения значительно вырос за последние несколько выпусков платформы .NET Framework, как будут добавлены новые функции, такие как Ajax, маршрутизации и интеграции со службами IIS 7. Это стало труднее настроить или запустить новый веб-приложений без такого средства, как Visual Studio. Основные элементы конфигурации в выполните указанные ниже .NET Framework 4, были перемещены в `machine.config` файл и приложений теперь наследуют эти параметры. Это позволяет `Web.config` файл в приложениях ASP.NET 4 быть пустым или содержать только следующие строки, которые укажите для Visual Studio версии платформы, для которой предназначено приложение:

[!code-xml[Main](overview/samples/sample1.xml)]

<a id="0.2__Toc253429240"></a><a id="0.2__Toc243304614"></a>

### <a name="extensible-output-caching"></a>Расширяемое кэширование вывода

С момента выпуска ASP.NET 1.0 кэширование вывода позволил разработчикам сохранять созданные выходные данные страницы, элементы управления и HTTP-ответов в памяти. При последующих запросах Web обработки содержимого быстрее получая созданные выходные данные из памяти вместо повторное создание выходных данных с нуля. Однако такой подход имеет ограничение — созданное содержимое всегда должно храниться в памяти, и на серверах, на которых наблюдается большая нагрузка, память, потребляемая кэширования вывода могут конкурировать с требованиями памяти из других частей веб-приложения.

ASP.NET 4 добавляет точку расширяемости для кэширования выходных данных, можно настроить один или несколько пользовательских поставщиков кэша вывода. Поставщиков кэша вывода можно использовать любой механизм хранения для сохранения содержимого HTML. Это дает возможность создания пользовательских поставщиков кэша вывода для сохраняемости различных механизмов, которые могут включать локальных или удаленных дисках, Облачное хранилище и распределенные модули кэширования.

Создание пользовательского поставщика кэша вывода как класс, производный от нового *System.Web.Caching.OutputCacheProvider* типа. Затем можно настроить поставщик в `Web.config` файл с новым *поставщики* подраздел *outputCache* элемента, как показано в следующем примере:

[!code-xml[Main](overview/samples/sample2.xml)]

По умолчанию в ASP.NET 4 все HTTP-ответов, отображаются страницы и элементы управления используют кэш вывода в памяти, как показано в предыдущем примере, где *defaultProvider* атрибуту присваивается AspNetInternalProvider. Можно изменить поставщика кэша вывода по умолчанию, используемый для веб-приложения, указав имя другого поставщика для *defaultProvider*.

Кроме того можно выбрать другой поставщиков кэша вывода каждого элемента управления и каждого запроса. Самый простой способ выбрать другой поставщик кэша вывода для разных пользовательских элементов управления, — сделать декларативно, используя новый *providerName* атрибут в директиве элемента управления, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample3.aspx)]

Указание другого поставщика кэша вывода для HTTP-запрос требует немного больше работы. Вместо декларативного задания поставщика, необходимо переопределить новый *GetOuputCacheProviderName* метод в `Global.asax` файл, чтобы программно указать, какой поставщик должен использоваться для конкретного запроса. Следующий пример показывает, как это сделать.

[!code-csharp[Main](overview/samples/sample4.cs)]

С появлением возможности расширения поставщика кэша вывода ASP.NET 4 более сложные и интеллектуальные стратегии кэширования выходных данных теперь подходит для веб-сайтов. Например теперь имеется возможность кэшировать эти страницы «Top 10» узла в памяти, во время кэширования страниц, которые создают меньший трафик на диске. Кроме того можно кэшировать каждый изменяющиеся комбинации для отображаемой странице, но использовать распределенный кэш, чтобы освободить ресурсы памяти интерфейсных веб-серверов.

<a id="0.2__Toc224729020"></a><a id="0.2__Toc253429241"></a><a id="0.2__Toc243304615"></a>

### <a name="auto-start-web-applications"></a>Автоматический запуск веб-приложений

Некоторые веб-приложения должны загружать большие объемы данных или инициализировать перед обработкой первого запроса. В более ранних версиях ASP.NET, в подобных случаях приходилось изобретать собственные методы «пробудить» приложения ASP.NET, а затем запустите код инициализации *приложения\_нагрузки* метод в `Global.asax` файл.

Новая функция масштабируемости с именем *автозапуска* что напрямую адреса этого сценария доступно при ASP.NET 4 выполняется на IIS 7.5 на Windows Server 2008 R2. Функция автозапуска позволяет управлять запуском пула приложений, инициализацией приложения ASP.NET и приемом HTTP-запросов.

> [!NOTE] 
> 
> Модуль прогрева приложений IIS для IIS 7.5
> 
> Группа разработчиков IIS был выпущен первой версии бета-тестирования модуля прогрева приложения для IIS 7.5. В результате прогрев приложений еще проще, чем описано выше. Вместо написания пользовательского кода, укажите URL-адреса ресурсов, прежде чем веб-приложение принимает запросы от сети. Этот период прогрева во время запуска службы IIS (Если вы настроили пула приложений IIS как *AlwaysRunning*) и при перезапуске рабочего процесса IIS. Во время перезапуска старый рабочий процесс IIS продолжает выполнять запросы, пока не будет вновь порожденном рабочий процесс полностью активировано, так, что приложения не прерывается или другие проблемы, из-за unprimed кэшей. Обратите внимание, что этот модуль работает с любой версии платформы ASP.NET, начиная с версии 2.0.
> 
> Дополнительные сведения см. в разделе [Подготовка приложений](https://www.iis.net/extensions/applicationwarmup%20on%20the%20IIS.net) IIS.net веб-сайте. Пошаговое руководство, которое показывает, как использовать функцию прогрева, см. в разделе [Приступая к работе с модулем прогрева приложения IIS 7.5](https://www.iis.net/learn/manage) IIS.net веб-сайте.


Чтобы использовать функцию автозапуска, администратор IIS задает пул приложений в IIS 7.5 для автоматического запуска, используя следующую конфигурацию в `applicationHost.config` файла:

[!code-xml[Main](overview/samples/sample5.xml)]

Поскольку в единый пул приложений может содержать несколько приложений, можно указать отдельные приложения для автоматического запуска, используя следующую конфигурацию в `applicationHost.config` файла:

[!code-xml[Main](overview/samples/sample6.xml)]

Когда сервер IIS 7.5 является холодный запуск, или при перезапуске отдельного пула приложений, IIS 7.5 использует эти сведения в `applicationHost.config` файл, чтобы определить, какие приложения необходимо Web запускаться автоматически. Для каждого приложения, помеченные для автоматического запуска IIS 7.5 отправляет запрос ASP.NET 4 для запуска приложения в состоянии, в течение которого приложение временно не принимает HTTP-запросы. Если в этом состоянии, ASP.NET создает экземпляр типа, определяемого *serviceAutoStartProvider* атрибут (как показано в предыдущем примере) и выполняет вызов в открытую точку входа.

Создать тип управляемых автозапуска с необходимая точка входа, реализовав *IProcessHostPreloadClient* интерфейс, как показано в следующем примере:

[!code-csharp[Main](overview/samples/sample7.cs)]

После инициализации ваш код выполняется в *предварительная загрузка* метод и метод возвращает, приложение ASP.NET будет готов к обработке запросов.

С появлением автозапуска IIS.5 и ASP.NET 4 теперь вы четко определенных подход для выполнения инициализации ресурсоемкие приложения перед обработкой первого запроса HTTP. Например новая функция автозапуска позволяет инициализировать приложение, а затем указать подсистему балансировки нагрузки, что приложению не инициализирована и готова к приему трафика HTTP.

<a id="0.2__Toc224729021"></a><a id="0.2__Toc253429242"></a><a id="0.2__Toc243304616"></a>

### <a name="permanently-redirecting-a-page"></a>Окончательное перемещение страницы

Это распространенный подход к веб-приложений для перемещения страниц и другие материалы, связанные со временем, что может привести к накоплению устаревших ссылок в поисковых системах. В ASP.NET, разработчики обрабатывают запросы на старые URL-адреса, используя *Response.Redirect* метод пересылать запрос на новый URL-адрес. Тем не менее *перенаправления* метод отправляет ответ HTTP 302 найдено (Временное перенаправление), что цикла приема-передачи приводит дополнительных HTTP, когда пользователи пытаются получить доступ к старые URL-адреса.

ASP.NET 4 добавляет новый *RedirectPermanent* вспомогательный метод, который позволяет легко проблема HTTP 301 перемещено навсегда ответов, как показано в следующем примере:

[!code-csharp[Main](overview/samples/sample8.cs)]

Поисковые системы и другие агенты пользователя, которые распознают постоянное перенаправление будет храниться новый URL-адрес, который связан с содержимым, которое избавляет от ненужных обмен данными веб-обозревателя для временного перенаправления.

<a id="0.2__Toc224729022"></a><a id="0.2__Toc253429243"></a><a id="0.2__Toc243304617"></a>

### <a name="shrinking-session-state"></a>Сжатие состояния сеанса

ASP.NET предоставляет два варианта по умолчанию для хранения состояния сеанса в веб-ферме: поставщик состояния сеанса, который вызывает серверу состояния сеанса вне процесса и поставщиком состояния сеанса, который хранит данные в базе данных Microsoft SQL Server. Так как оба варианта включают хранение сведений о состоянии вне рабочего процесса веб-приложения, должно быть сериализовано перед их отправкой во внешнее хранилище имеет состояние сеанса. В зависимости от того, какой объем информации, разработчик сохраняет в состоянии сеанса размер сериализованных данных может возрасти.

ASP.NET 4 появился новый параметр сжатия для обоих видов поставщики состояния сеанса вне процесса. Когда *compressionEnabled* показано в следующем примере параметру конфигурации присваивается *true*, ASP.NET будет сжатия (и распаковки) сериализованное состояние сеанса с помощью .NET Framework  *System.IO.Compression.GZipStream* класса.

[!code-xml[Main](overview/samples/sample9.xml)]

С помощью простого добавления нового атрибута для `Web.config` файлов, приложений с помощью свободной Процессорной мощности на веб-серверах и добиться значительного уменьшения размера сериализованных данных состояния сеанса.

<a id="0.2__Toc253429244"></a><a id="0.2__Toc243304618"></a>

### <a name="expanding-the-range-of-allowable-urls"></a>Расширяя диапазон допустимых URL-адресов

ASP.NET 4 предоставляет новые возможности увеличения размера URL-адреса приложения. Предыдущие версии ASP.NET ограничение длины пути URL-адрес до 260 символов, на основе ограничения путь к файлу NTFS. В ASP.NET 4, у вас есть возможность увеличить (или уменьшить) этого ограничения для приложений, с помощью двух новых *httpRuntime* атрибуты конфигурации. В следующем примере показано, эти новые атрибуты.

[!code-xml[Main](overview/samples/sample10.xml)]

Чтобы разрешить длительное или короткое путей (часть URL-адрес, который не поддерживает протокол, имя сервера и строку запроса), измените *[maxUrlLength](https://msdn.microsoft.com/library/system.web.configuration.httpruntimesection.maxurllength.aspx)* атрибута. Чтобы разрешить строки длиннее или короче запросов, измените значение *[maxQueryStringLength](https://msdn.microsoft.com/library/system.web.configuration.httpruntimesection.maxquerystringlength.aspx)* атрибута.

ASP.NET 4 также позволяет настроить символы, которые используются при проверке символов URL-адрес. Если ASP.NET обнаруживает недопустимый символ в часть пути URL-адрес, он отклоняет запрос и выдает ошибку HTTP 400. В предыдущих версиях ASP.NET проверку символов URL-адреса были ограничены фиксированный набор символов. В ASP.NET 4, можно настроить набор допустимых символов, с помощью нового *requestPathInvalidChars* атрибут *httpRuntime* элемента конфигурации, как показано в следующем примере:

[!code-xml[Main](overview/samples/sample11.xml)]

По умолчанию *requestPathInvalidChars* атрибут определяет восемь символов как недопустимые. (В строке, которая назначается *requestPathInvalidChars* по умолчанию меньше (&lt;), больше (&gt;) и амперсанд (&amp;) символы кодируются, так как `Web.config` файла является XML-файл). При необходимости можно настроить набор недопустимых символов.

> [!NOTE]
> Обратите внимание, ASP.NET 4 всегда отклоняет URL-путей, содержащих символы в диапазоне ASCII от 0x00 до 0x1F, потому что именно такие недопустимые символы URL-адрес, как определено в RFC 2396 пересматриваются ([http://www.ietf.org/rfc/rfc2396.txt](http://www.ietf.org/rfc/rfc2396.txt)). В версиях Windows Server под управлением IIS 6 или более поздней версии, драйвер устройства протокола http.sys автоматически отклоняет URL-адреса с таких символов.


<a id="0.2__Toc253429245"></a><a id="0.2__Toc243304619"></a>

### <a name="extensible-request-validation"></a>Расширяемая проверка запросов

Проверки запросов ASP.NET выполняет поиск входящие данные HTTP-запроса для строк, которые обычно используются в атаках межузловых сценариев (XSS). При обнаружении потенциальных строк XSS проверка запросов помечает подозрительную строку и возвращает сообщение об ошибке. Встроенная проверка запросов возвращает ошибку, только в том случае, когда находит наиболее распространенные строки, используемые в атак XSS. Предыдущие попытки создания более сложные проверки XSS привело к слишком много ложных положительных результатов. Тем не менее клиенты могут захотеть проверки запроса, который отличается более строгими требованиями или и наоборот, может возникнуть необходимость намеренно снизить XSS проверок для отдельных страниц или для некоторых типов запросов.

В ASP.NET 4 функция проверки запросов сделана расширяемой таким образом, можно использовать логику проверки пользовательских запросов. Чтобы расширить проверку запроса, создайте класс, производный от нового *System.Web.Util.RequestValidator* типа и настроить приложение (в *httpRuntime* раздел `Web.config`файл) для использования пользовательского типа. Приведенный ниже показано, как настроить пользовательские проверки запросов класс:

[!code-xml[Main](overview/samples/sample12.xml)]

Новый *requestValidationType* атрибут требует стандартную строку идентификатора типа .NET Framework, которая указывает класс, который предоставляет настраиваемой проверки запросов. Для каждого запроса ASP.NET вызывает пользовательский тип, для обработки каждого фрагмента данных входящего HTTP-запроса. Входящего URL-адреса всех заголовков HTTP (файлы cookie и пользовательские заголовки) и тела сообщения доступны для проверки с помощью класса проверки пользовательского запроса, как показано в следующем примере:

[!code-csharp[Main](overview/samples/sample13.cs)]

Для случаев, где вы хотите проверить часть входящих данных HTTP, класс проверки запросов может переключиться для запуска, просто вызвав проверки запроса ASP.NET по умолчанию *базовый. IsValidRequestString.*

<a id="0.2__Toc253429246"></a><a id="0.2__Toc243304620"></a>

### <a name="object-caching-and-object-caching-extensibility"></a>Кэширование объектов и расширяемость кэширования объектов

С момента первого выпуска, ASP.NET включает в себя мощные объектов в памяти кэша (*System.Web.Caching.Cache*). Реализация кэша стала настолько популярной, используемый в веб-приложений. Тем не менее, она становится менее приемлемой для приложения Windows Forms или WPF, чтобы включить ссылку `System.Web.dll` просто для того, чтобы иметь возможность использовать кэш объектов ASP.NET.

Чтобы обеспечить доступность кэширования для всех приложений, .NET Framework 4 вводит новую сборку, новое пространство имен, некоторые базовые типы и конкретная реализация кэширования. Новый `System.Runtime.Caching.dll` сборка содержит новый интерфейс API кэширования в *System.Runtime.Caching* пространства имен. Пространство имен содержит два основных набора классов:

- Абстрактные типы, которые образуют основу для создания любого типа пользовательскую реализацию кэша.
- Реализация кэша конкретный объект в памяти ( *System.Runtime.Caching.MemoryCache* класса).

Новый *MemoryCache* класс очень похож на кэш ASP.NET, и он использует большую часть логики подсистемы внутренней кэш-памяти с помощью ASP.NET. Несмотря на то что общедоступный API кеша в *System.Runtime.Caching* были обновлены для поддержки разработки пользовательских реализаций кэша, если вы использовали ASP.NET *кэша* объект, вы найдете привычными понятиями в новые интерфейсы API.

Подробное обсуждение нового *MemoryCache* класс и поддерживает базовые интерфейсы API потребует всего документа. Однако следующий пример дает представление о том, как работает новый кэш API. Пример был написан для приложения Windows Forms, вне зависимости на `System.Web.dll`.

[!code-csharp[Main](overview/samples/sample14.cs)]

<a id="0.2__Toc253429247"></a><a id="0.2__Toc243304621"></a>

### <a name="extensible-html-url-and-http-header-encoding"></a>Расширяемая HTML, URL-адреса и кодировку заголовка HTTP

В ASP.NET 4 можно создать пользовательские процедуры кодирования для следующих распространенных задач кодирования текста:

- Кодировка HTML.
- Кодировка URL-адрес.
- Кодировка атрибута HTML.
- Кодирование исходящих заголовков HTTP.

Можно создать пользовательский кодировщик путем наследования от нового *System.Web.Util.HttpEncoder* типа и последующей настройки ASP.NET для использования пользовательского типа в *httpRuntime* раздел `Web.config` файла, как показано в следующем примере:

[!code-xml[Main](overview/samples/sample15.xml)]

После настройки пользовательского кодировщика ASP.NET автоматически вызывает пользовательскую реализацию кодирования всякий раз, когда открытых методов кодирования *System.Web.HttpUtility* или *System.Web.HttpServerUtility* классы называются. Это позволяет одной части команда веб-разработчиков создать пользовательский кодировщик, который реализует интенсивное кодирование символов, а остальная часть команды веб-разработки продолжит использовать общедоступных API ASP.NET. Централизованная настройка пользовательского кодировщика в *httpRuntime* элемент, можно гарантировать, что все вызовы кодировки текста из общедоступных API ASP.NET, маршрутизируются через пользовательский кодировщик.

<a id="0.2__Toc253429248"></a><a id="0.2__Toc243304622"></a>

### <a name="performance-monitoring-for-individual-applications-in-a-single-worker-process"></a>Мониторинг производительности для отдельных приложений в одном рабочем процессе

Многие поставщики услуг размещения, чтобы увеличить количество веб-сайтов, которые могут размещаться на одном сервере, запустите несколько приложений ASP.NET в одном рабочем процессе. Тем не менее если несколько приложений используют один общий рабочий процесс, трудно для администраторов сервера для идентификации отдельного приложения, испытывает проблемы.

ASP.NET 4 использует новые функции наблюдения за ресурсами, представленную в среде CLR. Чтобы включить эту функцию, можно добавить следующий фрагмент конфигурации XML для `aspnet.config` файла конфигурации.

[!code-xml[Main](overview/samples/sample16.xml)]

> [!NOTE]
> Примечание `aspnet.config` файл находится в каталоге, где установлена платформа .NET Framework. Это не `Web.config` файл.


Когда *appDomainResourceMonitoring* функция включена, доступны два новых счетчиков производительности в категории производительности «Приложения ASP.NET»: *% загруженности процессора управляемого* и  *Управляемая память используется*. Оба эти счетчики производительности используйте новой функции управления ресурсами домена приложения среды CLR для отслеживания предполагаемое время ЦП и использования управляемой памяти по отдельным приложениям ASP.NET. Таким образом в ASP.NET 4, администраторы получают более детального представления потреблении ресурсов отдельных приложений, работающих в одном рабочем процессе.

<a id="0.2__Toc253429249"></a><a id="0.2__Toc243304623"></a>

### <a name="multi-targeting"></a>Нацеливание на несколько версий

Можно создать приложение, предназначенное для определенной версии платформы .NET Framework. В ASP.NET 4, новый атрибут в *компиляции* элемент `Web.config` файл позволяет предназначенных для .NET Framework 4 и более поздних версий. Если вы явно требуемой версии .NET Framework, и в том случае, если включить необязательные элементы в `Web.config` файл, например записи для *system.codedom*, эти элементы должны быть правильными для .NET Framework 4. (Если вы не устанавливаете явным образом в .NET Framework 4, требуемой версии .NET framework, выводится из-за отсутствия записи в `Web.config` файл.)

В следующем примере показано использование *targetFramework* атрибут в *компиляции* элемент `Web.config` файла.

[!code-xml[Main](overview/samples/sample17.xml)]

Обратите внимание на следующие особенности предназначенных для определенной версии платформы .NET Framework.

- В пуле приложений .NET Framework 4, система сборки ASP.NET предполагает .NET Framework 4 как целевой объект, если `Web.config` файл не содержит *targetFramework* атрибут или, если `Web.config` отсутствует файл. (Может потребоваться внести изменения кода в приложение, чтобы он выполнялся в .NET Framework 4.)
- Если вы включите *targetFramework* атрибут и если *system.codeDom* элемент определен в `Web.config` файл, этот файл должен содержать правильные записи для платформы .NET Framework 4.
- Если вы используете *aspnet\_компилятора* для предварительной компиляции приложения (например, в среде построения), необходимо использовать правильную версию *aspnet\_компилятора* Команда для целевой платформы. Используете компилятор, который поставляется с .NET Framework 2.0 (% WINDIR%\Microsoft.NET\Framework\v2.0.50727) для компиляции для платформы .NET Framework 3.5 и более ранних версий. Компилятор, который поставляется с .NET Framework 4 можно используете для компиляции приложения, созданные с помощью этой платформы или более поздних версий.
- Во время выполнения, компилятор использует последние сборки .NET framework, установленных на компьютере (и, следовательно, в глобальном кэше СБОРОК). Если обновление будет выполнен позже платформы (например, гипотетической версии 4.1 установлен), можно использовать функции в более новую версию платформы, даже если *targetFramework* атрибут предназначен для более ранней версии (например, 4.0). (Тем не менее, во время разработки в Visual Studio 2010 или при использовании *aspnet\_компилятора* команды с помощью новой функции framework приводит к ошибкам компилятора).

<a id="0.2__Toc224729023"></a><a id="0.2__Toc253429250"></a><a id="0.2__Toc243304624"></a>

## <a name="ajax"></a>Ajax

<a id="0.2__Toc253429251"></a><a id="0.2__Toc243304625"></a>

### <a name="jquery-included-with-web-forms-and-mvc"></a>jQuery в комплекте с Web Forms и MVC

Шаблоны Visual Studio для Web Forms и MVC включать библиотеку jQuery с открытым исходным кодом. При создании нового веб-сайта или проекта, создается папка сценариев со следующими файлами 3:

- jQuery-1.4.1.js — удобное для восприятия, неминифицированная версия библиотеки jQuery.
- jQuery-14.1.min.js — минифицированные версию библиотеки jQuery.
- jQuery-1.4.1-vsdoc.js-файл документации Intellisense для библиотеки jQuery.

Включите unminified версия jQuery, при разработке приложения. Включите минифицированные версию jQuery для рабочих приложений.

Например на следующей странице веб-форм иллюстрирует, как jQuery можно использовать, чтобы изменить цвет фона элемента управления ASP.NET TextBox на желтый, если они имеют фокус.

[!code-aspx[Main](overview/samples/sample18.aspx)]

<a id="0.2__Toc253429252"></a><a id="0.2__Toc243304626"></a>

### <a name="content-delivery-network-support"></a>Поддержка сети доставки содержимого

Microsoft Ajax доставки содержимого сети (CDN) позволяет легко добавить для веб-приложений ASP.NET Ajax и jQuery сценариев. Например, можно запустить с помощью библиотеки jQuery, просто добавив `<script>` тег на страницу, на который ссылается на Ajax.microsoft.com следующим образом:

[!code-html[Main](overview/samples/sample19.html)]

Используя преимущества сети Microsoft Ajax CDN, может значительно повысить производительность приложений Ajax. Содержимое сети Microsoft Ajax CDN кэшируется на серверах, расположенных по всему миру. Кроме того эта сеть позволяет браузерам повторно использовать кэшированные файлы JavaScript для веб-сайтов, которые находятся в разных доменах.

Microsoft Ajax Content Delivery Network поддерживает SSL (HTTPS), при необходимости для обслуживания веб-страницы, используя протокол SSL.

Реализуйте переход на резервный ресурс, если CDN недоступен. Протестируйте резервный вариант.

Дополнительные сведения о сети доставки Содержимого Microsoft Ajax, посетите следующий веб-сайт:

[https://www.asp.net/ajaxlibrary/CDN.ashx](../../ajax/cdn/overview.md)

ASP.NET ScriptManager поддерживает сети доставки Содержимого Microsoft Ajax. Путем простого одно свойство, свойство EnableCdn из сети CDN можно получить все файлы JavaScript для ASP.NET framework:

[!code-aspx[Main](overview/samples/sample20.aspx)]

После выбора EnableCdn свойство в значение true, платформа ASP.NET извлечет все файлы JavaScript платформы ASP.NET из сети CDN, включая все файлы JavaScript, используемый для проверки и UpdatePanel. Задание этого свойства один может иметь значительное влияние на производительность веб-приложения.

Можно задать путь CDN для собственных файлов JavaScript с помощью атрибута WebResource. Свойство CdnPath указывает путь к CDN, используемые при установке свойства EnableCdn значение true:

[!code-csharp[Main](overview/samples/sample21.cs)]

<a id="0.2__Toc253429253"></a><a id="0.2__Toc243304627"></a>

### <a name="scriptmanager-explicit-scripts"></a>ScriptManager явные скриптов

В прошлом Если вы использовали ASP.NET ScriptManger затем необходимо загрузить весь монолитных ASP.NET Ajax Library. Используя преимущества нового свойства ScriptManager.AjaxFrameworkMode, можно контролировать, загружаются только компоненты ASP.NET Ajax Library и загрузить только компоненты ASP.NET Ajax Library, необходимые.

Свойство ScriptManager.AjaxFrameworkMode можно присвоить следующие значения:

- Включено — Указывает, что элемент управления ScriptManager автоматически включает файл скрипта MicrosoftAjax.js, который представляет собой файл объединенного скрипта из всех основных скриптов платформы (поведение).
- Отключено — Указывает, что все функции скрипта Microsoft Ajax будут отключены и что элемент управления ScriptManager не ссылаться на какие-либо сценарии автоматически.
- Явные--Указывает, что будут включены явным образом скрипт ссылки на файл скрипта отдельных framework core, который вашей страницы требуется и что будет включать ссылки на зависимости, которые требуются для каждого файла скрипта.

Например если свойство AjaxFrameworkMode присвоено значение Explicit можно указать определенный сценарии компонентов ASP.NET Ajax, которые необходимы:

[!code-aspx[Main](overview/samples/sample22.aspx)]

<a id="0.2__The_DataView_Control"></a><a id="0.2__The_DataContext_and"></a><a id="0.2__Refactoring_the_Microsoft"></a><a id="0.2__Toc224729032"></a><a id="0.2__Toc253429256"></a><a id="0.2__Toc243304630"></a>

## <a name="web-forms"></a>Веб-формы

Веб-форм был центральным компонентом в ASP.NET с момента выпуска ASP.NET 1.0. Множество улучшений, находящихся в этой области для ASP.NET 4, включая следующие:

- Возможность установки *meta* теги.
- Больший контроль над состояние представления.
- Более простые способы работы с возможностями браузера.
- Поддержка использования маршрутизации ASP.NET с веб-форм.
- Больший контроль над созданных кодов.
- Возможность сохранения выбранных строк в элементах управления данными.
- Больший контроль над отображаемого HTML-кода в *FormView* и *ListView* элементов управления.
- Поддержка фильтрации для элементов управления источниками данных.

<a id="0.2__Toc224729033"></a><a id="0.2__Toc253429257"></a><a id="0.2__Toc243304631"></a>

### <a name="setting-meta-tags-with-the-pagemetakeywords-and-pagemetadescription-properties"></a>Параметр метатегов с Page.MetaKeywords и Page.MetaDescription свойствами

ASP.NET 4 добавляет два свойства для *страницы* класс, *кратко* и *MetaDescription*. Эти свойства представляют соответствующие *meta* тегов на странице, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample23.aspx)]

Эти два свойства работать так же, как страницы *Title* свойство. Они подчиняются следующим правилам:

1. При наличии не *meta* теги в *head* элемент, совпадают с именами свойств (то есть, имя = «keywords» для *Page.MetaKeywords* и имя = «description» для  *Page.MetaDescription*, это значит, что эти свойства не задано), *meta* теги будут добавляться на страницу, при его отрисовке.
2. Если уже есть *meta* теги с этими именами, эти свойства выступать в качестве методов для содержимого существующие теги get и set.

Эти свойства можно задать во время выполнения, которая позволяет получить содержимое из базы данных или другого источника, и вы сможете настроить теги динамически, чтобы описывать действия рассчитан на определенной странице.

Можно также задать *ключевые слова* и *описание* свойств в *@ Page* директив в верхней части разметку страницы веб-форм, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample24.aspx)]

Это переопределит *meta* содержимое (если таковые имеются), уже объявлен в странице тега.

Содержимое описания *meta* тегов используются для улучшения поиска, список предварительных версий в Google. (Дополнительные сведения см. в разделе [улучшить фрагменты кода с помощью метаданных описание преобразование](http://googlewebmastercentral.blogspot.com/2007/09/improve-snippets-with-meta-description.html) в блоге центра Webmaster Google.) Google и Windows Live Search используют содержимое ключевые слова для любого элемента, но может других поисковых систем. Дополнительные сведения см. в разделе [советы ключевые слова Meta](http://www.searchengineguide.com/richard-ball/meta-keywords-a.php) на ядра руководство по веб-сайт поиска.

Эти новые свойства являются компонентом простой, но можно сохранять из требования по добавлению их вручную или написать собственный код для создания *meta* теги.

<a id="0.2__Toc224729034"></a><a id="0.2__Toc253429258"></a><a id="0.2__Toc243304632"></a>

### <a name="enabling-view-state-for-individual-controls"></a>Включение состояния представления для отдельных элементов управления

По умолчанию для страницы, с результатом, что каждый элемент управления на странице потенциально сохраняет состояние представления, даже если он не является обязательным для приложения включено состояние представления. Данные состояния представления включается в разметке, что страница создает и увеличивает время, необходимое для отправки страницы на клиент и обратной передачи. Хранение дополнительные состояния представления, чем необходимо может привести к снижению производительности. В более ранних версиях ASP.NET разработчикам удалось отключить состояние представления для отдельных элементов управления, чтобы уменьшить размер страницы, но было явно сделать для отдельных элементов управления. В ASP.NET 4 Web серверные элементы управления включают *ViewStateMode* свойство, которое позволяет отключить состояние представления по умолчанию и затем включите ее только для элементов управления, требующих его на странице.

*ViewStateMode* свойство принимает перечисление, которое имеет три значения: *Включить*, *отключено*, и *наследовать*. *Включить* позволяет просматривать состояние для этого элемента управления, а также для дочерних элементов управления, для которых установлен *наследовать* или, ничего не установлен. *Отключенные* состояние просмотра отключено и *наследовать* указывает, что элемент управления использует *ViewStateMode* из родительского элемента управления.

В следующем примере показан как *ViewStateMode* свойства. Разметка и код для элементов управления на следующей странице содержит значения *ViewStateMode* свойство:

[!code-aspx[Main](overview/samples/sample25.aspx)]

Как вы видите, этот код отключает состояние представления для элемента управления прототип 1. Label1 дочерний элемент управления наследует значение этого свойства (*наследовать* является значением по умолчанию для *ViewStateMode* для элементов управления.) и поэтому сохраняет ни одно состояние представления. В элементе управления PlaceHolder2 *ViewStateMode* присваивается *включено*, поэтому label2 наследует это свойство и сохраняет состояние представления. При первой загрузке страницы, *текст* свойства обоих *метка* элементы управления присваивается строка «[DynamicValue]».

Эффект эти параметры в том, что при загрузке страницы в первый раз, выводятся следующие данные в браузере:

Отключено `: [DynamicValue]`

Включено:`[DynamicValue]`

После обратной передачи Однако выводится следующий результат:

Отключено `: [DeclaredValue]`

Включено:`[DynamicValue]`

Элемент управления label1 (которого *ViewStateMode* присваивается значение *отключено*) не имеет сохраняется значение, которое было установлено в коде. Однако управлять label2 (которого *ViewStateMode* присваивается значение *включено*) сохранить свое состояние.

Можно также задать *ViewStateMode* в *@ Page* директив, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample26.aspx)]

*Страницы* класс является просто еще один элемент управления; он выступает в качестве родительского элемента управления для всех других элементов управления на странице. Значение по умолчанию *ViewStateMode* — *включено* для экземпляров *страницы*. Так как элементы управления по умолчанию *наследовать*, элементы управления будут наследовать *включено* значение свойства, если не задать *ViewStateMode* на уровне страницы или элемента управления.

Значение *ViewStateMode* свойство определяет, если состояние представления сохраняется только в том случае, если *EnableViewState* свойству *true*. Если *EnableViewState* свойству *false*, состояние представления не будет поддерживаться даже в том случае, если *ViewStateMode* присваивается *включено*.

Как хороший эта функция используется с *ContentPlaceHolder* элементов управления на главных страницах, где можно задать *ViewStateMode* для *отключено* главной странице, а затем включите ее по отдельности для *ContentPlaceHolder* элементов управления, которые в свою очередь содержать элементы управления, которые требуется просмотреть состояние.

<a id="0.2__Toc224729035"></a><a id="0.2__Toc253429259"></a><a id="0.2__Toc243304633"></a>

### <a name="changes-to-browser-capabilities"></a>Изменения возможностей браузера

ASP.NET определяет возможности браузера, пользователь использует для просмотра веб-узла, используя компонент, именуемый *возможностей браузера*. Представлены возможности браузера *HttpBrowserCapabilities* объекта (предоставляемые *Request.Browser* свойство). Например, можно использовать *HttpBrowserCapabilities* объектом, чтобы определить, поддерживает ли тип и версия текущего браузера на конкретную версию JavaScript. Можно также использовать *HttpBrowserCapabilities* объектом, чтобы определить, создан ли запрос с мобильного устройства.

*HttpBrowserCapabilities* объекта определяется набор файлах определения браузеров. Эти файлы содержат сведения о возможностях конкретного браузеров. В ASP.NET 4 файлы описания браузеров обновлены для хранения сведений о недавно введенные браузерах и устройствах, таких как Google Chrome, справочные материалы в смартфоны BlackBerry движения, а также Apple iPhone.

Ниже перечислены новый обозреватель файлов определений:

- *BlackBerry.Browser*
- *Chrome.Browser*
- *Default.Browser*
- *Firefox.Browser*
- *Gateway.Browser*
- *generic.Browser*
- *ie.browser*
- *iemobile.browser*
- *iPhone.Browser*
- *Opera.Browser*
- *Safari.Browser*

#### <a name="using-browser-capabilities-providers"></a>С помощью поставщиков возможностей браузера

В ASP.NET версии 3.5 с пакетом обновления 1 может определить характеристики браузера, с одним из следующих способов:

- На уровне компьютера, создании или обновлении `.browser` XML-файл в следующую папку:

- [!code-console[Main](overview/samples/sample27.cmd)]

- После определения возможностей браузера, вы выполните следующую команду из командной строке Visual Studio для перестроения сборка возможностей обозревателя и добавьте его в глобальный кэш сборок:

- [!code-console[Main](overview/samples/sample28.cmd)]

- Для отдельного приложения, создаваемые `.browser` файл в приложении `App_Browsers` папки.

Эти подходы потребовать изменения XML-файлы, и для изменения на уровне компьютера, необходимо перезапустить приложение, после запуска aspnet\_regbrowsers.exe процесса.

ASP.NET 4 включает в себя функции, называемой *поставщики возможностей браузера*. Как и предполагает имя, это позволяет вам создать поставщика, который в свою очередь позволяет использовать собственный код для определения возможностей браузера.

На практике разработчики часто не определяют возможности пользовательского браузера. Браузер файлов являются трудно обновить, процесс для их обновления является довольно сложным и XML-синтаксис `.browser` файлы могут быть сложными и определения. Что сделает этот процесс намного проще — при наличии общего синтаксиса определения браузера, или базы данных, которая содержит обновленные определения браузера или даже веб-службу для такой базы данных. Новая функция поставщиков возможностей браузера делает эти сценарии можно и практические сторонних разработчиков.

Существует два основных подхода по использованию новой функции поставщика возможностей браузера ASP.NET 4: расширение возможностей браузера ASP.NET возможности определения или полной замены. В следующих разделах сначала как заменить функциональные возможности, а затем как расширить его.

#### <a name="replacing-the-aspnet-browser-capabilities-functionality"></a>Замена функциональность возможностей браузера ASP.NET

Чтобы полностью заменить функциональные возможности определение возможностей браузера ASP.NET, выполните следующие действия.

1. Создайте класс поставщика, который является производным от *HttpCapabilitiesProvider* и переопределяющее *GetBrowserCapabilities* метод, как показано в следующем примере: 

    [!code-csharp[Main](overview/samples/sample29.cs)]

    В этом примере создается новый *HttpBrowserCapabilities* объекта, указав только с именем браузера и установив эту возможность для MyCustomBrowser возможность.
2. Зарегистрируйте поставщик с приложением. 

    Чтобы использовать поставщик с приложением, необходимо добавить *поставщика* атрибут *browserCaps* статьи `Web.config` или `Machine.config` файлов. (Можно также определить атрибуты поставщика в *расположение* элемент для конкретных каталогов в приложении, например в папку для определенного мобильного устройства.) В следующем примере показано, как задать *поставщика* атрибут в файле конфигурации:

    [!code-xml[Main](overview/samples/sample30.xml)]

    Еще один способ зарегистрировать новое определение возможностей браузера является использование кода, как показано в следующем примере:

    [!code-csharp[Main](overview/samples/sample31.cs)]

    Этот код должен выполняться *приложения\_запустить* событие `Global.asax` файл. После любого изменения *BrowserCapabilitiesProvider* класс должен произойти до выполнения любого кода в приложении, чтобы убедиться, что кэш остается в состоянии, недопустимом для устранения *HttpCapabilitiesBase* объекта.

#### <a name="caching-the-httpbrowsercapabilities-object"></a>Кэширование объекта HttpBrowserCapabilities

В предыдущем примере имеется одна проблема, которая означает, что код будет работать при каждом вызове пользовательского поставщика для получения *HttpBrowserCapabilities* объекта. Это может произойти несколько раз во время выполнения каждого запроса. В примере кода для поставщика практически не делают. Тем не менее, если код в ваш пользовательский поставщик выполняет значительный объем работы в заказ для получения *HttpBrowserCapabilities* объекта, это может повлиять на производительность. Чтобы предотвратить такую ситуацию, можно кэшировать *HttpBrowserCapabilities* объекта. Выполните следующие действия.

1. Создайте класс, производный от *HttpCapabilitiesProvider*, такое как в следующем примере: 

    [!code-csharp[Main](overview/samples/sample32.cs)]

    В примере кода создает ключ кэша, вызвав пользовательский метод BuildCacheKey, и он возвращает длину времени кэширования путем вызова пользовательского метода GetCacheTime. Затем код добавляет разрешенная *HttpBrowserCapabilities* объекта в кэш. Объект можно получить из кэша и повторно использоваться на последующих запросов, которые делают использование пользовательского поставщика.
2. Зарегистрируйте поставщик с приложением, как описано в предыдущей процедуре.

#### <a name="extending-aspnet-browser-capabilities-functionality"></a>Расширение функциональных возможностей браузера ASP.NET возможности

В предыдущем разделе описан способ создания нового *HttpBrowserCapabilities* объекта в ASP.NET 4. Также можно расширить функциональные возможности возможностей браузера ASP.NET путем добавления новых определений возможностей браузера для тех, которые уже находятся в ASP.NET. Это можно сделать без использования браузера определения XML. В следующей процедуре показан способ.

1. Создайте класс, производный от *HttpCapabilitiesEvaluator* и переопределяющее *GetBrowserCapabilities* метод, как показано в следующем примере: 

    [!code-csharp[Main](overview/samples/sample33.cs)]

    Этот код сначала использует функции возможностей браузера ASP.NET для идентификации браузера. Тем не менее, если браузер не определяется на основе данных определены в запросе (то есть, в том случае, если *браузера* свойство *HttpBrowserCapabilities* объект имеет строку «Unknown»), код вызывает метод пользовательский поставщик (MyBrowserCapabilitiesEvaluator) для определения обозревателя.
2. Зарегистрируйте поставщик с приложением, как описано в предыдущем примере.

#### <a name="extending-browser-capabilities-functionality-by-adding-new-capabilities-to-existing-capabilities-definitions"></a>Расширение функциональных возможностей возможности браузера, добавив новые возможности в определения существующих возможностей

В дополнение к созданию определение поставщика пользовательского браузера и динамического создания новых определений браузера вы можете расширить существующие определения браузера, с дополнительными возможностями. Это позволяет использовать это определение, близкое к желаемого, но не хватает только несколько возможностей. Для этого выполните следующие действия.

1. Создайте класс, производный от *HttpCapabilitiesEvaluator* и переопределяющее *GetBrowserCapabilities* метод, как показано в следующем примере: 

    [!code-csharp[Main](overview/samples/sample34.cs)]

    В примере кода расширяет существующие ASP.NET *HttpCapabilitiesEvaluator* класс и получает *HttpBrowserCapabilities* объект, который соответствует текущей определение запроса, используя следующий код :

    [!code-csharp[Main](overview/samples/sample35.cs)]

    Код затем можно добавить или изменить функцию для этого браузера. Существует два способа, чтобы указать новую возможность браузера:

    - Добавить пару "ключ значение" в *IDictionary* объект, который предоставляется командлетом *возможности* свойство *HttpCapabilitiesBase* объекта. В предыдущем примере, код добавляет функцию с именем мультисенсорных функций со значением *true*.
    - Задайте свойства существующих *HttpCapabilitiesBase* объекта. В предыдущем примере, код задает *кадров* свойства *true*. Это свойство имеет метод доступа, для *IDictionary* объект, который предоставляется командлетом *возможности* свойство. 

        > [!NOTE]
        > Обратите внимание, эта модель применяется к любому свойству *HttpBrowserCapabilities*, включая адаптеров элементов управления.
2. Зарегистрируйте поставщик с приложением, как описано в предыдущей процедуре.

<a id="0.2__Toc224729036"></a><a id="0.2__Toc253429260"></a><a id="0.2__Toc243304634"></a>

### <a name="routing-in-aspnet-4"></a>Маршрутизация в ASP.NET 4

ASP.NET 4 появилась встроенная поддержка с помощью маршрутизации с помощью веб-форм. Маршрутизации позволяет настроить приложение для принятия запроса URL-адреса, которые не сопоставлены с физическими файлами. Вместо этого можно использовать маршрутизацию для определения URL-адреса, являются значимыми для пользователей и, которые могут помочь в оптимизации поисковой системы (SEO) для вашего приложения. Например URL-адрес для страницы, которая отображает категории продуктов в существующее приложение может выглядеть как в следующем примере:

[!code-console[Main](overview/samples/sample36.cmd)]

С помощью маршрутизации, можно настроить приложение для приема следующий URL-адрес для отображения той же информации:

[!code-console[Main](overview/samples/sample37.cmd)]

Маршрутизация было доступно, начиная с ASP.NET 3.5 с пакетом обновления 1. (Пример использования маршрутизации в ASP.NET 3.5 SP1, см. в записи [с помощью маршрутизации с помощью веб-форм](http://haacked.com/archive/2008/03/11/using-routing-with-webforms.aspx "название данной записи.") в блоге Фила Хаака.) Тем не менее ASP.NET 4 включает некоторые функции, которые упрощают использование маршрутизации, включая следующие:

- *PageRouteHandler* класс, который является простой обработчик HTTP, который используется при определении маршрутов. Класс передает данные, запрос перенаправляется на страницу.
- Новые свойства *HttpRequest.RequestContext* и *Page.RouteData* (который является прокси для *HttpRequest.RequestContext.RouteData* объекта). Эти свойства упрощают доступ к сведениям, который передается из маршрута.
- Следующие новые построители выражений, которые определены в *System.Web.Compilation.RouteUrlExpressionBuilder* и *System.Web.Compilation.RouteValueExpressionBuilder*:
- *RouteUrl*, который предоставляет простой способ создать URL-адрес, соответствующий URL-адрес маршрута в серверный элемент управления ASP.NET.
- *RouteValue*, который предоставляет простой способ извлечения информации из *RouteContext* объекта.
- *RouteParameter* класс, который упрощает процесс передачи данных, содержащихся в *RouteContext* объект запроса для элемента управления источником данных (аналогичную [ *FormParameter* ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.formparameter.aspx)).

#### <a name="routing-for-web-forms-pages"></a>Маршрутизация для страницы Web Forms

Приведенный ниже показано, как определить маршрут веб-форм с помощью нового *MapPageRoute* метод *маршрута* класса:

[!code-csharp[Main](overview/samples/sample38.cs)]

В ASP.NET 4 представлено *MapPageRoute* метод. Следующий пример эквивалентен определению SearchRoute, показанный в предыдущем примере, но использует *PageRouteHandler* класса.

[!code-csharp[Main](overview/samples/sample39.cs)]

Код в примере сопоставляет маршрут к физической страницы (в первый маршрут, чтобы `~/search.aspx`). В первом определении маршрута также указывает, что параметр именованные searchterm следует извлечь из URL-адрес и передается на страницу.

*MapPageRoute* метод поддерживает следующие перегрузки метода:

- *MapPageRoute (routeName строка, строка routeUrl, physicalFile строка, bool checkPhysicalUrlAccess)*
- *MapPageRoute (routeName строка, строка routeUrl, physicalFile строка, bool checkPhysicalUrlAccess, RouteValueDictionary значения по умолчанию)*
- *MapPageRoute (routeName строка, routeUrl строка, строка physicalFile, bool checkPhysicalUrlAccess, RouteValueDictionary значения по умолчанию, ограничения RouteValueDictionary)*

*CheckPhysicalUrlAccess* параметр указывает, должна ли проверять права доступа для физической страницы, маршрутизируемых для маршрута (в этом случае страница search.aspx) и разрешения на входящих URL-адрес (в этом случае поиск / {searchterm}). Если значение *checkPhysicalUrlAccess* — *false*, будут проверяться только те разрешения входящего URL-адреса. Эти разрешения определяются в `Web.config` файл с помощью параметров следующего вида:

[!code-xml[Main](overview/samples/sample40.xml)]

В примере конфигурации доступ к физической страницы `search.aspx` для всех пользователей, за исключением тех, которым назначена роль администратора. Когда *checkPhysicalUrlAccess* параметр имеет значение *true* (это значение по умолчанию), только администратор пользователей получают доступ к URL-адрес /search/ {searchterm}, так как страница search.aspx физической страницы только пользователи с этой ролью. Если *checkPhysicalUrlAccess* присваивается *false* и сайт настроен так, как показано в предыдущем примере, всем вошедшим пользователям разрешен доступ к URL-адрес /search/ {searchterm}.

#### <a name="reading-routing-information-in-a-web-forms-page"></a>Чтение информацию маршрутизации в страницу Web Forms

В коде веб-форм физической страницы, можно найти необходимую информацию маршрутизации извлечь из URL-адрес (или другой информации, которая добавлена в другой объект *RouteData* объекта), используя два новых свойства: *HttpRequest.RequestContext* и *Page.RouteData*. (*Page.RouteData* заключает в оболочку *HttpRequest.RequestContext.RouteData*.) В следующем примере показано, как использовать *Page.RouteData*.

[!code-csharp[Main](overview/samples/sample41.cs)]

Код извлекает значение, переданное для параметра searchterm, определенных в маршруте пример выше. Рассмотрим следующий URL-адрес запроса:

[!code-console[Main](overview/samples/sample42.cmd)]

При этом запросе, слово «scott» будет проходить в `search.aspx` страницы.

#### <a name="accessing-routing-information-in-markup"></a>Доступ к сведения о маршрутизации в разметке

Метод, описанный в предыдущем разделе показано, как получить данные о маршруте в коде на странице веб-форм. Можно также использовать выражения в разметке, предоставляющим доступ к той же информации. Построители выражений — это мощная и элегантный способ работы с декларативного кода. (Дополнительные сведения см. в записи [Express самостоятельно с помощью пользовательских построители выражений](http://haacked.com/archive/2006/11/29/Express_Yourself_With_Custom_Expression_Builders.aspx) в блоге Фила Хаака.)

ASP.NET 4 включает две новые построители выражений для маршрутизации веб-форм. В следующем примере показано, как их использования.

[!code-aspx[Main](overview/samples/sample43.aspx)]

В примере *RouteUrl* выражение используется для определения URL-адрес, основанный на параметр маршрута. Это избавляет от необходимости жесткая полный URL-адрес в разметку и позволяет позже изменить структуру URL-адрес без необходимости изменения для этой ссылки.

Исходя из маршрутов, определенные ранее, эта разметка создает следующий URL-адрес:

[!code-console[Main](overview/samples/sample44.cmd)]

ASP.NET автоматически происходит правильный маршрут (то есть он формирует правильный URL-адрес) на основе входных параметров. Можно также включить имя маршрута в выражении, где можно указать маршрут для использования.

В следующем примере показано, как использовать *RouteValue* выражение.

[!code-aspx[Main](overview/samples/sample45.aspx)]

При запуске страницы, содержащий этот элемент управления, значение «scott» отображается в метке.

*RouteValue* выражения очень просто использовать данные о маршруте в разметке, и позволяет избежать необходимости работать с более сложные Page.RouteData["x"] синтаксис в разметке.

#### <a name="using-route-data-for-data-source-control-parameters"></a>С помощью данных маршрута для параметров элемента управления источником данных

*RouteParameter* класса позволяет указать данные маршрута как значение параметра для запросов в элемент управления источником данных. Он [работает во многом аналогично](https://msdn.microsoft.com/library/system.web.ui.webcontrols.formparameter.aspx) класса, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample46.aspx)]

В этом случае будет использоваться значение searchterm параметр маршрута для @companyname параметр в *выберите* инструкции.

<a id="0.2__Toc224729037"></a><a id="0.2__Toc253429261"></a><a id="0.2__Toc243304635"></a>

### <a name="setting-client-ids"></a>Установка клиентских идентификаторов

Новый *ClientIDMode* свойство предназначено для долгосрочных в ASP.NET, а именно как элементы управления создать *идентификатор* атрибутов для элементов, которые они отображают. Зная *идентификатор* атрибутов отображаемых элементов важно, если приложение включает клиентский скрипт, который ссылается на эти элементы.

*Идентификатор* атрибут в формате HTML, отображаемый для серверных элементов управления создается на основе *ClientID* свойство элемента управления. До ASP.NET 4, алгоритм создания *идентификатор* из атрибута *ClientID* свойство было сцепляемых контейнера именования (если таковые имеются) с Идентификатором, а также в случае повторяющихся элементов управления (как показано на элементы управления данными), чтобы добавить префикс и порядковый номер. Хотя это всегда гарантирует, что идентификаторы элементов управления на странице уникальны, алгоритм помог управления идентификаторами, которые не были прогнозируемого и поэтому были сложны в ссылку из клиентского скрипта.

Новый *ClientIDMode* свойство позволяет указать более точно как идентификатор клиента создается для элементов управления. Можно задать *ClientIDMode* свойство для любого элемента управления, в том числе для страницы. Ниже перечислены возможные параметры.

- *AutoID* – это эквивалентно алгоритм создания *ClientID* значения свойств, которые было использовано в более ранних версиях ASP.NET.
- *Статические* – это указывает на то, что *ClientID* значение будет совпадать с Идентификатором без объединения идентификаторы родительских контейнеров именования. Это может быть полезно в веб-элементы управления пользователя. Так как пользователь веб-элементе управления находятся на разных страницах и в другой контейнер элементов управления, может быть трудно писать клиентский скрипт для элементов управления, использующих *AutoID* алгоритм, так как невозможно предсказать, какие значения идентификатора будут .
- *Прогнозируемый* — этот параметр используется главным образом для использования в элементах управления данными, которые используют повторяющиеся шаблоны. Он объединяет свойства ID контейнерах именования элемента управления, но созданный *ClientID* значения не содержат строки вроде «ctlxxx». Этот параметр работает в сочетании с *ClientIDRowSuffix* свойство элемента управления. Можно задать *ClientIDRowSuffix* присваивается имя поля данных, а значение этого поля используется в качестве суффикса для создаваемого *ClientID* значение. Обычно используется первичный ключ записи данных как *ClientIDRowSuffix* значение.
- *Наследовать* — этот параметр является поведением по умолчанию для элементов управления; он указывает, что создание идентификатора элемента управления так же, как его родителя.

Можно задать *ClientIDMode* свойства на уровне страницы. Определяет значение по умолчанию *ClientIDMode* значение для всех элементов управления на текущей странице.

Значение по умолчанию *ClientIDMode* значение на уровне страницы *AutoID*и значение по умолчанию *ClientIDMode* значение на уровне управления *наследовать*. Таким образом, если вы не установите это свойство в любом месте в коде, все элементы управления по умолчанию *AutoID* алгоритм.

Значение уровня страницы *@ Page* директивы, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample47.aspx)]

Можно также задать *ClientIDMode* значение в файле конфигурации, либо на уровне компьютера (по умолчанию), либо на уровне приложения. Определяет значение по умолчанию *ClientIDMode* параметр для всех элементов управления на всех страницах в приложении. Если задать значение на уровне компьютера, он определяет значение по умолчанию *ClientIDMode* параметр для всех веб-сайтов на этом компьютере. В следующем примере показан *ClientIDMode* в файле конфигурации:

[!code-xml[Main](overview/samples/sample48.xml)]

Как отмечалось ранее, значение *ClientID* свойство извлекается из контейнера именования для родительского элемента управления. В некоторых сценариях, например при использовании главные страницы элементы управления могут быть сохранены с идентификаторами как в следующем примере созданный HTML:

[!code-html[Main](overview/samples/sample49.html)]

Несмотря на то что *входной* элемент, показанный в разметке (из *TextBox* управления) — только два контейнера именования глубоко внутри страницы (вложенный *ContentPlaceholder* элементы управления), из-за способа обработки главных страниц конечным результатом является идентификатор элемента управления следующим образом:

[!code-console[Main](overview/samples/sample50.cmd)]

Этот идентификатор гарантированно будет уникальным в странице, но является излишне долго для большинства целей. Предположим, что требуется сократить готовый для просмотра идентификатора и более строгий контроль над созданием идентификатор. (Например, вы хотите исключить префиксы «ctlxxx».) Самый простой способ добиться этого является, задав *ClientIDMode* свойства, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample51.aspx)]

В этом образце *ClientIDMode* свойству *статический* для самых внешних *NamingPanel* и присвойте для *прогнозируемый* для внутреннего *NamingControl* элемент. Эти параметры привести следующую разметку (остальная часть страницы и создав главную страницу предполагается, что так же, как показано в предыдущем примере):

[!code-html[Main](overview/samples/sample52.html)]

*Статический* параметр действует Сброс иерархии имен для любых элементов управления внутри внешнего *NamingPanel* элемент и позволяет устранить *ContentPlaceHolder* и *MasterPage* идентификаторы из созданным идентификатором. ( *Имя* атрибутов из отображаемых элементов не влияет, поэтому нормальной работе ASP.NET сохраняется для события, состояние представления и т. д.) Сброс иерархии имен является побочным эффектом том, что даже при перемещении разметка для *NamingPanel* элементов на другой *ContentPlaceholder* элемента управления, готовый для просмотра клиентские идентификаторы не изменяются.

> [!NOTE]
> Обратите внимание, что вы можете обеспечить наличие уникальные идентификаторы отображаемых элементов управления. Если это не так, он может разорвать любые функции, которые требуются уникальные идентификаторы для отдельных элементов HTML, например, клиент *document.getElementById* функции.


#### <a name="creating-predictable-client-ids-in-data-bound-controls"></a>Создание прогнозируемые идентификаторы клиентов в элементах управления с привязкой к данным

*ClientID* значений, которые создаются для элементов управления в элементе управления списком с привязкой к данным прежних версий алгоритмом может быть длинные и не очень предсказуемо. *ClientIDMode* функциональные возможности помогут вам более управления создаются на том, как эти идентификаторы.

Разметка в следующем примере включает *ListView* управления:

[!code-aspx[Main](overview/samples/sample53.aspx)]

В предыдущем примере *ClientIDMode* и *RowClientIDRowSuffix* свойств в разметке. *ClientIDRowSuffix* свойство может использоваться только в элементах управления с привязкой к данным и его поведение отличается в зависимости от того, какой элемент управления, на который вы используете. Они приведены различия:

- *GridView* элемента управления, можно указать имя одного или нескольких столбцов в источнике данных, скомбинированные во время выполнения для создания идентификаторов клиента. Например, если задать *RowClientIDRowSuffix* для «ProductName, ProductId», идентификаторов элементов управления для визуализированных элементов будет иметь формат, как показано ниже:

- [!code-console[Main](overview/samples/sample54.cmd)]

- *ListView* элемента управления, можно указать один столбец в источнике данных, которое добавляется к идентификатор клиента. Например, если задать *ClientIDRowSuffix* для «ProductName», готовый для просмотра идентификаторы элементов управления будет иметь следующий формат:

- [!code-console[Main](overview/samples/sample55.cmd)]

- В этом случае конечные 1 является производным от идентификатора продукта текущего элемента данных.

- *Элемент управления Repeater* элемента управления, этот элемент управления не поддерживает *ClientIDRowSuffix* свойство. В *Repeater* используется элемент управления, индекс текущей строки. При использовании ClientIDMode = «Прогнозируемый» с *Repeater* управления, клиент, идентификаторы создаются, имеют следующий формат:

- [!code-console[Main](overview/samples/sample56.cmd)]

- Конечные 0 — индекс текущей строки.

*FormView* и *DetailsView* элементы не имеют несколько строк, поэтому они не поддерживают *ClientIDRowSuffix* свойство.

<a id="0.2__Toc224729038"></a><a id="0.2__Toc253429262"></a><a id="0.2__Toc243304636"></a>

### <a name="persisting-row-selection-in-data-controls"></a>Сохранение выбора строки в элементах управления данными

*GridView* и *ListView* элементы управления можно позволить пользователям выбрать строку. В предыдущих версиях ASP.NET выбор объясняется на индекс строки на странице. Например если вы выберите третий элемент на странице 1 и затем переходит на страницу 2, третий элемент на этой странице выбирается.

Сохраненные Выбор был изначально поддерживается только в проектах динамических данных в .NET Framework 3.5 SP1. Если эта функция включена, выбранный элемент зависит от ключа данных для элемента. Это означает, что если вы выберите третью строку на странице 1 и переходит на страницу 2, ничего не выбрано на странице 2. При перемещении обратно на страницу 1, все еще выбрана третья строка. Сохраненные выбор теперь поддерживается для *GridView* и *ListView* элементов управления во всех проектах с помощью *EnablePersistedSelection* свойства, как показано на Следующий пример:

[!code-aspx[Main](overview/samples/sample57.aspx)]

<a id="0.2__Toc253429263"></a><a id="0.2__Toc243304637"></a>

### <a name="aspnet-chart-control"></a>Элемент управления диаграммы для ASP.NET

ASP.NET *диаграммы* элемент управления расширяется предложения визуализации данных в .NET Framework. С помощью *диаграммы* элемента управления, можно создавать страницы ASP.NET с интуитивно понятными и визуально привлекательные диаграммы для сложного статистического или финансового анализа. ASP.NET *диаграммы* управления был представлен как дополнительный компонент для выпуска платформы .NET Framework версии 3.5 с пакетом обновления 1 и является частью выпуска .NET Framework 4.

Элемент управления включает в себя следующие компоненты:

- 35 различных типов диаграмм.
- Неограниченное количество областей диаграммы, заголовков, условных обозначений и заметок.
- Разнообразные параметры отображения для всех элементов диаграммы.
- Поддержка трехмерного для большинства типов диаграмм.
- Данные смарт-меток, которые можно автоматически помещаются вокруг точек данных.
- Полосковые линии, разрывы шкалы и логарифмической шкале.
- Более 50 финансовых и статистических формул для анализа данных и преобразования данных.
- Простая привязка и обработка данных диаграммы.
- Поддержка распространенных форматах данных, например дат, времени и валюты.
- Поддержка для интерактивности и настройка на основе событий, включая клиента щелкните событий с помощью Ajax.
- Управление состоянием.
- Двоичные потоки.

На следующих иллюстрациях показан примеры финансовых диаграмм, созданные с помощью элемента управления диаграммы для ASP.NET.

<a id="0.2_graphic17"></a>![](overview/_static/image1.png)

Рис. 2. Примеры элементов управления диаграммы для ASP.NET

Дополнительные примеры того, как использовать элемент управления диаграммы для ASP.NET, загрузив пример кода на [среда с примерами для элементов управления Microsoft Chart](https://go.microsoft.com/fwlink/?LinkId=128300) страницу на веб-сайте MSDN. Дополнительные примеры сообщества можно найти содержание веб- [форуме по элементу управления диаграммы](https://go.microsoft.com/fwlink/?LinkId=128713).

#### <a name="adding-the-chart-control-to-an-aspnet-page"></a>Добавление элемента управления диаграммы в страницу ASP.NET

В следующем примере показано, как добавить *диаграммы* элемента управления на страницу ASP.NET с помощью разметки. В примере *диаграммы* управления создает гистограмму для статических данных точек.

[!code-aspx[Main](overview/samples/sample58.aspx)]

#### <a name="using-3-d-charts"></a>Использование трехмерных диаграмм

*Диаграммы* элемент управления содержит *ChartAreas* коллекции, которая может содержать *ChartArea* объекты, определяющие характеристики областей диаграммы. Например, чтобы использовать трехмерные области диаграммы, используйте *Area3DStyle* свойства, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample59.aspx)]

На рисунке ниже показаны объемной диаграммы с помощью четырех рядов *панели* тип диаграммы.

<a id="0.2_graphic18"></a>![](overview/_static/image2.png)

Рис. 3. Объемной линейчатой диаграммы

#### <a name="using-scale-breaks-and-logarithmic-scales"></a>С помощью разрывов шкалы и логарифмической шкалы

Разрывы шкалы и логарифмических шкал являются два дополнительных способа добавления сложности к диаграмме. Эти функции относятся к каждой оси области диаграммы. Например, чтобы использовать эти возможности на основной оси Y области диаграммы, используйте *AxisY.IsLogarithmic* и *ScaleBreakStyle* свойств в *ChartArea* объекта. В следующем фрагменте показано, как использовать разрывы шкалы на основной оси Y.

[!code-aspx[Main](overview/samples/sample60.aspx)]

На рисунке ниже показана ось Y с разрывами шкалы включена.

<a id="0.2_graphic19"></a>![](overview/_static/image3.png)

Рис. 4. Разрывы шкалы

<a id="0.2__QueryExtender"></a><a id="0.2__Toc224729041"></a><a id="0.2__Toc253429264"></a><a id="0.2__Toc243304638"></a>

### <a name="filtering-data-with-the-queryextender-control"></a>Фильтрация данных с помощью элемента управления

Для фильтрации данных является очень общей задачей для разработчиков, которые создают управляемые данными веб-страниц. Это традиционно была выполнена, создав *где* элементами управления источниками предложения в данных. Этот подход может оказаться сложным, а в некоторых случаях *где* синтаксис не позволяет воспользоваться преимуществами возможности основной базе данных.

Для упрощения фильтрации, новый *элемента* элемент управления добавлен в ASP.NET 4. Этот элемент управления, которые могут добавляться к *EntityDataSource* или *LinqDataSource* элементов управления, чтобы отфильтровать данные, возвращаемые этими элементами управления. Так как *элемента* , элемент управления использует LINQ, перед отправкой данных на страницу, что приводит к очень эффективные операции на сервере базы данных применяется фильтр.

*Элемента* элемент управления поддерживает разнообразные параметры фильтра. В следующих разделах описываются эти параметры и приводятся примеры их использования.

#### <a name="search"></a>Поиск

Для параметра поиска *элемента* элемент управления выполняет поиск в заданных полях. В следующем примере элемент управления использует текст, который вводится в элемент управления TextBoxSearch и ищет свое содержимое в `ProductName` и `Supplier.CompanyName` столбцами данных, который возвращается из *LinqDataSource* элемент управления.

[!code-aspx[Main](overview/samples/sample61.aspx)]

#### <a name="range"></a>Диапазон

Параметр «диапазон» похоже на вариант поиска, но указывает пара значений для определения диапазона. В следующем примере *элемента* управления поиск `UnitPrice` столбец в данных, возвращаемых из *LinqDataSource* элемента управления. Диапазон считывается из TextBoxFrom и TextBoxTo элементов управления на странице.

[!code-aspx[Main](overview/samples/sample62.aspx)]

#### <a name="propertyexpression"></a>PropertyExpression

Параметр выражения свойство позволяет определить сравнение со значением свойства. Если выражение, результатом которого является *true*, возвращаемых данных, который анализируется. В следующем примере *элемента* управления фильтрует данные, сравнивая данные в `Discontinued` столбец значение из элемента управления CheckBoxDiscontinued на странице.

[!code-aspx[Main](overview/samples/sample63.aspx)]

#### <a name="customexpression"></a>CustomExpression

Наконец, можно указать пользовательское выражение для использования с *элемента* элемента управления. Этот параметр позволяет вызвать функцию в страницы и определяет логику пользовательского фильтра. В следующем примере показано, как декларативно задать пользовательское выражение в *элемента* элемента управления.

[!code-aspx[Main](overview/samples/sample64.aspx)]

В следующем примере показано пользовательскую функцию, вызываемую объектом *элемента* элемента управления. В этом случае вместо запроса к базе данных, который включает в себя *где* предложение, код использует запрос LINQ для фильтрации данных.

[!code-csharp[Main](overview/samples/sample65.cs)]

Эти примеры показывают только одно выражение используется в *элемента* управления за раз. Тем не менее, можно включить несколько выражений внутри *элемента* элемента управления.

<a id="0.2__Toc253429265"></a><a id="0.2__Toc243304639"></a>

### <a name="html-encoded-code-expressions"></a>Выражения кода в кодировке HTML

Некоторые сайты ASP.NET (особенно с ASP.NET MVC) сильно зависят от использования `<%` =  `expression %>` синтаксис (часто называемые «фрагменты кода») для записи какой-либо текст в ответ. При использовании выражения кода, это легко забыть для ввода текста, если текст поступает от пользователя, его можно оставить страниц открытым для атаки XSS (Cross Site Scripting) с HTML-кодирования.

ASP.NET 4 ниже новый синтаксис для выражения кода:

[!code-aspx[Main](overview/samples/sample66.aspx)]

Этот синтаксис используется кодировка HTML по умолчанию при записи ответа. Новое выражение фактически переводит следующим:

[!code-aspx[Main](overview/samples/sample67.aspx)]

Например &lt;%: Запрос [«UserInput»] %&gt; выполняет HTML-кодирования на значении *запроса [«UserInput»]*.

Эта функция призван обеспечить возможность замены всех экземпляров старого синтаксиса с новым синтаксисом, таким образом, чтобы вам не придется решить на каждом этапе, какой из них следует использовать. Тем не менее существуют случаи, в которых текст выходных данных должен быть HTML или уже закодирован, в этом случае это может привести к двойной кодировкой.

В таких случаях ASP.NET 4 введен новый интерфейс, *IHtmlString*, вместе с конкретной реализацией, *HtmlString*. Экземпляры этих типов позволяют указать, что возвращаемое значение уже правильную кодировку (или в противном случае исследовать) для отображения в виде HTML и, таким образом значение не должно быть HTML-кодированную еще раз. Например, следующее не должно быть (и не является) кодируется в HTML:

[!code-aspx[Main](overview/samples/sample68.aspx)]

Вспомогательные методы ASP.NET MVC 2 были обновлены до работы с помощью этого нового синтаксиса, таким образом, чтобы они не double в кодировке, но только при запуске ASP.NET 4. Этот новый синтаксис не работает при запуске приложения с помощью ASP.NET 3.5 с пакетом обновления 1.

Имейте в виду, что это не гарантирует защиту от атак с XSS. Например HTML, который использует значения атрибутов, которые не заключаются в кавычки может содержать данные, которые по-прежнему подвержен. Обратите внимание на то, что выходные данные элементов управления ASP.NET и вспомогательных методов ASP.NET MVC всегда включает значения атрибутов в кавычки, который является рекомендуемым подходом.

Аналогичным образом этот синтаксис не выполняет кодирование JavaScript, например при создании строки JavaScript на основе ввода пользователя.

<a id="0.2__Toc253429266"></a><a id="0.2__Toc243304640"></a>

### <a name="project-template-changes"></a>Изменения шаблонов проектов

В более ранних версиях ASP.NET, при использовании Visual Studio для создания нового проекта веб-сайта или проекта веб-приложения, полученный проекты содержат только страницу Default.aspx, но по умолчанию `Web.config` файл и `App_Data` папки, как показано в следующем примере иллюстрации:

<a id="0.2_graphic1A"></a>![](overview/_static/image4.png)

Visual Studio также поддерживает тип проекта пустого веб-сайта, который не содержит файлов вообще, как показано на следующем рисунке:

<a id="0.2_graphic1B"></a>![](overview/_static/image5.png)

Результатом является то, что для новичков, имеется очень мало рекомендации по созданию рабочей веб-приложения. Таким образом ASP.NET 4 впервые представлены три новых шаблона, один для пустой проект веб-приложения и по одному для каждого веб-приложения и веб-сайт проекта.

#### <a name="empty-web-application-template"></a>Шаблон пустой веб-приложения

Как и предполагает имя, шаблон пустое веб-приложение — это урезанная проект веб-приложения. Этот шаблон проекта выберите в диалоговом окне создания проекта Visual Studio, как показано на следующем рисунке:

[![](overview/_static/image7.png)](overview/_static/image6.png)

([Просмотр полноразмерного изображения](overview/_static/image8.png))

При создании пустой веб-приложения ASP.NET, Visual Studio создает макета следующие папки:

<a id="0.2_graphic1D"></a>![](overview/_static/image9.png)

Это похоже на макет пустой веб-сайт из более ранних версиях ASP.NET, за одним исключением. В Visual Studio 2010, пустое веб-приложение и пустой веб-сайт проекты содержат следующие минимальным `Web.config` файл, содержащий сведения, используемые Visual Studio для определения платформы, на которой предназначен проект:

<a id="0.2_graphic1E"></a>![](overview/_static/image10.png)

Без этого *targetFramework* свойства, предназначенные для .NET Framework 2.0 для сохранения совместимости при открытии старые приложения по умолчанию Visual Studio.

#### <a name="web-application-and-web-site-project-templates"></a>Веб-приложения и шаблоны проектов веб-сайта

Другие два новых шаблонов проектов, которые входят в состав Visual Studio 2010 содержит значительные изменения. На следующем рисунке показана макет проекта, который создается при создании нового проекта веб-приложения. (Макет для проекта веб-сайта практически идентичен.)

- <a id="0.2_graphic1F"></a>![](overview/_static/image11.png)

Проект содержит несколько файлов, которые не были созданы в более ранних версиях. Кроме того новый проект веб-приложения настроены базовый уровень участия возможность, которая позволяет быстро приступить к работе в защите доступа для нового приложения. Из-за это Включение `Web.config` файла для нового проекта содержит записи, которые используются для настройки членства, ролей и профилей. В следующем примере показан `Web.config` файла для нового проекта веб-приложения. (В этом случае *roleManager* отключена.)

[![](overview/_static/image13.png)](overview/_static/image12.png)

([Просмотр полноразмерного изображения](overview/_static/image14.png))

Проект также содержит секунды `Web.config` файл `Account` каталог. Второй файл конфигурации позволяет обеспечить безопасный доступ к странице ChangePassword.aspx не выполнивших вход пользователей. В следующем примере показано содержимое второго `Web.config` файл.

![](overview/_static/image15.png)

Страницы, созданный по умолчанию в новых шаблонов проектов также содержат больше содержимого, в предыдущих версиях. Проект содержит главную страницу по умолчанию и CSS-файл, и страница по умолчанию (Default.aspx) настроен на использование главной страницы по умолчанию. Результат является при запуске веб-приложение или веб-сайт в первый раз, странице (home) по умолчанию уже функциональной. На самом деле это похоже на страницу по умолчанию, отображаемые при запуске нового приложения MVC.

[![](overview/_static/image17.png)](overview/_static/image16.png)

([Просмотр полноразмерного изображения](overview/_static/image18.png))

Эти изменения в шаблоны проектов планируется предоставить рекомендации о том, как приступить к созданию нового веб-приложения. С помощью корректно, strict XHTML 1.0-разметки, совместимой с и макетом, который задается с помощью CSS страниц в шаблонах представляют рекомендации по созданию 4 веб-приложений ASP.NET. Страницы по умолчанию также имеют макет два столбца, который вы можете легко настроить.

Например представьте, что для нового веб-приложения вы хотите изменить некоторые цвета и вставьте логотип организации вместо логотип Мое приложение ASP.NET. Чтобы сделать это, создайте новый каталог в `Content` для хранения изображения логотипа:

<a id="0.2_graphic23"></a>![](overview/_static/image19.png)

Чтобы добавить изображение к странице, затем откройте `Site.Master` найдите, где определен текст Мое приложение ASP.NET и замените ее строкой *изображение* элемент которого *src* атрибут имеет значение нового логотипа образ, как показано в следующем примере:

[![](overview/_static/image21.png)](overview/_static/image20.png)

([Просмотр полноразмерного изображения](overview/_static/image22.png))

Затем можно перейти в файл Site.css и изменять определения классов CSS, чтобы изменить цвет фона страницы, а также, заголовка.

Эти изменения образом, можно отобразить настроенной домашней страницы без особых усилий:

[![](overview/_static/image24.png)](overview/_static/image23.png)

([Просмотр полноразмерного изображения](overview/_static/image25.png))

<a id="0.2__Toc253429267"></a><a id="0.2__Toc243304641"></a>

### <a name="css-improvements"></a>Усовершенствования CSS

Одно из основных областей работы в ASP.NET 4 было помогающие отрисовывать HTML, который соответствует требованиям новейших стандартов HTML. Сюда входят изменения как серверные элементы управления ASP.NET при помощи стилей CSS.

#### <a name="compatibility-setting-for-rendering"></a>Параметр совместимости для подготовки к просмотру

По умолчанию, когда веб-приложение или веб-сайт предназначен для .NET Framework 4 *controlRenderingCompatibilityVersion* атрибут *страниц* имеет значение «4.0». Этот элемент определен в уровне компьютера `Web.config` файла и по умолчанию применяется ко всем приложениям ASP.NET 4:

[!code-xml[Main](overview/samples/sample69.xml)]

Значение для *controlRenderingCompatibility* представляет собой строку, что позволяет потенциальных новых версий определений в будущих выпусках. В текущем выпуске для этого свойства поддерживаются следующие значения:

- "3.5". Этот параметр указывает отрисовки прежних версий и разметки. Разметка, элементы управления — 100% совместим, а также *xhtmlConformance* учитывается свойство.
- "4.0". Если свойство имеет этот параметр, серверные элементы управления ASP.NET сделайте следующее:
- *XhtmlConformance* всегда считается «Strict». Таким образом элементы управления отображают разметки XHTML 1.0 Strict.
- Отключение элементов управления не связанной с входом больше не отображает недопустимых стилей.
- *div* элементы вокруг скрытые поля теперь выглядят, поэтому они не конфликтуют с помощью правил CSS, созданные пользователем.
- Элементы управления меню используют разметку, семантически правильно и соответствует рекомендациям по доступности.
- Проверяющие элементы управления не отображают встроенные стили.
- Элементы управления, ранее к просмотру границы = «0» (элементы управления, которые являются производными от ASP.NET *таблицы* управления и ASP.NET *образа* управления) больше не отрисовывают этот атрибут.

#### <a name="disabling-controls"></a>Отключение элементов управления

В ASP.NET 3.5 с пакетом обновления 1 и более ранних версий, платформа отображает *отключена* атрибут в разметке HTML для любой элемент управления *включено* свойство значение *false*. Тем не менее, согласно спецификации HTML 4.01, только *ввода* элементы должны иметь этот атрибут.

В ASP.NET 4, можно задать *controlRenderingCompatibilityVersion* значение «3.5», как показано в следующем примере:

[!code-xml[Main](overview/samples/sample70.xml)]

Можно создать разметку для *метка* управления следующим образом, который отключает элемент управления:

[!code-aspx[Main](overview/samples/sample71.aspx)]

*Метка* управления будет отображен следующий HTML:

[!code-html[Main](overview/samples/sample72.html)]

В ASP.NET 4, можно задать *controlRenderingCompatibilityVersion* значение «4.0». Только элементы управления, работающие в этом случае *входной* элементы будут отображаться *отключена* атрибут элемента управления *включено* свойству *false* . Элементы управления, которые не отображают HTML *входной* вместо отображения элементов *класс* атрибут, который ссылается на класс CSS, который можно использовать для определения отключенный внешний вид элемента управления. Например *метка* элемента, показан в предыдущем примере создаст следующую разметку:

[!code-html[Main](overview/samples/sample73.html)]

Значение по умолчанию для класса, который указан для этого элемента управления — «aspNetDisabled». Тем не менее, это значение по умолчанию можно изменить, задав статический *DisabledCssClass* статическое свойство *WebControl* класса. Для разработчиков элементов управления, поведение, используемое для конкретного элемента управления также можно определить с помощью *SupportsDisabledAttribute* свойство.

<a id="0.2__Toc253429268"></a><a id="0.2__Toc243304642"></a>

### <a name="hiding-div-elements-around-hidden-fields"></a>Скрытие div элементы вокруг скрытые поля

ASP.NET 2.0 и более поздних версиях визуализации скрытого поля со сведениями о системе (например, *скрытые* элемент, используемый для хранения сведений о состоянии представления) внутри *div* элемент для обеспечения соответствия стандарту XHTML. Тем не менее, это может вызвать проблему, когда правило CSS затрагивает *div* элементов на странице. Например, это может привести в один пиксель строки в странице около скрытые *div* элементов. В ASP.NET 4 *div* элементов, в которые заключены скрытые поля, созданный ASP.NET добавьте ссылку на класс CSS как в следующем примере:

[!code-html[Main](overview/samples/sample74.html)]

Затем можно определить класс CSS, который применяется только к *скрытые* элементы, которые создаются, ASP.NET, как показано в следующем примере:

[!code-css[Main](overview/samples/sample75.css)]

<a id="0.2__Toc253429269"></a><a id="0.2__Toc243304643"></a>

### <a name="rendering-an-outer-table-for-templated-controls"></a>Подготовка к просмотру внешняя таблица шаблонных элементов управления

По умолчанию следующие серверные элементы управления ASP.NET, которые поддерживают шаблоны, будут автоматически переноситься в внешней таблицы, которая используется для применения встроенных стилей:

- *FormView*
- *Модуль*
- *PasswordRecovery*
- *Изменение пароля*
- *Мастер*
- *CreateUserWizard*

Новое свойство с именем *RenderOuterTable* был добавлен в эти элементы управления, которые позволяет внешней таблицы удаляются из разметки. Например, рассмотрим следующий пример *FormView* управления:

[!code-aspx[Main](overview/samples/sample76.aspx)]

Эта разметка отображает следующие выходные данные на страницу, которая включает таблицу HTML:

[!code-html[Main](overview/samples/sample77.html)]

Чтобы предотвратить вывод в таблице, можно задать *FormView* элемента управления *RenderOuterTable* свойства, как показано в следующем примере:

[!code-aspx[Main](overview/samples/sample78.aspx)]

Предыдущий пример отображает следующие выходные данные без *таблицы*, *tr*, и *td* элементов:

> Content


Это улучшение можно упростить его стиль содержимого элемента управления с помощью CSS, так как непредвиденные теги не отображаются с помощью элемента управления.

> [!NOTE]
> Обратите внимание, это изменение отключает поддержку функции автоматическое форматирование в конструкторе Visual Studio 2010, так как оно больше не *таблицы* элемент, который может содержать атрибуты стиля, которые создаются с помощью параметра автоматического форматирования.


<a id="0.2__Toc253429270"></a><a id="0.2__Toc243304644"></a>

### <a name="listview-control-enhancements"></a>Улучшенные элементы управления ListView

*ListView* управления стала проще в использовании в ASP.NET 4. Более раннюю версию элемента управления требуется указывать шаблон макета, содержащий серверный элемент управления с известным идентификатором. В следующей разметке показан типичный пример использования *ListView* элемента управления в ASP.NET 3.5.

[!code-aspx[Main](overview/samples/sample79.aspx)]

В ASP.NET 4 *ListView* шаблон макета не требуется. Разметка, показанная в предыдущем примере можно заменить на следующую разметку:

[!code-aspx[Main](overview/samples/sample80.aspx)]

<a id="0.2__Toc253429271"></a><a id="0.2__Toc243304645"></a>

### <a name="checkboxlist-and-radiobuttonlist-control-enhancements"></a>CheckBoxList и улучшенные элементы управления RadioButtonList

В ASP.NET 3.5, можно задать макет для *CheckBoxList* и *RadioButtonList* с помощью два следующих параметра:

- *Поток*. Выполняет визуализацию элемента управления *span* элементов для хранения его содержимого.
- *Таблица*. Выполняет визуализацию элемента управления *таблицы* элемента для хранения его содержимого.

В следующем примере показана разметка для каждого из этих элементов управления.

[!code-aspx[Main](overview/samples/sample81.aspx)]

По умолчанию элементы управления отображают HTML следующего вида:

[!code-html[Main](overview/samples/sample82.html)]

Так как эти элементы управления содержат списки элементов, для подготовки к просмотру нарушает семантическое упорядочивание HTML, маркеры должны отобразится правильно их содержимое при помощи HTML-списка (*li*) элементов. Это упрощает для пользователей, которым чтение веб-страниц, с помощью специальных возможностей и упрощает элементы управления стиля с помощью CSS.

В ASP.NET 4 *CheckBoxList* и *RadioButtonList* элементы управления поддерживают новые значения для *RepeatLayout* свойство:

- *OrderedList* — содержимое отображается в виде *li* элементы внутри *ol* элемент.
- *UnorderedList* — содержимое отображается в виде *li* элементы внутри *ul* элемент.

В следующем примере показано, как использовать эти новые значения.

[!code-aspx[Main](overview/samples/sample83.aspx)]

Предыдущая разметка создает следующий HTML:

[!code-html[Main](overview/samples/sample84.html)]

> [!NOTE]
> Обратите внимание, если значение *RepeatLayout* для *OrderedList* или *UnorderedList*, *RepeatDirection* свойство больше не может использоваться и будет создания исключения во время выполнения, если свойство было задано в разметку или код. Свойство бы нет значения, так как визуальное расположение этих элементов управления определяется с помощью CSS вместо этого.


<a id="0.2__Toc253429272"></a><a id="0.2__Toc243304646"></a>

### <a name="menu-control-improvements"></a>Усовершенствования управления меню

До ASP.NET 4 *меню* визуализация ряда таблиц HTML элемента управления. Это служит для применения стилей CSS за пределами встроенные свойства и оно также не соответствует стандартам специальных возможностей.

В ASP.NET 4 элемент управления теперь отображает HTML с использованием семантического разметку, которая содержит неупорядоченный список и элементы списка. В следующем примере разметки показано на странице ASP.NET для *меню* элемента управления.

[!code-aspx[Main](overview/samples/sample85.aspx)]

При отображении страницы, элемент управления создает следующий HTML ( *onclick* код включен для ясности):

[!code-html[Main](overview/samples/sample86.html)]

В дополнение к визуализации меню с помощью клавиатуры был улучшен с помощью управления фокусом. Когда *меню* элемент управления получает фокус, можно использовать клавиши со стрелками для перемещения элементов. *Меню* управления теперь также присоединяет доступны широкие возможности ролей приложений (ARIA) Интернета и атрибуты, а затем[ледующему](http://www.w3.org/TR/wai-aria-practices/#menu "рекомендации ARIA меню")для улучшения специальные возможности.

Стили для элемента управления меню выводятся в блок стилей в верхней части страницы, а не в соответствии с визуализированных элементов HTML. Если вы хотите воспользоваться полный контроль над стили для элемента управления, можно задать новый *IncludeStyleBlock* свойства *false*, в этом случае не создается блок стиля. Для использования этого свойства рекомендуется использовать функцию Автоматическое форматирование в конструкторе Visual Studio, чтобы задать внешний вид меню. Затем можно запустить эту страницу, откройте исходный код страницы и затем скопируйте отображаемый стиль блок во внешний файл CSS. В Visual Studio, отменить использование стилей и набор *IncludeStyleBlock* для *false*. Результатом является то, что внешний вид меню определен с использованием стилей во внешней таблице стилей.

<a id="0.2__Toc253429273"></a><a id="0.2__Toc243304647"></a>

### <a name="wizard-and-createuserwizard-controls"></a>Мастера и элементы управления CreateUserWizard

ASP.NET *мастер* и *CreateUserWizard* элементы управления поддерживают шаблоны, позволяющие определять код HTML, отображения. (*CreateUserWizard* является производным от *мастер*.) В следующем примере показана разметка для полностью шаблонного *CreateUserWizard* управления:

[!code-aspx[Main](overview/samples/sample87.aspx)]

Элемент управления отображает HTML, аналогичную следующей:

[!code-html[Main](overview/samples/sample88.html)]

В ASP.NET 3.5 SP1, несмотря на то, что можно изменить содержимое шаблона, вы по-прежнему имеют ограниченный контроль над выходные данные *мастер* элемента управления. В ASP.NET 4, можно создать *LayoutTemplate* шаблона и insert *заполнитель* управляет (с помощью зарезервированных имен) для указания способа *элемента управления Wizard* для подготовки к просмотру. Это показано в следующем примере:

[!code-aspx[Main](overview/samples/sample89.aspx)]

Пример содержит следующие именованные заполнители в *LayoutTemplate* элемент:

- *headerPlaceholder* — во время выполнения, оно заменяется содержимое *HeaderTemplate* элемент.
- *sideBarPlaceholder* — во время выполнения, оно заменяется содержимое *SideBarTemplate* элемент.
- *wizardStepPlaceHolder* — во время выполнения, оно заменяется содержимое *WizardStepTemplate* элемент.
- *navigationPlaceholder* — во время выполнения, оно заменяется навигации шаблоны, которые вы определили.

Разметка в примере, который использует заполнители отображает следующий HTML (без содержимого, фактически определенных в шаблонах):

[!code-html[Main](overview/samples/sample90.html)]

Только код HTML является теперь не определяемых пользователем является *span* элемент. (Мы полагаем, в будущих выпусках, даже *span* не будет визуализирован элемент.) Вы увидите полный контроль над практически все содержимое, создаваемое *мастер* элемента управления.

<a id="0.2_dyndata"></a><a id="0.2__Toc253429274"></a><a id="0.2__Toc243304648"></a><a id="0.2__Toc224729042"></a>

## <a name="aspnet-mvc"></a>ASP.NET MVC

ASP.NET MVC была введена как платформу надстройки ASP.NET 3.5 с пакетом обновления 1 в марте 2009 г. Visual Studio 2010 включает в себя ASP.NET MVC 2, который включает новые функции и возможности.

<a id="0.2__Toc253429275"></a>

### <a name="areas-support"></a>Поддержка областей

Области позволяют группы контроллеров и представлений в разделы большого приложения относительно изолированно от других разделов. Каждая область может быть реализован как отдельный проект ASP.NET MVC, который затем можно использовать для основного приложения. Это помогает справляться с трудностями при построении больших приложений и упрощает для нескольких команд для совместной работы по одному приложению.

<a id="0.2__Toc253429276"></a>

### <a name="data-annotation-attribute-validation-support"></a>Поддержка проверки атрибута заметок к данным

*DataAnnotations* атрибуты позволяют присоединить логику проверки в модель с помощью атрибутов метаданных. *DataAnnotations* атрибуты были представлены в платформе динамических данных ASP.NET в ASP.NET 3.5 SP1. Эти атрибуты были интегрированы на связыватель модели по умолчанию и предоставляют средства на основе метаданных, вводимых пользователем.

<a id="0.2__Toc253429277"></a>

### <a name="templated-helpers"></a>Шаблонизированные вспомогательные объекты

Шаблонизированные вспомогательные объекты позволяют автоматически связать редактирования и отобразить шаблоны с типами данных. Например, можно использовать вспомогательный объект шаблона для указания, что элемент пользовательского интерфейса выбора даты автоматически выводится для *System.DateTime* значение. Это похоже на шаблоны полей в платформе динамических данных ASP.NET.

*Объект Html.EditorFor* и *Html.DisplayFor* вспомогательные методы имеют встроенную поддержку для визуализации данных стандартные типы объектов, а также сложные с несколькими свойствами. Они также настройки отображения, позволяя применять атрибуты заметок к данным, например *DisplayName* и *ScaffoldColumn* для *ViewModel* объекта.

Часто требуется для настройки выходных данных из вспомогательных функций пользовательского интерфейса еще дальше и имеют полный контроль над создаваемой. *Объект Html.EditorFor* и *Html.DisplayFor* вспомогательные методы поддерживают это с помощью механизма шаблонов, позволяющее определять внешние шаблоны, которые можно переопределить и подготовке к просмотру выходные данные элемента управления. Шаблоны могут быть представлены отдельно для класса.

<a id="0.2__Toc253429278"></a><a id="0.2__Toc243304649"></a>

## <a name="dynamic-data"></a>динамические данные

Платформа динамических данных была введена в версии .NET Framework 3.5 SP1 в середине 2008. Эта функция обеспечивает множество улучшений для создания управляемых данными приложений, включая следующие:

- РАЗРАБОТКА приложений для быстрого создания управляемых данными веб-сайта.
- Автоматическая проверка на основе ограничений, определенных в модели данных.
- Возможность легко изменять разметку, которая создается для полей в *GridView* и *DetailsView* элементы управления, используя шаблоны полей, которые являются частью проекта платформы динамических данных.

> [!NOTE]
> Обратите внимание, Дополнительные сведения, см. в разделе [документации платформы динамических данных](https://msdn.microsoft.com/library/cc488545.aspx) в библиотеке MSDN.


Для ASP.NET 4 динамических данных была усовершенствована для предоставления разработчикам еще больше возможностей для быстрого создания управляемых данными веб-сайтов.

<a id="0.2__Toc253429279"></a><a id="0.2__Toc243304650"></a>

### <a name="enabling-dynamic-data-for-existing-projects"></a>Включение платформы динамических данных для существующих проектов

Динамических данных функций, которые поставляются в .NET Framework 3.5 SP1 подключить новые компоненты, например следующие:

- Шаблоны полей — они предоставляют шаблоны на основе типа данных для элементов управления с привязкой к данным. Поле шаблоны предоставляют простой способ настройки внешнего вида элементов управления данными, чем при использовании шаблона поля для каждого поля.
- Проверка платформы динамических данных позволяет использовать атрибуты в классах данных для указания проверки для распространенных сценариев, таких как обязательные поля, проверка диапазона, тип проверки, сопоставления с помощью регулярных выражений шаблонов и проведение пользовательской проверки. Проверка проводится элементами данных.

Тем не менее эти функции имели следующие требования:

- На уровне доступа к данным должен основываться на платформе Entity Framework или LINQ to SQL.
- Элементы управления, поддерживаемых для этих функций источника только данные *EntityDataSource* или *LinqDataSource* элементов управления.
- Функции требуется веб-проекта, созданной с помощью платформы динамических данных или шаблоны динамических сущностей данных для всех файлов, необходимых для поддержки функции.

Основная цель поддержки динамических данных в ASP.NET 4 состоит в том, чтобы включить новые функции платформы динамических данных для любого приложения ASP.NET. В следующем примере показана разметка для элементов управления, можно воспользоваться преимуществами функций платформы динамических данных в существующую страницу.

[!code-aspx[Main](overview/samples/sample91.aspx)]

В коде для страницы Чтобы включить поддержку платформы динамических данных для этих элементов управления необходимо добавить следующий код:

[!code-csharp[Main](overview/samples/sample92.cs)]

Когда *GridView* находится в режиме правки, динамических данных автоматически проверяет, принадлежит ли данные, введенные в неправильном формате. Если это не так, отображается сообщение об ошибке.

Эта функция также предоставляет другие преимущества, такие как возможность задать по умолчанию значения для вставки в режиме вставки. Без динамических данных, для реализации по умолчанию для поля, необходимо присоединить к событию, найдите элемент управления (с помощью *FindControl*) и присвойте ему значение. В ASP.NET 4 *EnableDynamicData* вызов поддерживает второй параметр, который позволяет передавать значения по умолчанию для любого поля в объекте, как показано в следующем примере:

[!code-csharp[Main](overview/samples/sample93.cs)]

<a id="0.2__Toc224729043"></a><a id="0.2__Toc253429280"></a><a id="0.2__Toc243304651"></a>

### <a name="declarative-dynamicdatamanager-control-syntax"></a>Синтаксис декларативной элемента управления DynamicDataManager

*DynamicDataManager* управления был усовершенствован таким образом, чтобы его можно настроить декларативно, как и в большинстве элементов управления ASP.NET, а не только в коде. Разметка для *DynamicDataManager* элемент управления выглядит как в следующем примере:

[!code-aspx[Main](overview/samples/sample94.aspx)]

Эта разметка разрешает поведение платформы динамических данных для элемента управления GridView1, упоминаемый в *DataControls* раздел *DynamicDataManager* элемента управления.

<a id="0.2__Toc224729044"></a><a id="0.2__Toc253429281"></a><a id="0.2__Toc243304652"></a>

### <a name="entity-templates"></a>Шаблоны сущностей

Шаблоны сущностей предлагают новый способ настройки макета данных без необходимости создания пользовательской страницы. Странице шаблонов *FormView* управления (а не *DetailsView* контролировать, как в шаблоны страниц в более ранних версиях платформы динамических данных) и *DynamicEntity* элемент управления для визуализации шаблонов сущностей. Это дает больший контроль над разметкой, отображаемой платформой динамических данных.

Ниже перечислены новый макет каталог проекта, который содержит шаблоны сущностей.

[!code-console[Main](overview/samples/sample95.cmd)]

`EntityTemplate` Каталог содержит шаблоны для отображения объектов модели данных. По умолчанию объекты отрисовываются с помощью `Default.ascx` шаблон, который предоставляет разметку, которая выглядит так же, как разметка, созданные *DetailsView* элемент управления, используемый платформой динамических данных в ASP.NET 3.5 SP1. В следующем примере показана разметка для `Default.ascx` управления:

[!code-aspx[Main](overview/samples/sample96.aspx)]

Шаблоны по умолчанию можно изменить для изменения внешнего вида и поведения для всего сайта. Существуют шаблоны для отображения, редактирования и операций вставки. Новые шаблоны можно добавить на основе имени объекта данных для изменения внешнего вида только один тип объекта. Например можно добавить следующий шаблон:

[!code-console[Main](overview/samples/sample97.cmd)]

Шаблон может содержать следующую разметку:

[!code-aspx[Main](overview/samples/sample98.aspx)]

Новые шаблоны сущности отображаются на странице с помощью нового *DynamicEntity* элемента управления. Во время выполнения этот элемент управления будет заменен содержимое шаблона сущности. Следующая разметка показывает *FormView* контролировать `Detail.aspx` странице шаблона, который использует шаблон сущности. Обратите внимание, что *DynamicEntity* элемент в разметке.

[!code-aspx[Main](overview/samples/sample99.aspx)]

<a id="0.2__Toc224729045"></a><a id="0.2__Toc253429282"></a><a id="0.2__Toc243304653"></a>

### <a name="new-field-templates-for-urls-and-email-addresses"></a>Новые шаблоны полей для URL-адреса и адреса электронной почты

ASP.NET 4 появились два новых встроенное поле шаблоны, `EmailAddress.ascx` и `Url.ascx`. Эти шаблоны используются для полей, которые помечены как *EmailAddress* или *URL-адрес* с *DataType* атрибута. Для *EmailAddress* объектов, поле отображается в виде гиперссылки, которая создается с помощью *mailto:* протокола. Когда пользователь щелкает ссылку, он открывает клиент электронной почты пользователя и создается макет сообщения. Объекты типизированными как *URL-адрес* отображаются как обычные гиперссылки.

В следующем примере показано, как будет помечать поля.

[!code-csharp[Main](overview/samples/sample100.cs)]

<a id="0.2__Toc224729046"></a><a id="0.2__Toc253429283"></a><a id="0.2__Toc243304654"></a>

### <a name="creating-links-with-the-dynamichyperlink-control"></a>Создание связей с элементом управления DynamicHyperLink

Динамические данные используют новую функцию маршрутизации, которое было добавлено в .NET Framework 3.5 SP1, для управления URL-адреса, которые конечные пользователи будут видеть при доступе к веб-сайта. Новый *DynamicHyperLink* управления упрощает создание ссылок на страницах сайта динамических данных. В следующем примере показано, как использовать *DynamicHyperLink* управления:

[!code-aspx[Main](overview/samples/sample101.aspx)]

Эта разметка создает ссылку, которая указывает на страницу списка для `Products` таблицы на основе маршрутов, которые определены в `Global.asax` файл. Элемент управления автоматически использует имя таблицы по умолчанию на основе динамических данных страницы.

<a id="0.2__Toc224729047"></a><a id="0.2__Toc253429284"></a><a id="0.2__Toc243304655"></a>

### <a name="support-for-inheritance-in-the-data-model"></a>Поддержка наследования в модели данных

Entity Framework и LINQ to SQL поддерживает наследование в моделях данных. Примером этого может быть база данных с `InsurancePolicy` таблицы. Она может также содержать `CarPolicy` и `HousePolicy` таблицы, имеющие те же поля, что `InsurancePolicy` и затем добавить дополнительные поля. Динамические данные изменялись наследуемые объекты в модели данных и поддержки формирования шаблонов для производных таблиц.

<a id="0.2__Toc224729048"></a><a id="0.2__Toc253429285"></a><a id="0.2__Toc243304656"></a>

### <a name="support-for-many-to-many-relationships-entity-framework-only"></a>Поддержка связей многие ко многим (только платформа Entity Framework)

Платформа Entity Framework поддерживает многие ко многим связи между таблицами, которые реализованы за счет предоставления связи в виде коллекции на *сущности* объекта. Новый `ManyToMany.ascx` и `ManyToMany_Edit.ascx` шаблоны полей были добавлены для поддержки отображения и редактирования данных, которая участвует в связи многие ко многим.

<a id="0.2__Toc224729049"></a><a id="0.2__Toc253429286"></a><a id="0.2__Toc243304657"></a>

### <a name="new-attributes-to-control-display-and-support-enumerations"></a>Новые атрибуты для управления отображением и поддержки перечислений

*DisplayAttribute* был добавлен обеспечивают дополнительный контроль над отображением полей. *DisplayName* атрибута в более ранних версиях можно было изменить имя, которое используется в качестве заголовка для поля динамических данных. Новый *DisplayAttribute* класса позволяет указать дополнительные параметры для отображения поля, например, порядок, в котором отображаются поля и поле будет использоваться в качестве фильтра. Атрибут также позволяет независимо управлять имя, используемое для меток в *GridView* управления, имя, используемое в *DetailsView* управления, текст справки для поля, а для водяной знак поля (если поле поддерживает ввод текста).

*EnumDataTypeAttribute* добавлен класс для поддержки сопоставления полей для перечисления. При применении этого атрибута к полю, необходимо указать тип перечисления. Динамические данные используют новый `Enumeration.ascx` шаблон поля для создания пользовательского интерфейса для отображения и редактирования значений перечисления. Шаблон сопоставляет значения из базы данных с именами в перечислении.

<a id="0.2__Toc224729050"></a><a id="0.2__Toc253429287"></a><a id="0.2__Toc243304658"></a>

### <a name="enhanced-support-for-filters"></a>Улучшенная поддержка фильтров

Платформа динамических данных 1.0 поставляется вместе с встроенные фильтры для логические столбцы и столбцы внешнего ключа. Фильтры не разрешают пользователям указать ли их выводом на экран или в каком порядке они были отображены. Новый *DisplayAttribute* атрибут адреса обе эти проблемы, предоставляя контроль над отображением столбец как фильтр, и в каком порядке будет отображаться.

Дополнительные улучшения — что поддержка фильтрации была повторно[записи для использования нового](#0.2__QueryExtender "_QueryExtender") особенностью веб-форм. Это позволяет создавать фильтры без необходимости знать, фильтры, которые будут использоваться с элемента управления источника данных. Вместе с эти расширения фильтров также была отключена в элементы управления шаблона, который позволяет добавлять новые. Наконец *DisplayAttribute* класс упоминалось ранее, позволяет фильтр по умолчанию для переопределения, в том же образом, как *UIHint* позволяет шаблона поля по умолчанию для столбца, который будет переопределен.

<a id="0.2__Toc224729051"></a><a id="0.2__Toc253429288"></a><a id="0.2__Toc243304659"></a>

## <a name="visual-studio-2010-web-development-improvements"></a>Усовершенствования Web разработки Visual Studio 2010

Веб-разработки в Visual Studio 2010 была улучшена для большей совместимости CSS, повысить производительность труда за счет фрагментов разметки HTML и ASP.NET и новый динамический IntelliSense JavaScript.

<a id="0.2__Toc224729052"></a><a id="0.2__Toc253429289"></a><a id="0.2__Toc243304660"></a>

### <a name="improved-css-compatibility"></a>Усовершенствование совместимости CSS

Конструктор Visual Web Developer в Visual Studio 2010 была обновлена для улучшения соответствия стандартам CSS 2.1. Конструктор лучше сохраняет целостность исходный код HTML и надежнее, чем в предыдущих версиях Visual Studio. За кулисами архитектурные усовершенствования также были внесены, необходимо лучше включить новые улучшения в визуализации, макет и удобство в обслуживании.

<a id="0.2__Toc224729053"></a><a id="0.2__Toc253429290"></a><a id="0.2__Toc243304661"></a>

### <a name="html-and-javascript-snippets"></a>HTML и JavaScript фрагменты кода

В редакторе HTML IntelliSense автоматически завершает имена тегов. Функция IntelliSense автоматически завершает все теги и многое другое. В Visual Studio 2010 фрагменты кода IntelliSense поддерживается для JavaScript, наряду с C# и Visual Basic, которые поддерживались в более ранних версиях Visual Studio.

Visual Studio 2010 включает более 200 фрагментов кода, которые помогут вам автозавершения распространенные теги ASP.NET и HTML, включая необходимые атрибуты (такие как runat = «server») и общие атрибуты, относящиеся к тегу (такие как *идентификатор*,  *DataSourceID*, *ControlToValidate*, и *текст*).

Можно загрузить дополнительные фрагменты кода, или можно написать собственные фрагменты кода, которые инкапсулируют блоки разметки, который вы или ваша команда для выполнения типичных задач.

<a id="0.2__Toc224729054"></a><a id="0.2__Toc253429291"></a><a id="0.2__Toc243304662"></a>

### <a name="javascript-intellisense-enhancements"></a>Усовершенствования IntelliSense для JavaScript

В Visual 2010 IntelliSense для JavaScript был переработан для обеспечения более широких возможностей редактирования. IntelliSense теперь распознает объекты, которые были динамически созданы методами, такими как *registerNamespace* и с помощью схожих технологий, используемых другими инфраструктурами JavaScript. Повышена производительность при анализе больших библиотек сценария и для отображения IntelliSense с минимальными задержками или без обработки. Совместимость значительно увеличен для поддержки практически всех сторонних библиотек и поддерживают разные стили программирования. Комментарии к документации разбираются, пока вы вводите немедленно передаются технологией IntelliSense.

<a id="0.2__Toc224729055"></a><a id="0.2__Toc253429292"></a><a id="0.2__Toc243304663"></a>

## <a name="web-application-deployment-with-visual-studio-2010"></a>Развертывание веб-приложений с помощью Visual Studio 2010

Разработчики ASP.NET развернуть веб-приложения, они часто находится что возникающих проблем, таких как следующие:

- Для развертывания на сайте общего размещения требуется технологий, таких как FTP, которого может выполняться медленно. Кроме того необходимо выполнить действия, такие как выполнение скриптов SQL, чтобы настроить базу данных вручную, и необходимо изменить параметры IIS, такие как настройка папку виртуального каталога, как приложение.
- В корпоративной среде, помимо развертывания файлов веб-приложения администраторы должны часто изменения файлов конфигурации ASP.NET и параметры служб IIS. Администраторы баз данных необходимо выполнить ряд сценарии SQL для базы данных приложения. Такие установки трудоемкая, часто занимает часов и необходимо тщательно документировать.

Visual Studio 2010 включает технологии, решить эти проблемы и позволяют легко развертывать веб-приложения. Одним из этих технологий является средство веб-развертывания IIS (MsDeploy.exe).

Функции развертывания Web в Visual Studio 2010 включают следующие основные области:

- Веб-пакетов
- Преобразования Web.config
- Развертывание базы данных
- Публикация одним щелчком для веб-приложений

Следующие разделы содержат сведения об этих функциях.

<a id="0.2__Toc224729056"></a><a id="0.2__Toc253429293"></a><a id="0.2__Toc243304664"></a>

### <a name="web-packaging"></a>Веб-пакетов

Visual Studio 2010 используется средство MSDeploy для создания ZIP-файла для приложения, который называется *веб-пакета*. Файл пакета содержит метаданные о приложении, а также следующее содержимое:

- Параметры IIS, которые включает в себя параметры пула приложений, параметров страницы ошибки и т. д.
- Фактический веб-содержимое, включая веб-страниц, пользовательские элементы управления, статическое содержимое (изображения и HTML-файлы) и т. д.
- SQL Server схемы базы данных и данных.
- Сертификаты безопасности, компоненты для установки в глобальный кэш СБОРОК, параметры реестра и т. д.

Веб-пакет можно скопировать на любой сервер и затем установить вручную с помощью диспетчера IIS. Кроме того для автоматического развертывания пакета можно установить с помощью команды командной строки или с помощью API развертывания.

Visual Studio 2010 предоставляет встроенные задачи MSBuild и целевых объектов для создания веб-пакетов. Дополнительные сведения см. в разделе [обзор ASP.NET веб-приложения проекта развертывания](https://msdn.microsoft.com/library/dd394698%28VS.100%29.aspx) на сайте MSDN и [10 + 20 причин, почему необходимо создать веб-пакет](http://vishaljoshi.blogspot.com/2009/07/10-20-reasons-why-you-should-create-web.html) на работы.

<a id="0.2__Toc224729057"></a><a id="0.2__Toc253429294"></a><a id="0.2__Toc243304665"></a>

### <a name="webconfig-transformation"></a>Преобразования Web.config

Для развертывания веб-приложения, Visual Studio 2010 представлен [преобразования XML-документов (XDT)](http://vishaljoshi.blogspot.com/2009/03/web-deployment-webconfig-transformation_23.html), это функция, которая позволяет преобразовать `Web.config` файл с параметрами разработки в настройке рабочей среды. Параметры преобразования указываются в файлах преобразования, с именем `web.debug.config`, `web.release.config`, и т. д. (Имена этих файлов совпадают MSBuild конфигурации). Файл преобразования включает в себя только изменения, которые необходимо внести в развернутый `Web.config` файл. Укажите изменения с помощью простой синтаксис.

В следующем примере показано часть `web.release.config` файла, которое может быть произведено для развертывания конфигурации выпуска. Ключевое слово "Replace" в примере указывает, что во время развертывания *connectionString* узел в `Web.config` файла будут заменены значениями, которые перечислены в примере.

[!code-xml[Main](overview/samples/sample102.xml)]

Дополнительные сведения см. в разделе [синтаксис преобразования файла Web.config для развертывания проекта веб-приложения](https://msdn.microsoft.com/library/dd465326%28VS.100%29.aspx) на MSDN <a id="0.2_a"> </a> веб-сайта и[веб-развертывания: Преобразования Web.Config](http://vishaljoshi.blogspot.com/2009/03/web-deployment-webconfig-transformation_23.html) на работы.

<a id="0.2__Toc224729058"></a><a id="0.2__Toc253429295"></a><a id="0.2__Toc243304666"></a>

### <a name="database-deployment"></a>Развертывание базы данных

Пакет развертывания Visual Studio 2010, может включать зависимости базы данных SQL Server. Как часть определения пакета можно указать строку подключения для базы данных-источника. При создании веб-пакета Visual Studio 2010 создает скрипты SQL для схемы базы данных и при необходимости для данных и затем добавляет их в пакет. Можно также предоставить пользовательские сценарии SQL и укажите последовательность, в котором их следует запустить на сервере. Во время развертывания укажите строку подключения, который подходит для целевого сервера; затем процесс развертывания использует эту строку подключения для выполнения скриптов, которые создают схему базы данных и добавить данные.

Кроме того, с помощью одного щелчка публикации, можно настроить развертывание для публикации базы данных напрямую, при публикации приложения на удаленный сайт общего размещения. Дополнительные сведения см. в разделе [Как Развертывание базы данных с проектом веб-приложения](https://msdn.microsoft.com/library/dd465343%28VS.100%29.aspx) на сайте MSDN и [развертывания базы данных с VS 2010](http://vishaljoshi.blogspot.com/2009/03/web-deployment-webconfig-transformation_23.html) на работы.

<a id="0.2__Toc224729059"></a><a id="0.2__Toc253429296"></a><a id="0.2__Toc243304667"></a>

### <a name="one-click-publish-for-web-applications"></a>Публикация одним щелчком для веб-приложений

Visual Studio 2010 также позволяет использовать службу удаленного управления IIS для публикации веб-приложения на удаленном сервере. Можно создать профиль публикации, для учетной записи размещения или серверов тестирования и промежуточных серверов. Каждый профиль можно безопасно сохранить соответствующие учетные данные. Затем можно развернуть на любой из целевой панель инструментов публикации серверов одним щелчком с помощью веб-одним щелчком. С помощью Visual Studio 2010 также можно опубликовать с помощью командной строки MSBuild. Это позволяет настроить среду сборки team, чтобы включить публикацию в модели непрерывной интеграции.

Дополнительные сведения см. в разделе [Как Развертывание Web Application Project с помощью публикации одним щелчком и веб-развертывания](https://msdn.microsoft.com/library/dd465337%28VS.100%29.aspx) на сайте MSDN и [веб-публикация одним щелчком с VS 2010](http://vishaljoshi.blogspot.com/2009/05/web-1-click-publish-with-vs-2010.html) на работы. Видеопрезентации о развертывании веб-приложения в Visual Studio 2010, см. в разделе [VS 2010 для разработчиков веб-просмотры](http://vishaljoshi.blogspot.com/2008/12/vs-2010-for-web-developer-previews.html) на работы.

<a id="0.2__Toc224729060"></a><a id="0.2__Toc253429297"></a><a id="0.2__Toc243304668"></a>

### <a name="resources"></a>Ресурсы

Следующие веб-сайты предоставляют дополнительные сведения об ASP.NET 4 и Visual Studio 2010.

- [ASP.NET 4](https://msdn.microsoft.com/library/ee532866%28VS.100%29.aspx) — Официальная документация ASP.NET 4 на веб-сайте MSDN.
- [https://www.asp.net/](https://www.asp.net/) — ASP.NET команды собственных веб-сайта.
- [https://www.asp.net/dynamicdata/](https://msdn.microsoft.com/library/cc488545.aspx) и [динамической карты содержимого ASP.NET данных](https://msdn.microsoft.com/library/cc488545%28VS.100%29.aspx) — сетевые ресурсы, на сайте группы ASP.NET и в официальной документации платформы динамических данных ASP.NET.
- [https://www.asp.net/ajax/](../../ajax/index.md) — Основной веб-ресурса для разработки приложений ASP.NET Ajax.
- [https://blogs.msdn.com/webdevtools/](https://blogs.msdn.com/webdevtools/) Web Developer блог команды разработчиков Visual, который включает сведения о функциях в Visual Studio 2010.
- [Интернет-стек любви ASP.NET](https://github.com/aspnet/AspNetWebStack) — основной веб-ресурса для предварительных выпусков ASP.NET.

<a id="0.2__Toc224729061"></a><a id="0.2__Toc253429298"></a><a id="0.2__Toc243304669"></a>

## <a name="disclaimer"></a>Отказ от ответственности

Это предварительный документ, он может быть существенно изменен до выхода окончательного коммерческого выпуска описанного здесь программного обеспечения.

Сведения, содержащиеся в этом документе, отражают представление корпорации Майкрософт по описанным здесь вопросам на дату публикации. Поскольку корпорация Майкрософт должна реагировать на изменяющиеся рыночные условия, данный документ не должен интерпретироваться как обязательство со стороны Майкрософт, и корпорация Майкрософт не может гарантировать точность любой информации, представленной после даты публикации.

Данный технический документ предназначен только для ознакомительных целей. МАЙКРОСОФТ НЕ ПРЕДОСТАВЛЯЕТ НИКАКИХ ГАРАНТИЙ, ЯВНЫХ ИЛИ ПРЕДУСМОТРЕННЫХ ЗАКОНОДАТЕЛЬСТВОМ, ОТНОСИТЕЛЬНО СВЕДЕНИЙ, СОДЕРЖАЩИХСЯ В ДАННОМ ДОКУМЕНТЕ.

Ответственность за соблюдение всех авторских прав и прав на интеллектуальную собственность целиком и полностью несет пользователь. Ни одна из частей этого документа не может быть воспроизведена, сохранена или использована в системах поиска или передана в любой форме, любыми способами (электронными, механическими, в виде фотокопии, в виде записи или любыми другими) и для любых целей без соблюдения ограничений авторских прав и письменного разрешения корпорации Майкрософт.

В настоящем документе могут упоминаться запатентованные или патентуемые технологии, товарные знаки, авторские права или другие права интеллектуальной собственности корпорации Майкрософт. Если иного явно не указано в письменном лицензионном соглашении корпорации Майкрософт, данный документ не предоставляет лицензии на эти патенты, товарные знаки, авторские права или другие права интеллектуальной собственности.

Если не указано иное, примеры компаний, организаций, продукты, доменные имена, адреса электронной почты, логотипы, люди, места и события упоминающиеся названия являются вымышленными и сходство с реальными предприятиями, организации, продукта, доменное имя, адрес электронной почты адрес эмблемы, лица и события являются случайными и непреднамеренными.

© Корпорация Майкрософт, 2009 г. Все права защищены.

Microsoft и Windows являются охраняемыми товарными знаками корпорации Майкрософт в США и других странах.

Названия фактических компаний и продуктов, упомянутые здесь, могут являться охраняемыми товарными знаками соответствующих владельцев.
