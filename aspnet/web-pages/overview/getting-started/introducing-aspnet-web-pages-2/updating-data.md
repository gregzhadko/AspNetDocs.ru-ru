---
uid: web-pages/overview/getting-started/introducing-aspnet-web-pages-2/updating-data
title: Введение в веб-страницы ASP.NET обновление данных базы данных | Документация Майкрософт
author: Rick-Anderson
description: В этом руководстве показано, как обновить (изменить) существующую запись базы данных при использовании веб-страницы ASP.NET (Razor). Предполагается, что вы выполнили ряд...
ms.author: riande
ms.date: 01/02/2018
ms.assetid: ac86ec9c-6b69-485b-b9e0-8b9127b13e6b
msc.legacyurl: /web-pages/overview/getting-started/introducing-aspnet-web-pages-2/updating-data
msc.type: authoredcontent
ms.openlocfilehash: 8f8bcfb7d9d2416a2699776cadbdaae8e12415ba
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78463494"
---
# <a name="introducing-aspnet-web-pages---updating-database-data"></a>Введение в веб-страницы ASP.NET обновление данных базы данных

от [Tom фитзмаккен](https://github.com/tfitzmac)

> В этом руководстве показано, как обновить (изменить) существующую запись базы данных при использовании веб-страницы ASP.NET (Razor). Предполагается, что вы выполнили цикл по [вводу данных с помощью форм, Использующих веб-страницы ASP.NET](entering-data.md).
> 
> Из этого руководства вы узнаете, как выполнять такие задачи:
> 
> - Выбор отдельной записи в вспомогательном приложении `WebGrid`.
> - Чтение одной записи из базы данных.
> - Предварительная загрузка формы со значениями из записи базы данных.
> - Обновление существующей записи в базе данных.
> - Хранение информации на странице без ее отображения.
> - Использование скрытого поля для хранения информации.
>   
> 
> Обсуждаемые функции и технологии:
> 
> - Вспомогательный метод `WebGrid`.
> - Команда SQL `Update`.
> - метод `Database.Execute` ;
> - Скрытые поля (`<input type="hidden">`).

## <a name="what-youll-build"></a>Что вы создадите

В предыдущем руководстве вы узнали, как добавить запись в базу данных. Здесь вы узнаете, как отобразить запись для редактирования. На странице *фильмов* вы обновите вспомогательную функцию `WebGrid`, чтобы она отображала ссылку **Edit (изменить** ) рядом с каждым фильмом:

![Отображение сетки, включая ссылку "Изменить" для каждого фильма](updating-data/_static/image1.png)

Щелкнув ссылку **изменить** , вы переведете на другую страницу, где сведения о фильме уже находятся в форме:

![Изменение страницы фильма с фильмом для изменения](updating-data/_static/image2.png)

Можно изменить любое из значений. При отправке изменений код на странице обновляет базу данных и переводит вас назад в список фильмов.

Эта часть процесса работает почти так же, как страница *аддмовие. cshtml* , созданная в предыдущем учебном курсе, поэтому многие из этих учебников будут знакомы.

Существует несколько способов реализовать способ изменения отдельного фильма. Показанный подход был выбран, так как его легко реализовать и легко понять.

## <a name="adding-an-edit-link-to-the-movie-listing"></a>Добавление ссылки для редактирования в список фильмов

Для начала обновите страницу *фильмов* , чтобы в каждом списке фильмов также была ссылка для **редактирования** .

Откройте файл *movies. cshtml* .

В тексте страницы измените разметку `WebGrid`, добавив столбец. Измененная разметка:

[!code-html[Main](updating-data/samples/sample1.html?highlight=6)]

Новый столбец является следующим:

[!code-html[Main](updating-data/samples/sample2.html)]

В этом столбце отображается ссылка (`<a>` элемент), текст которой говорит «Edit» (изменить). После этого создается ссылка, которая выглядит следующим образом при выполнении страницы, при этом значение `id` для каждого фильма различается.

[!code-css[Main](updating-data/samples/sample3.css)]

Эта ссылка вызывает страницу с именем *едитмовие*и передает строку запроса `?id=7` на эту страницу.

Синтаксис нового столбца может показаться немного сложным, но это только потому, что он объединяет несколько элементов. Каждый отдельный элемент прост. Если сосредоточиться только на элементе `<a>`, вы увидите следующую разметку:

[!code-html[Main](updating-data/samples/sample4.html)]

Некоторые общие сведения о работе сетки: Сетка отображает строки, по одной для каждой записи базы данных и отображает столбцы для каждого поля в записи базы данных. При создании каждой строки сетки объект `item` содержит запись базы данных (элемент) для этой строки. Такое размещение дает возможность в коде получить данные для этой строки. Вот что вы видите: выражение `item.ID` получает значение идентификатора текущего элемента базы данных. Можно получить любое из значений базы данных (название, жанр или год) таким же образом, используя `item.Title`, `item.Genre`или `item.Year`.

Выражение `"~/EditMovie?id=@item.ID` сочетает жестко закодированную часть целевого URL-адреса (`~/EditMovie?id=`) с этим динамически производным ИДЕНТИФИКАТОРом. (Вы видели оператор `~` в предыдущем учебном курсе; это оператор ASP.NET, представляющий текущий корневой каталог веб-сайта.)

В результате эта часть разметки в столбце просто создает нечто вроде приведенной ниже разметки во время выполнения:

[!code-xml[Main](updating-data/samples/sample5.xml)]

Естественно, фактическое значение `id` будет различным для каждой строки.

## <a name="creating-a-custom-display-for-a-grid-column"></a>Создание пользовательского интерфейса для столбца сетки

Теперь вернемся к столбцу сетки. Три столбца, которые изначально были в сетке, отображали только значения данных (заголовок, жанр и год). Вы указали это отображение, передав имя столбца базы данных &mdash; например `grid.Column("Title")`.

Новый столбец **изменить** ссылку отличается. Вместо указания имени столбца передается параметр `format`. Этот параметр позволяет определить разметку, которую вспомогательный модуль `WebGrid` будет визуализировать вместе со значением `item`, чтобы отобразить данные столбца полужирным или зеленым цветом или в любом нужном формате. Например, если нужно, чтобы заголовок отображался полужирным, можно создать столбец, подобный приведенному ниже.

[!code-html[Main](updating-data/samples/sample6.html)]

(Различные символы `@`, отображаемые в свойстве `format`, помечают переход между разметкой и значением кода.)

Когда вы узнаете о свойстве `format`, проще понять, как помещается новый столбец ссылки **Edit** :

[!code-html[Main](updating-data/samples/sample7.html)]

Столбец состоит *только* из разметки, в которой отображается ссылка, а также некоторые сведения (идентификатор), извлеченные из записи базы данных для строки.

> [!TIP]
> 
> **Именованные и позиционированные параметры для метода**
> 
> Многие случаи, когда вы вызывали метод и передали ему параметры, вы просто указали значения параметров, разделенные запятыми. Вот несколько примеров.
> 
> `db.Execute(insertCommand, title, genre, year)`
> 
> `Validation.RequireField("title", "You must enter a title")`
> 
> Мы не упомянули проблемы, когда впервые познакомились с этим кодом, но в каждом случае вы передаете параметры в методы в определенном порядке &mdash; а именно в том порядке, в котором параметры определены в этом методе. Для `db.Execute` и `Validation.RequireFields`, если вы простроили порядок передаваемых значений, при выполнении страницы или по крайней мере неопределенного результата выдается сообщение об ошибке. Очевидно, что необходимо определить порядок передачи параметров в. (В WebMatrix технология IntelliSense поможет вам понять, как можно узнать имя, тип и порядок параметров.)
> 
> В качестве альтернативы передаче значений по порядку можно использовать *именованные параметры*. (Передача параметров в порядке называется использованием *параметров позиционирования*.) Для именованных параметров необходимо явно указать имя параметра при передаче его значения. В этих учебниках уже несколько раз использовались именованные параметры. Пример:
> 
> [!code-csharp[Main](updating-data/samples/sample8.cs)]
> 
> и
> 
> [!code-css[Main](updating-data/samples/sample9.css)]
> 
> Именованные параметры удобны для нескольких ситуаций, особенно если метод принимает много параметров. Одна из них — если требуется передать только один или два параметра, но значения, которые необходимо передать, не являются значениями в списке параметров. Другая ситуация заключается в том, что вы хотите сделать код более удобочитаемым, передав параметры в том порядке, который наиболее удобен для вас.
> 
> Очевидно, что для использования именованных параметров необходимо знание имен параметров. Технология WebMatrix IntelliSense может *Показывать* имена, но в настоящее время их невозможно заполнить.

## <a name="creating-the-edit-page"></a>Создание страницы редактирования

Теперь можно создать страницу *едитмовие* . Когда пользователь найдет ссылку " **изменить** ", они появятся на этой странице.

Создайте страницу с именем *едитмовие. cshtml* и замените содержимое файла следующей разметкой:

[!code-cshtml[Main](updating-data/samples/sample10.cshtml)]

Эта разметка и код аналогичны тем, которые имеются на странице *аддмовие* . Есть небольшая разница в тексте кнопки Submit (отправить). Как и на странице *аддмовие* , имеется вызов `Html.ValidationSummary`, который будет отображать ошибки проверки, если таковые имеются. На этот раз мы оставляем вызовы `Validation.Message`, так как ошибки будут отображаться в сводке проверки. Как отмечалось в предыдущем руководстве, можно использовать сводку проверки и отдельные сообщения об ошибках в различных сочетаниях.

Обратите внимание, что атрибуту `method` элемента `<form>` присвоено значение `post`. Как и на странице *аддмовие. cshtml* , эта страница вносит изменения в базу данных. Поэтому эта форма должна выполнять `POST` операцию. (Дополнительные сведения о различиях между операциями `GET` и `POST` см. в разделе [Получение, публикация и использование HTTP-команд](form-basics.md#GET,_POST,_and_HTTP_Verb_Safety) в учебнике по HTML-формам.)

Как было показано в предыдущем учебном курсе, `value` атрибуты текстовых полей задаются с помощью кода Razor, чтобы их можно было предварительно загрузить. Но на этот раз вы используете такие переменные, как `title` и `genre` для этой задачи, а не `Request.Form["title"]`:

`<input type="text" name="title" value="@title" />`

Как и ранее, эта разметка будет загружать значения текстовых полей со значениями фильмов. Вы увидите, что в это время удобно использовать переменные, а не использовать объект `Request`.

На этой странице также имеется элемент `<input type="hidden">`. Этот элемент сохраняет идентификатор фильма, не делая его видимым на странице. Идентификатор первоначально передается на страницу с помощью значения строки запроса (`?id=7` или аналогичного URL-адресу). Поместив значение идентификатора в скрытое поле, можно убедиться, что оно доступно при отправке формы, даже если у вас больше нет доступа к исходному URL-адресу, с помощью которого была вызвана страница.

В отличие от страницы *аддмовие* , код для страницы *едитмовие* имеет две отдельные функции. Первая функция заключается в том, что когда страница отображается в первый раз (и *только* затем), код получает идентификатор фильма из строки запроса. Затем код использует идентификатор для чтения соответствующего фильма из базы данных и его вывода (Предварительная загрузка) в текстовые поля.

Вторая функция заключается в том, что когда пользователь нажимает кнопку **отправить изменения** , код должен считывать значения текстовых полей и проверять их. Код также должен обновить элемент базы данных новыми значениями. Этот метод аналогичен добавлению записи, как показано в *аддмовие*.

## <a name="adding-code-to-read-a-single-movie"></a>Добавление кода для чтения одного фильма

Чтобы выполнить первую функцию, добавьте следующий код в верхнюю часть страницы:

[!code-cshtml[Main](updating-data/samples/sample11.cshtml)]

Большая часть этого кода находится внутри блока, который начинается `if(!IsPost)`. Оператор `!` означает «not», поэтому выражение означает, что *этот запрос не является отправкой POST*, что является косвенным способом сказать, *является ли этот запрос первым при выполнении этой страницы*. Как отмечалось ранее, этот код должен выполняться *только* при первом запуске страницы. Если вы не заключаете код в `if(!IsPost)`, он будет выполняться при каждом вызове страницы, будь то первый раз или в ответ на нажатие кнопки.

Обратите внимание, что в этот раз код включает блок `else`. Как мы сказали при вводе блоков `if`, иногда требуется выполнить другой код, если проверяемое условие не выполняется. Это так. Если условие передается (то есть если идентификатор, переданный на страницу, имеет значение OK), то считывается строка из базы данных. Однако если условие не проходит, выполняется блок `else`, и код устанавливает сообщение об ошибке.

## <a name="validating-a-value-passed-to-the-page"></a>Проверка значения, переданного на страницу

Код использует `Request.QueryString["id"]` для получения идентификатора, который передается на страницу. Код гарантирует, что значение было фактически передано для идентификатора. Если значение не было передано, код задает ошибку проверки.

Этот код показывает другой способ проверки информации. В предыдущем руководстве вы работали с вспомогательным приложением `Validation`. Вы зарегистрировали поля для проверки, и ASP.NET автоматически выполнил проверку и отображение ошибок с помощью `Html.ValidationMessage` и `Html.ValidationSummary`. Однако в этом случае вы не проверяете вводимые пользователем данные. Вместо этого выполняется проверка значения, переданного на страницу из другого места. Модуль поддержки `Validation` не делает этого.

Поэтому вы проверяете значение самостоятельно, проверяя его с помощью `if(!Request.QueryString["ID"].IsEmpty()`). Если возникла проблема, можно отобразить ошибку с помощью `Html.ValidationSummary`, как это было сделано при работе со вспомогательным приложением `Validation`. Для этого вызовите `Validation.AddFormError` и передайте ему сообщение для вывода. `Validation.AddFormError` — это встроенный метод, который позволяет определять пользовательские сообщения, которые связываются с системой проверки, с которой вы уже знакомы. (Далее в этом учебнике мы поговорим о том, как сделать этот процесс проверки более надежным.)

Убедившись в наличии идентификатора для фильма, код считывает базу данных и ищет только один элемент базы данных. (Возможно, вы заметили общий шаблон для операций с базой данных: Откройте базу данных, определите инструкцию SQL и выполните инструкцию.) На этот раз инструкция SQL `Select` включает `WHERE ID = @0`. Поскольку идентификатор уникален, может возвращаться только одна запись.

Запрос выполняется с помощью `db.QuerySingle` (не `db.Query`, как используется для перечислений фильмов), и код помещает результат в переменную `row`. Имя `row` является произвольным; Вы можете присвоить переменным любые значения. Переменные, инициализированные в верхней части, затем заполняются сведениями о фильме, чтобы эти значения можно было отобразить в текстовых полях.

## <a name="testing-the-edit-page-so-far"></a>Тестирование страницы редактирования (до сих пор)

Если вы хотите протестировать страницу, запустите страницу *фильмов* сейчас и щелкните ссылку Edit ( **изменить** ) рядом с любым фильмом. Вы увидите страницу *едитмовие* с данными, заполненными для выбранного фильма:

![Изменение страницы фильма с фильмом для изменения](updating-data/_static/image3.png)

Обратите внимание, что URL-адрес страницы содержит нечто вроде `?id=10` (или другое число). Итак, вы проверили, что ссылки **Edit** на странице *фильмов* работают, что страница считывает идентификатор из строки запроса и работает запрос к базе данных для получения одной записи фильма.

Можно изменить сведения о фильме, но при нажатии кнопки **отправить изменения**ничего не происходит.

## <a name="adding-code-to-update-the-movie-with-the-users-changes"></a>Добавление кода для обновления фильма с учетом изменений пользователя

Чтобы реализовать вторую функцию (сохранение изменений) в файле *едитмовие. cshtml* , добавьте следующий код непосредственно внутри закрывающей скобки блока `@`. (Если вы точно не знаете, где разместить код, можно взглянуть на [полный листинг кода для страницы "изменение фильма"](#Complete_Page_Listing_for_EditMovie) , которая отображается в конце этого руководства.)

[!code-csharp[Main](updating-data/samples/sample12.cs)]

Опять же, эта разметка и код похожи на код в *аддмовие*. Код находится в блоке `if(IsPost)`, так как этот код выполняется только в том случае, если пользователь нажимает кнопку **отправить изменения** &mdash; то есть (и только в момент, когда) была отправлена форма. В этом случае вы не используете такой тест, как `if(IsPost && Validation.IsValid())`, то есть вы не объединяете оба теста с помощью и. На этой странице сначала определите, есть ли отправка формы (`if(IsPost)`), и только затем зарегистрируйте поля для проверки. Затем можно проверить результаты проверки (`if(Validation.IsValid()`). Последовательность немного отличается от последовательности на странице *аддмовие. cshtml* , но результат такой же.

Значения текстовых полей можно получить с помощью `Request.Form["title"]` и аналогичного кода для других элементов `<input>`. Обратите внимание, что на этот раз код получает идентификатор фильма из скрытого поля (`<input type="hidden">`). При первом запуске страницы код получил идентификатор из строки запроса. Вы получаете значение из скрытого поля, чтобы убедиться, что вы получаете идентификатор фильма, который был первоначально отображен, в случае, когда строка запроса изменилась с этого момента.

Действительно важное различие между кодом *аддмовие* и этим кодом заключается в том, что в этом коде используется инструкция SQL `Update`, а не инструкция `Insert Into`. В следующем примере показан синтаксис инструкции SQL `Update`.

`UPDATE table SET col1="value", col2="value", col3="value" ... WHERE ID = value`

Можно указать любые столбцы в любом порядке, и вам не обязательно обновлять каждый столбец во время операции `Update`. (Вы не можете обновить сам идентификатор, так как он, в силу этого, сохранит запись как новую запись, и это недопустимо для операции `Update`.)

> [!NOTE] 
> 
> **Важно!** Предложение `Where` с ИДЕНТИФИКАТОРом очень важно, так как база данных знает, какую запись базы данных необходимо обновить. Если оставить предложение `Where`, база данных будет обновлять *каждую* запись в базе данных. В большинстве случаев это может привести к сбою.

В коде обновляемые значения передаются в инструкцию SQL с помощью заполнителей. Чтобы повторить то, что мы уже говорили: в целях безопасности используйте *только* заполнители для передачи значений в инструкцию SQL.

После того как код использует `db.Execute` для выполнения инструкции `Update`, он перенаправляется обратно на страницу листинга, где можно увидеть изменения.

> [!TIP] 
> 
> **Разные инструкции SQL, различные методы**
> 
> Возможно, вы заметили, что для выполнения различных инструкций SQL используются несколько различных методов. Для выполнения `Select` запроса, который потенциально возвращает несколько записей, используется метод `Query`. Чтобы выполнить `Select` запрос, который будет возвращать только один элемент базы данных, используется метод `QuerySingle`. Для выполнения команд, которые делают изменения, но не возвращают элементы базы данных, используется метод `Execute`.
> 
> У вас должны быть разные методы, так как каждый из них возвращает разные результаты, как уже говорилось в различиях между `Query` и `QuerySingle`. (`Execute` метод фактически возвращает значение также &mdash; а именно, количество строк базы данных, затронутых командой &mdash; но проигнорированное до сих пор.)
> 
> Разумеется, метод `Query` может возвращать только одну строку базы данных. Однако ASP.NET всегда обрабатывает результаты метода `Query` в виде коллекции. Даже если метод возвращает только одну строку, необходимо извлечь эту единственную строку из коллекции. Таким образом, если *известно* , что вы получаете только одну строку, более удобно использовать `QuerySingle`.
> 
> Существует несколько других методов, выполняющих определенные типы операций с базами данных. Список методов базы данных можно найти в [кратком справочнике по API веб-страницы ASP.NET](../../api-reference/asp-net-web-pages-api-reference.md#Data).

## <a name="making-validation-for-the-id-more-robust"></a>Обеспечение более надежной проверки идентификатора

При первом запуске страницы вы получаете идентификатор фильма из строки запроса, чтобы можно было получить этот фильм из базы данных. Вы уверены, что на самом деле имелось значение для поиска, которое вы выполнили с помощью этого кода:

[!code-csharp[Main](updating-data/samples/sample13.cs)]

Этот код использовался, чтобы убедиться, что если пользователь получит на страницу *едитмовиес* , не выбирая фильм на странице *фильмов* , на странице будет отображаться понятное сообщение об ошибке. (В противном случае пользователи увидят ошибку, которая, вероятно, просто запутать их.)

Однако эта проверка не очень надежна. Эту страницу также можно вызвать с этими ошибками:

- Идентификатор не является числом. Например, страницу можно вызвать с URL-адресом, например `http://localhost:nnnnn/EditMovie?id=abc`.
- Идентификатор является числом, но ссылается на фильм, который не существует (например, `http://localhost:nnnnn/EditMovie?id=100934`).

Если вы хотите просмотреть ошибки, возникающие в результате этих URL-адресов, запустите страницу *фильмов* . Выберите фильм для редактирования, а затем измените URL-адрес страницы *едитмовие* на URL-адрес, содержащий буквенный идентификатор или идентификатор несуществующего фильма.

Так что же делать? Первое исправление — убедиться, что идентификатор не только передается на страницу, но идентификатор является целым числом. Измените код для `!IsPost` теста, как показано в следующем примере:

[!code-csharp[Main](updating-data/samples/sample14.cs)]

Вы добавили второе условие в `IsEmpty` тест, связанное с `&&` (логическое и):

[!code-csharp[Main](updating-data/samples/sample15.cs)]

Вы можете не забыть ознакомиться со статьей [Введение в веб-страницы ASP.NET программирование](../introducing-razor-syntax-c.md) , в котором такие методы, как `AsBool` `AsInt`, преобразуют строку символов в другой тип данных. Метод `IsInt` (и другие, такие как `IsBool` и `IsDateTime`) похожи. Однако они проверяют только *возможность преобразования строки* без фактического выполнения преобразования. Итак, здесь вы говорите, что *значение строки запроса можно преобразовать в целое число...* .

Другая потенциальная проблема заключается в поиске фильма, который не существует. Код для получения фильма выглядит следующим образом:

[!code-csharp[Main](updating-data/samples/sample16.cs)]

Если в метод `QuerySingle` передается `movieId` значение, которое не соответствует реальному фильму, ничего не возвращается, а последующие инструкции (например, `title=row.Title`) приводят к ошибкам.

Опять же, это легко исправить. Если метод `db.QuerySingle` не возвращает результатов, `row` переменная будет иметь значение null. Поэтому можно проверить, имеет ли переменная `row` значение null, прежде чем пытаться получить из нее значения. Следующий код добавляет блок `if` вокруг инструкций, которые получают значения из объекта `row`:

[!code-csharp[Main](updating-data/samples/sample17.cs)]

С этими двумя дополнительными проверочными тестами страница станет более подробным. Полный код ветви `!IsPost` теперь выглядит следующим образом:

[!code-csharp[Main](updating-data/samples/sample18.cs)]

Мы будем Заметьте, что эта задача хорошо используется для `else` блока. Если тесты не пройдены, `else` блокирует задание сообщений об ошибках.

## <a name="adding-a-link-to-return-to-the-movies-page"></a>Добавление ссылки для возврата на страницу фильмов

Окончательная и полезная информация — Добавление ссылки обратно на страницу *фильмов* . В обычном потоке событий пользователи начинают со страницы *фильмов* и щелкают ссылку Edit ( **изменить** ). В результате они перемещаются на страницу *едитмовие* , где можно изменить фильм и нажать кнопку. После того как код обрабатывает изменение, он перенаправляется обратно на страницу *фильмов* .

Но:

- Пользователь может решить не изменять что-либо.
- Пользователь мог стать на этой странице без предварительного выбора ссылки Edit ( **изменить** ) на странице *фильмов* .

В любом случае, вам нужно легко вернуться к основному листингу. Это простое исправление &mdash; добавить следующую разметку сразу после закрывающего тега `</form>` в разметке:

[!code-html[Main](updating-data/samples/sample19.html)]

Эта разметка использует тот же синтаксис для элемента `<a>`, который вы видели в других местах. URL-адрес включает `~` в значение "корень веб-сайта".

## <a name="testing-the-movie-update-process"></a>Тестирование процесса обновления фильма

Теперь можно протестировать. Запустите страницу *фильмов* и нажмите кнопку **изменить** рядом с фильмом. Когда появится страница *едитмовие* , внесите изменения в фильм и нажмите кнопку **отправить изменения**. Когда появится список фильмов, убедитесь, что изменения отображаются.

Чтобы убедиться, что проверка работает, нажмите кнопку **изменить** для другого фильма. При переходе на страницу *едитмовие* очистите поле **Жанр** (или поле **year** или оба) и попытайтесь отправить изменения. Вы увидите сообщение об ошибке, как было бы ожидаемо:

![Страница редактирования фильма с ошибками проверки](updating-data/_static/image4.png)

Щелкните ссылку **вернуться к списку фильмов** , чтобы отменить изменения и вернуться на страницу *фильмов* .

## <a name="coming-up-next"></a>Далее

В следующем руководстве вы узнаете, как удалить запись фильма.

## <a name="complete-listing-for-movie-page-updated-with-edit-links"></a>Полный список для страницы фильмов (обновляется ссылками для редактирования)

[!code-cshtml[Main](updating-data/samples/sample20.cshtml)]

<a id="Complete_Page_Listing_for_EditMovie"></a>
## <a name="complete-page-listing-for-edit-movie-page"></a>Полный список страниц для страницы "изменение фильма"

[!code-cshtml[Main](updating-data/samples/sample21.cshtml)]

## <a name="additional-resources"></a>Дополнительные ресурсы

- [Введение в веб-программирование ASP.NET с помощью синтаксиса Razor](../../getting-started/introducing-razor-syntax-c.md)
- [Инструкция SQL UPDATE](http://www.w3schools.com/sql/sql_update.asp) на сайте W3Schools

> [!div class="step-by-step"]
> [Назад](entering-data.md)
> [Вперед](deleting-data.md)
