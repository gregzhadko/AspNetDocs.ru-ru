---
uid: web-pages/overview/getting-started/introducing-aspnet-web-pages-2/form-basics
title: Представляем ASP.NET веб-страниц - Основы формы HTML Документы Майкрософт
author: Rick-Anderson
description: В этом уроке показаны основы создания формы ввода и обработки ввода пользователя при использовании ASP.NET web Pages (Razor). И теперь, когда вы ...
ms.author: riande
ms.date: 05/28/2015
ms.assetid: 81ed82bf-b940-44f1-b94a-555d0cb7cc98
msc.legacyurl: /web-pages/overview/getting-started/introducing-aspnet-web-pages-2/form-basics
msc.type: authoredcontent
ms.openlocfilehash: f57661077ec3bb13f3d4ec41b130bda4d2fb9070
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675925"
---
# <a name="introducing-aspnet-web-pages---html-form-basics"></a>Представляем ASP.NET веб-страниц - Основы формы HTML

; автор — [Том ФитцМакен (Tom FitzMacken)](https://github.com/tfitzmac)

> В этом уроке показаны основы создания формы ввода и обработки ввода пользователя при использовании ASP.NET web Pages (Razor). И теперь, когда у вас есть база данных, вы будете использовать свои навыки формы, чтобы позволить пользователям находить конкретные фильмы в базе данных. Он предполагает, что вы завершили серию через [Введение в отображение данных с помощью ASP.NET веб-страниц](/aspnet/web-pages/overview/getting-started/introducing-aspnet-web-pages-2/displaying-data).
> 
> Из этого руководства вы узнаете, как выполнять такие задачи:
> 
> - Как создать форму с помощью стандартных элементов HTML.
> - Как прочитать вход пользователя в форме.
> - Как создать запрос S'L, который выборочно получает данные с помощью поискового термина, который предоставляет пользователь.
> - Как иметь поля на странице "помните", что пользователь ввел.
>   
> 
> Обсуждались особенности/технологии:
> 
> - Объект `Request`.
> - `Where` Оговорка О СЗЛ.

## <a name="what-youll-build"></a>Что вы создадите

В предыдущем уроке вы создали базу данных, добавили `WebGrid` в нее данные, а затем использовали помощника для отображения данных. В этом учебнике вы добавите поле поиска, которое позволяет находить фильмы определенного жанра или название которого содержит любое слово, которое вы вводите. (Например, вы сможете найти все фильмы, жанр которых "Действие" или название которого содержит "Гарри" или "Приключение".)

Когда вы закончите с этим учебником, вы будете иметь страницу, как эта:

![Страница фильмов с поиском жанра и заголовка](form-basics/_static/image1.png)

Часть страницы является такой же, как &mdash; в последнем учебнике сетки. Разница будет в том, что сетка будет показывать только фильмы, которые вы искали.

## <a name="about-html-forms"></a>О формах HTML

(Если у вас есть опыт создания HTML-форм `GET` `POST`и с разницей между и, вы можете пропустить этот раздел.)

Форма имеет текстовые &mdash; ящики ввода пользователей, кнопки, радиокнопки, флажки, списки выпадающих и так далее. Пользователи заполняют эти элементы управления или делают выбор, а затем отправляют форму, нажав на кнопку.

Основной синтаксис HTML формы иллюстрируется этим примером:

[!code-html[Main](form-basics/samples/sample1.html)]

Когда эта разметка работает на странице, она создает простую форму, которая выглядит как эта иллюстрация:

![Базовая форма HTML, отображаемый в браузере](form-basics/_static/image2.png)

Элемент `<form>` примыкает к элементам HTML, которые должны быть представлены. (Легко сделать ошибку – добавить элементы на страницу, а затем забыть поместить их в `<form>` элемент. В этом случае ничего не представлено.) Атрибут `method` сообщает браузеру, как отправить пользовательский ввод. Вы устанавливаете `post` это, если вы выполняете обновление `get` на сервере или если вы просто извлечения данных с сервера.

<a id="GET,_POST,_and_HTTP_Verb_Safety"></a>

> [!TIP] 
> 
> **GET, POST и HTTP Глагол безопасности**
> 
> HTTP, протокол, который браузеры и серверы используют для обмена информацией, удивительно прост в своих основных операциях. Браузеры используют только несколько глаголов для запросов на серверы. Когда вы пишете код для Интернета, полезно понять эти глаголы и как браузер и сервер используют их. Далеко и далеко наиболее часто используемые глаголы являются следующие:
> 
> - `GET`. Браузер использует этот глагол, чтобы получить что-то с сервера. Например, при вводе URL-адреса в браузере `GET` браузер выполняет операцию по запросу нужной страницы. Если страница содержит графику, браузер `GET` выполняет дополнительные операции для получения изображений. Если `GET` операция должна передать информацию серверу, информация передается как часть URL-адреса в строке запроса.
> - `POST`. Браузер отправляет `POST` запрос для отправки данных для добавления или изменения на сервере. Например, `POST` глагол используется для создания записей в базе данных или изменения существующих. Большую часть времени, когда вы заполняете форму и нажимаете кнопку отправки, браузер выполняет операцию. `POST` В `POST` операции данные, передаваемые на сервер, находится в теле страницы.
> 
> Важное различие между этими `GET` глаголами заключается в том, что операция не должна что-либо `GET` менять на сервере - или, говоря немного более абстрактно, операция не приводит к изменению состояния на сервере. Вы можете `GET` выполнять операцию на тех же ресурсах столько раз, сколько вам нравится, и эти ресурсы не меняются. (Операция `GET` часто говорят, что "безопасный", или использовать технический термин, является *идемпотентным*.) В отличие от этого, конечно, `POST` запрос что-то изменяет на сервере каждый раз при выполнении операции.
> 
> Два примера помогут проиллюстрировать это различие. При выполнении поиска с помощью движка, как Bing или Google, вы заполните форму, которая состоит из одного текстового ящика, а затем нажмите кнопку поиска. Браузер выполняет операцию, `GET` при этом значение, вписававеее в поле, передаваемые как часть URL-адреса. Использование `GET` операции для такого типа формы является прекрасным, потому что поисковая операция не изменяет никаких ресурсов на сервере, он просто получает информацию.
> 
> Теперь рассмотрим процесс заказа что-то в Интернете. Вы заполняете детали заказа, а затем нажмите кнопку отправки. Эта операция будет `POST` запросом, поскольку операция приведет к изменениям на сервере, таким как новая запись заказа, изменение информации об учетной записи и, возможно, многие другие изменения. В `GET` отличие от операции, `POST` вы не можете повторить запрос - если вы сделали, каждый раз, когда вы повторно отправили запрос, вы бы создать новый заказ на сервере. (В подобных случаях веб-сайты часто предупреждают вас не нажимать кнопку отправки более одного раза или отогивают кнопку отправки, чтобы вы случайно не отправили форму повторно.)
> 
> В ходе этого урока вы будете `GET` использовать как `POST` операцию, так и операцию для работы с HTML-формами. В каждом случае мы объясним, почему используется глагол.
> 
> (Чтобы узнать больше о глаголах HTTP, смотрите статью [Определения методов](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) на сайте W3C.)

Большинство элементов пользовательского `<input>` ввода являются html-элементами. Они выглядят так, как `<input type="type" name="name">,` *будто тип* указывает на тип пользовательского элемента управления вхданным, который вы хотите. Эти элементы являются общими:

- Текстовое окно:`<input type="text">`
- Флажок:`<input type="check">`
- Кнопка радио:`<input type="radio">`
- Кнопку:`<input type="button">`
- Кнопка отправки:`<input type="submit">`

Вы также можете `<textarea>` использовать элемент для создания многолинейного текстового ящика и `<select>` элемента для создания списка выпадающих или прокрутки списка. (Подробнее об элементах [HTML Forms and Input](http://www.w3schools.com/html/html_forms.asp) формы HTML см.

Атрибут `name` очень важен, потому что имя — как вы получите значение элемента позже, как вы увидите в ближайшее время.

Интересная часть заключается в том, что вы, разработчик страницы, делаете с вводом пользователя. С этими элементами нет встроенного поведения. Вместо этого, вы должны получить значения, которые пользователь ввел или выбрал и сделать что-то с ними. Это то, что вы узнаете в этом учебнике.

> [!TIP] 
> 
> **HTML5 и входные формы**
> 
> Как вы знаете, HTML находится в переходном периоде, а последняя версия (HTML5) включает в себя поддержку более интуитивных способов ввода информации пользователями. Например, в HTML5 вы (разработчик страницы) можете узнать на странице, что вы хотите, чтобы пользователь ввезло дату. Браузер может автоматически отображать календарь, а не требовать от пользователя вводить дату вручную. Тем не менее, HTML5 является новым и не поддерживается во всех браузерах еще.
> 
> ASP.NET Web Pages поддерживает ввод HTML5 в той мере, в какой это делает браузер пользователя. Для идеи новых атрибутов `<input>` для элемента в HTML5 см. атрибут [ввода &lt;&gt; HTML](http://www.w3schools.com/html/html_form_input_types.asp) на сайте W3Schools.

## <a name="creating-the-form"></a>Создание формы

В WebMatrix, в рабочей области **файлов,** откройте страницу *Movies.cshtml.*

После закрытия `</h1>` тега и `<div>` перед `grid.GetHtml` открытием тега вызова, добавить следующую разметку:

[!code-html[Main](form-basics/samples/sample2.html)]

Эта разметка создает форму, которая `searchGenre` имеет текстовое поле с именем и кнопкой отправки. Текстовое поле и кнопка отправки заключены в `<form>` элемент, атрибут которого `method` установлен на. `get` (Помните, что если вы не поместите текстовый ящик и не отправите кнопку внутри элемента, `<form>` ничего не будет отправлено при нажатии кнопки.) Вы используете `GET` глагол здесь, потому что вы создаете форму, которая не вносят никаких изменений на сервере - это просто приводит к поиску. (В предыдущем учебнике вы `post` использовали метод, который является, как вы отправляете изменения на сервере. Вы увидите, что в следующем учебнике снова.)

Запустите страницу. Хотя вы не определили какое-либо поведение для формы, вы можете увидеть, как она выглядит:

![Страница фильмов с полем поиска для жанра](form-basics/_static/image3.png)

Введите значение в текстовое окно, как "Комедия". Затем нажмите **Поиск жанра**.

Обратите внимание на URL страницы. Поскольку атрибут `<form>` элемента `method` настраивается на `get`вводящее значение, вписанное в строку запроса, в URL-

`http://localhost:45661/Movies.cshtml?searchGenre=Comedy`

## <a name="reading-form-values"></a>Значение формы чтения

Страница уже содержит некоторый код, который получает данные базы данных и отображает результаты в сетке. Теперь вам нужно добавить некоторый код, который читает значение текстового поля, так что вы можете запустить запрос S'L, который включает в себя термин поиска.

Поскольку вы устанавливаете метод `get`формы для того, чтобы вы могли прочитать значение, которое было введено в текстовое поле, используя код, как следующее:

`var searchTerm = Request.QueryString["searchGenre"];`

Объект `Request.QueryString` `QueryString` (свойство `Request` объекта) включает в себя значения элементов, которые `GET` были представлены в рамках операции. Свойство `Request.QueryString` содержит *коллекцию* (список) значений, которые представлены в форме. Чтобы получить какое-либо индивидуальное значение, вы указываете имя элемента, который вы хотите. Вот почему вы должны иметь `name` атрибут `<input>` на`searchTerm`элементе (), который создает текстовое поле. (Подробнее об `Request` объекте смотрите [боковую панель](#BKMK_TheRequestObject) позже.)

Это достаточно просто, чтобы прочитать значение текстового окна. Но если пользователь не введал ничего вообще в текстовом поле, но нажал **Поиск** в любом случае, вы можете игнорировать этот клик, так как нет ничего для поиска.

Следующий код является примером, который показывает, как реализовать эти условия. (Вы не должны добавить этот код еще; вы будете делать это в момент.)

[!code-csharp[Main](form-basics/samples/sample3.cs)]

Тест ломается таким образом:

- Получить значение `Request.QueryString["searchGenre"]`, а именно значение, которое `<input>` `searchGenre`было введено в элемент под названием.
- Узнайте, пуста ли она `IsEmpty` с помощью метода. Этот метод является стандартным способом определения того, содержит ли значение что-то (например, элемент формы). Но на самом деле, вы заботитесь только, если он *не* пуст, поэтому ...
- Добавьте `!` оператора перед `IsEmpty` тестом. (Оператор `!` означает логический НЕ).

На простом английском `if` языке, все условие переводится в следующее: *Если элемент searchGenre формы не пуст, то ...*

Этот блок создает условия для создания запроса, использующего термин поиска. Это будет сделано в следующем разделе.

<a id="BKMK_TheRequestObject"></a>

> [!TIP] 
> 
> **Объект запроса**
> 
> Объект `Request` содержит всю информацию, которую браузер отправляет в ваше приложение при запросе или отправке страницы. Этот объект включает в себя любую информацию, которую пользователь предоставляет, например значения текстового поля или файл для загрузки. Он также включает в себя все виды дополнительной информации, такие как файлы cookie, значения строки запроса URL (если таковые имеются), путь файла страницы, который работает, тип браузера, который использует пользователь, список языков, которые установлены в браузере, и многое другое.
> 
> Объект `Request` представляет собой *набор* (список) значений. Вы получаете индивидуальную стоимость из коллекции, указывая ее название:
> 
> `var someValue = Request["name"];`
> 
> Объект `Request` фактически предоставляет несколько подмножеств. Пример:
> 
> - `Request.Form`дает значения из элементов `<form>` внутри представленного элемента, если запрос является запросом. `POST`
> - `Request.QueryString`дает только значения в строке запроса URL. (В URL, `http://mysite/myapp/page?searchGenre=action&page=2`как, `?searchGenre=action&page=2` раздел URL строки запроса.)
> - `Request.Cookies`коллекция дает вам доступ к файлам cookie, которые браузер отправил.
> 
> Чтобы получить значение, которое вы знаете, находится `Request["name"]`в представленной форме, вы можете использовать. Кроме того, можно использовать более `Request.Form["name"]` конкретные версии (для `POST` запросов) или `Request.QueryString["name"]` (для `GET` запросов). Конечно, *имя* имя пункта, чтобы получить.
> 
> Название предмета, который вы хотите получить, должно быть уникальным в коллекции, которая вы используете. Вот почему `Request` объект предоставляет подмножества, `Request.Form` `Request.QueryString`как и . Предположим, что ваша страница `userName` содержит элемент формы `userName`с именем, а *также* содержит файл cookie с именем . Если вы `Request["userName"]`получаете, это неоднозначно ли вы хотите значение формы или печенье. Однако, если `Request.Form["userName"]` `Request.Cookie["userName"]`вы получаете или , вы явно о том, какое значение, чтобы получить.
> 
> Это хорошая практика, чтобы быть конкретным и `Request` использовать подмножество, что `Request.Form` `Request.QueryString`вы заинтересованы в, как или . Для простых страниц, которые вы создаете в этом учебнике, это, вероятно, на самом деле не имеет никакого значения. Однако при создании более сложных страниц, используя явную версию `Request.Form` или `Request.QueryString` может помочь вам избежать проблем, которые могут возникнуть, когда страница содержит форму (или несколько форм), файлы cookie, значения строк запроса и так далее.

## <a name="creating-a-query-by-using-a-search-term"></a>Создание запроса с помощью термина поиска

Теперь, когда вы знаете, как получить термин поиска, который ввел пользователь, можно создать запрос, который использует его. Не забудьте, что для того, чтобы вывести все элементы фильма из базы данных, вы используете запрос S'L, похожий на это утверждение:

`SELECT * FROM Movies`

Чтобы получить только определенные фильмы, необходимо использовать `Where` запрос, который включает в себя оговорку. Это положение позволяет установить условие, на котором строки возвращаются запросом. Ниже приведен пример:

`SELECT * FROM Movies WHERE Genre = 'Action'`

Основной формат `WHERE column = value`. Вы можете использовать различные `>` операторы, `<` кроме просто, `<>` `<=` `=`как (больше, чем), (меньше, чем), (не равна), (меньше, чем или равны), и т.д., в зависимости от того, что вы ищете.

В случае, если вам интересно, заявления &mdash; `SELECT` s'L `Select` не являются `select`чувствительными случае так же, как (или даже). Тем не менее, люди часто капитализируют `SELECT` ключевые слова в выписке по S'L, например, и, `WHERE`чтобы сделать его легче читать.

### <a name="passing-the-search-term-as-a-parameter"></a>Прохождение термина поиска в качестве параметра

Поиск конкретного жанра достаточно`WHERE Genre = 'Action'`легко ( ), но вы хотите, чтобы иметь возможность искать для любого жанра, что пользователь входит. Для этого вы создаете в качестве запроса S'L, который включает в себя заполнитель для значения для поиска. Это будет выглядеть как эта команда:

`SELECT * FROM Movies WHERE Genre = @0`

Заполнитель `@` символ следует ноль. Как вы могли догадаться, запрос может содержать несколько заполнителей, и они будут названы `@0`, `@1` `@2`и т.д.

Чтобы настроить запрос и передать его значение, вы используете код, как следующее:

[!code-sql[Main](form-basics/samples/sample4.sql)]

Этот код аналогичен тому, что вы уже сделали для отображения данных в сетке. Единственные отличия:

- Запрос содержит заполнитель`WHERE Genre = @0"`().
- Запрос вводима в`selectCommand`переменную (); ранее вы передавали запрос непосредственно `db.Query` методу.
- При вызове `db.Query` метода вы передаете как запрос, так и значение для использования для заполнителя. (Если в запросе было несколько заполнителей, вы бы передали их все как отдельные значения методу.)

Если собрать все эти элементы вместе, вы получите следующий код:

[!code-csharp[Main](form-basics/samples/sample5.cs)]

> [!NOTE] 
> 
> **Важно!** Использование заполнителей (например), `@0`чтобы передать значения команде S'L, чрезвычайно *важно* для безопасности. То, как вы видите это здесь, с заполнителями для переменных данных, является единственным способом, которым вы должны построить команды S'L.
> 
> Никогда не стройте заявление s'L, объединяя (конкатенацию) буквальный текст и значения, которые вы получаете от пользователя. Совмещение пользовательского ввода в выписку s'L открывает ваш сайт для *атаки на инъекцию S'L,* где вредоносный пользователь отправляет значения на вашу страницу, которая взломает вашу базу данных. (Вы можете прочитать больше в статье [S'L инъекций](https://msdn.microsoft.com/library/ms161953.aspx) веб-сайт MSDN.)

## <a name="updating-the-movies-page-with-search-code"></a>Обновление страницы фильмов с помощью кода поиска

Теперь вы можете обновить код в файле *Movies.cshtml.* Для начала замените код в блоке кода в верхней части страницы этим кодом:

[!code-csharp[Main](form-basics/samples/sample6.cs)]

Разница в том, что вы поместили `selectCommand` запрос в переменную, `db.Query` которую перейдите позже. Ввод оператора S'L в переменную позволяет изменить оператор, что и будет делать для выполнения поиска.

Вы также удалили эти две строки, которые вы поставите обратно в позже:

[!code-csharp[Main](form-basics/samples/sample7.cs)]

Вы не хотите, чтобы запустить запрос еще (то есть, вызов), `db.Query`и вы `WebGrid` не хотите, чтобы инициализировать помощника еще либо. Вы будете делать эти вещи после того, как вы поняли, какой s'L выписка должна работать.

После этого переписана блокировка, можно добавить новую логику для обработки поиска. Заполненный код будет выглядеть следующим образом. Обновление кода на странице, чтобы он соответствовал этому примеру:

[!code-cshtml[Main](form-basics/samples/sample8.cshtml)]

Страница теперь работает следующим образом. Каждый раз, когда страница выполняется, `selectCommand` код открывает базу данных, и переменная `Movies` устанавливается в выписку s'L, которая получает все записи из таблицы. Код также инициализирует переменную. `searchTerm`

Однако, если текущий запрос `searchGenre` включает значение для `selectCommand` элемента, код устанавливается на другой `Where` запрос, а именно на запрос, который включает положение для поиска жанра. Он также `searchTerm` устанавливает на все, что было передано для поиска окно (которое может быть ничего).

Независимо от того, в `selectCommand`какой выписке находится S'L, код затем вызывает `db.Query` для выполнения запроса, передавая его на все, что находится в `searchTerm`. Если нет ничего `searchTerm`в, это не имеет значения, потому что в этом `selectCommand` случае нет параметра, чтобы передать значение в любом случае.

Наконец, код инициализирует `WebGrid` помощника, используя результаты запроса, как и раньше.

Вы можете видеть, что, разместив оператор s-L и термин поиска в переменные, вы добавили гибкость в код. Как вы увидите позже в этом учебнике, вы можете использовать эту базовую структуру и продолжать добавлять логику для различных типов поисков.

## <a name="testing-the-search-by-genre-feature"></a>Тестирование функции поиска по жанру

В WebMatrix запустите страницу *Movies.cshtml.* Вы видите страницу с текстовым полем для жанра.

Введите жанр, который вы ввели для одной из ваших тестовых записей, а затем нажмите **Поиск.** На этот раз вы видите список только фильмы, которые соответствуют этому жанру:

![Фильмы страницы листинг после поиска жанра 'Комедии'](form-basics/_static/image4.png)

Введите другой жанр и поиск снова. Попробуйте войти в жанр, используя все нижние или все буквы верхнего регистра, так что вы можете видеть, что поиск не является случае чувствительным.

## <a name="remembering-what-the-user-entered"></a>"Вспоминая" Что пользователь ввел

Вы могли заметить, что после того, как вы вошли в жанр и нажал **поиск жанра**, вы видели листинг для этого жанра. Тем не менее, текстовый ящик поиска был пуст, &mdash; другими словами, он не помнит, что вы ввели.

Важно понять, почему такое поведение происходит. При отправке страницы браузер отправляет запрос на веб-сервер. Когда ASP.NET получает запрос, он создает совершенно новый экземпляр страницы, запускает код в нем, а затем снова отосвносит страницу в браузер. В действительности, однако, страница не знает, что вы просто работали с предыдущей версией себя. Все, что он знает, что он получил запрос, который имел некоторые данные формы в нем.

Каждый раз, &mdash; когда вы запрашиваете страницу, будь то в первый раз или, представив ее, &mdash; вы получаете новую страницу. Веб-сервер не помнит ваш последний запрос. Как и ASP.NET, и браузер не работает. Единственная связь между этими отдельными экземплярами страницы — это любые данные, которые вы передаете между ними. Например, если вы отправляете страницу, в экземпляр новой страницы можно получить данные формы, отправленные предыдущим экземпляром. (Еще один способ передачи данных между страницами — использование файлов cookie.)

Формальный способ описать эту ситуацию заключается в том, чтобы сказать, что веб-страницы *являются абрежными.* Веб-серверы и сами страницы и элементы страницы не сохраняют никакой информации о предыдущем состоянии страницы. Веб был разработан таким образом, потому что поддержание состояния для индивидуальных запросов быстро исчерпает ресурсы веб-серверов, которые часто обрабатывают тысячи, может быть, даже сотни тысяч запросов в секунду.

Так вот почему текстовый ящик был пуст. После отправки страницы ASP.NET создал новый экземпляр страницы и пробежал код и разметку. В этом коде не было ничего, что говорило бы ASP.NET внести значение в текстовое поле. Так что ASP.NET ничего не сделал, и текстовый ящик был представлен без значения в нем.

Там на самом деле простой способ обойти этот вопрос. Жанр, который вы ввели в текстовое &mdash; поле *доступен* для вас в коде это в `Request.QueryString["searchGenre"]`.

Обновление разметки для текстового окна так, что `value` атрибут получает свою ценность от, `searchTerm`как этот пример:

[!code-html[Main](form-basics/samples/sample9.html?highlight=1)]

На этой странице можно также `value` установить `searchTerm` атрибут переменной, так как эта переменная также содержит введомый жанр. Но использование `Request` объекта для `value` установки атрибута, как показано здесь, является стандартным способом выполнения этой задачи. (Предполагая, что вы &mdash; даже хотите сделать это в некоторых ситуациях, вы можете сделать страницу *без* значений в полях. Все зависит от того, что происходит с вашим приложением.)

> [!NOTE]
> Вы не можете "запомнить" значение текстового ящика, используемого для паролей. Это будет дыра в безопасности, чтобы позволить людям заполнить поле паролей с помощью кода.

Запустите страницу снова, введите жанр, и нажмите **Поиск жанра**. На этот раз вы не только видите результаты поиска, но текстовый ящик запоминает то, что вы ввели в прошлый раз:

![Страница, показывающая, что текстовое окно "запомнило" предыдущую запись](form-basics/_static/image5.png)

## <a name="searching-for-any-word-in-the-title"></a>Поиск любого слова в заголовке

Теперь вы можете искать для любого жанра, но вы также можете искать название. Трудно получить название точно правильно, когда вы ищете, так что вместо этого вы можете искать слово, которое появляется в любом месте внутри названия. Для этого в S'L `LIKE` используется оператор и синтаксис:

`SELECT * FROM Movies WHERE Title LIKE '%adventure%'`

Эта команда получает все фильмы, названия которых содержат "приключение". При использовании `LIKE` оператора вы включаете `%` символ подстановочного знака как часть поискового термина. Поиск `LIKE 'adventure%'` означает "начало с "приключения". (Технически, это означает "строка' приключение", а затем что-нибудь.") Аналогичным образом, `LIKE '%adventure'` термин поиска означает "все, что следует строка'приключение", который является еще одним способом сказать "окончание с" приключения ".

Таким образом, термин `LIKE '%adventure%'` поиска означает "приключение" в любом месте заголовка". (Технически, "все в названии, а затем" приключения ", а затем ничего.")

Внутри `<form>` элемента добавьте следующую разметку прямо под тегом `</div>` закрытия `</form>` для поиска жанра (незадолго до элемента закрытия):

[!code-html[Main](form-basics/samples/sample10.html)]

Код для обработки этого поиска похож на код для поиска жанра, за исключением того, что вы должны собрать `LIKE` поиск. Внутри блока кода в верхней части `if` страницы, `if` добавить этот блок сразу после блока для жанра поиска:

[!code-csharp[Main](form-basics/samples/sample11.cs)]

Этот код использует ту же логику, которую `LIKE` вы видели ранее, за исключением того, что поиск использует оператора и код ставит "`%`до и после термина поиска.

Обратите внимание, как было легко добавить еще один поиск на страницу. Все, что вам нужно было сделать, это:

- Создайте `if` блок, который тестируется, чтобы увидеть, имеет ли значение соответствующее поле поиска.
- Установите `selectCommand` переменную на новую выписку S'L.
- Установите `searchTerm` переменную к значению для передачи в запрос.

Вот полный блок кода, который содержит новую логику для поиска заголовков:

[!code-cshtml[Main](form-basics/samples/sample12.cshtml)]

Если вкратце, этот код выполняет указанные ниже действия.

- Переменные `searchTerm` имитируются `selectCommand` в верхней части. Вы собираетесь установить эти переменные на соответствующий термин поиска (если таковые имеется) и соответствующую команду S'L на основе того, что пользователь делает на странице. Поиск по умолчанию является простым случаем получения всех фильмов из базы данных.
- В тестах `searchGenre` `searchTitle`для и, `searchTerm` код устанавливает значение, вы хотите искать. Эти блоки `selectCommand` кода также устанавливаются в соответствующую команду S'L для этого поиска.
- Метод `db.Query` вызывается только один раз, используя все, что команда S'L находится в `selectedCommand` и независимо от значения в `searchTerm`. Если нет термина поиска (нет жанра и `searchTerm` нет заголовка слова), значение является пустой строкой. Однако это не имеет значения, так как в этом случае запрос не требует параметра.

## <a name="testing-the-title-search-feature"></a>Тестирование функции поиска заголовка

Теперь вы можете протестировать завершенную страницу поиска. Выполнить *Movies.cshtml*.

Введите жанр и нажмите **Поиск жанра**. Сетка отображает фильмы этого жанра, как и раньше.

Введите заголовок слова и нажмите **Кнопка Поиск Название**. Сетка отображает фильмы, которые имеют это слово в названии.

![Фильмы страницы листинг после поиска 'The' в названии](form-basics/_static/image6.png)

Оставьте оба текстовых ящика пустыми и нажмите на любой из кнопок. Сетка отображает все фильмы.

## <a name="combining-the-queries"></a>Объединение запросов

Вы можете заметить, что поиск, который вы можете выполнить, являются эксклюзивными. Вы не можете искать название и жанр в то же время, даже если оба поиска коробки имеют значения в них. Например, нельзя искать все боевики, название которых содержит "Приключение". (Поскольку страница закодирована сейчас, если вы вводите значения как для жанра, так и для заголовка, поиск заголовка получает приоритет.) Для создания поиска, сочетающего в себе условия, необходимо создать запрос s-L, который имеет синтаксис, как следующее:

`SELECT * FROM Movies WHERE Genre = @0 AND Title LIKE @1`

И вам придется запустить запрос, используя заявление, как следующее (примерно говоря):

`var selectedData = db.Query(selectCommand, searchGenre, searchTitle);`

Создание логики, позволяющей многим перестановкам критериев поиска, может быть немного вовлечено, как вы можете видеть. Поэтому мы остановимся на этом.

## <a name="coming-up-next"></a>Далее

В следующем уроке вы создадите страницу, которая использует форму, чтобы позволить пользователям добавлять фильмы в базу данных.

## <a name="complete-listing-for-movie-page-updated-with-search"></a>Полный список страницы фильма (обновлено с поиском)

[!code-cshtml[Main](form-basics/samples/sample13.cshtml)]

## <a name="additional-resources"></a>Дополнительные ресурсы

- [Введение в веб-программирование для ASP.NET с использованием синтаксиса Razor](https://go.microsoft.com/fwlink/?LinkID=202890)
- [Пункт ОДД](http://www.w3schools.com/sql/sql_where.asp) на сайте W3Schools
- [Статья определения методов](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) на сайте W3C

> [!div class="step-by-step"]
> [Назад](displaying-data.md)
> [Вперед](entering-data.md)
