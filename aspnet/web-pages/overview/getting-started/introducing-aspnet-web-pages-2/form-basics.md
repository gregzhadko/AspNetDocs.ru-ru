---
uid: web-pages/overview/getting-started/introducing-aspnet-web-pages-2/form-basics
title: Знакомство с веб-страниц ASP.NET — основы форм HTML | Документация Майкрософт
author: Rick-Anderson
description: Мы продемонстрируем основы как создать форму ввода и как обрабатывать ввод пользователя, при использовании веб-страниц ASP.NET (Razor). И теперь, когда...
ms.author: riande
ms.date: 05/28/2015
ms.assetid: 81ed82bf-b940-44f1-b94a-555d0cb7cc98
msc.legacyurl: /web-pages/overview/getting-started/introducing-aspnet-web-pages-2/form-basics
msc.type: authoredcontent
ms.openlocfilehash: f88f7a31551abda029bee0ec16aa35ce2ef5d2f0
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59385960"
---
# <a name="introducing-aspnet-web-pages---html-form-basics"></a>Знакомство с веб-страниц ASP.NET — основы форм HTML

по [Tom FitzMacken](https://github.com/tfitzmac)

> Мы продемонстрируем основы как создать форму ввода и как обрабатывать ввод пользователя, при использовании веб-страниц ASP.NET (Razor). И теперь, когда у вас есть базы данных, вы используете свои навыки формы пользователям найти определенные фильмов в базе данных. Предполагается, вы выполнили рядов через [введение для отображения данных с помощью ASP.NET Web Pages](/aspnet/web-pages/overview/getting-started/introducing-aspnet-web-pages-2/displaying-data).
> 
> Вы узнаете, как:
> 
> - Как создать форму с помощью стандартных элементов HTML.
> - Как считать пользователя входных в форме.
> - Предоставляет способ создания SQL-запрос, что выборочно получает данные с помощью поиска терминов, пользователь.
> - Как у поля, на странице «запомнить» ввод пользователя.
>   
> 
> Функции и технологии:
> 
> - Объект `Request`.
> - SQL `Where` предложение.


## <a name="what-youll-build"></a>Что вы создадите

В предыдущем учебном курсе, создали базу данных, добавления данных к нему и затем используется `WebGrid` вспомогательный метод для отображения данных. В этом руководстве вы добавите поле поиска позволяет находить фильмы из определенного жанра или заголовки которых содержит любое слово, вводе. (Например, вы сможете найти все фильмы жанрах «Action» или заголовки которых содержит «Гарри» или «Adventure.»)

Когда все будет готово к этому учебнику, вы получите страницу следующего вида:

![Страница фильмы с поиском жанр и заголовок](form-basics/_static/image1.png)

Листинг часть страницы совпадает с последнего курса &mdash; сетки. Отличие может быть, что в сетке перечислены все фильмы только что вы искали.

## <a name="about-html-forms"></a>О HTML-формы

(Если у вас есть опыт создания HTML-формы и с той разницей между `GET` и `POST`, этот раздел можно пропустить.)

Форма содержит элементы пользовательского ввода &mdash; текстовые поля, кнопки, переключатели, флажки, раскрывающиеся списки и т. д. Пользователи заполнить эти элементы управления или сделайте выбор и затем отправить форму нажатием кнопки.

В этом примере показана базовый синтаксис HTML формы.

[!code-html[Main](form-basics/samples/sample1.html)]

При запуске этой разметки на странице создается простая форма, которая выглядит как на этом рисунке:

![Базовая форма HTML как готовый для просмотра в браузере](form-basics/_static/image2.png)

`<form>` Элемент заключает в себе элементы HTML для отправки. (Простой ошибки, чтобы сделать — добавить элементы на страницу, но потом просто забыть их внутри `<form>` элемент. В этом случае ничего не отправляется.) `method` Атрибут указывает обозревателю, как отправлять входные данные пользователя. Выбрано значение `post` при выполнении обновления на сервере или к `get` если только что выборка данных с сервера.

<a id="GET,_POST,_and_HTTP_Verb_Safety"></a>

> [!TIP] 
> 
> **GET, POST и HTTP-команда безопасности**
> 
> Протокол HTTP, протокол, который браузеров и серверы используют для обмена данными, примечательно прост в его основные операции. Браузеры используют только несколько команд для выполнения запросов к серверам. При написании кода для веб-, полезно понимать эти команды, которая браузером и сервером использовать их. Использующимся наиболее часто используемые команды указаны следующие:
> 
> - `GET`. Эта команда автоматически обозревателем для выборки что-то с сервера. Например, при вводе URL-адрес в адресную строку браузера браузер выполняет `GET` операцию запроса страницы. Если страница содержит графики, браузер выполняет дополнительные `GET` операции для получения изображений. Если `GET` операции должен передать сведения на сервер, данные, передаваемые как часть URL-адреса в строке запроса.
> - `POST`. Браузер отправляет `POST` запрос для отправки данных необходимо добавить или изменить на сервере. Например `POST` команда используется для создания записей в базе данных или изменить существующие. В большинстве случаев, когда заполните форму и нажмите кнопку "Отправить", браузер выполняет `POST` операции. В `POST` , передаваемых на сервер данных выполняется в основной области страницы.
> 
> Важное различие между эти команды является то, что `GET` операции не должен изменять что-либо на сервере, или чтобы поместить его в виде немного более абстрактными `GET` операция не приводит к изменению состояния на сервере. Можно выполнить `GET` операцию на те же ресурсы столько раз, сколько нужно, а не изменяйте эти ресурсы. (Объект `GET` операция часто называется «безопасность», или использовать технический термин, является *идемпотентными*.) В свою очередь, само собой `POST` запрос вносит изменения на сервере каждый раз при выполнении операции.
> 
> Два примера помогут проиллюстрировать это различие. При выполнении поиска используется подсистема, например Bing или Google, заполните форму, которая состоит из одного текстового поля и затем нажмите кнопку поиска. Браузер выполняет `GET` операции со значением, введенным в поле, передаются как часть URL-адрес. С помощью `GET` операции за этим типом формы нормально, так как операция поиска не изменяется все ресурсы на сервере, он просто извлекает сведения.
> 
> Теперь рассмотрим процесс упорядочения, что-то через Интернет. Введите сведения о заказе и нажмите кнопку «Отправить». Эта операция будет `POST` запроса, так как операция приведет к изменению на сервере, например новый заказ, изменения в данные вашей учетной записи и может быть много других изменений. В отличие от `GET` операции, не может повторяться в `POST` запроса — Если вы выполнили, каждый раз, когда вы повторно отправить запрос, создается новый заказ на сервере. (В таких случаях веб-сайтов часто предупредит вас не нажимать кнопку отправки более одного раза или отключит «отправить», чтобы вы случайно не отправку формы.)
> 
> В этом руководстве будет использоваться `GET` операции и `POST` операции для работы с HTML-формы. Мы объясним, в каждой вариантов почему команды, которая использовалась та же соответствующие.
> 
> (Дополнительные сведения о HTTP-команды, см. в разделе [определений методов](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) статье на веб-узле W3C.)


Большинство элементов ввода являются HTML `<input>` элементов. Они выглядят как `<input type="type" name="name">,` где *тип* указывает тип элемента управления вводом пользователя, требуется. Наиболее часто относятся следующие элементы.

- Текстовое поле: `<input type="text">`
- Флажок: `<input type="check">`
- "Переключатель": `<input type="radio">`
- Кнопка: `<input type="button">`
- Кнопка "отправьте": `<input type="submit">`

Можно также использовать `<textarea>` элемент для создания многострочного текстового окна и `<select>` элемент для создания раскрывающегося списка или прокручиваемый список. (Дополнительные сведения о HTML форме элементов см. в разделе [HTML-формах и входных данных](http://www.w3schools.com/html/html_forms.asp) на сайте W3Schools.)

`name` Атрибут очень важно, так как оно каким образом вы получите значение элемента в более поздней версии, вы вскоре увидите.

Особый интерес представляет, разработчик, возможностях с входными данными пользователя. Нет нет встроенного поведения, связанные с этими элементами. Вместо этого необходимо получить значения, введенные или выбранные пользователем и с ними. Это, вы узнаете, как в этом руководстве.

> [!TIP] 
> 
> **HTML5 и формы ввода**
> 
> Как вы знаете, HTML находится в состоянии перехода, и последняя версия (HTML5) включает поддержку методов более интуитивно понятным для пользователей ввести сведения. Например с помощью HTML5 (разработчик) можно сказать, странице возникает необходимость пользователю ввести дату. Затем, браузер может автоматически отобразить календаря, а не требовать от пользователя, чтобы вручную ввести дату. Тем не менее HTML5, новые и еще не поддерживается во всех браузерах.
> 
> Веб-страницы ASP.NET поддерживает входные данные при условии, что обозреватель пользователя делает HTML5. Для получения представления о новые атрибуты `<input>` элемент в HTML5, см. в разделе [HTML &lt;входной&gt; атрибут type](http://www.w3schools.com/html/html_form_input_types.asp) на сайте W3Schools.


## <a name="creating-the-form"></a>Создание формы

В WebMatrix в **файлы** рабочей области, откройте *Movies.cshtml* страницы.

После закрывающего `</h1>` тега и перед открывающим `<div>` тег `grid.GetHtml` вызывать, добавьте следующую разметку:

[!code-html[Main](form-basics/samples/sample2.html)]

Эта разметка создает форму, которая содержит текстовое поле с именем `searchGenre` и кнопка отправки. Текст поле и отправить кнопку заключаются в `<form>` элемент которого `method` атрибут имеет значение `get`. (Помните, что если вы не Поместите текстовое поле и кнопка внутри "Отправить" `<form>` элемент, ничего не будут отправлены после нажатия кнопки.) Использовании `GET` глагол здесь потому, что вы создаете формы, не вносить любые изменения на сервере — только в результате поиска. (В предыдущем руководстве вы использовали `post` метод, который является метод отправки изменений на сервер. Вы увидите, в следующем учебном курсе еще раз.)

Откройте страницу. Несмотря на то, что вы еще не определили любое поведение для формы, видно, что получится:

![Страница фильмов с помощью поля поиска для жанра](form-basics/_static/image3.png)

Введите значение в текстовое поле, например «Комедия.» Нажмите кнопку **жанр поиска**.

Запишите URL-адрес страницы. Так как вы задали `<form>` элемента `method` атрибут `get`, введенное значение теперь является частью строки запроса в URL-адрес, следующим образом:

`http://localhost:45661/Movies.cshtml?searchGenre=Comedy`

## <a name="reading-form-values"></a>Считывание значений формы

Страница уже содержит код, который получает данные базы данных и отображает результаты в виде сетки. Теперь необходимо добавить некоторый код, который считывает значение текстового поля, чтобы можно было запустить SQL-запрос, включающий условие поиска.

Так как значение формы метод `get`, можно прочитать значение, введенное в текстовое поле, с помощью следующего кода:

`var searchTerm = Request.QueryString["searchGenre"];`

`Request.QueryString` Объекта ( `QueryString` свойство `Request` объекта) включает в себя значения элементов, которые были переданы как часть `GET` операции. `Request.QueryString` Свойство содержит *коллекции* (список), которые передаются в виде значений. Для получения всех индивидуальных значений, указать имя элемента, который вы хотите. Вот почему нам нужна `name` атрибут `<input>` элемент (`searchTerm`), создает текстовое поле. (Дополнительные сведения о `Request` объекта, см. в разделе [боковой панели](#BKMK_TheRequestObject) позже.)

Это достаточно простым, чтобы считать значение текстового поля. Но если пользователь ничего не введено вообще в текстовом поле, но нажал **поиска** в любом случае, можно игнорировать, нажмите кнопку, так как нет элементов для поиска.

Ниже приведен пример, демонстрирующий способы реализации этих условий. (Добавьте следующий код еще не нужно, это можно сделать позже.)

[!code-csharp[Main](form-basics/samples/sample3.cs)]

Тест делится таким образом:

- Получить значение `Request.QueryString["searchGenre"]`, а именно, введенный в значение `<input>` элемент с именем `searchGenre`.
- Узнайте, пуст ли с помощью `IsEmpty` метод. Этот метод является стандартным способом для определения того, содержит ли что-нибудь (например, элемент form) значение. Но действительно, интересуют только в том случае, если он имеет *не* пуст, поэтому...
- Добавить `!` оператор в начале `IsEmpty` тестирования. ( `!` Оператор означает логическое не).

Простыми словами, весь `if` условие преобразуется в следующий: *Если элемент searchGenre формы не пустой, то...*

Этот блок задает рабочей области для создания запроса, использующего условие поиска. Можно сделать в следующем разделе.

<a id="BKMK_TheRequestObject"></a>

> [!TIP] 
> 
> **Объект запроса**
> 
> `Request` Объект содержит всю информацию, браузер отправляет в приложение, когда страницы запроса или отправки. Этот объект включает все сведения, пользователь предоставляет, таких как значения текстового поля или файл для передачи. Он также включает все виды Дополнительные сведения, такие как файлы cookie, значения в строке запроса URL-адрес (если таковые имеются), путь к файлу страницы, на котором выполняется, тип браузера, которое пользователь использует, список языков, заданных в браузере и многое другое.
> 
> `Request` Объект *коллекции* (список) значений. Получение отдельное значение из коллекции путем указания его имени:
> 
> `var someValue = Request["name"];`
> 
> `Request` Объект фактически предоставляет несколько подмножеств. Пример:
> 
> - `Request.Form` Предоставляет значения из элементов внутри отправленного `<form>` элемент, если запрос является `POST` запроса.
> - `Request.QueryString` предоставляет только значения в строке запроса URL-адрес. (В URL-адресу вида `http://mysite/myapp/page?searchGenre=action&page=2`, `?searchGenre=action&page=2` раздел URL-адрес является строка запроса.)
> - `Request.Cookies` коллекции предоставляет доступ к файлам cookie, отправленные браузера.
> 
> Чтобы получить значение, которое известно в отправленной формы, можно использовать `Request["name"]`. Кроме того, можно использовать более конкретные версии `Request.Form["name"]` (для `POST` запросов) или `Request.QueryString["name"]` (для `GET` запросов). Само собой *имя* имя элемента.
> 
> Имя элемента, который вы хотите получить должно быть уникальным в пределах коллекции, которую вы используете. Вот почему `Request` предоставляет подмножества, такие как `Request.Form` и `Request.QueryString`. Предположим, что страница содержит элемент формы с именем `userName` и *также* содержит файл cookie с именем `userName`. Если вы получаете `Request["userName"]`, он является неоднозначным, нужно ли значение формы или файл cookie. Тем не менее если вы получаете `Request.Form["userName"]` или `Request.Cookie["userName"]`, что что явное значение, которое нужно получить.
> 
> Рекомендуется, чтобы указать точно и использовать подмножество `Request` что вас интересует, как `Request.Form` или `Request.QueryString`. Для простых страниц, которые вы создаете в этом руководстве вероятно, нет необходимости действительно разница. Тем не менее, как создать более сложные страницы, с помощью версии явно `Request.Form` или `Request.QueryString` могут помочь избежать проблем, которые могут возникнуть, когда страница содержит форму (или несколько форм), файлы cookie, значения строки запроса и т. д.


## <a name="creating-a-query-by-using-a-search-term"></a>Создание запроса с помощью условия поиска

Теперь, когда вы знаете, как получить условие поиска, введенное пользователем, можно создать запрос, который его использует. Помните, что для получения всех элементов фильма из базы данных, вы используете SQL-запрос, который выглядит, как эта инструкция:

`SELECT * FROM Movies`

Чтобы получить только определенные фильмы, необходимо использовать запрос, включающий `Where` предложение. Это предложение позволяет задать условие, на котором строки возвращаются в запросе. Ниже приведен пример:

`SELECT * FROM Movies WHERE Genre = 'Action'`

— Базовый формат `WHERE column = value`. Можно использовать различные операторы, кроме просто `=`, например `>` (больше), `<` (меньше), `<>` (не равно), `<=` (меньше или равно), т. д., в зависимости от того, что вы искали.

В случае, если вам интересно, инструкции SQL не учитывают регистр &mdash; `SELECT` совпадает со значением `Select` (или даже `select`). Тем не менее, люди часто реализуйте весь потенциал ключевые слова в инструкцию SQL, например `SELECT` и `WHERE`, чтобы сделать его более удобным для чтения.

### <a name="passing-the-search-term-as-a-parameter"></a>Передавая в качестве параметра условия поиска

Поиск определенного жанра достаточно просто (`WHERE Genre = 'Action'`), но вы хотите иметь возможность поиска для любой жанра, вводимых пользователем. Для этого создается как SQL-запрос, имеется заполнитель для значения для поиска. Будет выглядеть, как эта команда:

`SELECT * FROM Movies WHERE Genre = @0`

Является прототипом `@` символ указан после знака деления на ноль. Как можно догадаться, запрос может содержать несколько заполнителей, и они будут называться `@0`, `@1`, `@2`и т. д.

Для настройки запроса и фактически передайте ему значение, используйте код, аналогичный следующему:

[!code-sql[Main](form-basics/samples/sample4.sql)]

Этот код похож на то, что вы уже сделали для отображения данных в сетке. Единственными отличиями являются:

- Запрос содержит заполнитель (`WHERE Genre = @0"`).
- Запрос помещается в переменную (`selectCommand`); прежде, чем вы передали запрос непосредственно к `db.Query` метод.
- При вызове `db.Query` метода, передаче и запрос и значение, используемое для местозаполнителя. (Если запрос содержит несколько заполнителей, следует передавать их все как отдельные значения в метод.)

Если поместить все эти элементы друг с другом, вы получите следующий код:

[!code-csharp[Main](form-basics/samples/sample5.cs)]

> [!NOTE] 
> 
> **Важно!** С помощью заполнителей (таких как `@0`) для передачи значений команды SQL является *крайне важно* для безопасности. Так, здесь можно увидеть его с заполнителями для динамических данных является единственным способом, необходимо так сконструировать команды SQL.
> 
> Никогда не создает инструкцию SQL, собирая их (сцепления) литеральный текст и значения, которые можно получить от пользователя. Объединения вводимых пользователем данных в одну инструкцию SQL откроется веб-узел *атака путем внедрения кода SQL* когда злоумышленник отправляет значения на страницу, hack базы данных. (Дополнительные сведения в статье [путем внедрения кода SQL](https://msdn.microsoft.com/library/ms161953.aspx) веб-сайте MSDN.)


## <a name="updating-the-movies-page-with-search-code"></a>Обновления страницы фильмы с поиск кода

Теперь можно обновить код в *Movies.cshtml* файла. Чтобы начать, замените код в блоке кода в верхней части страницы этот код:

[!code-csharp[Main](form-basics/samples/sample6.cs)]

Отличие заключается в том, что вы помещаете этот запрос в `selectCommand` переменной, которую вы будете передавать `db.Query` позже. Поместив инструкцию SQL в переменную можно изменить оператор, который вы можете выполнять для выполнения поиска.

Кроме того, вы удалили эти две строки, в которых будет размещаться обратно в более поздней версии:

[!code-csharp[Main](form-basics/samples/sample7.cs)]

Выполните запрос еще не требуется (то есть вызывать `db.Query`) и вы не хотите инициализировать `WebGrid` вспомогательный еще одно. Предстоит выполнить эти действия, после вы поняли какие инструкции SQL должен выполняться.

После этого перезаписанный блока можно добавить новый логику для обработки поиска. Полный код будет выглядеть следующим образом. Обновление кода на странице, как и в этом примере:

[!code-cshtml[Main](form-basics/samples/sample8.cshtml)]

Страница теперь работает следующим образом. Каждый раз при запуске страницы, код открывает базу данных и `selectCommand` переменной присваивается инструкцию SQL, которая возвращает все записи из `Movies` таблицы. Этот код инициализирует также `searchTerm` переменной.

Тем не менее если текущий запрос включает значение `searchGenre` элемент, в коде устанавливается `selectCommand` для другой запрос, а именно на ту, которая включает в себя `Where` предложение для поиска жанр фильма. Он также задает `searchTerm` все, что был передан для поля поиска (это может быть nothing).

Независимо от того, какие SQL инструкция находится в `selectCommand`, затем код вызывает `db.Query` для выполнения запроса, передавая ему любые находится в `searchTerm`. Если нет ничего `searchTerm`, не имеет значения, так как в этом случае параметр не предназначен для передачи значения для `selectCommand` в любом случае.

Наконец, этот код инициализирует `WebGrid` вспомогательный с помощью результаты запроса, как и прежде.

Как видите, поместив в инструкции SQL и условие поиска в переменных, вы добавили гибкость в код. Как вы увидите далее в этом руководстве, можно использовать этот основную инфраструктуру и добавлять логику для различных типов поиска.

## <a name="testing-the-search-by-genre-feature"></a>Тестирование функции поиска по жанру

В WebMatrix, выполните *Movies.cshtml* страницы. Отобразится страница с текстовым полем для жанра.

Введите жанра, который вы ввели по одной записи теста, а затем нажмите кнопку **поиска**. На этом этапе отобразится список просто фильмов, которые соответствуют, Жанр:

![После поиска Comedies «genre» страницу Movies](form-basics/_static/image4.png)

Введите другой жанр и повторить поиск. Попробуйте ввести жанр с использованием всех и строчные буквы, поэтому вы увидите, что поиск выполняется без учета регистра.

## <a name="remembering-what-the-user-entered"></a>«Запоминание» пользователь ввел

Вы могли заметить, после ввода жанр фильма и щелкнул **жанр поиска**, можно было увидеть список для этого жанра. Тем не менее, поле поиска текст был пуст &mdash; другими словами, он не вспомнил был введен.

Важно понять, почему это происходит. При отправке страницы, браузер отправляет запрос на веб-сервер. Когда ASP.NET получает запрос, создается совершенно новый экземпляр страницы, выполняет код в его и снова отрисовывает страницы в браузер. По сути однако страница не знает, просто вы работали с предыдущей версией самой себя. Все известно, что он получен запрос оказывали некоторые данные формы в ней.

При каждом запросе страницы &mdash; в первый раз или отправив его &mdash; вы получаете новую страницу. Веб-сервер имеет недостаточно памяти последнего запроса. Не делает ASP.NET, а не браузера. Только подключение между этими экземплярами отдельные страницы — это все данные, передаваемые между ними. При отправке страницы, например, новый экземпляр страницы можно получить данные формы, которая была послана на экземпляре более ранней. (Другой способ передачи данных между страницами — использовать файлы cookie.)

Формальный способ описания этой ситуации является сказать, что веб-страницами гораздо *без отслеживания состояния*. Веб-серверов и самих страниц и элементов на странице не поддерживают все сведения о предыдущем состоянии страницы. Веб-узла был разработан таким образом, поскольку поддержание состояния для отдельных запросов будет быстро исчерпать ресурсы из веб-серверов, которые часто обработка тысяч, возможно даже сотни тысяч запросов в секунду.

Так вот почему текстовое поле было пустым. После отправки страницы ASP.NET создается новый экземпляр страницы и запустил кода и разметки. Произошла nothing, код, который сказал ASP.NET, чтобы поместить значение в текстовое поле. Поэтому ASP.NET ничего не произошло, и текстовое поле было подготавливается к просмотру без значения в нем.

Есть действительно простой способ обойти эту проблему. Жанр, введенный в текстовое поле *—* доступны в коде &mdash; в `Request.QueryString["searchGenre"]`.

Измените разметку для текстового поля, чтобы `value` атрибут получает свое значение из `searchTerm`, как показано в примере:

[!code-html[Main](form-basics/samples/sample9.html?highlight=1)]

На этой странице вы могли также задать `value` атрибут `searchTerm` переменной, так как эта переменная содержит также жанр вы ввели. Однако применение `Request` объект для задания `value` атрибута, как показано здесь является стандартным способом для выполнения этой задачи. (При условии, что требуется даже этого &mdash; в некоторых ситуациях может потребоваться отображать страницу *без* значения в полях. Все зависит от происходящего с вашим приложением.)

> [!NOTE]
> «Неизвестен» значение текстового поля, который используется для паролей. Было бы брешь в системе безопасности для заполнения поля пароля с помощью кода.


Снова запустить страницу, введите жанр фильма и нажмите кнопку **жанр поиска**. Это время не только отобразятся результаты поиска, но текстовое поле запоминает, что последний введенный:

![Страница, показывающий, что текстовое поле «запоминаются» предыдущей записи](form-basics/_static/image5.png)

## <a name="searching-for-any-word-in-the-title"></a>Поиск любых слов в заголовке

Теперь можно искать любые жанра, но можно также найти заголовок. Это затрудняет получают название абсолютно правильно при поиске, поэтому вместо этого можно искать слово, которое появляется в любом месте внутри заголовка. Чтобы сделать это в SQL, используйте `LIKE` операторы и синтаксис следующим образом:

`SELECT * FROM Movies WHERE Title LIKE '%adventure%'`

Эта команда возвращает все фильмы, названия которых содержат «adventure». При использовании `LIKE` оператор, включают подстановочный знак `%` как часть условия поиска. Поиск `LIKE 'adventure%'` означает «начиная с 'adventure'». (С технической точки зрения означает «Строка 'adventure', следует ничего.») Аналогичным образом, условие поиска `LIKE '%adventure'` означает «все, за которым следует строка 'adventure'», что и сказать «заканчивая 'adventure'».

Условие поиска `LIKE '%adventure%'` таким образом означает «с 'adventure' в любом месте заголовок.» (С технической точки зрения «все, что в заголовке, следуют 'adventure', следует ничего.»)

Внутри `<form>` элемента, добавьте следующую разметку прямо под закрывающей `</div>` тег для поиска жанра (непосредственно перед закрывающим `</form>` элемента):

[!code-html[Main](form-basics/samples/sample10.html)]

Код для обработки этого поиска аналогичен коду для поиска жанра, за исключением того, что у вас есть сборка `LIKE` поиска. Внутри блока кода в верхней части страницы, добавьте это `if` блокировать сразу после `if` блок для поиска Жанр:

[!code-csharp[Main](form-basics/samples/sample11.cs)]

Этот код использует ту же логику, вы уже видели, за исключением того, что при поиске используются `LIKE` оператор и помещает код "`%`" до и после поисковому запросу.

Обратите внимание на то, как оно было просто добавить другой поиска на страницу. Все, что нужно было сделать был:

- Создание `if` блок, проверяется ли поле соответствующие поиска имело значение.
- Задайте `selectCommand` переменных для новой инструкции SQL.
- Задайте `searchTerm` переменной на значение для передачи запросу.

Вот законченный блок кода, содержащий новый логику для поиска title:

[!code-cshtml[Main](form-basics/samples/sample12.cshtml)]

Вот Сводка того, что делает этот код:

- Переменные `searchTerm` и `selectCommand` инициализируются вверху. Вы собираетесь задать эти переменные для соответствующих поисковому запросу (если таковые имеются) и соответствующей командой SQL в соответствии действия пользователя на странице. Поиск по умолчанию — это простой пример получения всех фильмов из базы данных.
- В тестах для `searchGenre` и `searchTitle`, код задает `searchTerm` на нужное значение для поиска. Эти блоки кода также задать `selectCommand` в соответствующую команду SQL для поиска.
- `db.Query` Метод вызывается только один раз, с помощью какой угодно командой SQL находится в `selectedCommand` и значение `searchTerm`. Если условие поиска не задано (не жанр и отсутствие слов title), значение `searchTerm` представляет собой пустую строку. Тем не менее, не имеет значения, так как в этом случае запрос не требует параметра.

## <a name="testing-the-title-search-feature"></a>Тестирование функции поиска Title

Теперь можно протестировать страницу завершения поиска. Запустите *Movies.cshtml*.

Введите жанр фильма и нажмите кнопку **жанр поиска**. В сетке отображаются фильмы из этого жанра, как и до.

Введите слово заголовка и нажмите кнопку **заголовок поиска**. В сетке отображаются фильмы, содержащие это слово в заголовок.

![После поиска «» в заголовке страницы фильмов](form-basics/_static/image6.png)

Не указывайте оба поля и щелкните одну из кнопок. В сетке отображаются все фильмы.

## <a name="combining-the-queries"></a>Объединение запросов

Можно заметить, что поисковые запросы, которые можно выполнять являются взаимоисключающими. Не удается найти название и жанр в то же время, даже если оба поля поиска значений в них. Например нельзя выполнять поиск для всех фильмов действие, заголовок которого содержит «Adventure». (Как страницы используется в коде, при вводе значения для жанр и title, поиск заголовка получает приоритет). Чтобы создать поиска, которая объединяет условия, пришлось бы создать запрос SQL, который имеет следующий синтаксис:

`SELECT * FROM Movies WHERE Genre = @0 AND Title LIKE @1`

И необходимо выполнить запрос с помощью инструкции, как показано ниже (примерно говоря):

`var selectedData = db.Query(selectCommand, searchGenre, searchTitle);`

Создание логики для многих вариантов условия поиска можно получить немного сложной, как вы видите. Таким образом мы остановим здесь.

## <a name="coming-up-next"></a>В ближайшее время

В следующем руководстве вы создадите страницы, использующей формы пользователи смогут добавлять видео в базу данных.

## <a name="complete-listing-for-movie-page-updated-with-search"></a>Полный пример для страницы фильма (обновление с помощью поиска)

[!code-cshtml[Main](form-basics/samples/sample13.cshtml)]

## <a name="additional-resources"></a>Дополнительные ресурсы

- [Введение в программирование веб-ASP.NET, с помощью синтаксиса Razor](https://go.microsoft.com/fwlink/?LinkID=202890)
- [Предложение WHERE SQL](http://www.w3schools.com/sql/sql_where.asp) на сайте W3Schools
- [Определения методов](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) статьи на сайте W3C

> [!div class="step-by-step"]
> [Назад](displaying-data.md)
> [Вперед](entering-data.md)
