---
uid: web-api/overview/advanced/dependency-injection
title: Внедрение зависимостей в веб-API ASP.NET 2 — ASP.NET 4. x
author: MikeWasson
description: В этом руководстве показано, как внедрить зависимости в контроллер веб-API ASP.NET для ASP.NET 4. x.
ms.author: riande
ms.date: 01/20/2014
ms.custom: seoapril2019
ms.assetid: e3d3e7ba-87f0-4032-bdd3-31f3c1aa9d9c
msc.legacyurl: /web-api/overview/advanced/dependency-injection
msc.type: authoredcontent
ms.openlocfilehash: f9c212af92168ac02644625b9aa8ec1bef329cab
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78504948"
---
# <a name="dependency-injection-in-aspnet-web-api-2"></a>Внедрение зависимостей в веб-API ASP.NET 2

по [Майк Уоссон](https://github.com/MikeWasson)

[Скачать завершенный проект](https://code.msdn.microsoft.com/ASP-NET-Web-API-Tutorial-468ee148)

> В этом руководстве показано, как внедрить зависимости в контроллер веб-API ASP.NET.
> 
> ## <a name="software-versions-used-in-the-tutorial"></a>Версии программного обеспечения, используемые в этом руководстве
> 
> 
> - Веб-API 2
> - [Блок приложения Unity](https://www.nuget.org/packages/Unity/)
> - Entity Framework 6 (версия 5 также работает)

## <a name="what-is-dependency-injection"></a>Что такое внедрение зависимостей?

*Зависимость* — это любой объект, который требуется другому объекту. Например, вы обычно определяете [репозиторий](http://martinfowler.com/eaaCatalog/repository.html) , который обрабатывает доступ к данным. Давайте продемонстрируем пример. Сначала мы определим модель предметной области:

[!code-csharp[Main](dependency-injection/samples/sample1.cs)]

Ниже приведен простой класс репозитория, в котором хранятся элементы в базе данных с помощью Entity Framework.

[!code-csharp[Main](dependency-injection/samples/sample2.cs)]

Теперь определим контроллер веб-API, который поддерживает запросы GET для сущностей `Product`. (Я не использую POST и другие методы для простоты.) Вот первая предпринятая ошибка:

[!code-csharp[Main](dependency-injection/samples/sample3.cs)]

Обратите внимание, что класс Controller зависит от `ProductRepository`, и мы разрешив контроллеру создавать экземпляр `ProductRepository`. Тем не менее, неплохой смысл жестко запрограммировать зависимость таким образом, по нескольким причинам.

- Если требуется заменить `ProductRepository` другой реализацией, необходимо также изменить класс контроллера.
- Если `ProductRepository` имеет зависимости, их необходимо настроить внутри контроллера. Для большого проекта с несколькими контроллерами код конфигурации преобразуется в несколько проектов.
- Трудно тестировать модульный тест, так как контроллер жестко закодирован для запроса базы данных. Для модульного теста следует использовать репозиторий или заглушку, что невозможно с текущим дизайном.

Эти проблемы можно решить, *внедряя* репозиторий в контроллер. Сначала выполните рефакторинг класса `ProductRepository` в интерфейсе:

[!code-csharp[Main](dependency-injection/samples/sample4.cs)]

Затем укажите `IProductRepository` в качестве параметра конструктора:

[!code-csharp[Main](dependency-injection/samples/sample5.cs)]

В этом примере используется [внедрение конструктора](http://www.martinfowler.com/articles/injection.html#FormsOfDependencyInjection). Можно также использовать *внедрение метода задания*, где зависимость задается через метод задания или свойство.

Но теперь возникла проблема, так как приложение не создает контроллер напрямую. Веб-API создает контроллер при маршрутизации запроса, и веб-API не знает о `IProductRepository`. Именно здесь поступает сопоставитель зависимостей веб-API.

## <a name="the-web-api-dependency-resolver"></a>Сопоставитель зависимостей веб-API

Веб-API определяет интерфейс **IDependencyResolver** для разрешения зависимостей. Ниже приведено определение интерфейса.

[!code-csharp[Main](dependency-injection/samples/sample6.cs)]

Интерфейс **идепенденцископе** имеет два метода:

- **Служба "услуга** " создает один экземпляр типа.
- **Службы** создают коллекцию объектов указанного типа.

Метод **IDependencyResolver** наследует **идепенденцископе** и добавляет метод **бегинскопе** . Далее в этом руководстве я расскажу об областях.

Когда веб-API создает экземпляр контроллера, он сначала вызывает **IDependencyResolver.-Service**, передавая ему тип контроллера. С помощью этого обработчика расширяемости можно создать контроллер, разрешающий все зависимости. Если функция " **услуга** " возвращает значение null, веб-API ищет конструктор без параметров в классе Controller.

## <a name="dependency-resolution-with-the-unity-container"></a>Разрешение зависимостей с помощью контейнера Unity

Несмотря на то, что можно написать полную реализацию **IDependencyResolver** с нуля, интерфейс на самом деле спроектирован так, что он выступает в роли моста между веб-API и существующими контейнерами IOC.

Контейнер IoC — это программный компонент, отвечающий за управление зависимостями. Вы регистрируете типы в контейнере, а затем используете контейнер для создания объектов. Контейнер автоматически определяет отношения зависимости. Многие контейнеры IoC также позволяют контролировать время существования и области действия объекта.

> [!NOTE]
> "IoC" означает "инверсия управления", которая представляет собой общий шаблон, в котором инфраструктура вызывает код приложения. Контейнер IoC конструирует ваши объекты, что «инвертирует» обычный поток управления.

В рамках этого руководства мы будем использовать [Unity](https://msdn.microsoft.com/library/ff647202.aspx) из шаблонов Майкрософт &amp; методик. (Другие популярные библиотеки включают [Castle Windsor](http://www.castleproject.org/), [Spring.NET](http://www.springframework.net/), [Autofac](https://code.google.com/p/autofac/), [нинжект](http://www.ninject.org/)и [StructureMap](http://structuremap.github.io/documentation/).) Для установки Unity можно использовать диспетчер пакетов NuGet. В меню **Сервис** в Visual Studio выберите **Диспетчер пакетов NuGet**, а затем выберите **консоль диспетчера пакетов**. В окне консоли диспетчера пакетов введите следующую команду:

[!code-console[Main](dependency-injection/samples/sample7.cmd)]

Ниже приведена реализация **IDependencyResolver** , которая заключает в оболочку контейнер Unity.

[!code-csharp[Main](dependency-injection/samples/sample8.cs)]

> [!NOTE]
> Если методу метода **WebService** не удается разрешить тип, он должен вернуть **значение NULL**. Если **методу** GetObject не удается разрешить тип, он должен возвращать пустой объект коллекции. Не вызывайте исключения для неизвестных типов.

## <a name="configuring-the-dependency-resolver"></a>Настройка сопоставителя зависимостей

Установите сопоставитель зависимостей в свойстве **депенденциресолвер** глобального объекта **HttpConfiguration** .

Следующий код регистрирует интерфейс `IProductRepository` с помощью Unity, а затем создает `UnityResolver`.

[!code-csharp[Main](dependency-injection/samples/sample9.cs)]

## <a name="dependency-scope-and-controller-lifetime"></a>Область зависимости и время существования контроллера

Контроллеры создаются для каждого запроса. Для управления жизненным циклом объекта **IDependencyResolver** использует концепцию *области*.

Сопоставитель зависимостей, присоединенный к объекту **HttpConfiguration** , имеет глобальную область видимости. Когда веб-API создает контроллер, он вызывает **бегинскопе**. Этот метод возвращает объект **идепенденцископе** , представляющий дочернюю область.

Затем веб-API вызывает метод **WebService** для дочерней области, чтобы создать контроллер. По завершении запроса веб-API вызывает **Dispose** для дочерней области. Используйте метод **Dispose** для удаления зависимостей контроллера.

Реализация **бегинскопе** зависит от контейнера IoC. Для Unity область соответствует дочернему контейнеру:

[!code-csharp[Main](dependency-injection/samples/sample10.cs)]

Большинство контейнеров IoC имеют аналогичные эквиваленты.
