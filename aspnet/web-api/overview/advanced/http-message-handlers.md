---
uid: web-api/overview/advanced/http-message-handlers
title: Обработчики сообщений HTTP в веб-API ASP.NET | Документация Майкрософт
author: MikeWasson
description: ''
ms.author: riande
ms.date: 02/13/2012
ms.assetid: 9002018b-3aa3-4358-bb1c-fbb5bc751d01
msc.legacyurl: /web-api/overview/advanced/http-message-handlers
msc.type: authoredcontent
ms.openlocfilehash: 0b0d7b4c543dc4e597c6c472083898f3a8095a83
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57043211"
---
<a name="http-message-handlers-in-aspnet-web-api"></a>Обработчики сообщений HTTP в веб-API ASP.NET
====================
по [Майк Уоссон](https://github.com/MikeWasson)

Объект *обработчик сообщений* — это класс, который получает HTTP-запрос и возвращает ответ HTTP. Обработчики сообщений являются производными от абстрактного **HttpMessageHandler** класса.

Как правило ряд обработчиков сообщений соединяются друг с другом. Первый обработчик получает запрос HTTP, обрабатывает и предоставляет запрос к следующий обработчик. Рано или поздно ответа создается и возвращается в цепочке. Такая модель называется *делегирование* обработчика.

![](http-message-handlers/_static/image1.png)

## <a name="server-side-message-handlers"></a>Обработчики сообщений на стороне сервера

На стороне сервера конвейер веб-API использует некоторые обработчики встроенных сообщений:

- **Сервер HTTP** получает запрос от узла.
- **HttpRoutingDispatcher** отправляет запрос на основе маршрута.
- **HttpControllerDispatcher** отправляет запрос контроллеру веб-API.

Можно добавить пользовательские обработчики в конвейере. Обработчики сообщений хорошо подходят для сквозных функций, которые работают на уровне HTTP сообщения (а не действий контроллера). Например обработчик сообщений может:

- Чтение и изменение заголовков запроса.
- Добавьте заголовок ответа для ответов.
- Проверьте запросы, прежде чем они достигнут контроллера.

На этой диаграмме показаны два пользовательских обработчиков, которые вставлены в конвейер:

![](http-message-handlers/_static/image2.png)

> [!NOTE]
> На стороне клиента HttpClient также использует обработчики сообщений. Дополнительные сведения см. в разделе [обработчики сообщений HttpClient](httpclient-message-handlers.md).


## <a name="custom-message-handlers"></a>Обработчики пользовательских сообщений

Чтобы написать обработчик пользовательского сообщения, являются производными от **System.Net.Http.DelegatingHandler** и переопределить **SendAsync** метод. Этот метод имеет следующую сигнатуру:

[!code-csharp[Main](http-message-handlers/samples/sample1.cs)]

Этот метод принимает **HttpRequestMessage** как входных данных и асинхронно возвращает **HttpResponseMessage**. Типичной реализации выполняет следующие функции:

1. Процесс сообщения запроса.
2. Вызовите `base.SendAsync` для отправки запроса на внутренний обработчик.
3. Внутренний обработчик возвращает ответное сообщение. (Этот шаг выполняется асинхронно).
4. Обработать ответ и вернуть его вызывающей стороне.

Вот тривиальный пример:

[!code-csharp[Main](http-message-handlers/samples/sample2.cs)]

> [!NOTE]
> Вызов `base.SendAsync` является асинхронным. Если обработчик не выполняет никакой работы после этого вызова, используйте **await** ключевое слово, как показано.


Делегирование обработчик можно также пропустить внутренний обработчик и напрямую создать ответ:

[!code-csharp[Main](http-message-handlers/samples/sample3.cs)]

Если делегирование обработчик создает ответ без вызова `base.SendAsync`, запрос пропускает остальной части конвейера. Это может быть полезно для обработчика, который проверяет запрос (Создание сообщение об ошибке).

![](http-message-handlers/_static/image3.png)

## <a name="adding-a-handler-to-the-pipeline"></a>Добавление обработчика в конвейер

Чтобы добавить обработчик сообщений на стороне сервера, добавьте обработчик **HttpConfiguration.MessageHandlers** коллекции. Если вы использовали шаблон «ASP.NET MVC 4 веб-приложение» для создания проекта, это можно сделать это внутри **WebApiConfig** класса:

[!code-csharp[Main](http-message-handlers/samples/sample4.cs)]

Обработчики сообщений вызываются в том же порядке, в котором они расположены в **MessageHandlers** коллекции. Так как они являются вложенными, ответное сообщение перемещается в обратном направлении. Последним обработчиком является первым ответного сообщения.

Обратите внимание на то, что вам не нужно задавать внутренних обработчиков; Платформа веб-API автоматически подключается обработчиков сообщений.

Если вы являетесь [размещение на собственном сервере](../older-versions/self-host-a-web-api.md), создайте экземпляр **HttpSelfHostConfiguration** класса и добавьте обработчики для **MessageHandlers** коллекции.

[!code-csharp[Main](http-message-handlers/samples/sample5.cs)]

Теперь давайте рассмотрим несколько примеров обработчики пользовательских сообщений.

## <a name="example-x-http-method-override"></a>Пример X-HTTP-Method-Override

X-HTTP-Method-Override является стандартным заголовком HTTP. Она предназначена для клиентов, которые не удается отправить определенные типы HTTP-запросов, таких как PUT или DELETE. Вместо этого клиент отправляет запрос POST и задает заголовок X-HTTP-Method-Override для нужного метода. Пример:

[!code-console[Main](http-message-handlers/samples/sample6.cmd)]

Ниже приведен обработчик сообщений, который добавляет поддержку для X-HTTP-Method-Override.

[!code-csharp[Main](http-message-handlers/samples/sample7.cs)]

В **SendAsync** метод, обработчик проверяет, является ли сообщение запроса запрос POST и содержит ли он заголовок X-HTTP-Method-Override. Если Да, он проверяет значение заголовка и затем изменяет метод запроса. Наконец, обработчик вызывает `base.SendAsync` для передачи сообщения следующего обработчика.

Когда запрос достигает **HttpControllerDispatcher** класс, **HttpControllerDispatcher** направит запрос на основе метода обновленный запрос.

## <a name="example-adding-a-custom-response-header"></a>Пример Добавление настраиваемого заголовка ответа

Вот обработчик сообщений, который добавляет пользовательский заголовок к каждому сообщению ответа:

[!code-csharp[Main](http-message-handlers/samples/sample8.cs)]

Во-первых, обработчик вызывает `base.SendAsync` для передачи запроса внутренний обработчик сообщений. Внутренний обработчик возвращает ответное сообщение, но не асинхронно с помощью **задачи&lt;T&gt;**  объекта. Ответное сообщение недоступно до `base.SendAsync` завершения асинхронно.

В этом примере используется **await** ключевое слово, чтобы выполнять работу асинхронно после того, как `SendAsync` завершения. Если вы ориентируетесь на .NET Framework 4.0, используйте **задачи**&lt;T&gt;**. ContinueWith** метод:

[!code-csharp[Main](http-message-handlers/samples/sample9.cs)]

## <a name="example-checking-for-an-api-key"></a>Пример Проверка наличия ключа API

Некоторые веб-службы требуется клиентам содержать ключ API в свой запрос. В следующем примере показано, как обработчик сообщений можно проверить запросы на допустимый ключ API:

[!code-csharp[Main](http-message-handlers/samples/sample10.cs)]

Этот обработчик выполняет поиск ключа API в строке запроса URI. (В этом примере предполагается, что ключ является статическая строка. Фактической реализации используются более сложные проверки.) Если строка запроса содержит ключ, обработчик передает запрос внутреннему обработчику.

Если запрос не имеет допустимый ключ, обработчик создает ответное сообщение с состояния 403, запрещено. В этом случае обработчик не вызывает `base.SendAsync`, поэтому внутренний обработчик никогда не получает запрос, а также контроллер. Таким образом контроллер может рассчитывать на все входящие запросы действительный ключ API.

> [!NOTE]
> Если ключ API применяется только к определенным действиям контроллера, рассмотрите возможность использования фильтра действий вместо обработчика сообщений. Фильтры действий выполняются после выполняется маршрутизация URI.


## <a name="per-route-message-handlers"></a>Обработчики сообщений-Route

Обработчики в **HttpConfiguration.MessageHandlers** коллекции применяются глобально.

Кроме того можно добавить обработчик сообщений для определенного маршрута при определении маршрута:

[!code-csharp[Main](http-message-handlers/samples/sample11.cs?highlight=16)]

В этом примере, если URI запроса совпадает с «Route2», запрос отправляется `MessageHandler2`. В примере ниже показан конвейер для этих маршрутов:

![](http-message-handlers/_static/image4.png)

Обратите внимание, что `MessageHandler2` заменяет значение по умолчанию **HttpControllerDispatcher**. В этом примере `MessageHandler2` создает ответ, и запросы, которые соответствуют «Route2» не переходить к контроллеру. Это позволяет заменить весь механизм контроллера веб-API с пользовательской конечной точке.

Кроме того, можно делегировать обработчик сообщений-route **HttpControllerDispatcher**, который затем отправляет к контроллеру.

![](http-message-handlers/_static/image5.png)

Ниже показано, как настроить этот маршрут:

[!code-csharp[Main](http-message-handlers/samples/sample12.cs)]
