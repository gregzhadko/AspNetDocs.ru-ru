---
uid: web-api/overview/advanced/http-message-handlers
title: Обработчики сообщений HTTP в веб-API ASP.NET-ASP.NET 4. x
author: MikeWasson
description: Обзор обработчиков сообщений HTTP в веб-API ASP.NET для ASP.NET 4. x
ms.author: riande
ms.date: 02/13/2012
ms.custom: seoapril2019
ms.assetid: 9002018b-3aa3-4358-bb1c-fbb5bc751d01
msc.legacyurl: /web-api/overview/advanced/http-message-handlers
msc.type: authoredcontent
ms.openlocfilehash: a8e6f1da8df4802e1acf7779a2fc75bfe8ab876f
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78504930"
---
# <a name="http-message-handlers-in-aspnet-web-api"></a>Обработчики сообщений HTTP в веб-API ASP.NET

по [Майк Уоссон](https://github.com/MikeWasson)

*Обработчик сообщений* — это класс, который получает HTTP-запрос и ВОЗВРАЩАЕТ ответ HTTP. Обработчики сообщений являются производными от абстрактного класса **HttpMessageHandler** .

Как правило, ряд обработчиков сообщений объединяется в цепочку. Первый обработчик получает HTTP-запрос, выполняет некоторую обработку и передает запрос следующему обработчику. В какой-то момент ответ создается и помещается в резервную копию цепочки. Этот шаблон называется *делегированным* обработчиком.

![](http-message-handlers/_static/image1.png)

## <a name="server-side-message-handlers"></a>Обработчики сообщений на стороне сервера

На стороне сервера конвейер веб-API использует некоторые встроенные обработчики сообщений:

- **HttpServer** получает запрос от узла.
- **Хттпраутингдиспатчер** отправляет запрос на основе маршрута.
- **Хттпконтроллердиспатчер** отправляет запрос в контроллер веб-API.

К конвейеру можно добавить пользовательские обработчики. Обработчики сообщений хорошо подходят для проблем с пересечением, которые работают на уровне HTTP-сообщений (а не действий контроллера). Например, обработчик сообщений может:

- Чтение или изменение заголовков запросов.
- Добавление заголовка ответа в ответы.
- Проверка запросов перед достижением контроллера.

На этой схеме показаны два пользовательских обработчика, вставленных в конвейер:

![](http-message-handlers/_static/image2.png)

> [!NOTE]
> На стороне клиента HttpClient также использует обработчики сообщений. Дополнительные сведения см. в разделе [обработчики сообщений HttpClient](httpclient-message-handlers.md).

## <a name="custom-message-handlers"></a>Пользовательские обработчики сообщений

Для написания пользовательского обработчика сообщений следует использовать класс **System .NET. http. DelegatingHandler** и переопределить метод **SendAsync** . Этот метод имеет следующую сигнатуру:

[!code-csharp[Main](http-message-handlers/samples/sample1.cs)]

Метод принимает **HttpRequestMessage** в качестве входных данных и асинхронно возвращает **HttpResponseMessage**. Типичная реализация выполняет следующие действия:

1. Обработать сообщение запроса.
2. Вызовите `base.SendAsync`, чтобы отправить запрос внутреннему обработчику.
3. Внутренний обработчик возвращает ответное сообщение. (Этот шаг является асинхронным.)
4. Обработайте ответ и верните его вызывающему объекту.

Ниже приведен простой пример.

[!code-csharp[Main](http-message-handlers/samples/sample2.cs)]

> [!NOTE]
> Вызов к `base.SendAsync` выполняется асинхронно. Если после этого вызова обработчик выполняет любую работу, используйте ключевое слово **await** , как показано ниже.

Делегирующий обработчик также может пропустить внутренний обработчик и создать ответ напрямую:

[!code-csharp[Main](http-message-handlers/samples/sample3.cs)]

Если делегирующий обработчик создает ответ без вызова `base.SendAsync`, запрос пропускает оставшуюся часть конвейера. Это может быть полезно для обработчика, который проверяет запрос (создает ответ об ошибке).

![](http-message-handlers/_static/image3.png)

## <a name="adding-a-handler-to-the-pipeline"></a>Добавление обработчика в конвейер

Чтобы добавить обработчик сообщений на стороне сервера, добавьте обработчик в коллекцию **HttpConfiguration. мессажехандлерс** . Если для создания проекта использовался шаблон "веб-приложение ASP.NET MVC 4", это можно сделать в классе **WebApiConfig** :

[!code-csharp[Main](http-message-handlers/samples/sample4.cs)]

Обработчики сообщений вызываются в том же порядке, в котором они отображаются в коллекции **мессажехандлерс** . Так как они вложены, ответное сообщение перемещается в другое направление. То есть последний обработчик является первым, чтобы получить ответное сообщение.

Обратите внимание, что не нужно задавать внутренние обработчики; платформа веб-API автоматически подключает обработчики сообщений.

При [размещении на собственном узле](../older-versions/self-host-a-web-api.md)создайте экземпляр класса **хттпселфхостконфигуратион** и добавьте обработчики в коллекцию **мессажехандлерс** .

[!code-csharp[Main](http-message-handlers/samples/sample5.cs)]

Теперь рассмотрим некоторые примеры пользовательских обработчиков сообщений.

## <a name="example-x-http-method-override"></a>Пример: X-HTTP-Method-override

Переопределение X-HTTP-Method-override не является стандартным заголовком HTTP. Он предназначен для клиентов, которые не могут отправлять определенные типы HTTP-запросов, такие как "поместить" или "Удалить". Вместо этого клиент отправляет запрос POST и задает для заголовка X-HTTP-Method-override нужный метод. Пример:

[!code-console[Main](http-message-handlers/samples/sample6.cmd)]

Ниже приведен обработчик сообщений, который добавляет поддержку для переопределения X-HTTP-Method:

[!code-csharp[Main](http-message-handlers/samples/sample7.cs)]

В методе **SendAsync** обработчик проверяет, является ли сообщение запроса запросом POST, и содержит ли он заголовок X-HTTP-Method-override. Если да, то он проверяет значение заголовка, а затем изменяет метод запроса. Наконец, обработчик вызывает `base.SendAsync`, чтобы передать сообщение следующему обработчику.

Когда запрос достигает класса **хттпконтроллердиспатчер** , **хттпконтроллердиспатчер** направит запрос на основе обновленного метода запроса.

## <a name="example-adding-a-custom-response-header"></a>Пример. Добавление пользовательского заголовка ответа

Ниже приведен обработчик сообщений, который добавляет пользовательский заголовок к каждому ответному сообщению:

[!code-csharp[Main](http-message-handlers/samples/sample8.cs)]

Сначала обработчик вызывает `base.SendAsync`, чтобы передать запрос обработчику внутреннего сообщения. Внутренний обработчик возвращает ответное сообщение, но асинхронно использует **задачу&lt;t&gt;** объект. Ответное сообщение недоступно, пока `base.SendAsync` не завершится асинхронно.

В этом примере ключевое слово **await** используется для выполнения работы в асинхронном режиме после завершения `SendAsync`. Если вы нацеливание на .NET Framework 4,0, используйте&gt;**Task**&lt;t **. Метод ContinueWith** :

[!code-csharp[Main](http-message-handlers/samples/sample9.cs)]

## <a name="example-checking-for-an-api-key"></a>Пример. Проверка ключа API

Некоторые веб-службы требует, чтобы клиенты включали ключ API в свой запрос. В следующем примере показано, как обработчик сообщений может проверить запросы на наличие допустимого ключа API:

[!code-csharp[Main](http-message-handlers/samples/sample10.cs)]

Этот обработчик выполняет поиск ключа API в строке запроса URI. (В этом примере предполагается, что ключ является статической строкой. Реальная реализация, вероятно, будет использовать более сложную проверку.) Если строка запроса содержит ключ, обработчик передает запрос внутреннему обработчику.

Если у запроса нет допустимого ключа, обработчик создает ответное сообщение с состоянием 403, запрещено. В этом случае обработчик не вызывает `base.SendAsync`, поэтому внутренний обработчик никогда не получает запрос и не выполняет контроллер. Таким образом, контроллер может предположить, что все входящие запросы имеют действительный ключ API.

> [!NOTE]
> Если ключ API применяется только к определенным действиям контроллера, рассмотрите возможность использования фильтра действий вместо обработчика сообщений. Фильтры действий выполняются после выполнения маршрутизации URI.

## <a name="per-route-message-handlers"></a>Обработчики сообщений для каждого маршрута

Обработчики в коллекции **HttpConfiguration. мессажехандлерс** применяются глобально.

Кроме того, можно добавить обработчик сообщений к конкретному маршруту при определении маршрута:

[!code-csharp[Main](http-message-handlers/samples/sample11.cs?highlight=16)]

В этом примере, если URI запроса соответствует "Route2", запрос отправляется в `MessageHandler2`. На следующей схеме показан конвейер для этих двух маршрутов.

![](http-message-handlers/_static/image4.png)

Обратите внимание, что `MessageHandler2` заменяет **хттпконтроллердиспатчер**по умолчанию. В этом примере `MessageHandler2` создает ответ, и запросы, соответствующие "Route2", никогда не переходят к контроллеру. Это позволяет заменить весь механизм контроллера веб-API собственной пользовательской конечной точкой.

Кроме того, обработчик сообщений для каждого маршрута может делегироваться **хттпконтроллердиспатчер**, который затем отправляется контроллеру.

![](http-message-handlers/_static/image5.png)

В следующем примере кода показано, как настроить этот маршрут:

[!code-csharp[Main](http-message-handlers/samples/sample12.cs)]
