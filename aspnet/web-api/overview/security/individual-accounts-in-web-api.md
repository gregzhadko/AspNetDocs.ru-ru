---
uid: web-api/overview/security/individual-accounts-in-web-api
title: Защита веб-API с помощью отдельных учетных записей и локального имени входа в ASP.NET Web API 2.2 | Документация Майкрософт
author: MikeWasson
description: В этом разделе показано, как защитить веб-API с использованием OAuth2 для проверки подлинности в базе данных членства. Версии программного обеспечения, используемые в руководстве Visual Studio 201...
ms.author: riande
ms.date: 10/15/2014
ms.assetid: 92c84846-f0ea-4b5e-94b6-5004874eb060
msc.legacyurl: /web-api/overview/security/individual-accounts-in-web-api
msc.type: authoredcontent
ms.openlocfilehash: 29c3670ad7ab93acb0be878e5bd961d0ea446eee
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59396236"
---
# <a name="secure-a-web-api-with-individual-accounts-and-local-login-in-aspnet-web-api-22"></a>Защита веб-API с помощью отдельных учетных записей и локального имени входа в ASP.NET Web API 2.2

по [Майк Уоссон](https://github.com/MikeWasson)

[Скачайте пример приложения](https://github.com/MikeWasson/LocalAccountsApp)

> В этом разделе показано, как защитить веб-API с использованием OAuth2 для проверки подлинности в базе данных членства.
> 
> ## <a name="software-versions-used-in-the-tutorial"></a>Версии программного обеспечения, используемые в этом руководстве
> 
> 
> - [Visual Studio 2013 с обновлением 3](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - [Веб-API 2.2](../releases/whats-new-in-aspnet-web-api-22.md)
> - [ASP.NET Identity 2.1](../../../identity/index.md)


В Visual Studio 2013 шаблон проекта веб-API предоставляет три варианта проверки подлинности:

- **Индивидуальные учетные записи.** Приложение использует базу данных членства.
- **Учетные записи организации.** Вход пользователей с помощью их Azure Active Directory, Office 365 или учетные данные Active Directory на предприятии.
- **Проверка подлинности Windows.** Этот параметр предназначен для приложений интрасети и использует модуль IIS проверку подлинности Windows.

Дополнительные сведения об этих параметрах см. в разделе [Создание веб-проектов ASP.NET в Visual Studio 2013](../../../visual-studio/overview/2013/creating-web-projects-in-visual-studio.md#auth).

Индивидуальные учетные записи предоставляют два способа для пользователя выполнить вход:

- **Локальное имя входа**. Пользователь проходит регистрацию на сайте, указав имя пользователя и пароль. Приложение хранит хэш пароля в базе данных членства. При входе пользователя в систему ASP.NET Identity проверка пароля.
- **Учетные записи социальных сетей**. Пользователь выполняет вход с помощью внешней службы, например Microsoft, Google или Facebook. Приложение по-прежнему создает запись для пользователя в базе данных членства, но не хранит учетные данные. Пользователь проходит проверку подлинности при входе в внешней службы.

В этой статье рассматриваются сценарии локального имени входа. Для входа на локальных и социальных сетей веб-API использует OAuth2 для проверки подлинности запросов. Тем не менее потоки учетные данные отличаются для локальных и социальных сетей имени входа.

В этой статье я продемонстрирую простое приложение, которое позволяет пользователю войти в систему и отправить проверенные на подлинность вызовы AJAX в веб-API. Можно загрузить образец кода [здесь](https://github.com/MikeWasson/LocalAccountsApp). Файл readme описывается создание примера с нуля в Visual Studio.

[![](individual-accounts-in-web-api/_static/image2.png)](individual-accounts-in-web-api/_static/image1.png)

Пример приложения использует Knockout.js для привязки данных и jQuery для отправки запросов AJAX. Я уделю вызовы AJAX, поэтому не нужно знать Knockout.js для этой статьи.

Кроме того я опишу:

- Приложение действия на стороне клиента.
- Что происходит на сервере.
- HTTP-трафика в середине.

Во-первых необходимо определить термины OAuth2.

- *Ресурс*. Некоторые часть данных, могут быть защищены.
- *Сервер ресурсов*. Сервер, на котором размещается ресурс.
- *Владелец ресурса*. Сущность, можно предоставить разрешение на доступ к ресурсу. (Обычно пользователя).
- *Клиент*: Приложение, которое хочет получить доступ к ресурсу. В этой статье клиентом является веб-браузер.
- *Маркер доступа*. Маркер, который предоставляет доступ к ресурсу.
- *Токен носителя*. Определенный тип маркера доступа, со свойством, что любой пользователь может использовать маркер. Другими словами клиент не криптографический ключ или других секрет для использования токена носителя. По этой причине токены носителя должны использоваться только по протоколу HTTPS и должен иметь относительно короткие сроки действия.
- *Сервер авторизации*. Сервер, который выдает маркеры доступа.

Приложение может действовать как сервер авторизации и сервером ресурсов. Шаблон проекта веб-API соответствует следующему шаблону.

## <a name="local-login-credential-flow"></a>Поток учетных данных локального имени входа

Для локального имени входа веб-API использует [поток пароль владельца ресурса](http://oauthlib.readthedocs.org/en/latest/oauth2/grants/password.html) определенные в OAuth2.

1. Пользователь вводит имя пользователя и пароль в клиент.
2. Клиент отправляет эти учетные данные серверу авторизации.
3. Сервер авторизации проверяет подлинность учетных данных и возвращает маркер доступа.
4. Чтобы получить доступ к защищенному ресурсу, клиент включает маркер доступа в заголовок авторизации HTTP-запроса.

![](individual-accounts-in-web-api/_static/image3.png)

При выборе **отдельным учетным записям** в шаблоне проекта веб-API, проект включает сервер авторизации, который проверяет учетные данные пользователя и выдает маркеры. В примере ниже показан же поток учетных данных с точки зрения компоненты веб-API.

![](individual-accounts-in-web-api/_static/image4.png)

В этом случае контроллеров веб-API в качестве серверов ресурсов. Фильтр проверки подлинности проверяет маркеры доступа и **[Authorize]** атрибут используется для защиты ресурса. Если контроллер или действие имеет **[Authorize]** атрибута, все запросы в этот контроллер или действие должен пройти проверку подлинности. В противном случае авторизации отказано, и веб-API возвращает ошибку 401 (неавторизованный).

Сервер авторизации и фильтр проверки подлинности, оба вызова [по промежуточного слоя OWIN](../../../aspnet/overview/owin-and-katana/an-overview-of-project-katana.md) компонент, который обрабатывает сведения о OAuth2. Я опишу разработки более подробно далее в этом руководстве.

## <a name="sending-an-unauthorized-request"></a>Отправка неавторизованный запрос

Чтобы начать работу, запустите приложение и нажмите кнопку **вызова API** кнопки. По завершении запроса вы увидите сообщение об ошибке в **результат** поле. Том, что запрос не содержит маркер доступа, поэтому запрос не авторизован.

[![](individual-accounts-in-web-api/_static/image6.png)](individual-accounts-in-web-api/_static/image5.png)

**Вызова API** кнопка отправляет запрос AJAX ~/api/значения, вызывающее действие контроллера веб-API. Ниже представлена часть кода JavaScript, который отправляет запрос AJAX. В примере приложения весь код приложения JavaScript находится в файле Scripts\app.js.

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample1.js)]

До входа пользователя отсутствует токен носителя не и поэтому не заголовок авторизации в запросе. В результате запрос о получении сообщение об ошибке 401.

Ниже приведен HTTP-запроса. (Я использовал [Fiddler](http://www.telerik.com/fiddler) для записи трафика HTTP.)

[!code-console[Main](individual-accounts-in-web-api/samples/sample2.cmd)]

HTTP-ответа:

[!code-console[Main](individual-accounts-in-web-api/samples/sample3.cmd?highlight=1,4)]

Обратите внимание на то, что ответ содержит заголовок Www-Authenticate с запросом, значение носителя. Это указывает, что сервер должен находиться токен носителя.

## <a name="register-a-user"></a>Регистрация пользователя

В **зарегистрировать** раздела приложения, введите адрес электронной почты и пароль учетной записи и нажмите кнопку **зарегистрировать** кнопки.

Не нужно использовать допустимый адрес электронной почты для этого примера, но реальное приложение будет подтвердить адрес. (См. в разделе [создать безопасное веб-приложение ASP.NET MVC 5 со входом, по электронной почте подтверждение и сброс пароля](../../../mvc/overview/security/create-an-aspnet-mvc-5-web-app-with-email-confirmation-and-password-reset.md).) Пароль Используйте нечто вроде «Пароль1!», с буквой в верхнем регистре, буквы нижнего регистра, номер и отличные от алфавитно цифровой символ. Чтобы не усложнять приложение, я оставил out проверки на стороне клиента, поэтому если имеется проблема с формат пароля, вы получите ошибку 400 (неправильный запрос).

[![](individual-accounts-in-web-api/_static/image8.png)](individual-accounts-in-web-api/_static/image7.png)

**Зарегистрировать** кнопка отправляет запрос POST к ~/api/Account/Register /. Тело запроса представляет собой объект JSON, который содержит имя и пароль. Ниже приведен код JavaScript, который отправляет запрос:

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample4.js)]

HTTP-запроса:

[!code-console[Main](individual-accounts-in-web-api/samples/sample5.cmd?highlight=5,10)]

HTTP-ответа:

[!code-console[Main](individual-accounts-in-web-api/samples/sample6.cmd)]

Этот запрос обрабатывается `AccountController` класса. На внутреннем уровне `AccountController` использует для управления базой данных членства ASP.NET Identity.

Если вы запустите приложение локально из Visual Studio, учетные записи пользователей хранятся в LocalDB, в таблице AspNetUsers. Чтобы просмотреть таблицы в Visual Studio, нажмите кнопку **представление** меню, выберите **обозревателя серверов**, затем разверните **подключения к данным**.

![](individual-accounts-in-web-api/_static/image9.png)

## <a name="get-an-access-token"></a>Получение токена доступа

Пока мы еще не все OAuth, но сейчас мы увидим сервер авторизации OAuth в действии, при запросе маркера доступа. В **вход** примера приложения, введите адрес электронной почты и пароль и нажмите кнопку **вход**.

[![](individual-accounts-in-web-api/_static/image11.png)](individual-accounts-in-web-api/_static/image10.png)

**Вход** кнопка отправляет запрос в конечную точку маркера. Текст запроса содержит следующие данные формы url кодированием.

- Предоставьте\_типа: «пароль»
- имя пользователя: &lt;электронной почты пользователя&gt;
- Пароль: &lt;пароль&gt;

Ниже приведен код JavaScript, который отправляет запрос AJAX:

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample7.js?highlight=14)]

Если запрос выполнен успешно, сервер авторизации возвращает маркер доступа в тексте ответа. Обратите внимание на то, что мы сохраняем маркер в хранилище сеанса, для последующего использования при отправке запросов к API. В отличие от некоторых форм проверки подлинности (например, проверка подлинности на основе файлов cookie) браузер не будет содержать автоматически маркер доступа в последующих запросах. Приложение необходимо делать это явным образом. Это удобно, так как она ограничивает [уязвимости CSRF](preventing-cross-site-request-forgery-csrf-attacks.md).

HTTP-запроса:

[!code-console[Main](individual-accounts-in-web-api/samples/sample8.cmd?highlight=5,10)]

Вы увидите, что запрос содержит учетные данные пользователя. Вы *необходимо* использования протокола HTTPS для обеспечения безопасности транспортного уровня.

HTTP-ответа:

[!code-console[Main](individual-accounts-in-web-api/samples/sample9.cmd?highlight=8)]

Для удобства чтения с отступом JSON и усечен маркер доступа, который является довольно длинными.

`access_token`, `token_type`, И `expires_in` свойства, определенные в спецификации OAuth2. Другие свойства (`userName`, `.issued`, и `.expires`) предназначены только для ознакомительных целей. Можно найти код, который добавляет эти дополнительные свойства в `TokenEndpoint` метод в файле /Providers/ApplicationOAuthProvider.cs.

## <a name="send-an-authenticated-request"></a>Отправить запрос с проверкой подлинности

Теперь, когда у нас есть токен носителя, мы можем сделать запрос с проверкой подлинности к API. Это делается, задав для заголовка авторизации в запросе. Нажмите кнопку **вызова API** кнопку еще раз, чтобы увидеть это.

[![](individual-accounts-in-web-api/_static/image13.png)](individual-accounts-in-web-api/_static/image12.png)

HTTP-запроса:

[!code-console[Main](individual-accounts-in-web-api/samples/sample10.cmd?highlight=5)]

HTTP-ответа:

[!code-console[Main](individual-accounts-in-web-api/samples/sample11.cmd)]

## <a name="log-out"></a>Выход

Поскольку обозреватель не кэширует учетные данные или маркер доступа, то при выходе достаточно просто «забыть» токен, удалив его из хранилища сеанса:

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample12.js)]

## <a name="understanding-the-individual-accounts-project-template"></a>Основные сведения о шаблоне проекта отдельных учетных записей

При выборе **отдельным учетным записям** в шаблоне проекта веб-приложения ASP.NET, проект включает:

- Сервер авторизации OAuth2.
- Конечную точку веб-API управления учетными записями пользователей
- Модель EF для хранения учетных записей пользователей.

Ниже приведены классы основного приложения, реализующие эти функции.

- `AccountController`. Предоставляет конечную точку веб-API управления учетными записями пользователей. `Register` Действие — единственный, который мы использовали в этом руководстве. Другие методы в классе поддерживает сброс пароля, социальные сети и другие функциональные возможности.
- `ApplicationUser`, определенный в /Models/IdentityModels.cs. Этот класс является модель EF для учетных записей пользователей в базе данных членства.
- `ApplicationUserManager`, определенный в/App\_Start/IdentityConfig.cs, этот класс является производным от [UserManager](https://msdn.microsoft.com/library/dn613290.aspx) автоматически сохраняется и выполняет операции для учетных записей пользователей, таких как создание нового пользователя, проверка того, пароли и т. д. изменения в базе данных.
- `ApplicationOAuthProvider`. Этот объект подключается по промежуточного слоя OWIN и обрабатывает события, вызываемые по промежуточного слоя. Он является производным от [OAuthAuthorizationServerProvider](https://msdn.microsoft.com/library/microsoft.owin.security.oauth.oauthauthorizationserverprovider.aspx).

![](individual-accounts-in-web-api/_static/image14.png)

### <a name="configuring-the-authorization-server"></a>Настройка сервера авторизации

В StartupAuth.cs приведенный ниже код настраивает сервер авторизации OAuth2.

[!code-csharp[Main](individual-accounts-in-web-api/samples/sample13.cs)]

`TokenEndpointPath` Свойство является URL-адрес конечной точки сервера авторизации. Это URL-адрес этого приложения использует для получения токенов носителя.

`Provider` Свойство указан поставщик, который подключается к по промежуточного слоя OWIN и обрабатывает события, вызываемые по промежуточного слоя.

Ниже приведен базовый поток, когда приложение хочет получить маркер.

1. Чтобы получить маркер доступа, приложение отправляет запрос на ~ / Token.
2. Вызовы по промежуточного слоя OAuth `GrantResourceOwnerCredentials` на поставщике.
3. Поставщик вызывает метод `ApplicationUserManager` для проверки учетных данных и создания удостоверений утверждений.
4. В случае успеха, поставщик создает билет проверки подлинности, который используется для создания токена.

[![](individual-accounts-in-web-api/_static/image16.png)](individual-accounts-in-web-api/_static/image15.png)

По промежуточного слоя OAuth не знает ничего о учетных записях. Поставщик обменивается данными между по промежуточного слоя и ASP.NET Identity. Дополнительные сведения о реализации сервера авторизации, см. в разделе [сервер авторизации OAuth 2.0 OWIN](../../../aspnet/overview/owin-and-katana/owin-oauth-20-authorization-server.md).

### <a name="configuring-web-api-to-use-bearer-tokens"></a>Настройка веб-API используют токены носителя

В `WebApiConfig.Register` метод, следующий код задает проверку подлинности для веб-API конвейера:

[!code-csharp[Main](individual-accounts-in-web-api/samples/sample14.cs)]

**HostAuthenticationFilter** класс включает проверку подлинности, с помощью токенов носителя.

**SuppressDefaultHostAuthentication** метод указывает веб-API, чтобы пропустить проверку подлинности, что происходит, прежде чем они достигнут веб-API конвейера, службами IIS или по промежуточного слоя OWIN. Таким образом, мы можно ограничить веб-API для проверки подлинности только с помощью токенов носителя.

> [!NOTE]
> В частности MVC, часть приложения может использовать проверку подлинности форм, которые содержат учетные данные в файле cookie. На основе файлов cookie проверки подлинности требует использования маркеров защиты от подделки, для предотвращения атак CSRF. Это проблема для веб-API, так как нет способа удобный для веб-API для отправки клиенту маркер защиты от подделки. (Дополнительные сведения об этой проблеме см. в разделе [предотвращение атак CSRF, в веб-API](preventing-cross-site-request-forgery-csrf-attacks.md).) Вызов **SuppressDefaultHostAuthentication** гарантирует, что веб-API не является уязвимым для атак CSRF учетные данные, хранящиеся в файлах cookie.


Когда клиент запрашивает защищенному ресурсу, вот что происходит в конвейере веб-API:

1. **HostAuthentication** фильтр вызывает по промежуточного слоя OAuth для проверки токена.
2. По промежуточного слоя преобразует токен в удостоверение утверждений.
3. На этом этапе запрос является *проверку подлинности* , но не *авторизованных*.
4. Фильтр авторизации проверяет удостоверение утверждений. Если утверждения авторизации пользователей для этого ресурса, запрос авторизуется. По умолчанию **[Authorize]** атрибут авторизует запрос, который проходит проверку подлинности. Тем не менее можно авторизовать роли или другие утверждения. Дополнительные сведения см. в разделе [проверки подлинности и авторизации в веб-API](authentication-and-authorization-in-aspnet-web-api.md).
5. Если предыдущие шаги выполнены успешно, контроллер возвращает защищенному ресурсу. В противном случае клиент получает ошибку 401 (неавторизованный).

[![](individual-accounts-in-web-api/_static/image18.png)](individual-accounts-in-web-api/_static/image17.png)

## <a name="additional-resources"></a>Дополнительные ресурсы

- [ASP.NET Identity](../../../identity/index.md)
- [Основные сведения о функции безопасности в шаблоне SPA для версии-Кандидата VS2013](https://blogs.msdn.com/b/webdev/archive/2013/09/20/understanding-security-features-in-spa-template.aspx). Блог MSDN для учета Hongye Sun.
- [Разбор веб-API отдельные учетные записи шаблона — часть 2: Локальные учетные записи](http://leastprivilege.com/2013/11/26/dissecting-the-web-api-individual-accounts-templatepart-2-local-accounts/). Запись блога, Доминик Байер.
- [Разместить проверку подлинности и веб-API с OWIN](http://brockallen.com/2013/10/27/host-authentication-and-web-api-with-owin-and-active-vs-passive-authentication-middleware/). Подробное объяснение `SuppressDefaultHostAuthentication` и `HostAuthenticationFilter` по Брок Аллен.
- [Настройка сведения о профиле в ASP.NET Identity в шаблонах Visual STUDIO 2013](https://blogs.msdn.com/b/webdev/archive/2013/10/16/customizing-profile-information-in-asp-net-identity-in-vs-2013-templates.aspx). В блоге MSDN с Пранавом Растоги.
- [Для управления жизненным циклом запроса для класса UserManager в ASP.NET Identity](https://blogs.msdn.com/b/webdev/archive/2014/02/12/per-request-lifetime-management-for-usermanager-class-in-asp-net-identity.aspx). В блоге MSDN по Suhas Joshi, с которой подробно объясняется `UserManager` класса.
