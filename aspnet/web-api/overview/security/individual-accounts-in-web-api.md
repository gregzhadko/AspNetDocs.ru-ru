---
uid: web-api/overview/security/individual-accounts-in-web-api
title: Защита веб-API с помощью индивидуальных учетных записей и локального входа в веб-API ASP.NET 2,2 | Документация Майкрософт
author: MikeWasson
description: В этом разделе показано, как защитить веб-API с помощью OAuth2 для проверки подлинности в базе данных членства. Версии программного обеспечения, используемые в учебнике Visual Studio 201...
ms.author: riande
ms.date: 10/15/2014
ms.assetid: 92c84846-f0ea-4b5e-94b6-5004874eb060
msc.legacyurl: /web-api/overview/security/individual-accounts-in-web-api
msc.type: authoredcontent
ms.openlocfilehash: 7492c4aa4c2a0a8aeed64c3462bda8fc51f35a6b
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78447180"
---
# <a name="secure-a-web-api-with-individual-accounts-and-local-login-in-aspnet-web-api-22"></a>Защита веб-API с помощью индивидуальных учетных записей и локального входа в веб-API ASP.NET 2,2

по [Майк Уоссон](https://github.com/MikeWasson)

[Скачать пример приложения](https://github.com/MikeWasson/LocalAccountsApp)

> В этом разделе показано, как защитить веб-API с помощью OAuth2 для проверки подлинности в базе данных членства.
> 
> ## <a name="software-versions-used-in-the-tutorial"></a>Версии программного обеспечения, используемые в этом руководстве
> 
> 
> - [Visual Studio 2013 с обновлением 3](https://www.microsoft.com/visualstudio/eng/2013-downloads)
> - [Веб-API 2,2](../releases/whats-new-in-aspnet-web-api-22.md)
> - [ASP.NET Identity 2,1](../../../identity/index.md)

В Visual Studio 2013 шаблон проекта веб-API предоставляет три варианта проверки подлинности:

- **Отдельные учетные записи.** Приложение использует базу данных членства.
- **Учетные записи организации.** Пользователи входят с помощью Azure Active Directory, Office 365 или локальных Active Directory учетных данных.
- **Проверка подлинности Windows.** Этот параметр предназначен для приложений интрасети и использует модуль IIS проверки подлинности Windows.

Дополнительные сведения об этих параметрах см. [в разделе Создание веб-проектов ASP.NET в Visual Studio 2013](../../../visual-studio/overview/2013/creating-web-projects-in-visual-studio.md#auth).

Отдельные учетные записи предоставляют пользователю два способа входа:

- **Локальное имя входа**. Пользователь регистрируется на сайте, вводя имя пользователя и пароль. Приложение хранит хэш пароля в базе данных членства. При входе пользователя в систему ASP.NET Identity система проверяет пароль.
- **Имя входа в социальных сетях**. Пользователь входит в систему с помощью внешней службы, например Facebook, Microsoft или Google. Приложение по-прежнему создает запись для пользователя в базе данных членства, но не сохраняет учетные данные. Пользователь проходит проверку подлинности, войдя во внешнюю службу.

В этой статье рассматривается локальный вход в систему. Для локальных и социальных учетных записей веб-API использует OAuth2 для проверки подлинности запросов. Однако потоки учетных данных отличаются для локальных и социальных имен.

В этой статье я продемонстрирую простое приложение, которое позволяет пользователю войти в систему и отправить прошедшие проверку подлинности вызовы AJAX в веб-API. Пример кода можно скачать [здесь](https://github.com/MikeWasson/LocalAccountsApp). В файле сведений описывается создание образца с нуля в Visual Studio.

[![](individual-accounts-in-web-api/_static/image2.png)](individual-accounts-in-web-api/_static/image1.png)

Пример приложения использует выколачивание. js для привязки данных и jQuery для отправки запросов AJAX. Я буду сосредоточиться на вызовах AJAX, поэтому вам не нужно знать выколачивание. js для этой статьи.

Кстати, я опишу:

- Действия, выполняемые приложением на стороне клиента.
- Что происходит на сервере.
- Трафик HTTP в середине.

Сначала необходимо определить некоторую OAuth2 терминологию.

- *Ресурс*. Часть данных, которые можно защитить.
- *Сервер ресурсов*. Сервер, на котором размещен ресурс.
- *Владелец ресурса*. Сущность, которая может предоставлять разрешение на доступ к ресурсу. (Обычно это пользователь.)
- *Клиент*: приложение, которому требуется доступ к ресурсу. В этой статье клиент является веб-браузером.
- *Маркер доступа*. Маркер, который предоставляет доступ к ресурсу.
- *Токен носителя*. Определенный тип маркера доступа со свойством, которое любой может использовать маркер. Иными словами, клиенту не требуется криптографический ключ или другой секрет для использования токена носителя. По этой причине токены носителя следует использовать только по протоколу HTTPS и иметь относительно короткий срок действия.
- *Сервер авторизации*. Сервер, предоставляющий маркеры доступа.

Приложение может действовать как сервер авторизации и сервер ресурсов. Шаблон проекта веб-API соответствует этому шаблону.

## <a name="local-login-credential-flow"></a>Поток учетных данных локального входа

Для локального входа веб-API использует [поток паролей владельца ресурса](http://oauthlib.readthedocs.org/en/latest/oauth2/grants/password.html) , определенный в OAuth2.

1. Пользователь вводит имя и пароль в клиент.
2. Клиент отправляет эти учетные данные на сервер авторизации.
3. Сервер авторизации проверяет подлинность учетных данных и возвращает маркер доступа.
4. Для доступа к защищенному ресурсу клиент включает маркер доступа в заголовок авторизации HTTP-запроса.

![](individual-accounts-in-web-api/_static/image3.png)

При выборе **отдельных учетных записей** в шаблоне проекта веб-API проект включает сервер авторизации, который проверяет учетные данные пользователя и маркеры проблем. На следующей схеме показан один и тот же поток учетных данных в терминах компонентов веб-API.

![](individual-accounts-in-web-api/_static/image4.png)

В этом сценарии контроллеры веб-API выступают в качестве серверов ресурсов. Фильтр проверки подлинности проверяет маркеры доступа, а атрибут **[авторизовать]** используется для защиты ресурса. Если у контроллера или действия есть атрибут **[авторизовать]** , все запросы к этому контроллеру или действию должны пройти проверку подлинности. В противном случае авторизация отклоняется, а веб-API возвращает ошибку 401 (не санкционировано).

Сервер авторизации и фильтр проверки подлинности вызывают компонент по [промежуточного слоя OWIN](../../../aspnet/overview/owin-and-katana/an-overview-of-project-katana.md) , который обрабатывает сведения о OAuth2. Далее в этом руководстве я подробно расскажу о проектировании.

## <a name="sending-an-unauthorized-request"></a>Отправка неавторизованного запроса

Чтобы приступить к работе, запустите приложение и нажмите кнопку **вызвать API** . По завершении запроса в поле **результат** появится сообщение об ошибке. Это обусловлено тем, что запрос не содержит маркер доступа, поэтому запрос не авторизован.

[![](individual-accounts-in-web-api/_static/image6.png)](individual-accounts-in-web-api/_static/image5.png)

Кнопка **вызвать API** ОТПРАВЛЯЕТ запрос Ajax в ~/API/Values, который вызывает действие контроллера веб-API. Ниже приведен раздел кода JavaScript, который отправляет запрос AJAX. В примере приложения весь код приложения JavaScript находится в файле Скриптс\апп.ЖС.

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample1.js)]

Пока пользователь не войдет в систему, токен носителя отсутствует, поэтому в запросе отсутствует заголовок авторизации. Это приводит к тому, что запрос возвращает ошибку 401.

Ниже приведен HTTP-запрос. (Я использовал [Fiddler](http://www.telerik.com/fiddler) для записи HTTP-трафика.)

[!code-console[Main](individual-accounts-in-web-api/samples/sample2.cmd)]

HTTP-ответ:

[!code-console[Main](individual-accounts-in-web-api/samples/sample3.cmd?highlight=1,4)]

Обратите внимание, что ответ включает заголовок WWW-Authenticate с запросом, имеющим значение носителя. Это означает, что сервер ждет токен носителя.

## <a name="register-a-user"></a>Регистрация пользователя

В разделе **Регистрация** приложения введите адрес электронной почты и пароль и нажмите кнопку **зарегистрировать** .

Для этого примера не нужно использовать допустимый адрес электронной почты, но реальное приложение подтвердит адрес. (См. статью [Создание безопасного веб-приложения ASP.NET MVC 5 с входом, подтверждением электронной почты и сбросом пароля](../../../mvc/overview/security/create-an-aspnet-mvc-5-web-app-with-email-confirmation-and-password-reset.md)). Для пароля используйте нечто вроде "password1!" с прописной буквой, строчной буквой, цифрой и небуквенно-цифровым символом. Чтобы упростить работу с приложением, я оставил проверку на стороне клиента, поэтому при возникновении проблем с форматом пароля вы получите ошибку 400 (недопустимый запрос).

[![](individual-accounts-in-web-api/_static/image8.png)](individual-accounts-in-web-api/_static/image7.png)

Кнопка **зарегистрировать** ОТПРАВЛЯЕТ запрос POST в ~/АПИ/аккаунт/регистер/. Текст запроса — это объект JSON, содержащий имя и пароль. Ниже приведен код JavaScript, который отправляет запрос:

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample4.js)]

HTTP-запрос:

[!code-console[Main](individual-accounts-in-web-api/samples/sample5.cmd?highlight=5,10)]

HTTP-ответ:

[!code-console[Main](individual-accounts-in-web-api/samples/sample6.cmd)]

Этот запрос обрабатывается классом `AccountController`. На внутреннем уровне `AccountController` использует ASP.NET Identity для управления базой данных членства.

Если приложение запускается локально из Visual Studio, учетные записи пользователей хранятся в LocalDB в таблице AspNetUsers. Чтобы просмотреть таблицы в Visual Studio, в меню **вид** выберите **Обозреватель сервера**, а затем разверните узел **подключения к данным**.

![](individual-accounts-in-web-api/_static/image9.png)

## <a name="get-an-access-token"></a>Получение маркера доступа

Пока мы не сделали ни одного OAuth, но теперь мы увидим, что сервер авторизации OAuth в действии, когда мы запрашиваете маркер доступа. В области **Вход** в примере приложения введите адрес электронной почты и пароль и нажмите кнопку **войти**.

[![](individual-accounts-in-web-api/_static/image11.png)](individual-accounts-in-web-api/_static/image10.png)

Кнопка **войти** отправляет запрос в конечную точку маркера. Текст запроса содержит следующие данные в формате URL-адреса:

- Тип\_предоставления: "пароль"
- имя пользователя. &lt;электронной почты пользователя&gt;
- пароль: &lt;пароль&gt;

Ниже приведен код JavaScript, который отправляет запрос AJAX:

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample7.js?highlight=14)]

Если запрос выполнен, сервер авторизации возвращает маркер доступа в тексте ответа. Обратите внимание, что мы сохраняем токен в хранилище сеанса, чтобы использовать его позже при отправке запросов в API. В отличие от некоторых форм проверки подлинности (например, проверки подлинности на основе файлов cookie), браузер не будет автоматически включать маркер доступа в последующие запросы. Приложение должно сделать это явным образом. Это хорошая вещь, так как она ограничивает [CSRF уязвимости](preventing-cross-site-request-forgery-csrf-attacks.md).

HTTP-запрос:

[!code-console[Main](individual-accounts-in-web-api/samples/sample8.cmd?highlight=5,10)]

Как видите, запрос содержит учетные данные пользователя. Для обеспечения безопасности транспортного уровня *необходимо* использовать протокол HTTPS.

HTTP-ответ:

[!code-console[Main](individual-accounts-in-web-api/samples/sample9.cmd?highlight=8)]

Для удобочитаемости я создам отступ для JSON и усекает маркер доступа, который довольно длинный.

Свойства `access_token`, `token_type`и `expires_in` определяются спецификацией OAuth2. Другие свойства (`userName`, `.issued`и `.expires`) предназначены только для информационных целей. Код, который добавляет эти дополнительные свойства в метод `TokenEndpoint`, можно найти в файле/Провидерс/аппликатионоауспровидер.КС.

## <a name="send-an-authenticated-request"></a>Отправить запрос, прошедший проверку подлинности

Теперь, когда у нас есть токен носителя, можно сделать запрос, прошедший проверку подлинности, в API. Для этого необходимо задать заголовок авторизации в запросе. Нажмите кнопку **вызвать API** еще раз, чтобы увидеть это.

[![](individual-accounts-in-web-api/_static/image13.png)](individual-accounts-in-web-api/_static/image12.png)

HTTP-запрос:

[!code-console[Main](individual-accounts-in-web-api/samples/sample10.cmd?highlight=5)]

HTTP-ответ:

[!code-console[Main](individual-accounts-in-web-api/samples/sample11.cmd)]

## <a name="log-out"></a>Выйти

Так как браузер не кэширует учетные данные или маркер доступа, выход из системы — это просто вопрос "забыли" маркер, удалив его из хранилища сеанса:

[!code-javascript[Main](individual-accounts-in-web-api/samples/sample12.js)]

## <a name="understanding-the-individual-accounts-project-template"></a>Общие сведения о шаблоне проекта индивидуальных учетных записей

При выборе **отдельных учетных записей** в шаблоне проекта веб-приложения ASP.NET проект включает:

- Сервер авторизации OAuth2.
- Конечная точка веб-API для управления учетными записями пользователей
- Модель EF для хранения учетных записей пользователей.

Ниже приведены основные классы приложений, реализующие эти функции.

- `AccountController`. Предоставляет конечную точку веб-API для управления учетными записями пользователей. В этом руководстве используется только `Register` действие. Другие методы класса поддерживают сброс пароля, вход в социальные сети и другие функциональные возможности.
- `ApplicationUser`, определенные в/Моделс/идентитимоделс.КС. Этот класс является моделью EF для учетных записей пользователей в базе данных членства.
- `ApplicationUserManager`, определенный в/АПП\_Start/IdentityConfig. cs этот класс является производным от [UserManager](https://msdn.microsoft.com/library/dn613290.aspx) и выполняет операции с учетными записями пользователей, например создание нового пользователя, проверка паролей и т. д., и автоматическое сохранение изменений в базе данных.
- `ApplicationOAuthProvider`. Этот объект подключается к по промежуточного слоя OWIN и обрабатывает события, вызываемые по промежуточного слоя. Он является производным от [oauthauthorizationserverprovider заключается](https://msdn.microsoft.com/library/microsoft.owin.security.oauth.oauthauthorizationserverprovider.aspx).

![](individual-accounts-in-web-api/_static/image14.png)

### <a name="configuring-the-authorization-server"></a>Настройка сервера авторизации

В StartupAuth.cs следующий код настраивает сервер авторизации OAuth2.

[!code-csharp[Main](individual-accounts-in-web-api/samples/sample13.cs)]

Свойство `TokenEndpointPath` — это URL-адрес конечной точки сервера авторизации. Это URL-адрес, используемый приложением для получения токенов носителя.

Свойство `Provider` указывает поставщика, который подключается к по промежуточного слоя OWIN и обрабатывает события, вызываемые по промежуточного слоя.

Вот базовый поток, когда приложению требуется получить маркер:

1. Чтобы получить маркер доступа, приложение отправляет запрос в ~/токен.
2. По промежуточного слоя OAuth вызывает `GrantResourceOwnerCredentials` поставщика.
3. Поставщик вызывает `ApplicationUserManager`, чтобы проверить учетные данные и создать удостоверение утверждения.
4. В случае успешности поставщик создает билет проверки подлинности, который используется для создания маркера.

[![](individual-accounts-in-web-api/_static/image16.png)](individual-accounts-in-web-api/_static/image15.png)

По промежуточного слоя OAuth ничего не знает об учетных записях пользователей. Поставщик взаимодействует между по промежуточного слоя и ASP.NET Identity. Дополнительные сведения о реализации сервера авторизации см. в разделе [OWIN OAuth 2,0 Authorization Server](../../../aspnet/overview/owin-and-katana/owin-oauth-20-authorization-server.md).

### <a name="configuring-web-api-to-use-bearer-tokens"></a>Настройка веб-API для использования токенов носителя

В методе `WebApiConfig.Register` следующий код настраивает проверку подлинности для конвейера веб-API:

[!code-csharp[Main](individual-accounts-in-web-api/samples/sample14.cs)]

Класс **HostAuthenticationFilter** обеспечивает проверку подлинности с помощью токенов носителя.

Метод **SuppressDefaultHostAuthentication** сообщает веб-API о необходимости пропуска любой проверки подлинности, которая происходит до того, как запрос достигнет конвейера веб-API либо по промежуточного слоя IIS, либо через OWIN Таким образом можно ограничить веб-API для проверки подлинности только с помощью токенов носителя.

> [!NOTE]
> В частности, часть MVC приложения может использовать проверку подлинности с помощью форм, которая хранит учетные данные в файле cookie. Для проверки подлинности на основе файлов cookie необходимо использовать маркеры защиты от подделки, чтобы предотвратить атаки CSRF. Это проблема для веб-API, так как не существует удобного способа, которым веб-API отправляет маркер защиты от подделки клиенту. (Дополнительные сведения об этой ошибке см. [в разделе Предотвращение атак CSRF в веб-API](preventing-cross-site-request-forgery-csrf-attacks.md).) Вызов **SuppressDefaultHostAuthentication** гарантирует, что веб-API не будет уязвим для атак CSRF от учетных данных, хранящихся в файлах cookie.

Когда клиент запрашивает защищенный ресурс, вот что происходит в конвейере веб-API:

1. Фильтр **хостаусентикатион** вызывает по промежуточного слоя OAuth для проверки маркера.
2. По промежуточного слоя преобразует токен в удостоверение утверждений.
3. На этом этапе запрос *прошел проверку подлинности* , но не *авторизован*.
4. Фильтр авторизации проверяет удостоверение утверждений. Если утверждения авторизовать пользователя для этого ресурса, запрос будет авторизован. По умолчанию атрибут **[авторизовать]** позволяет авторизовать любой запрос, который прошел проверку подлинности. Тем не менее, можно авторизовать по роли или другим утверждениям. Дополнительные сведения см. [в разделе Проверка подлинности и авторизация в веб-API](authentication-and-authorization-in-aspnet-web-api.md).
5. Если предыдущие шаги выполнены успешно, контроллер Возвращает защищенный ресурс. В противном случае клиент получает ошибку 401 (не санкционировано).

[![](individual-accounts-in-web-api/_static/image18.png)](individual-accounts-in-web-api/_static/image17.png)

## <a name="additional-resources"></a>Дополнительные ресурсы

- [ASP.NET Identity](../../../identity/index.md)
- [Основные сведения о функциях безопасности в шаблоне SPA для VS2013 RC](https://blogs.msdn.com/b/webdev/archive/2013/09/20/understanding-security-features-in-spa-template.aspx). Запись блога MSDN по Хонге Sun.
- [Которая разбила. шаблон индивидуальных учетных записей API — часть 2: локальные учетные записи](http://leastprivilege.com/2013/11/26/dissecting-the-web-api-individual-accounts-templatepart-2-local-accounts/). Запись блога с помощью Доминик Байер.
- [Проверка подлинности узла и веб-API с помощью OWIN](http://brockallen.com/2013/10/27/host-authentication-and-web-api-with-owin-and-active-vs-passive-authentication-middleware/). Хорошее объяснение `SuppressDefaultHostAuthentication` и `HostAuthenticationFilter` Брок Аллен.
- [Настройка сведений о профиле в ASP.NET Identity в шаблонах VS 2013](https://blogs.msdn.com/b/webdev/archive/2013/10/16/customizing-profile-information-in-asp-net-identity-in-vs-2013-templates.aspx). Запись блога MSDN по получения запись блога.
- [Управление жизненным циклом каждого запроса для класса UserManager в ASP.NET Identity](https://blogs.msdn.com/b/webdev/archive/2014/02/12/per-request-lifetime-management-for-usermanager-class-in-asp-net-identity.aspx). Блог MSDN, посвященный Сухас Джоши, с хорошим объяснением класса `UserManager`.
