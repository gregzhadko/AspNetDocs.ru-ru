---
uid: web-api/overview/security/authentication-and-authorization-in-aspnet-web-api
title: Проверка подлинности и авторизация в веб-API ASP.NET | Документация Майкрософт
author: MikeWasson
description: Содержит общие сведения о проверке подлинности и авторизации в веб-API ASP.NET.
ms.author: riande
ms.date: 11/27/2012
ms.assetid: 6dfb51ea-9f4d-4e70-916c-8ef8344a88d6
msc.legacyurl: /web-api/overview/security/authentication-and-authorization-in-aspnet-web-api
msc.type: authoredcontent
ms.openlocfilehash: 368d2b9456d12b2bb4063a23333e5c8837faa3b8
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78484422"
---
# <a name="authentication-and-authorization-in-aspnet-web-api"></a>Проверка подлинности и авторизация веб-API ASP.NET

по [Майк Уоссон](https://github.com/MikeWasson)

Вы создали веб-API, но теперь хотите управлять доступом к нему. В этой серии статей мы рассмотрим некоторые варианты защиты веб-API от неавторизованных пользователей. В этой серии будут рассмотрены проверка подлинности и авторизация.

- *Проверка подлинности* — это знание удостоверения пользователя. Например, Алиса входит в систему с именем пользователя и паролем, а сервер использует пароль для проверки подлинности Алисы.
- *Авторизация* позволяет решить, разрешено ли пользователю выполнять действие. Например, Алиса имеет разрешение на получение ресурса, но не на создание ресурса.

В первой статье серии приводятся общие сведения о проверке подлинности и авторизации в веб-API ASP.NET. В других разделах описываются распространенные сценарии проверки подлинности для веб-API.

> [!NOTE]
> Благодаря людям, которые проверили эту серию, вы указали ценные отзывы: Рик Андерсон (, Бродерикк, Барри Доррансом, Tom Dykstra), Хонгмеи GE, Дэвид Матсон, Даниэль Roth), Тим Тибкен.

## <a name="authentication"></a>Аутентификация

Веб-API предполагает, что проверка подлинности выполняется на узле. Для веб-размещения узел является IIS, который использует модули HTTP для проверки подлинности. Вы можете настроить проект для использования любого из модулей проверки подлинности, встроенных в IIS или ASP.NET, или написать собственный модуль HTTP для выполнения пользовательской проверки подлинности.

Когда узел выполняет проверку подлинности пользователя, он создает *участника*, который представляет собой объект [IPrincipal](https://msdn.microsoft.com/library/System.Security.Principal.IPrincipal.aspx) , представляющий контекст безопасности, в котором выполняется код. Узел присоединяет участника к текущему потоку, устанавливая **Thread. CurrentPrincipal**. Участник содержит связанный объект **Identity** , содержащий сведения о пользователе. Если пользователь прошел проверку подлинности, свойство **Identity.** IsTrue возвращает **значение true**. Для анонимных запросов функция **проверки подлинности** возвращает **значение false**. Дополнительные сведения об участниках см. в разделе [безопасность на основе ролей](https://msdn.microsoft.com/library/shz8h065.aspx).

### <a name="http-message-handlers-for-authentication"></a>Обработчики сообщений HTTP для проверки подлинности

Вместо использования узла для проверки подлинности можно поместить логику проверки подлинности в [обработчик сообщений HTTP](../advanced/http-message-handlers.md). В этом случае обработчик сообщений проверяет HTTP-запрос и задает участника.

Когда следует использовать обработчики сообщений для проверки подлинности? Ниже приведены некоторые компромиссные решения.

- HTTP-модуль видит все запросы, которые проходят через конвейер ASP.NET. Обработчик сообщений видит только те запросы, которые перенаправляются в веб-API.
- Можно задать обработчики сообщений для каждого маршрута, что позволяет применить схему проверки подлинности к конкретному маршруту.
- Модули HTTP относятся к службам IIS. Обработчики сообщений не зависят от узла, поэтому их можно использовать как в веб-размещении, так и в автономном размещении.
- Модули HTTP участвуют в ведении журналов IIS, аудита и т. д.
- Модули HTTP выполняются ранее в конвейере. При обработке проверки подлинности в обработчике сообщений участник не получает значение Set до запуска обработчика. Более того, участник возвращается к предыдущему участнику, когда ответ покидает обработчик сообщений.

Как правило, если поддержка автономного размещения не требуется, то HTTP-модуль является лучшим вариантом. Если требуется поддержка автономного размещения, рассмотрим обработчик сообщений.

### <a name="setting-the-principal"></a>Установка субъекта

Если приложение выполняет какую-либо пользовательскую логику проверки подлинности, необходимо задать участника в двух местах:

- **Thread. CurrentPrincipal**. Это свойство является стандартным способом установки участника потока в .NET.
- **HttpContext. Current. пользователь**. Это свойство относится к ASP.NET.

В следующем коде показано, как задать субъект:

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample1.cs)]

Для веб-хостинга необходимо задать участника в обоих местах. в противном случае контекст безопасности может стать несогласованным. Однако для размещения в собственном размещении **HttpContext. Current** имеет значение null. Для обеспечения того, чтобы код не зависят от узла, необходимо проверить наличие значения null перед назначением **HttpContext. Current**, как показано ниже.

## <a name="authorization"></a>Авторизация

Авторизация происходит позже в конвейере ближе к контроллеру. Это позволяет выполнять более детализированный выбор при предоставлении доступа к ресурсам.

- *Фильтры авторизации* выполняются перед действием контроллера. Если запрос не имеет полномочий, фильтр возвращает сообщение об ошибке и действие не вызывается.
- В рамках действия контроллера можно получить текущего участника из свойства **ApiController. User** . Например, можно отфильтровать список ресурсов на основе имени пользователя, возвращая только те ресурсы, которые принадлежат этому пользователю.

![](authentication-and-authorization-in-aspnet-web-api/_static/image1.png)

<a id="auth3"></a>
### <a name="using-the-authorize-attribute"></a>Использование атрибута [авторизовать]

Веб-API предоставляет встроенный фильтр авторизации, [AuthorizeAttribute](https://msdn.microsoft.com/library/system.web.http.authorizeattribute.aspx). Этот фильтр проверяет, прошел ли пользователь проверку подлинности. В противном случае возвращается код состояния HTTP 401 (несанкционированный) без вызова действия.

Фильтр можно применять глобально, на уровне контроллера или на уровне отдельных действий.

**Глобально**. чтобы ограничить доступ для каждого контроллера веб-API, добавьте фильтр **AuthorizeAttribute** в глобальный список фильтров:

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample2.cs)]

**Контроллер**. чтобы ограничить доступ к конкретному контроллеру, добавьте фильтр в качестве атрибута к контроллеру:

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample3.cs)]

**Действие**: чтобы ограничить доступ для определенных действий, добавьте атрибут в метод действия:

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample4.cs)]

Кроме того, можно ограничить контроллер, а затем разрешить анонимный доступ к определенным действиям с помощью атрибута `[AllowAnonymous]`. В следующем примере метод `Post` ограничен, но метод `Get` допускает анонимный доступ.

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample5.cs)]

В предыдущих примерах фильтр позволяет любому пользователю, прошедшему проверку подлинности, получить доступ к ограниченным методам. поддерживаются только анонимные пользователи. Вы также можете ограничить доступ для конкретных пользователей или пользователей в конкретных ролях:

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample6.cs)]

> [!NOTE]
> Фильтр **AuthorizeAttribute** для контроллеров веб-API находится в пространстве имен **System. Web. http** . Существует аналогичный фильтр для контроллеров MVC в пространстве имен **System. Web. MVC** , который несовместим с контроллерами веб-API.

### <a name="custom-authorization-filters"></a>Пользовательские фильтры авторизации

Чтобы написать пользовательский фильтр авторизации, сделайте его производным от одного из следующих типов:

- **AuthorizeAttribute**. Расширьте этот класс для выполнения логики авторизации на основе текущего пользователя и ролей пользователя.
- **Аусоризатионфилтераттрибуте**. Расширьте этот класс для выполнения синхронной логики авторизации, которая не обязательно основана на текущем пользователе или роли.
- **Иаусоризатионфилтер**. Реализуйте этот интерфейс для выполнения логики асинхронной авторизации. Например, если логика авторизации выполняет асинхронный ввод-вывод или сетевые вызовы. (Если логика авторизации привязана к ЦП, проще создать производную от **аусоризатионфилтераттрибуте**, так как вам не нужно писать асинхронный метод.)

На следующей диаграмме показана иерархия классов для класса **AuthorizeAttribute** .

![](authentication-and-authorization-in-aspnet-web-api/_static/image2.png)

### <a name="authorization-inside-a-controller-action"></a>Авторизация внутри действия контроллера

В некоторых случаях можно разрешить продолжение запроса, но изменить поведение на основе участника. Например, возвращаемые сведения могут изменяться в зависимости от роли пользователя. В методе контроллера можно получить текущего участника из свойства **ApiController. User** .

[!code-csharp[Main](authentication-and-authorization-in-aspnet-web-api/samples/sample7.cs)]
