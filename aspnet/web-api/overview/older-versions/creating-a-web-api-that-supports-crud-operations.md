---
uid: web-api/overview/older-versions/creating-a-web-api-that-supports-crud-operations
title: Включение операций CRUD в веб-API ASP.NET 1-ASP.NET 4. x
author: MikeWasson
description: В этом руководстве показано, как поддерживать операции CRUD в службе HTTP с помощью веб-API ASP.NET для ASP.NET 4. x.
ms.author: riande
ms.date: 01/28/2012
ms.custom: seoapril2019
ms.assetid: c125ca47-606a-4d6f-a1fc-1fc62928af93
msc.legacyurl: /web-api/overview/older-versions/creating-a-web-api-that-supports-crud-operations
msc.type: authoredcontent
ms.openlocfilehash: a096fd1c54df33b40115907a5c2517b2e3fec5b8
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78448044"
---
# <a name="enabling-crud-operations-in-aspnet-web-api-1"></a>Включение операций CRUD в веб-API ASP.NET 1

по [Майк Уоссон](https://github.com/MikeWasson)

[Скачать завершенный проект](https://code.msdn.microsoft.com/ASP-NET-Web-API-Tutorial-c4761894)

> В этом руководстве показано, как поддерживать операции CRUD в службе HTTP с помощью веб-API ASP.NET для ASP.NET 4. x.
> 
> ## <a name="software-versions-used-in-the-tutorial"></a>Версии программного обеспечения, используемые в этом руководстве
> 
> 
> - Visual Studio 2012
> - Веб-API 1 (также работает с веб-API 2)

CRUD означает &quot;создания, чтения, обновления и удаления&quot; которые являются четырьмя основными операциями с базой данных. Многие службы HTTP также моделируют операции CRUD с помощью API-интерфейсов RESTFUL или RESTFUL.

В этом руководстве вы создадите очень простой веб-API для управления списком продуктов. Каждый продукт будет содержать имя, цену и категорию (например, &quot;Toys&quot; или &quot;оборудования&quot;), а также идентификатор продукта.

API продуктов предоставит следующие методы.

| Действие | Метод HTTP | Относительный URI |
| --- | --- | --- |
| Получить список всех продуктов | GET | /апи/продуктс |
| Получение продукта по ИДЕНТИФИКАТОРу | GET | *идентификатор* /АПИ/Продуктс/ |
| Получение продукта по категории | GET | /АПИ/Продуктс? Category =*Категория* |
| Создать продукт | POST | /апи/продуктс |
| Обновить продукт | ОТПРАВКА | *идентификатор* /АПИ/Продуктс/ |
| Удалить продукт | DELETE | *идентификатор* /АПИ/Продуктс/ |

Обратите внимание, что некоторые URI содержат идентификатор продукта в пути. Например, чтобы получить продукт, идентификатор которого равен 28, клиент отправляет запрос GET для `http://hostname/api/products/28`.

### <a name="resources"></a>Ресурсы

API продуктов определяет URI для двух типов ресурсов:

| Ресурс | URI |
| --- | --- |
| Список всех продуктов. | /апи/продуктс |
| Отдельный продукт. | *идентификатор* /АПИ/Продуктс/ |

### <a name="methods"></a>Методы

Четыре основных метода HTTP (GET, WHERE, POST и DELETE) можно сопоставить с операциями CRUD следующим образом:

- GET получает представление ресурса по указанному универсальному коду ресурса (URI). GET не должен иметь побочных эффектов на сервере.
- Помещает обновление ресурса по указанному универсальному коду ресурса (URI). Также можно использовать для создания нового ресурса по указанному универсальному коду ресурса (URI), если сервер позволяет клиентам указывать новые URI. В этом руководстве API не поддерживает создание с помощью инструкции For.
- POST создает новый ресурс. Сервер назначает универсальный код ресурса (URI) для нового объекта и возвращает этот URI как часть ответного сообщения.
- DELETE удаляет ресурс по указанному универсальному коду ресурса (URI).

Примечание. метод размещения заменяет всю сущность Product. То есть клиент должен отправить полное представление обновленного продукта. Если требуется поддержка частичных обновлений, рекомендуется использовать метод PATCH. В этом руководстве не реализовано исправление.

## <a name="create-a-new-web-api-project"></a>Создание нового проекта веб-API

Начните с запуска Visual Studio и выберите **создать проект** на **начальной** странице. Либо в меню **файл** выберите **создать** , а затем — **проект**.

В области **шаблоны** выберите **Установленные шаблоны** и разверните узел  **C# визуального** элемента. В **разделе C#визуальный** элемент выберите **веб**. В списке шаблонов проектов выберите **ASP.NET MVC 4 веб-приложение**. Присвойте проекту имя &quot;Продуктсторе&quot; и нажмите кнопку **ОК**.

![](creating-a-web-api-that-supports-crud-operations/_static/image1.png)

В диалоговом окне **Новый проект ASP.NET MVC 4** выберите **веб-API** и нажмите кнопку **ОК**.

![](creating-a-web-api-that-supports-crud-operations/_static/image2.png)

## <a name="adding-a-model"></a>Добавление модели

*Модель* — это объект, который представляет данные в приложении. В веб-API ASP.NET можно использовать строго типизированные объекты CLR в качестве моделей, и они будут автоматически сериализованы в XML или JSON для клиента.

Для API Продуктсторе наши данные состоят из продуктов, поэтому мы создадим новый класс с именем `Product`.

Если обозреватель решений не отображается, щелкните меню **Просмотр** и выберите **Обозреватель решений**. В обозреватель решений щелкните правой кнопкой мыши папку **модели** . В контекстном меню выберите **Добавить**, а затем выберите **класс**. Присвойте классу имя &quot;&quot;продукта.

![](creating-a-web-api-that-supports-crud-operations/_static/image3.png)

Добавьте следующие свойства в класс `Product`.

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample1.cs)]

## <a name="adding-a-repository"></a>Добавление репозитория

Необходимо сохранить коллекцию продуктов. Рекомендуется отделить коллекцию от нашей реализации службы. Таким образом, можно изменить резервное хранилище, не переписывая класс службы. Этот тип проекта называется шаблоном *репозитория* . Начните с определения универсального интерфейса для репозитория.

В обозреватель решений щелкните правой кнопкой мыши папку **модели** . Нажмите кнопку **Добавить**, а затем выберите **новый элемент**.

![](creating-a-web-api-that-supports-crud-operations/_static/image4.png)

В области **шаблоны** выберите **Установленные шаблоны** и разверните C# узел. В C#разделе Выберите **код**. В списке шаблонов кода выберите **интерфейс**. Присвойте интерфейсу имя &quot;&quot;Ипродуктрепоситори.

![](creating-a-web-api-that-supports-crud-operations/_static/image5.png)

Добавьте следующую реализацию:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample2.cs)]

Теперь добавьте еще один класс в папку Models с именем &quot;Продуктрепоситори.&quot; этот класс будет реализовывать интерфейс `IProductRepository`. Добавьте следующую реализацию:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample3.cs)]

Репозиторий хранит список в локальной памяти. Это нормально для учебника, но в реальном приложении вы храните данные извне, либо в базе данных, либо в облачном хранилище. Шаблон репозитория упростит изменение реализации.

## <a name="adding-a-web-api-controller"></a>Добавление контроллера веб-API

Если вы работали с ASP.NET MVC, вы уже знакомы с контроллерами. В веб-API ASP.NET *контроллер* — это класс, который обрабатывает HTTP-запросы от клиента. При создании проекта мастер создания проекта создал два контроллера. Чтобы увидеть их, разверните папку Controllers в обозреватель решений.

- HomeController — это традиционный контроллер MVC ASP.NET. Он отвечает за обслуживание HTML-страниц для сайта и не связан напрямую с нашим веб-API.
- Объекта valuescontroller — это пример контроллера WebAPI.

Удалите объекта valuescontroller, щелкнув правой кнопкой мыши файл в обозреватель решений и выбрав пункт **Удалить.** Теперь добавьте новый контроллер, как показано ниже.

В **обозревателе решений** щелкните правой кнопкой мыши папку Controllers. Щелкните **Добавить**, а затем выберите **Контроллер**.

![](creating-a-web-api-that-supports-crud-operations/_static/image6.png)

В мастере **добавления контроллера** назовите контроллер &quot;продуктсконтроллер&quot;. В раскрывающемся списке **шаблон** выберите **пустой контроллер API**. Нажмите кнопку **Добавить**.

![](creating-a-web-api-that-supports-crud-operations/_static/image7.png)

> [!NOTE]
> Нет необходимости размещать контроллеры в папке с именем Controllers. Имя папки не имеет значения; Это просто удобный способ организации исходных файлов.

Мастер **добавления контроллера** создаст файл с именем ProductsController.cs в папке Controllers. Если этот файл еще не открыт, дважды щелкните его. Добавьте следующий оператор **using** :

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample4.cs)]

Добавьте поле, содержащее экземпляр **ипродуктрепоситори** .

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample5.cs)]

> [!NOTE]
> Вызов `new ProductRepository()` в контроллере не является оптимальным решением, так как он связывает контроллер с определенной реализацией `IProductRepository`. Более эффективный подход см. в разделе [Использование сопоставителя зависимостей веб-API](../advanced/dependency-injection.md).

## <a name="getting-a-resource"></a>Получение ресурса

API Продуктсторе предоставит несколько &quot;чтения&quot; действий в виде методов HTTP GET. Каждое действие будет соответствовать методу в классе `ProductsController`.

| Действие | Метод HTTP | Относительный URI |
| --- | --- | --- |
| Получить список всех продуктов | GET | /апи/продуктс |
| Получение продукта по ИДЕНТИФИКАТОРу | GET | *идентификатор* /АПИ/Продуктс/ |
| Получение продукта по категории | GET | /АПИ/Продуктс? Category =*Категория* |

Чтобы получить список всех продуктов, добавьте этот метод в класс `ProductsController`:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample6.cs)]

Имя метода начинается с &quot;Get&quot;, поэтому по сопоставлению с запросами GET. Кроме того, поскольку метод не имеет параметров, он сопоставляется с URI, который не содержит *&quot;идентификатор&quot;* сегмент в пути.

Чтобы получить продукт по ИДЕНТИФИКАТОРу, добавьте этот метод в класс `ProductsController`:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample7.cs)]

Это имя метода также начинается с &quot;Get&quot;, но у метода есть параметр с именем *ID*. Этот параметр сопоставляется с идентификатором &quot;&quot; сегменте пути URI. Платформа веб-API ASP.NET автоматически преобразует идентификатор в правильный тип данных (**int**) для параметра.

Если *идентификатор* является недопустимым, метод **хттпреспонсиксцептион** создает исключение типа. Это исключение будет переведено платформой в ошибку 404 (не найдено).

Наконец, добавьте метод для поиска продуктов по категории:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample8.cs)]

Если URI запроса содержит строку запроса, веб-API пытается сопоставить параметры запроса с параметрами метода контроллера. Таким образом, URI в форме "API/Products? Category =*Category*" будет сопоставляться с этим методом.

## <a name="creating-a-resource"></a>Создание ресурса

Далее мы добавим метод в класс `ProductsController`, чтобы создать новый продукт. Ниже приведена простая реализация метода.

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample9.cs)]

Обратите внимание на два вещи, касающиеся этого метода:

- Имя метода начинается с &quot;POST...&quot;. Чтобы создать новый продукт, клиент отправляет запрос HTTP POST.
- Метод принимает параметр типа Product. В веб-API параметры со сложными типами десериализованы из текста запроса. Поэтому мы ожидаем, что клиент отправляет сериализованное представление объекта Product в формате XML или JSON.

Эта реализация будет работать, но это не совсем полная. В идеале мы хотим, чтобы HTTP-ответ включал следующее:

- **Код ответа:** По умолчанию платформа веб-API устанавливает для кода состояния ответа значение 200 (ОК). Но в соответствии с протоколом HTTP/1.1, когда запрос POST приводит к созданию ресурса, сервер должен ответить с состоянием 201 (создано).
- **Расположение:** Когда сервер создает ресурс, он должен содержать URI нового ресурса в заголовке Location ответа.

Веб-API ASP.NET позволяет легко управлять ответным сообщением HTTP. Ниже приведена Улучшенная реализация.

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample10.cs)]

Обратите внимание, что возвращаемый тип метода теперь **HttpResponseMessage**. При возврате **HttpResponseMessage** вместо продукта можно управлять сведениями об ответном сообщении HTTP, включая код состояния и заголовок Location.

Метод **креатереспонсе** создает **HttpResponseMessage** и автоматически записывает сериализованное представление объекта Product в текст ответного сообщения.

> [!NOTE]
> В этом примере не выполняется проверка `Product`. Дополнительные сведения о проверке модели см. [в разделе Проверка модели в веб-API ASP.NET](../formats-and-model-binding/model-validation-in-aspnet-web-api.md).

## <a name="updating-a-resource"></a>Обновление ресурса

Обновление продукта с помощью постановки выполняется просто:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample11.cs)]

Имя метода начинается с &quot;помещения...&quot;, поэтому веб-API сопоставляет его для размещения запросов. Этот метод принимает два параметра: идентификатор продукта и обновленный продукт. Параметр *ID* берется из пути URI, а параметр *Product* десериализуется из текста запроса. По умолчанию веб-API ASP.NET Framework принимает простые типы параметров из маршрута и сложных типов из текста запроса.

## <a name="deleting-a-resource"></a>Удаление ресурса

Чтобы удалить ресурс, определите "Delete..." Method.

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample12.cs)]

Если запрос на удаление завершился успешно, он может вернуть состояние 200 (ОК) с текстом сущности, описывающим состояние. состояние 202 (принято), если удаление все еще ожидается; или состояние 204 (без содержимого) без тела сущности. В этом случае метод `DeleteProduct` имеет тип возвращаемого значения `void`, поэтому веб-API ASP.NET автоматически преобразует его в код состояния 204 (нет содержимого).
