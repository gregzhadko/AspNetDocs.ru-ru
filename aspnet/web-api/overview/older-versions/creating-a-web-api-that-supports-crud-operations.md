---
uid: web-api/overview/older-versions/creating-a-web-api-that-supports-crud-operations
title: Включение операций CRUD в ASP.NET веб-API 1 - ASP.NET 4.x
author: MikeWasson
description: Руководстве показано, как для поддержки операций CRUD в HTTP-службу с помощью веб-API ASP.NET для ASP.NET 4.x.
ms.author: riande
ms.date: 01/28/2012
ms.custom: seoapril2019
ms.assetid: c125ca47-606a-4d6f-a1fc-1fc62928af93
msc.legacyurl: /web-api/overview/older-versions/creating-a-web-api-that-supports-crud-operations
msc.type: authoredcontent
ms.openlocfilehash: 855c3fa35d82173c87d13adb51e10fd13698ade5
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59381358"
---
# <a name="enabling-crud-operations-in-aspnet-web-api-1"></a>Включение операций CRUD в ASP.NET веб-API 1

по [Майк Уоссон](https://github.com/MikeWasson)

[Скачать завершенный проект](http://code.msdn.microsoft.com/ASP-NET-Web-API-Tutorial-c4761894)

> Этом руководстве показано, как для поддержки операций CRUD в HTTP-службу с помощью веб-API ASP.NET для ASP.NET 4.x.
> 
> ## <a name="software-versions-used-in-the-tutorial"></a>Версии программного обеспечения, используемые в этом руководстве
> 
> 
> - Visual Studio 2012
> - Веб-API 1 (также работает с веб-API 2)


Обозначает CRUD &quot;создание, чтение, обновление и удаление,&quot; являющиеся четыре основных операций базы данных. Многие службы HTTP также моделировать операции CRUD с помощью REST или API-интерфейсов в стиле REST.

В этом руководстве вы создадите простое веб-API для управления списком продуктов. Каждый продукт будет содержать имя, цену и категории (такие как &quot;toys&quot; или &quot;оборудования&quot;), а также идентификатора продукта.

Продукты API предоставляет следующие методы.

| Действие | Метод HTTP | Относительный URI |
| --- | --- | --- |
| Получение списка всех продуктов | GET | / api/продуктов |
| Получить продукт по Идентификатору | GET | /API/продукты/*идентификатор* |
| Получить продукт по категории | GET | /api/products?category=*category* |
| Создать продукт | ПОМЕСТИТЬ | / api/продуктов |
| Обновления продукта | PUT | /API/продукты/*идентификатор* |
| Удалить продукт | DELETE | /API/продукты/*идентификатор* |

Обратите внимание на то, что некоторые из URI включают идентификатор продукта в пути. Например, чтобы получить продукт, идентификатор которого — 28, клиент отправляет запрос GET для `http://hostname/api/products/28`.

### <a name="resources"></a>Ресурсы

Продукты API определяет идентификаторы URI для двух типов ресурсов:

| Ресурс | URI |
| --- | --- |
| Список всех продуктов. | / api/продуктов |
| Отдельному продукту. | /API/продукты/*идентификатор* |

### <a name="methods"></a>Методы

Четыре основных метода HTTP (GET, PUT, POST и DELETE) может быть сопоставлен операции CRUD следующим образом:

- GET возвращает представление ресурса по указанному URI. GET не оказывает влияния на стороне сервера.
- PUT обновляет ресурс с указанным URI. PUT можно также использовать для создания нового ресурса с указанным URI, если сервер разрешает клиентам указывать новые URI. В этом учебнике API не будет поддерживать создание через PUT.
- POST создает новый ресурс. Сервер назначает URI для нового объекта и возвращает этот URI как часть ответного сообщения.
- DELETE удаляет ресурс по указанному URI.

Примечание. Метод PUT заменяет сущность всего продукта. То есть клиент ожидается для отправки обновленных продукта полное представление. Если вы хотите обеспечить поддержку частичных обновлений, метод PATCH является предпочтительным. В этом руководстве реализуются PATCH.

## <a name="create-a-new-web-api-project"></a>Создать проект нового веб-API

Начните с запуска Visual Studio и выберите **новый проект** из **запустить** страницы. Или с **файл** меню, выберите **New** и затем **проекта**.

В **шаблоны** области выберите **установленные шаблоны** и разверните **Visual C#** узла. В разделе **Visual C#** выберите **Web**. В списке шаблонов проектов выберите **веб-приложение ASP.NET MVC 4**. Назовите проект &quot;ProductStore&quot; и нажмите кнопку **ОК**.

![](creating-a-web-api-that-supports-crud-operations/_static/image1.png)

В **создания проекта ASP.NET MVC 4** диалоговом окне выберите **веб-API** и нажмите кнопку **ОК**.

![](creating-a-web-api-that-supports-crud-operations/_static/image2.png)

## <a name="adding-a-model"></a>Добавление модели

*Модель* — это объект, представляющий данные в приложении. В веб-API ASP.NET строго типизированные объекты CLR можно использовать в качестве модели, и они будет автоматически сериализован в XML или JSON для клиента.

Для ProductStore API, наших данных состоит из продуктов, поэтому мы создадим новый класс с именем `Product`.

Если обозреватель решений не отображается, нажмите кнопку **представление** меню и выберите **обозревателе решений**. В обозревателе решений щелкните правой кнопкой мыши **моделей** папки. В контекстном меню выберите **добавить**, а затем выберите **класс**. Назовите класс &quot;продукта&quot;.

![](creating-a-web-api-that-supports-crud-operations/_static/image3.png)

Добавьте следующие свойства `Product` класса.

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample1.cs)]

## <a name="adding-a-repository"></a>Добавление репозитория

Нам нужно хранить коллекции продуктов. Это хороший способ разделения коллекции из нашей реализации службы. Таким образом, мы можем изменить хранилище без перезаписи классу службы. Этот тип проектирования называется *репозитория* шаблон. Начинается с определения универсальный интерфейс для репозитория.

В обозревателе решений щелкните правой кнопкой мыши **моделей** папки. Выберите **добавить**, а затем выберите **новый элемент**.

![](creating-a-web-api-that-supports-crud-operations/_static/image4.png)

В **шаблоны** области выберите **установленные шаблоны** и разверните узел C#. В области C#, выберите **кода**. В списке шаблонов кода, выберите **интерфейс**. Назовите этот интерфейс &quot;IProductRepository&quot;.

![](creating-a-web-api-that-supports-crud-operations/_static/image5.png)

Добавьте следующую реализацию:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample2.cs)]

Теперь добавьте еще один класс в папке «модели», с именем &quot;ProductRepository.&quot; Этот класс реализует интерфейс `IProductRepository`. Добавьте следующую реализацию:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample3.cs)]

Хранилище сохраняет список в локальной памяти. Это нормально для учебника, но в реальном приложении, будут храниться данные во внешней системе, либо базы данных или в облачном хранилище. Шаблон репозитория упростит состоит в изменении реализации более поздней версии.

## <a name="adding-a-web-api-controller"></a>Добавление контроллер веб-API

Если вы работали с ASP.NET MVC, то вы уже знакомы с контроллерами. В веб-API ASP.NET *контроллера* является классом, который обрабатывает HTTP-запросы от клиента. При создании проекта мастером создания проекта автоматически создается два контроллера. Чтобы увидеть их, разверните папку Controllers в обозревателе решений.

- HomeController — это традиционный контроллер ASP.NET MVC. Он отвечает за обслуживание HTML-страниц для сайта и не имеет прямого отношения к нашей веб-API.
- ValuesController — это пример контроллера WebAPI.

Продолжить и удалить ValuesController, дважды щелкнув файл в обозревателе решений и выбрав **удалить.** Теперь добавьте новый контроллер, следующим образом:

В **обозревателе решений**, щелкните правой кнопкой мыши папку Controllers. Выберите **добавить** , а затем выберите **контроллера**.

![](creating-a-web-api-that-supports-crud-operations/_static/image6.png)

В **Добавление контроллера** мастера, назовите контроллер &quot;ProductsController&quot;. В **шаблона** стрелку раскрывающегося списка выберите **пустой контроллер API**. Затем нажмите кнопку **Добавить**.

![](creating-a-web-api-that-supports-crud-operations/_static/image7.png)

> [!NOTE]
> Не бывает необходимо поместить в папку с именем контроллеры контроллеров. Имя папки не имеет значения; Это просто удобный способ организации исходные файлы.


**Добавление контроллера** мастер создаст файл с именем ProductsController.cs в папку "контроллеры". Если этот файл еще не открыт, дважды щелкните файл, чтобы открыть его. Добавьте следующий **с помощью** инструкции:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample4.cs)]

Добавьте поле, которое хранит **IProductRepository** экземпляра.

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample5.cs)]

> [!NOTE]
> Вызов `new ProductRepository()` в контроллере не является лучшим Дизайн, привязывает контроллера для конкретной реализации `IProductRepository`. Лучший подход, см. в разделе [с помощью сопоставителя зависимостей Web API](../advanced/dependency-injection.md).


## <a name="getting-a-resource"></a>Получение сведений о ресурсе

Предоставляет несколько ProductStore API &quot;чтение&quot; действия, как методы HTTP GET. Каждое действие будет соответствовать методу в `ProductsController` класса.

| Действие | Метод HTTP | Относительный URI |
| --- | --- | --- |
| Получение списка всех продуктов | GET | / api/продуктов |
| Получить продукт по Идентификатору | GET | /API/продукты/*идентификатор* |
| Получить продукт по категории | GET | /api/products?category=*category* |

Чтобы получить список всех продуктов, добавьте этот метод, чтобы `ProductsController` класса:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample6.cs)]

Имя метода начинается с &quot;получить&quot;, поэтому по соглашению он сопоставляет на запросы GET. Кроме того, поскольку метод не имеет параметров, он сопоставляется с URI, который не содержит *&quot;идентификатор&quot;* сегментом пути.

Чтобы получить продукт по Идентификатору, добавьте этот метод, чтобы `ProductsController` класса:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample7.cs)]

Это имя метода также начинается с &quot;получить&quot;, но метод будет иметь параметр с именем *идентификатор*. Этот параметр сопоставляется &quot;идентификатор&quot; сегмент пути URI. Платформа веб-API ASP.NET автоматически преобразует идентификатор в правильный тип данных (**int**) для параметра.

Метод GetProduct вызывает исключение типа **HttpResponseException** Если *идентификатор* является недопустимым. Это исключение будет преобразован средой в ошибку 404 (не найдено).

Наконец добавьте метод для поиска продуктов по категориям:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample8.cs)]

Если URI запроса содержит строку запроса, веб-API пытается сопоставить параметры запроса для параметров метода контроллера. Таким образом, URI в формате «api/products? категории =*категории*"будет сопоставлен этот метод.

## <a name="creating-a-resource"></a>Создание ресурса

Далее мы добавим метод `ProductsController` класса для создания нового продукта. Вот простая реализация метода:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample9.cs)]

Обратите внимание два аспекта этот метод:

- Имя метода начинается с &quot;Post... &quot;. Чтобы создать новый продукт, клиент отправляет запрос HTTP POST.
- Этот метод принимает параметр типа продукта. В веб-API параметры со сложными типами десериализуются из текста запроса. Следовательно мы ожидаем, чтобы клиент отправлял сериализованное представление объекта продукта, в формате XML или JSON.

Эта реализация будет работать, но он не дописан. В идеале хотелось бы, ответ HTTP, включая следующие:

- **Код ответа:** По умолчанию платформа веб-API задает код состояния отклика 200 (ОК). Но в соответствии с протоколом HTTP/1.1, когда запрос POST приводит к созданию ресурса, сервер должен возвращаться состояния 201 (создано).
- **Расположение:** Когда сервер создает ресурс, оно должно содержать URI нового ресурса в заголовке Location ответа.

Веб-API ASP.NET позволяет легко управлять сообщение HTTP-ответа. Вот улучшенную реализацию:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample10.cs)]

Обратите внимание, что тип возвращаемого значения метода теперь **HttpResponseMessage**. Путем возвращения **HttpResponseMessage** вместо продукта, можно управлять параметрами сообщение HTTP-ответа, включая код состояния и заголовок Location.

**CreateResponse** метод создает **HttpResponseMessage** и автоматически записывает сериализованное представление объекта продукта в тексте fo ответного сообщения.

> [!NOTE]
> В этом примере не проверяет `Product`. Сведения о проверке модели, см. в разделе [проверка модели в веб-API ASP.NET](../formats-and-model-binding/model-validation-in-aspnet-web-api.md).


## <a name="updating-a-resource"></a>Обновление ресурса

При обновлении продукта с PUT прост:

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample11.cs)]

Имя метода начинается с &quot;поместить... &quot;, поэтому веб-API соответствующих запросов PUT. Этот метод принимает два параметра: идентификатор продукта и обновленные продукта. *Идентификатор* параметр взят из пути URI и *продукта* параметр десериализации из текста запроса. По умолчанию платформа ASP.NET веб-API принимает простые типы параметров из маршрута и сложные типы из текста запроса.

## <a name="deleting-a-resource"></a>Удаление ресурса

Чтобы удалить ресурс, определите «удалить...» метод.

[!code-csharp[Main](creating-a-web-api-that-supports-crud-operations/samples/sample12.cs)]

Успешное завершение запроса на удаление, он может возвращать состояние 200 (ОК) с тело сущности, описывающая состояние; состояние 202 (принято), если удаление по-прежнему ожидающие; или состояния 204 (нет содержимого) без тела сущности. В этом случае `DeleteProduct` имеет метод `void` тип возвращаемого значения, поэтому веб-API ASP.NET автоматически преобразует это в состояние код 204 (нет содержимого).
