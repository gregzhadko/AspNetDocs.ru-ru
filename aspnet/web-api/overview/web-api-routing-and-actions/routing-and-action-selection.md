---
uid: web-api/overview/web-api-routing-and-actions/routing-and-action-selection
title: Выбор маршрутизации и действий в веб-API ASP.NET | Документация Майкрософт
author: MikeWasson
description: ''
ms.author: riande
ms.date: 12/14/2018
ms.assetid: bcf2d223-cb7f-411e-be05-f43e96a14015
msc.legacyurl: /web-api/overview/web-api-routing-and-actions/routing-and-action-selection
msc.type: authoredcontent
ms.openlocfilehash: 62114e56fb29e80c93b82dcb78ce2bc2a123a83b
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78446916"
---
# <a name="routing-and-action-selection-in-aspnet-web-api"></a>Выбор маршрутизации и действий в веб-API ASP.NET

по [Майк Уоссон](https://github.com/MikeWasson)

В этой статье описывается, как веб-API ASP.NET направляет HTTP-запрос к определенному действию на контроллере.

> [!NOTE]
> Общий обзор маршрутизации см. [в разделе Маршрутизация в веб-API ASP.NET](routing-in-aspnet-web-api.md).

В этой статье рассматриваются сведения о процессе маршрутизации. Если вы создадите проект веб-API и обнаружите, что некоторые запросы не направляются должным образом, надеюсь, эта статья поможет вам.

Маршрутизация включает три основных этапа:

1. Сопоставление URI с шаблоном маршрута.
2. Выбор контроллера.
3. Выбор действия.

Некоторые части процесса можно заменить собственными пользовательским поведением. В этой статье я опишу поведение по умолчанию. В конце я занимаю места, где можно настроить поведение.

## <a name="route-templates"></a>Шаблоны маршрутов

Шаблон маршрута похож на путь URI, но может содержать значения заполнителей, обозначенные фигурными скобками:

[!code-csharp[Main](routing-and-action-selection/samples/sample1.ps1)]

При создании маршрута можно указать значения по умолчанию для некоторых или всех заполнителей:

[!code-csharp[Main](routing-and-action-selection/samples/sample2.cs)]

Можно также предоставить ограничения, ограничивающие соответствие сегмента URI заполнительу.

[!code-csharp[Main](routing-and-action-selection/samples/sample3.js)]

Платформа пытается сопоставить сегменты в пути URI с шаблоном. Литералы в шаблоне должны точно совпадать. Заполнитель соответствует любому значению, если только не указаны ограничения. Платформа не соответствует другим частям URI, таким как имя узла или параметры запроса. Платформа выбирает первый маршрут в таблице маршрутов, соответствующий универсальному коду ресурса (URI).

Есть два специальных заполнителя: "{Controller}" и "{Action}".

- "{Controller}" — имя контроллера.
- "{Action}" предоставляет имя действия. В веб-API обычным соглашением является пропуск "{Action}".

### <a name="defaults"></a>Умолчания;

Если указать значения по умолчанию, маршрут будет соответствовать URI, в котором отсутствуют эти сегменты. Пример:

[!code-csharp[Main](routing-and-action-selection/samples/sample4.cs)]

URI `http://localhost/api/products/all` и `http://localhost/api/products` соответствуют предыдущему маршруту. В последнем URI отсутствует сегмент `{category}` присваивается значение по умолчанию `all`.

### <a name="route-dictionary"></a>Словарь маршрутов

Если платформа находит совпадение для URI, создается словарь, содержащий значение для каждого заполнителя. Ключи — это имена заполнителей, не включая фигурные скобки. Значения берутся из пути URI или из значений по умолчанию. Словарь хранится в объекте **ихттпраутедата** .

Во время этой фазы сопоставления маршрутов специальные заполнители "{Controller}" и "{Action}" обрабатываются точно так же, как и другие заполнители. Они просто хранятся в словаре с другими значениями.

Значение по умолчанию может быть специальным значением **раутепараметер. Optional**. Если заполнитель назначает это значение, это значение не добавляется в словарь маршрутов. Пример:

[!code-csharp[Main](routing-and-action-selection/samples/sample5.cs)]

Для пути URI "API/Products" словарь маршрутов будет содержать:

- Controller: "Products"
- Категория: "все"

Однако для «API/Products/Toys/123» словарь маршрутов будет содержать:

- Controller: "Products"
- Категория: "Toys"
- Идентификатор: "123"

Значения по умолчанию также могут включать значение, которое не отображается в любом месте шаблона маршрута. Если маршрут совпадает, это значение сохраняется в словаре. Пример:

[!code-csharp[Main](routing-and-action-selection/samples/sample6.cs)]

Если путь URI имеет значение "API/root/8", словарь будет содержать два значения:

- контроллер: "клиенты"
- Идентификатор: "8"

## <a name="selecting-a-controller"></a>Выбор контроллера

Выбор контроллера обрабатывается методом **ихттпконтроллерселектор. селектконтроллер** . Этот метод принимает экземпляр **HttpRequestMessage** и возвращает **хттпконтроллердескриптор**. Реализация по умолчанию предоставляется классом **дефаулсттпконтроллерселектор** . Этот класс использует простой алгоритм:

1. Просмотрите словарь маршрутов для ключа "контроллер".
2. Примите значение для этого ключа и добавьте строку "Controller", чтобы получить имя типа контроллера.
3. Найдите контроллер веб-API с этим именем типа.

Например, если словарь маршрутов содержит пару "ключ-значение" "Controller" = "Products", то тип контроллера — "Продуктсконтроллер". При отсутствии соответствующего типа или нескольких совпадений платформа возвращает клиенту ошибку.

В шаге 3 **дефаулсттпконтроллерселектор** использует интерфейс **ихттпконтроллертипересолвер** для получения списка типов контроллеров веб-API. Реализация **ихттпконтроллертипересолвер** по умолчанию возвращает все открытые классы, которые (a) реализуют **ихттпконтроллер**, (b) не являются абстрактными, а (c) имеют имя, заканчивающееся на "Controller".

## <a name="action-selection"></a>Выбор действия

После выбора контроллера платформа выбирает действие, вызывая метод **ихттпактионселектор. селектактион** . Этот метод принимает **HttpControllerContext** и возвращает **хттпактиондескриптор**.

Реализация по умолчанию предоставляется классом **апиконтроллерактионселектор** . Чтобы выбрать действие, оно будет выглядеть следующим образом:

- Метод HTTP, используемый для запроса.
- Заполнитель "{Action}" в шаблоне маршрута, если он есть.
- Параметры действий на контроллере.

Прежде чем взглянуть на алгоритм выбора, необходимо понять некоторые моменты, связанные с действиями контроллера.

**Какие методы в контроллере считаются "действиями"?** При выборе действия платформа проверяет только открытые методы экземпляра на контроллере. Кроме того, в нем исключены методы ["специального имени"](https://msdn.microsoft.com/library/system.reflection.methodbase.isspecialname) (конструкторы, события, перегрузки операторов и т. д.) и методы, унаследованные от класса **ApiController** .

**Методы HTTP.** Платформа выбирает только те действия, которые соответствуют HTTP-методу запроса, определяется следующим образом:

1. Метод HTTP можно указать с помощью атрибута: **акцептвербс**, **хттпделете**, **HttpGet**, **хттфеад**, **хттпоптионс**, **хттппатч**, **HttpPost**или **хттппут**.
2. В противном случае, если имя метода контроллера начинается с «Get», «POST», «WHERE», «DELETE», «Head», «Options» или «patch», то по соглашению действие поддерживает этот метод HTTP.
3. Если ни один из вышеперечисленных методов не указан, метод поддерживает POST.

**Привязки параметров.** Привязка параметра — это то, как веб-API создает значение для параметра. Ниже приведено правило по умолчанию для привязки параметров.

- Простые типы берутся из универсального кода ресурса (URI).
- Сложные типы берутся из текста запроса.

Простые типы включают все [.NET Framework примитивные типы](https://msdn.microsoft.com/library/system.type.isprimitive), а также **DateTime**, **Decimal**, **GUID**, **String**и **TimeSpan**. Для каждого действия не более одного параметра может считывать текст запроса.

> [!NOTE]
> Можно переопределить правила привязки по умолчанию. См. раздел [Привязка параметра WebAPI](https://blogs.msdn.com/b/jmstall/archive/2012/05/11/webapi-parameter-binding-under-the-hood.aspx).

В этом примере используется алгоритм выбора действий.

1. Создайте список всех действий на контроллере, которые соответствуют методу HTTP-запроса.
2. Если словарь маршрутов содержит запись Action, удалите действия, имя которых не соответствует этому значению.
3. Попробуйте сопоставить параметры действия с URI следующим образом: 

    1. Для каждого действия получите список параметров, которые являются простым типом, где привязка получает параметр из универсального кода ресурса (URI). Исключите необязательные параметры.
    2. В этом списке попытайтесь найти совпадение для каждого имени параметра либо в словаре маршрутов, либо в строке запроса URI. Совпадения не учитывают регистр и не зависят от порядка параметров.
    3. Выберите действие, в котором каждый параметр в списке имеет совпадение в URI.
    4. Если одно действие соответствует этим критериям, выберите его с наибольшим совпадением параметров.
4. Пропускать действия с атрибутом **[unaction]** .

Действие #3, вероятно, является самым запутанным. Основная идея состоит в том, что параметр может получить свое значение из универсального кода ресурса (URI), из тела запроса или из пользовательской привязки. Для параметров, полученных из универсального кода ресурса (URI), мы хотим убедиться, что универсальный код ресурса (URI) действительно содержит значение для этого параметра либо в пути (через словарь маршрутов), либо в строке запроса.

Например, рассмотрим следующее действие:

[!code-csharp[Main](routing-and-action-selection/samples/sample7.cs)]

Параметр *ID* привязывается к универсальному коду ресурса (URI). Таким образом, это действие может совпадать только с URI, содержащим значение для "ID", в словаре маршрутов или в строке запроса.

Необязательные параметры являются исключением, так как они являются необязательными. Для необязательного параметра, если привязка не может получить значение из универсального кода ресурса (URI).

Сложные типы являются исключением по другой причине. Сложный тип может быть привязан только к URI через пользовательскую привязку. Но в этом случае платформа не может заранее определить, будет ли параметр привязан к конкретному универсальному коду ресурса (URI). Чтобы выяснить это, необходимо вызвать привязку. Цель алгоритма выбора заключается в выборе действия из статического описания перед вызовом любых привязок. Поэтому сложные типы исключаются из алгоритма сопоставления.

После выбора действия вызываются все привязки параметров.

Сводка.

- Действие должно соответствовать методу HTTP запроса.
- Имя действия должно соответствовать записи "Action" в словаре маршрутов, если он есть.
- При каждом параметре действия, если параметр берется из универсального кода ресурса (URI), имя параметра должно быть найдено либо в словаре маршрутов, либо в строке запроса URI. (Необязательные параметры и параметры со сложными типами исключаются.)
- Попробуйте сопоставить наибольшее количество параметров. Лучшим совпадением может быть метод без параметров.

## <a name="extended-example"></a>Расширенный пример

Маршрутизации

[!code-csharp[Main](routing-and-action-selection/samples/sample8.cs)]

Контроллер:

[!code-csharp[Main](routing-and-action-selection/samples/sample9.cs)]

HTTP-запрос:

[!code-console[Main](routing-and-action-selection/samples/sample10.cmd)]

### <a name="route-matching"></a>Сопоставление маршрутов

Универсальный код ресурса (URI) соответствует маршруту с именем «Дефаултапи». Словарь маршрутов содержит следующие записи:

- Controller: "Products"
- Идентификатор: "1"

Словарь маршрутов не содержит параметров строки запроса "Version" и "Details", но они по-прежнему будут учитываться во время выбора действия.

### <a name="controller-selection"></a>Выбор контроллера

Из записи контроллера в словаре маршрутов типом контроллера является `ProductsController`.

### <a name="action-selection"></a>Выбор действия

HTTP-запрос является запросом GET. Действия контроллера, поддерживающие GET, — это `GetAll`, `GetById`и `FindProductsByName`. Словарь маршрутов не содержит записи для "Action", поэтому не нужно сопоставлять имя действия.

Затем мы пытаемся сопоставить имена параметров для действий, просмотрев только действия GET.

| Действие | Параметры для сопоставления |
| --- | --- |
| `GetAll` | none |
| `GetById` | идентификатор |
| `FindProductsByName` | безымян |

Обратите внимание, что параметр *версии* `GetById` не рассматривается, так как это необязательный параметр.

Метод `GetAll` соответствует тривиальному. Метод `GetById` также соответствует, так как словарь маршрутов содержит "ID". Метод `FindProductsByName` не соответствует.

Метод `GetById` WINS, так как он соответствует одному параметру и не имеет параметров для `GetAll`. Метод вызывается со следующими значениями параметров:

- *ИД* = 1
- *версия* = 1,5

Обратите внимание, что несмотря на то, что *версия* не использовалась в алгоритме выбора, значение параметра берется из строки запроса URI.

## <a name="extension-points"></a>Точки расширения

Веб-API предоставляет точки расширения для некоторых частей процесса маршрутизации.

| Интерфейс | Description |
| --- | --- |
| **ихттпконтроллерселектор** | Выбирает контроллер. |
| **ихттпконтроллертипересолвер** | Возвращает список типов контроллеров. **Дефаулсттпконтроллерселектор** выбирает тип контроллера из этого списка. |
| **иассемблиесресолвер** | Возвращает список сборок проекта. Интерфейс **ихттпконтроллертипересолвер** использует этот список для поиска типов контроллеров. |
| **ихттпконтроллерактиватор** | Создает новые экземпляры контроллера. |
| **ихттпактионселектор** | Выбирает действие. |
| **ихттпактионинвокер** | Вызывает действие. |

Чтобы предоставить собственную реализацию для любого из этих интерфейсов, используйте коллекцию **Services** для объекта **HttpConfiguration** :

[!code-csharp[Main](routing-and-action-selection/samples/sample11.cs)]
