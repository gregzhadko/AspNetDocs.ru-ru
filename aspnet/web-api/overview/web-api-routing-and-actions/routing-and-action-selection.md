---
uid: web-api/overview/web-api-routing-and-actions/routing-and-action-selection
title: Маршрутизация и выбор действий в веб-API ASP.NET | Документация Майкрософт
author: MikeWasson
description: ''
ms.author: riande
ms.date: 12/14/2018
ms.assetid: bcf2d223-cb7f-411e-be05-f43e96a14015
msc.legacyurl: /web-api/overview/web-api-routing-and-actions/routing-and-action-selection
msc.type: authoredcontent
ms.openlocfilehash: ce54181996376cb5dde3b91c10c16f33b3c6a570
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57058921"
---
<a name="routing-and-action-selection-in-aspnet-web-api"></a>Маршрутизация и выбор действий в веб-API ASP.NET
====================
по [Майк Уоссон](https://github.com/MikeWasson)

В этой статье описывается, как веб-API ASP.NET направляет HTTP-запрос для определенного действия на контроллере.

> [!NOTE]
> Общий обзор маршрутизации, см. в разделе [маршрутизации в ASP.NET Web API](routing-in-aspnet-web-api.md).


В этой статье рассматриваются аспекты процесс маршрутизации. Если вы создаете проект веб-API и проверили, что некоторые запросы не поймите маршрутизироваться должным образом, будем надеяться, что эта статья поможет.

Маршрутизация имеет три основных этапа:

1. Сопоставлении по URI в шаблон маршрута.
2. Выбор контроллера.
3. Выберите действие.

Некоторые части процесса можно заменить собственные пользовательские поведения. В этой статье я опишу поведение по умолчанию. В итоге я Обратите внимание, местах, где можно настроить поведение.

## <a name="route-templates"></a>Шаблоны маршрутов

Шаблон маршрута будет выглядеть пути URI, но он может иметь значение заполнителя, обозначаются с помощью фигурных скобок:

[!code-csharp[Main](routing-and-action-selection/samples/sample1.ps1)]

При создании маршрута, можно предоставить значения по умолчанию для некоторых или всех заполнителей:

[!code-csharp[Main](routing-and-action-selection/samples/sample2.cs)]

Также можно указать ограничения, которые ограничивают как сегмент URI может соответствовать заполнитель:

[!code-csharp[Main](routing-and-action-selection/samples/sample3.js)]

Платформа framework пытается соответствовать сегменты в пути URI к шаблону. Литералы в шаблоне должны точно совпадать. Заполнитель совпадает с любым значением, если не указать ограничения. Другие части URI, например имя узла или параметры запроса не совпадает с платформой. Платформа framework выбирает первый маршрут в таблице маршрутов, соответствующий URI.

Существуют два специальных заполнителя: «{controller}» и «{action}».

- «{controller}» предоставляет имя контроллера.
- «{action}» предоставляет имя действия. В веб-API и обычных соглашений является пропуск «{action}».

### <a name="defaults"></a>расписания

Если вы предоставляете значения по умолчанию, маршрут будет соответствовать URI, который отсутствует в сегментах. Пример:

[!code-csharp[Main](routing-and-action-selection/samples/sample4.cs)]

Коды URI `http://localhost/api/products/all` и `http://localhost/api/products` соответствует маршруту выше. В последнем URI, отсутствующий `{category}` сегмент назначается значение по умолчанию `all`.

### <a name="route-dictionary"></a>Словарь маршрута

Если платформа обнаруживает соответствие для URI, он создает словарь, содержащий значение для каждого местозаполнителя. Ключи являются имена-заполнители, не включая фигурные скобки. Значения берутся из пути URI или значения по умолчанию. Словарь хранится в **IHttpRouteData** объекта.

На этом этапе сопоставление маршрутов специальными «{controller}» и «{action}» заполнители, обрабатываются так же, как другие заполнители. Просто они хранятся в словаре с другими значениями.

По умолчанию могут иметь особое значение **RouteParameter.Optional**. Если заполнитель получает это значение, значение не добавляется в словарь маршрута. Пример:

[!code-csharp[Main](routing-and-action-selection/samples/sample5.cs)]

Для пути URI «api/продукты» будет содержать словарь маршрута:

- контроллер: «продукты»
- Категория: «все»

Для «api/продукты/toys/123» Однако словарь маршрута будет содержать:

- контроллер: «продукты»
- Категория: «toys»
- Идентификатор: "123"

Значения по умолчанию также может включать значение, которое не встречается в любом месте в шаблоне маршрута. Если этот маршрут соответствует, это значение хранится в словаре. Пример:

[!code-csharp[Main](routing-and-action-selection/samples/sample6.cs)]

Если пути URI «корневой/api/8», словарь будет содержать два значения:

- контроллер: «customers»
- Идентификатор: "8"

## <a name="selecting-a-controller"></a>Выбор контроллера

Выбор контроллера обрабатывается **IHttpControllerSelector.SelectController** метод. Этот метод принимает **HttpRequestMessage** экземпляра и возвращает **HttpControllerDescriptor**. Реализация по умолчанию предоставляется **DefaultHttpControllerSelector** класса. Этот класс использует простой алгоритм:

1. Искать в словаре маршрутов для ключа «controller».
2. Значение для этого ключа, добавьте строку «Controller», чтобы получить имя типа контроллера.
3. Найдите контроллер Web API с таким именем типа.

Например если маршрут словарь содержит пары "ключ значение"«controller» = «продукты», тип контроллера является «ProductsController». Если отсутствует соответствующий тип или несколько соответствий, платформа возвращает ошибку клиенту.

Для шага 3 **DefaultHttpControllerSelector** использует **IHttpControllerTypeResolver** интерфейса для получения списка типов контроллера веб-API. Реализация по умолчанию **IHttpControllerTypeResolver** возвращает все открытые классы, реализующие (a) **IHttpController**, (б): не абстрактный и (c) иметь имя, которое заканчивается на «Controller».

## <a name="action-selection"></a>Выбор действия

После выбора контроллера, платформа framework выбирает действие, вызвав **IHttpActionSelector.SelectAction** метод. Этот метод принимает **HttpControllerContext** и возвращает **HttpActionDescriptor**.

Реализация по умолчанию предоставляется **ApiControllerActionSelector** класса. Чтобы выбрать действие, она проверяет следующее:

- Метод HTTP запроса.
- Заполнитель «{action}» в шаблоне маршрута, если он имеется.
- Параметры действия на контроллере.

Перед тем как рассмотреть алгоритм выбора, мы должны знать кое о действий контроллера.

**Какие методы на контроллере, считаются «действия»?** При выборе действия, платформа считывает только открытые методы экземпляра на контроллере. Кроме того, он исключает [«специальным именем»](https://msdn.microsoft.com/library/system.reflection.methodbase.isspecialname) методы (конструкторы, события, перегрузки операторов и т. д.) и методы, унаследованные от **ApiController** класса.

**Методы HTTP.** Платформа framework выбирает только действий, которые соответствуют метод HTTP запроса, определяется следующим образом:

1. Можно указать метод HTTP с атрибутом: **AcceptVerbs**, **HttpDelete**, **HttpGet**, **HttpHead**, **HttpOptions**, **HttpPatch**, **HttpPost**, или **HttpPut**.
2. В противном случае если имя метода контроллера начинается с «Get», «Post», «Put», «Удалить», «Head», «Параметры» или «Исправления», затем по соглашению, поддерживаемые действием этого метода HTTP.
3. Если ни один из перечисленных выше, поддерживает метод POST.

**Привязки параметров.** Привязка параметра имеет, как веб-API создает значение для параметра. Вот правило по умолчанию для привязки параметров:

- Простые типы, взяты из URI.
- Сложные типы, взяты из текста запроса.

Простые типы включают все [простые типы .NET Framework](https://msdn.microsoft.com/library/system.type.isprimitive), а также **даты и времени**, **десятичное**, **Guid**, **строка** , и **TimeSpan**. Для каждого действия не более одного параметра может считывать текст запроса.

> [!NOTE]
> Это можно переопределить правила привязки по умолчанию. См. в разделе [привязки параметров веб-API за кулисами](https://blogs.msdn.com/b/jmstall/archive/2012/05/11/webapi-parameter-binding-under-the-hood.aspx).


С учетом этого Вот алгоритм выбора действия.

1. Создайте список всех действий на контроллере, который соответствует метод запроса HTTP.
2. Если словарь маршрута имеет запись «действия», удалите действия, имя которого соответствует ли это значение.
3. Повторите для сопоставления параметров действия на URI следующим образом: 

    1. Для каждого действия получение списка параметров, которые являются простой тип, где привязка получает параметр из URI. Исключите необязательные параметры.
    2. В этом списке попробуйте найти совпадения для каждого параметра, словарь маршрута или в строке запроса URI. Совпадения учитывается регистр и не зависят от порядка параметров.
    3. Выберите действие, где каждый параметр в списке, имеет соответствие в URI.
    4. Если более одного действия соответствует этим критериям, выберите любой из с большинство параметров соответствия.
4. Игнорировать действия с **[NonAction]** атрибута.

Шаг #3 является, вероятно, наиболее путаницу. Основная идея заключается в том, что его значение можно получить параметр из URI, из текста запроса или из пользовательской привязки. Для параметров, полученных из URI мы хотим убедиться, что URI фактически содержит значение для этого параметра, либо в пути (через словарь маршрута), либо в строке запроса.

Например рассмотрим следующее действие:

[!code-csharp[Main](routing-and-action-selection/samples/sample7.cs)]

*Идентификатор* привязывается параметр URI. Таким образом это действие может соответствовать только URI, содержащий значение для «id», либо в словаре маршрутов, либо в строке запроса.

Необязательные параметры являются исключением, так как они являются необязательными. Для необязательного параметра это нормально привязку невозможно получить значение из URI.

Сложные типы являются исключением по другой причине. Сложный тип может быть привязан только к URL-АДРЕСУ через пользовательскую привязку. Но в этом случае платформа не может знать заранее ли параметр будет привязан к определенному URI. Чтобы узнать, ей потребуется вызывать привязку. Алгоритм выбора призван выберите действие из статических описания, перед вызовом любой привязки. Таким образом сложные типы, исключаются из алгоритм сопоставления.

После выбора действия вызываются все привязки параметров.

Сводка:

- Действие должно соответствовать метод HTTP запроса.
- Имя действия должно соответствовать «действие» запись в словаре маршрутов, при его наличии.
- Для каждого параметра действия Если параметр взят из URI, затем имя параметра необходимо найти в словаре маршрутов или в строке запроса URI. (Необязательные параметры и параметры со сложными типами, исключаются.)
- Попробуйте в соответствии с максимальным числом параметров. Возможно, наиболее подходящий метод без параметров.

## <a name="extended-example"></a>Развернутый пример

Маршруты:

[!code-csharp[Main](routing-and-action-selection/samples/sample8.cs)]

Контроллер:

[!code-csharp[Main](routing-and-action-selection/samples/sample9.cs)]

HTTP-запроса:

[!code-console[Main](routing-and-action-selection/samples/sample10.cmd)]

### <a name="route-matching"></a>Маршрутизации в компоненте

URI соответствует маршрут с именем «DefaultApi». Словарь маршрута содержит следующие записи:

- контроллер: «продукты»
- Идентификатор: "1"

Словарь маршрута не содержит параметры строки запроса, «версия» и «подробности», но они по-прежнему будут учитываться во время выбора действия.

### <a name="controller-selection"></a>Выбор контроллера

Из записи «controller» в словаре маршрутов, является тип контроллера `ProductsController`.

### <a name="action-selection"></a>Выбор действия

HTTP-запрос является запросом GET. Действия контроллера, которые поддерживают GET являются `GetAll`, `GetById`, и `FindProductsByName`. Словарь маршрута не содержит запись для «действия», так что мы не должны совпадать с именем действия.

Далее попытка сопоставить имена параметров для действий, искать только действия GET.

| Действие | Параметры соответствия |
| --- | --- |
| `GetAll` | Нет |
| `GetById` | «Идентификатор» |
| `FindProductsByName` | «name» |

Обратите внимание, что *версии* параметр `GetById` не является, так как это необязательный параметр.

`GetAll` Тривиально соответствующий метод. `GetById` Метод также соответствует, так как «id» содержит словарь маршрута. `FindProductsByName` Метод не соответствует.

`GetById` Метод wins, так как он соответствует один параметр, и без параметров для `GetAll`. Метод вызывается с приведенными ниже значениями параметров:

- *Идентификатор* = 1
- *версия* = 1.5

Обратите внимание, что даже если *версии* не использовался в алгоритм выбора, значение параметра берется из строки запроса URI.

## <a name="extension-points"></a>Точки расширения

Веб-API предоставляет точки расширения для некоторых этапов процесса маршрутизации.

| Интерфейс | Описание: |
| --- | --- |
| **IHttpControllerSelector** | Выбирает контроллер. |
| **IHttpControllerTypeResolver** | Получает список типов контроллеров. **DefaultHttpControllerSelector** выбирает тип контроллера из этого списка. |
| **IAssembliesResolver** | Возвращает список сборок, проект. **IHttpControllerTypeResolver** интерфейс использует этот список для поиска типов контроллеров. |
| **IHttpControllerActivator** | Создает новые экземпляры объектов controller. |
| **IHttpActionSelector** | Выбирает действие. |
| **IHttpActionInvoker** | Вызывает действие. |

Чтобы предоставить собственную реализацию для любого из этих интерфейсов, используйте **служб** коллекции **HttpConfiguration** объекта:

[!code-csharp[Main](routing-and-action-selection/samples/sample11.cs)]
