---
uid: web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2
title: Маршрутизация атрибутов в веб-API ASP.NET 2 | Документация Майкрософт
author: MikeWasson
description: ''
ms.author: riande
ms.date: 01/20/2014
ms.assetid: 979d6c9f-0129-4e5b-ae56-4507b281b86d
msc.legacyurl: /web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2
msc.type: authoredcontent
ms.openlocfilehash: 7da1805d8a7066e82743dc9bd7e024cc9813ee89
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78447000"
---
# <a name="attribute-routing-in-aspnet-web-api-2"></a>Маршрутизация атрибутов в веб-API ASP.NET 2

по [Майк Уоссон](https://github.com/MikeWasson)

*Маршрутизация* — это то, как веб-API сопоставляет URI с действием. Веб-API 2 поддерживает новый тип маршрутизации, называемый *маршрутизацией атрибутов*. Как следует из названия, маршрутизация атрибутов использует атрибуты для определения маршрутов. Маршрутизация атрибутов обеспечивает более полный контроль над URI в веб-API. Например, можно легко создать URI, описывающие иерархии ресурсов.

Более ранний стиль маршрутизации, называемый маршрутизацией на основе соглашений, по-прежнему поддерживается полностью. На самом деле можно сочетать оба метода в одном проекте.

В этом разделе показано, как включить маршрутизацию атрибутов и приводятся различные параметры маршрутизации атрибутов. Полное руководство, в котором используется маршрутизация атрибутов, см. в разделе [создание REST API с маршрутизацией атрибутов в веб-API 2](create-a-rest-api-with-attribute-routing.md).

## <a name="prerequisites"></a>предварительные требования

[Visual Studio 2017](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=button+cta&utm_content=download+vs2017) Community, Professional или Enterprise Edition

Кроме того, можно использовать диспетчер пакетов NuGet для установки необходимых пакетов. В меню **Сервис** в Visual Studio выберите **Диспетчер пакетов NuGet**, а затем выберите **консоль диспетчера пакетов**. В окне консоли диспетчера пакетов введите следующую команду:

`Install-Package Microsoft.AspNet.WebApi.WebHost`

<a id="why"></a>
## <a name="why-attribute-routing"></a>Зачем нужна маршрутизация атрибутов?

Первый выпуск веб-API использовал маршрутизацию *на основе соглашений* . В этом типе маршрутизации определяется один или несколько шаблонов маршрутов, которые по сути являются параметризованными строками. Когда платформа получает запрос, она сопоставляет URI с шаблоном маршрута. (Дополнительные сведения о маршрутизации на основе соглашений см. [в разделе Маршрутизация в веб-API ASP.NET](routing-in-aspnet-web-api.md).

Одним из преимуществ маршрутизации на основе соглашений является то, что шаблоны определяются в одном месте, а правила маршрутизации применяются одинаково ко всем контроллерам. К сожалению, маршрутизация на основе соглашений делает несложным поддержку определенных шаблонов URI, общих для интерфейсов API RESTFUL. Например, ресурсы часто содержат дочерние ресурсы: у клиентов есть заказы, у них есть актеры, авторы книг и т. д. Естественно создать универсальные коды ресурса (URI), отражающие эти отношения:

`/customers/1/orders`

Этот тип URI трудно создать с помощью маршрутизации на основе соглашений. Хотя это и может быть сделано, результаты не масштабируются, если имеется много контроллеров или типов ресурсов.

С помощью маршрутизации атрибутов можно просто определить маршрут для этого URI. Просто добавьте атрибут к действию контроллера:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample1.cs)]

Ниже приведены некоторые другие шаблоны, которые упрощают маршрутизацию атрибутов.

**Управление версиями API**

В этом примере "/API/V1/Products" будет направляться на другой контроллер, чем "/API/v2/Products".

`/api/v1/products`
`/api/v2/products`

**Перегруженные сегменты URI**

В этом примере "1" — номер заказа, но "ожидание" сопоставляется с коллекцией.

`/orders/1`
`/orders/pending`

**Несколько типов параметров**

В этом примере "1" — номер заказа, но "2013/06/16" указывает дату.

`/orders/1`
`/orders/2013/06/16`

<a id="enable"></a>
## <a name="enabling-attribute-routing"></a>Включение маршрутизации атрибутов

Чтобы включить маршрутизацию атрибутов, вызовите **мафттпаттрибутераутес** во время настройки. Этот метод расширения определен в классе **System. Web. http. хттпконфигуратионекстенсионс** .

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample2.cs)]

Маршрутизацию атрибутов можно сочетать с маршрутизацией [на основе соглашения](routing-in-aspnet-web-api.md) . Чтобы определить маршруты на основе соглашения, вызовите метод **мафттпрауте** .

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample3.cs)]

Дополнительные сведения о настройке веб-API см. в разделе [настройка веб-API ASP.NET 2](../advanced/configuring-aspnet-web-api.md).

<a id="config"></a>
### <a name="note-migrating-from-web-api-1"></a>Примечание. Переход с веб-API 1

До веб-API 2 шаблоны проектов веб-API создавали код следующим образом:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample4.cs)]

Если включена маршрутизация атрибутов, этот код вызовет исключение. При обновлении существующего проекта веб-API для использования маршрутизации атрибутов обязательно обновите этот код конфигурации следующим образом:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample5.cs?highlight=4)]

> [!NOTE]
> Дополнительные сведения см. [в разделе Настройка веб-API с ASP.NET размещением](../advanced/configuring-aspnet-web-api.md#webhost).

<a id="add-routes"></a>
## <a name="adding-route-attributes"></a>Добавление атрибутов маршрута

Ниже приведен пример маршрута, определенного с помощью атрибута.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample6.cs)]

Строка &quot;Customers/{customerId}/Orders&quot; является шаблоном универсального кода ресурса (URI) для маршрута. Веб-API пытается сопоставить универсальный код ресурса (URI) запроса с шаблоном. В этом примере "Customers" и "Orders" являются сегментами литералов, а "{customerId}" является параметром переменной. Следующий URI будет соответствовать этому шаблону:

- `http://localhost/customers/1/orders`
- `http://localhost/customers/bob/orders`
- `http://localhost/customers/1234-5678/orders`

Сопоставление можно ограничить с помощью [ограничений](#constraints), описанных далее в этом разделе.

Обратите внимание, что параметр &quot;{customerId}&quot; в шаблоне маршрута соответствует имени параметра *customerId* в методе. Когда веб-API вызывает действие контроллера, он пытается привязать параметры маршрута. Например, если URI `http://example.com/customers/1/orders`, веб-API пытается привязать значение "1" к параметру *customerId* в действии.

Шаблон URI может иметь несколько параметров:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample7.cs)]

Все методы контроллера, не имеющие атрибута Route, используют маршрутизацию на основе соглашений. Таким образом, можно объединить оба типа маршрутизации в одном проекте.

## <a name="http-methods"></a>Методы HTTP

Веб-API также выбирает действия на основе метода HTTP запроса (GET, POST и т. д.). По умолчанию веб-API ищет совпадение без учета регистра с началом имени метода контроллера. Например, метод контроллера с именем `PutCustomers` соответствует запросу HTTP-размещения.

Это соглашение можно переопределить, добавив метод с помощью следующих атрибутов:

- **[Хттпделете]**
- **[HttpGet]**
- **[Хттфеад]**
- **[Хттпоптионс]**
- **[Хттппатч]**
- **HttpPost**
- **[Хттппут]**

В следующем примере метод Креатебук сопоставляется с запросами HTTP POST.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample8.cs)]

Для всех других методов HTTP, включая нестандартные методы, используйте атрибут **акцептвербс** , который принимает список методов HTTP.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample9.cs)]

<a id="prefixes"></a>
## <a name="route-prefixes"></a>Префиксы маршрутов

Часто маршруты в контроллере начинаются с одного и того же префикса. Пример:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample10.cs)]

Общий префикс для всего контроллера можно задать с помощью атрибута **[RoutePrefix]** :

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample11.cs)]

Используйте тильду (~) в атрибуте Method, чтобы переопределить префикс маршрута:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample12.cs)]

Префикс маршрута может включать параметры:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample13.cs)]

<a id="constraints"></a>
## <a name="route-constraints"></a>Ограничения маршрута

Ограничения маршрутов позволяют ограничить способ сопоставления параметров в шаблоне маршрута. Общий синтаксис — &quot;{параметр: Constraint}&quot;. Пример:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample14.cs)]

В этом случае первый маршрут будет выбран, только если идентификатор &quot;&quot; сегмент URI является целым числом. В противном случае будет выбран второй маршрут.

В следующей таблице перечислены поддерживаемые ограничения.

| Ограничение | Description | Пример |
| --- | --- | --- |
| альфа | Соответствует символам латинского алфавита в верхнем или нижнем регистре (a – z, A – Z) | {КС:Алфа} |
| bool | Соответствует логическому значению. | {КС:бул} |
| DATETIME | Соответствует значению **даты и времени** . | {КС:датетиме} |
| Decimal | Соответствует десятичному значению. | {КС:деЦимал} |
| double | Соответствует 64-разрядному значению с плавающей запятой. | {КС:даубле} |
| FLOAT | Соответствует 32-разрядному значению с плавающей запятой. | {КС:флоат} |
| guid | Соответствует значению GUID. | {КС:гуид} |
| INT | Соответствует 32-разрядному целому значению. | {КС:Инт} |
| length | Соответствует строке с указанной длиной или в пределах указанного диапазона длин. | {КС:ленгс (6)} {КС:ленгс (1, 20)} |
| long | Соответствует 64-разрядному целому значению. | {КС:Лонг} |
| max | Соответствует целочисленному значению с максимальным значением. | {КС:Макс (10)} |
| MaxLength | Соответствует строке с максимальной длиной. | {КС:максленгс (10)} |
| Min | Соответствует целочисленному значению с минимальным значением. | {КС:мин (10)} |
| MinLength | Соответствует строке с минимальной длиной. | {КС:минленгс (10)} |
| range | Соответствует целому числу в диапазоне значений. | {КС:ранже (10, 50)} |
| regex | Соответствует регулярному выражению. | {КС:режекс (^ \d{3}-\d{3}-\d{4}$)} |

Обратите внимание, что некоторые ограничения, такие как &quot;min&quot;, принимают аргументы в круглых скобках. К параметру можно применить несколько ограничений, разделенных двоеточием.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample15.cs)]

### <a name="custom-route-constraints"></a>Пользовательские ограничения маршрутов

Можно создать пользовательские ограничения маршрута, реализовав интерфейс **ихттпраутеконстраинт** . Например, следующее ограничение ограничит параметр до ненулевого целочисленного значения.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample16.cs)]

В следующем коде показано, как зарегистрировать ограничение:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample17.cs)]

Теперь можно применить ограничение к маршрутам:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample18.cs)]

Также можно заменить весь класс **дефаултинлинеконстраинтресолвер** , реализовав интерфейс **иинлинеконстраинтресолвер** . Это приведет к замене всех встроенных ограничений, если только реализация **иинлинеконстраинтресолвер** специально не добавит их.

<a id="optional"></a>
## <a name="optional-uri-parameters-and-default-values"></a>Необязательные параметры URI и значения по умолчанию

Параметр URI можно сделать необязательным, добавив вопросительный знак в параметр Route. Если параметр маршрута является необязательным, необходимо определить значение по умолчанию для параметра метода.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample19.cs)]

В этом примере `/api/books/locale/1033` и `/api/books/locale` возвращают один и тот же ресурс.

Кроме того, можно указать значение по умолчанию в шаблоне маршрута следующим образом:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample20.cs)]

Это почти так же, как в предыдущем примере, но при применении значения по умолчанию существует небольшая разница в поведении.

- В первом примере ("{LCID: int?}") значение по умолчанию 1033 присваивается непосредственно параметру метода, поэтому параметр будет иметь это точное значение.
- Во втором примере ("{LCID: int = 1033}") значение по умолчанию "1033" проходит процесс привязки модели. Связыватель модели по умолчанию преобразует "1033" в числовое значение 1033. Однако можно подключить пользовательский связыватель модели, который может сделать что-то другое.

(В большинстве случаев, если в конвейере нет пользовательских связывателей модели, эти две формы будут эквивалентны.)

<a id="route-names"></a>
## <a name="route-names"></a>Имена маршрутов

В веб-API у каждого маршрута есть имя. Имена маршрутов удобно использовать для создания ссылок, чтобы можно было включить ссылку в HTTP-ответ.

Чтобы указать имя маршрута, задайте свойство **Name** атрибута. В следующем примере показано, как задать имя маршрута, а также как использовать имя маршрута при создании ссылки.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample21.cs)]

<a id="order"></a>
## <a name="route-order"></a>Порядок маршрутов

Когда платформа пытается сопоставить URI с маршрутом, он оценивает маршруты в определенном порядке. Чтобы указать порядок, задайте свойство **Order** для атрибута Route. Значения меньшего уровня оцениваются первыми. Значение порядка по умолчанию равно нулю.

Вот как определяется общее упорядочение:

1. Сравните свойство **Order** атрибута Route.
2. Взгляните на каждый сегмент URI в шаблоне маршрута. Для каждого сегмента выполните следующий порядок:

    1. Литеральные сегменты.
    2. Параметры маршрутизации с ограничениями.
    3. Параметры маршрутизации без ограничений.
    4. Сегменты параметра-шаблона с ограничениями.
    5. Сегменты параметров с подстановочными знаками без ограничений.
3. В случае с привязкум маршруты упорядочиваются по порядковому номеру строки ([OrdinalIgnoreCase](https://msdn.microsoft.com/library/system.stringcomparer.ordinalignorecase.aspx)) шаблона маршрута без учета регистра.

Ниже приведен пример. Предположим, вы определили следующий контроллер:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample22.cs)]

Эти маршруты упорядочиваются следующим образом.

1. заказы/подробности
2. Orders/{ID}
3. Orders/{customerName}
4. Orders/{\*Date}
5. заказы/ожидание

Обратите внимание, что «Details» — это литеральный сегмент, который отображается перед «{ID}», но «ожидание» отображается последним, так как свойство **Order** имеет значение 1. (В этом примере предполагается, что клиенты с именами «Details» и «Pending» отсутствуют. Как правило, старайтесь не использовать неоднозначные маршруты. В этом примере лучше использовать шаблон маршрута для `GetByCustomer` — "Customers/{customerName}").
