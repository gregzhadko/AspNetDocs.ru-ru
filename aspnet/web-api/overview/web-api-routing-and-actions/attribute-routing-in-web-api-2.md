---
uid: web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2
title: Маршрутизация в ASP.NET Web API 2 атрибутов | Документация Майкрософт
author: MikeWasson
description: ''
ms.author: riande
ms.date: 01/20/2014
ms.assetid: 979d6c9f-0129-4e5b-ae56-4507b281b86d
msc.legacyurl: /web-api/overview/web-api-routing-and-actions/attribute-routing-in-web-api-2
msc.type: authoredcontent
ms.openlocfilehash: 65e2268418501f89a77a0ba20f7960a618c2e9b7
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59405461"
---
# <a name="attribute-routing-in-aspnet-web-api-2"></a>Маршрутизация в ASP.NET Web API 2 с помощью атрибутов

по [Майк Уоссон](https://github.com/MikeWasson)

*Маршрутизация* является как веб-API сопоставляет URI с действием. Веб-API 2 поддерживает новый тип маршрутизации, вызывается *маршрутизации с помощью атрибутов*. Как и предполагает название, маршрутизация с помощью атрибутов использует атрибуты для определения маршрутов. Маршрутизация с помощью атрибутов предоставляет больший контроль над коды URI в веб-API. Например можно легко создать URI, которые описывают иерархии ресурсов.

Более ранние стиль маршрутизации, вызывается на основе соглашений маршрутизации, по-прежнему полностью поддерживается. На самом деле можно сочетать оба способа в том же проекте.

В этом разделе показано, как включить маршрутизацию атрибутов и описываются различные параметры для маршрутизации с помощью атрибутов. End-to-end учебник, в котором используется маршрутизация с помощью атрибутов, см. в разделе [Создание REST API с помощью маршрутизации с помощью атрибутов в веб-API 2](create-a-rest-api-with-attribute-routing.md).

## <a name="prerequisites"></a>Предварительные требования

[Visual Studio 2017](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=button+cta&utm_content=download+vs2017) Community, Professional или Enterprise edition

Кроме того можно используйте диспетчер пакетов NuGet для установки необходимых пакетов. Из **средства** меню в Visual Studio, выберите пункт **диспетчер пакетов NuGet**, а затем выберите **консоль диспетчера пакетов**. Введите следующую команду в окне консоли диспетчера пакетов:

`Install-Package Microsoft.AspNet.WebApi.WebHost`

<a id="why"></a>
## <a name="why-attribute-routing"></a>Почему Маршрутизация атрибутов?

Первая версия веб-API используется *соглашениям* маршрутизации. В этом типе маршрутизации определить один или дополнительные шаблоны маршрутов, которые по сути являются параметризованные строки. Когда платформа получает запрос, он соответствует URI с шаблоном маршрута. (Дополнительные сведения о маршрутизации на основе соглашения, см. в разделе [маршрутизации в ASP.NET Web API](routing-in-aspnet-web-api.md).

Одним из преимуществ маршрутизации на основе соглашения является определены шаблоны в одном месте, что согласованное применение правила маршрутизации на всех контроллерах. К сожалению маршрутизация на основе соглашения об затрудняет для поддержки определенных шаблонов URI, которые являются общими в API-интерфейсов RESTful. Например ресурсы часто содержат дочерние ресурсы. Клиенты размещают заказы, субъекты имеют фильмы, книги у авторов и т. д. Логично, чтобы создать URI, которые отражают следующие связи:

`/customers/1/orders`

Такой тип URI трудно создать с помощью маршрутизации на основе соглашения. Несмотря на то, что это можно сделать, результаты не масштабируются также в том случае, если у вас много контроллеров или типов ресурсов.

С помощью маршрутизации с помощью атрибутов, это просто определить маршрут для данного универсального кода Ресурса. Нужно просто добавить атрибут действие контроллера:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample1.cs)]

Ниже приведены некоторые шаблоны, которые атрибуту маршрутизации легко.

**Управление версиями API**

В этом примере «/ api/v1/products» будет перенаправляться в другом контроллере, чем «/ api/v2/products».

`/api/v1/products`
`/api/v2/products`

**Перегруженный сегментов URI-адреса**

В этом примере «1» — это номер заказа, но «ожидание», которому сопоставлен коллекции.

`/orders/1`
`/orders/pending`

**Несколькими типами параметров**

В этом примере «1» — это номер заказа, но дата «2013/06/16".

`/orders/1`
`/orders/2013/06/16`

<a id="enable"></a>
## <a name="enabling-attribute-routing"></a>Включение маршрутизации с помощью атрибутов

Чтобы включить маршрутизацию атрибутов, вызовите **MapHttpAttributeRoutes** во время настройки. Этот метод расширения определен в **System.Web.Http.HttpConfigurationExtensions** класса.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample2.cs)]

Маршрутизация с помощью атрибутов можно сочетать с [соглашениям](routing-in-aspnet-web-api.md) маршрутизации. Чтобы определить маршруты на основе соглашения, вызовите **MapHttpRoute** метод.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample3.cs)]

Дополнительные сведения о настройке веб-API, см. в разделе [Настройка ASP.NET Web API 2](../advanced/configuring-aspnet-web-api.md).

<a id="config"></a>
### <a name="note-migrating-from-web-api-1"></a>Примечание. Миграция с веб-API 1

Прежде чем веб-API 2 шаблоны проектов веб-API созданный код следующим образом:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample4.cs)]

Если включен маршрутизации с помощью атрибутов, этот код вызовет исключение. Если вы обновляете существующий проект веб-API для использования маршрутизации с помощью атрибутов, не забудьте обновить этот код конфигурации следующим:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample5.cs?highlight=4)]

> [!NOTE]
> Дополнительные сведения см. в разделе [Настройка веб-API с размещением ASP.NET](../advanced/configuring-aspnet-web-api.md#webhost).


<a id="add-routes"></a>
## <a name="adding-route-attributes"></a>Добавление атрибутов маршрута

Вот пример маршрута, определенных с помощью атрибута:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample6.cs)]

Строка &quot;клиентов / {customerId} / orders&quot; шаблон URI для маршрута. Веб-API пытается сопоставить запрос URI в шаблон. В этом примере «customers» и «orders» являются литерала сегментов, а «{customerId}» является параметром переменной. Этот шаблон соответствует следующих URI:

- `http://localhost/customers/1/orders`
- `http://localhost/customers/bob/orders`
- `http://localhost/customers/1234-5678/orders`

Вы можете ограничить соответствия с помощью [ограничения](#constraints), описанные далее в этом разделе.

Обратите внимание, что &quot;{customerId}&quot; параметра в шаблоне маршрута совпадает с именем *customerId* параметра метода. Когда веб-API вызывает действие контроллера, он пытается привязать параметры маршрута. Например, если URL-адрес является `http://example.com/customers/1/orders`, веб-API пытается привязать значение «1» для *customerId* параметра в действии.

Шаблон URI может иметь несколько параметров.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample7.cs)]

Методы контроллера, у которых нет атрибута маршрута используйте маршрутизации на основе соглашения. Таким образом, вы можете сочетать оба типа маршрутизации в том же проекте.

## <a name="http-methods"></a>Методы HTTP

Веб-API также выбирает действия на основе метода HTTP запроса (GET, POST, и т.д.). По умолчанию веб-API ищет совпадение без учета регистра, с запуском имя метода контроллера. Например, метод контроллера с именем `PutCustomers` соответствует запрос HTTP PUT.

Вы можете переопределить это соглашение, дополняя метод с любым следующие атрибуты:

- **[HttpDelete]**
- **[HttpGet]**
- **[HttpHead]**
- **[HttpOptions]**
- **[HttpPatch]**
- **[HttpPost]**
- **[HttpPut]**

Следующий пример сопоставляет метод CreateBook на запросы HTTP POST.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample8.cs)]

Для всех остальных методов HTTP, включая нестандартными способами, используйте **AcceptVerbs** атрибут, который принимает список методов HTTP.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample9.cs)]

<a id="prefixes"></a>
## <a name="route-prefixes"></a>Префиксов маршрутов

Часто маршруты в контроллере, начинающихся с одинаковым префиксом. Пример:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample10.cs)]

Можно задать Общий префикс для всего контроллера с помощью **[RoutePrefix]** атрибут:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample11.cs)]

Используйте тильды (~) на атрибут method, чтобы переопределить префикс маршрута:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample12.cs)]

Префикс маршрута может включать параметры:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample13.cs)]

<a id="constraints"></a>
## <a name="route-constraints"></a>Ограничения маршрута

Ограничения маршрута позволяют ограничить возможности сопоставления параметров в шаблоне маршрута. Общий синтаксис &quot;{параметр: ограничение}&quot;. Пример:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample14.cs)]

Здесь первый маршрут выбирается только если &quot;идентификатор&quot; сегмент URI должно быть целым числом. В противном случае будет выбран второй маршрут.

В следующей таблице перечислены ограничения, которые поддерживаются.

| Ограничение | Описание | Пример |
| --- | --- | --- |
| альфа-канала | Совпадения прописные или строчные буквы латинского алфавита (a-z, A-Z) | {x:alpha} |
| bool | Сопоставляет логическое значение. | {x:bool} |
| datetime | Совпадения **DateTime** значение. | {x:datetime} |
| decimal | Соответствует значение десятичного числа. | {x:decimal} |
| double | Совпадает со значением с плавающей запятой 64-разрядной. | {x:double} |
| float | Совпадает с 32-разрядное значение с плавающей запятой. | {x:float} |
| guid | Совпадает со значением GUID. | {x:guid} |
| int | Совпадает со значением 32-разрядное целое число. | {x:int} |
| длина | Соответствует строке с указанным значением длины или в указанном диапазоне длин. | {x:length(6)} {x:length(1,20)} |
| long | Совпадает со значением 64-разрядное целое число. | {x:long} |
| max | Соответствует целое максимальное значение. | {x:max(10)} |
| MaxLength | Соответствует строке с максимальной длиной. | {x:maxlength(10)} |
| min | Соответствует целое число с минимальным значением. | {x:min(10)} |
| minLength | Соответствует строке минимальной длины. | {x:minlength(10)} |
| range | Соответствует целым числом в диапазоне значений. | {x:range(10,50)} |
| regex | Соответствует регулярному выражению. | {x:regex(^\d{3}-\d{3}-\d{4}$)} |

Обратите внимание на то что некоторые ограничения, такие как &quot;min&quot;, принимают аргументы в круглые скобки. Можно применить несколько ограничений для параметра, разделенные двоеточием.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample15.cs)]

### <a name="custom-route-constraints"></a>Пользовательские ограничения маршрутов

Ограничения пользовательских маршрутов можно создать путем реализации **IHttpRouteConstraint** интерфейс. Например следующее ограничение ограничивает параметр ненулевое целочисленное значение.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample16.cs)]

Ниже показано, как зарегистрировать ограничение:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample17.cs)]

Теперь можно применить ограничения в свои маршруты:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample18.cs)]

Также можно заменить весь **DefaultInlineConstraintResolver** класса путем реализации **IInlineConstraintResolver** интерфейс. Это заменит все встроенные ограничения, если ваша реализация **IInlineConstraintResolver** специально добавляет их.

<a id="optional"></a>
## <a name="optional-uri-parameters-and-default-values"></a>Дополнительный URI параметры и значения по умолчанию

Можно сделать необязательным параметра URI, добавив вопросительным знаком для параметра маршрута. Если параметр маршрута является необязательным, необходимо определить значение по умолчанию для параметра метода.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample19.cs)]

В этом примере `/api/books/locale/1033` и `/api/books/locale` возвращает тот же ресурс.

Кроме того можно указать значение по умолчанию в шаблоне маршрута, следующим образом:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample20.cs)]

Это почти так же, как в предыдущем примере, но есть незначительные различия поведения, когда применяется значение по умолчанию.

- В первом примере («{lcid:int?}») значение по умолчанию 1033 назначается непосредственно параметр метода, поэтому параметр будет иметь точное значение.
- Во втором примере ("{lcid:int = 1033}»), значение по умолчанию «1033» проходит через процесс привязки модели. Связыватель модели по умолчанию преобразует «1033» в числовое значение 1033. Тем не менее можно подключить в настраиваемый связыватель модели, который может делать нечто иное.

(В большинстве случаев при отсутствии пользовательские связыватели модели в конвейере, две формы будет эквивалентное.)

<a id="route-names"></a>
## <a name="route-names"></a>Имена маршрутов

В веб-API каждый маршрут имеет имя. Имена маршрутов можно использовать для создания ссылок, таким образом, можно добавить ссылку в HTTP-ответа.

Чтобы указать имя маршрута, задайте **имя** атрибута. Следующий пример показывает, как задать имя маршрута, а также как использовать имя маршрута, при создании ссылки.

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample21.cs)]

<a id="order"></a>
## <a name="route-order"></a>Порядок маршрута

Когда платформа пытается соответствует URI с маршрутом, она проверяет маршруты в определенном порядке. Чтобы указать порядок, задайте **порядок** атрибута маршрута. Более низкие значения вычисляются первыми. Значение порядка по умолчанию равно нулю.

Вот, как определяется общем порядке:

1. Сравнение **порядок** свойство атрибута маршрута.
2. Рассмотрим каждый сегмент URI в шаблоне маршрута. Для каждого сегмента заказов следующим образом:

    1. Литерал сегменты.
    2. Параметры маршрута с ограничениями.
    3. Параметры маршрута без ограничений.
    4. Сегменты с подстановочными знаками параметр с ограничениями.
    5. Сегменты с подстановочными знаками параметр без ограничений.
3. В случае равенства преимущество получает маршруты упорядочиваются по сравнение строк по порядковому номеру без учета регистра ([OrdinalIgnoreCase](https://msdn.microsoft.com/library/system.stringcomparer.ordinalignorecase.aspx)) шаблона маршрута.

Пример. Предположим, вы определяете следующего контроллера:

[!code-csharp[Main](attribute-routing-in-web-api-2/samples/sample22.cs)]

Эти маршруты упорядочены следующим образом.

1. заказы и сведения
2. заказы / {id}
3. заказы / {customerName}
4. заказы / {\*Дата}
5. заказы / ожидание

Обратите внимание, что «подробности» является сегментом литерала и появляется перед «{id}», но «Ожидание» отображается последнее, так как **порядок** свойства является 1. (В этом примере предполагается, что существует то заказчики с именем «подробности» или «Ожидание». Как правило Старайтесь избегать неоднозначных маршрутов. В этом примере лучше шаблон маршрута для `GetByCustomer` является «клиентов / {customerName}»)
