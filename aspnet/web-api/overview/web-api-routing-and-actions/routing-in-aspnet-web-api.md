---
uid: web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api
title: Трассировка в ASP.NET Web API Документы Майкрософт
author: MikeWasson
description: ''
ms.author: riande
ms.date: 10/29/2018
ms.assetid: 0675bdc7-282f-4f47-b7f3-7e02133940ca
msc.legacyurl: /web-api/overview/web-api-routing-and-actions/routing-in-aspnet-web-api
msc.type: authoredcontent
ms.openlocfilehash: 85862c094cc54365267b1f21e68d235a15519cda
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675757"
---
# <a name="routing-in-aspnet-web-api"></a>Маршрутизация в веб-API ASP.NET

[Майк Уоссон](https://github.com/MikeWasson)

В этой статье описывается, как ASP.NET веб-API маршруты HTTP запросов контроллеров.

> [!NOTE]
> Если вы знакомы с ASP.NET MVC, то трассировка Web API очень похожа на трассировку MVC. Основное отличие заключается в том, что Web API использует глагол HTTP, а не путь URI, чтобы выбрать действие. В Web API можно также использовать трассу в стиле MVC. Эта статья не предполагает каких-либо знаний о ASP.NET MVC.

## <a name="routing-tables"></a>Таблицы для реанивания

В ASP.NET Web API *контроллер* представляет собой класс, который обрабатывает запросы HTTP. Публичные методы контроллера называются *методами действия* или просто *действиями.* Когда платформа Web API получает запрос, она направляет запрос на действие.

Чтобы определить, какое действие следует вызвать, в фреймворке используется *таблица размывания.* Шаблон проекта Visual Studio для Web API создает маршрут по умолчанию:

[!code-csharp[Main](routing-in-aspnet-web-api/samples/sample1.cs)]

Этот маршрут определен в *WebApiConfig.cs* файле, который помещается в каталог *\_App Start:*

![](routing-in-aspnet-web-api/_static/image1.png)

Для получения дополнительной `WebApiConfig` информации о классе см [ASP.NET.](../advanced/configuring-aspnet-web-api.md)

Если вы самостоятельно размещаете Web API, необходимо установить таблицу трассировки непосредственно на объекте. `HttpSelfHostConfiguration` Для получения дополнительной информации [см.](../older-versions/self-host-a-web-api.md)

Каждая запись в таблице маршрутов содержит *шаблон маршрута.* Шаблон маршрута по умолчанию &quot;для Web API является api/(контроллер) / (id)&quot;. В этом &quot;шаблоне&quot; api является буквальным сегментом пути, а «контроллер» и «id» являются переменными заполнителя.

Когда платформа Web API получает запрос HTTP, она пытается сопоставить URI с одним из шаблонов маршрутов в таблице маршрутов. Если маршрут не совпадает, клиент получает ошибку 404. Например, следующие URIs соответствуют маршруту по умолчанию:

- /api/контакты
- /api/contacts/1
- /api/products/gizmo1

Тем не менее, следующие URI не &quot;совпадает, потому что ему не хватает сегмента api:&quot;

- /контакты/1

> [!NOTE]
> Причина использования "апи" в маршруте заключается в том, чтобы избежать столкновений с маршрутизированием ASP.NET MVC. Таким образом, вы &quot;можете&quot; иметь /контакты перейти к контроллеру MVC, и &quot;/api/контакты&quot; перейти к контроллеру Web API. Конечно, если вам не нравится эта конвенция, вы можете изменить таблицу маршрутов по умолчанию.

После того, как будет найден соответствующий маршрут, Web API выбирает контроллер и действие:

- Чтобы найти контроллер, Web &quot;API добавляет контроллер&quot; к значению переменной *«контроллер».*
- Чтобы найти действие, Web API смотрит на глагол HTTP, а затем ищет действие, имя которого начинается с имени глагола HTTP. Например, с помощью запроса GET Web API &quot;&quot;ищет прикрепимые действия get, &quot;такие как GetContact&quot; или &quot;GetAllContacts.&quot; Эта конвенция распространяется только на глаголы GET, POST, PUT, DELETE, HEAD, OPTIONS и PATCH. Вы можете включить другие глаголы HTTP, используя атрибуты на контроллере. Мы увидим пример этого позже.
- Другие переменные заполнителя в шаблоне маршрута, такие как *«id»,* отображаются по параметрам действия.

Давайте рассмотрим пример. Предположим, что вы определяете следующий контроллер:

[!code-csharp[Main](routing-in-aspnet-web-api/samples/sample2.cs)]

Вот некоторые возможные запросы HTTP, а также действие, которое вызывается для каждого из них:

| HTTP-команда | Путь URI | Действие | Параметр |
| --- | --- | --- | --- |
| GET | апи/продукты | GetAllProducts | *(нет)* |
| GET | api/продукты/4 | GetProductbyid | 4 |
| DELETE | api/продукты/4 | УдалитьПродукт | 4 |
| POST | апи/продукты | *(без совпадений)* |  |

Обратите внимание, что сегмент *URI,* если он присутствует, отображается по параметру *идентификатора* действия. В этом примере контроллер определяет два метода GET, один с параметром *идентификатора* и один без параметров.

Кроме того, обратите внимание, что запрос POST не &quot;удастся, потому что контроллер не определяет сообщение ... &quot; метод.

## <a name="routing-variations"></a>Вариации реаутинга

В предыдущем разделе описан базовый механизм реуктора для ASP.NET Web API. В этом разделе описаны некоторые вариации.

### <a name="http-verbs"></a>Команды HTTP

Вместо того, чтобы использовать конвенцию именования для глаголов HTTP, можно прямо указать глагол HTTP для действия, усвоив метод действия одним из следующих атрибутов:

- `[HttpGet]`
- `[HttpPut]`
- `[HttpPost]`
- `[HttpDelete]`
- `[HttpHead]`
- `[HttpOptions]`
- `[HttpPatch]`

В следующем примере `FindProduct` метод отображается на запросах GET:

[!code-csharp[Main](routing-in-aspnet-web-api/samples/sample3.cs)]

Чтобы разрешить несколько глаголов HTTP для действия, или разрешить глаголы HTTP, кроме GET, PUT, `[AcceptVerbs]` POST, DELETE, HEAD, OPTIONS и PATCH, используйте атрибут, который использует список глаголов HTTP.

[!code-csharp[Main](routing-in-aspnet-web-api/samples/sample4.cs)]

<a id="routing_by_action_name"></a>
### <a name="routing-by-action-name"></a>Расшатывание по названию действия

С шаблоном трассировки по умолчанию Web API использует глагол HTTP для выбора действия. Тем не менее, вы также можете создать маршрут, где имя действия включено в URI:

[!code-csharp[Main](routing-in-aspnet-web-api/samples/sample5.cs)]

В этом шаблоне маршрута параметр *«действие»* называет метод действия на контроллере. С этим стилем разгрома используйте атрибуты для указания допустимых глаголов HTTP. Например, предположим, что у контроллера есть следующий метод:

[!code-csharp[Main](routing-in-aspnet-web-api/samples/sample6.cs)]

В этом случае запрос GET на "api/products/details/1" `Details` будет отображаться к методу. Этот стиль конечной связи похож на ASP.NET MVC и может быть подходящим для API в стиле RPC.

Вы можете переопределить имя действия `[ActionName]` с помощью атрибута. В следующем примере, Есть два &quot;действия, которые карта для api / продукты / thumbnail /*id*. Один поддерживает GET, а другой поддерживает POST:

[!code-csharp[Main](routing-in-aspnet-web-api/samples/sample7.cs)]

### <a name="non-actions"></a>Недействия

Чтобы предотвратить вызов метода в качестве действия, используйте `[NonAction]` атрибут. Это сигнализирует системе, что метод не является действием, даже если он в противном случае соответствует правилам разгрома.

[!code-csharp[Main](routing-in-aspnet-web-api/samples/sample8.cs)]

## <a name="further-reading"></a>Дополнительные материалы

Эта тема предоставила представление на высоком уровне о разгроме. Для получения более подробной информации см. [Маршрутирование и выбор действий,](routing-and-action-selection.md)в котором точно описывается, как фреймворк соответствует URI маршруту, выбирает контроллер, а затем выбирает действие для вызывания.
