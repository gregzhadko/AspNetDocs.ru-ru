---
uid: web-api/overview/odata-support-in-aspnet-web-api/odata-v3/working-with-entity-relations
title: Поддержка отношений сущностей в OData v3 с веб-API 2 | Документация Майкрософт
author: MikeWasson
description: 'В большинстве наборов данных определить отношения между сущностями: Клиенты имеют заказы; у книги может быть авторов; продукты, имеют поставщики. С помощью OData, клиенты могут переходить по...'
ms.author: riande
ms.date: 02/26/2014
ms.assetid: 1e4c2eb4-b6cf-42ff-8a65-4d71ddca0394
msc.legacyurl: /web-api/overview/odata-support-in-aspnet-web-api/odata-v3/working-with-entity-relations
msc.type: authoredcontent
ms.openlocfilehash: c78787aac83720eb9e8d6e9e0499f30a31951bc2
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59393864"
---
# <a name="supporting-entity-relations-in-odata-v3-with-web-api-2"></a>Поддержка отношений сущностей в OData v3 с веб-API 2

по [Майк Уоссон](https://github.com/MikeWasson)

[Скачать завершенный проект](http://code.msdn.microsoft.com/ASPNET-Web-API-OData-cecdb524)

> В большинстве наборов данных определить отношения между сущностями: Клиенты имеют заказы; у книги может быть авторов; продукты, имеют поставщики. С помощью OData, клиенты можно переходить через отношения сущности. Учитывая продукта, можно найти поставщика. Также можно создать или удалить связи. Например можно задать поставщик для продукта.
> 
> Этом руководстве показано, как для поддержки этих операций в веб-API ASP.NET. Учебном курсе руководство [Создание конечной точки OData v3 с веб-API 2](creating-an-odata-endpoint.md).
> 
> ## <a name="software-versions-used-in-the-tutorial"></a>Версии программного обеспечения, используемые в этом руководстве
> 
> 
> - Веб-API 2
> - OData версии 3
> - Entity Framework 6


## <a name="add-a-supplier-entity"></a>Добавление сущности Supplier

Во-первых, нам нужно добавить новый тип сущности для наших веб-канала OData. Мы добавим `Supplier` класса.

[!code-csharp[Main](working-with-entity-relations/samples/sample1.cs)]

Этот класс использует строку для ключа сущности. На практике, это может быть реже, чем с помощью целочисленного ключа. Но стоит видеть, как OData обрабатывает другие типы ключей, помимо целых чисел.

Далее, мы создадим связь путем добавления `Supplier` свойства `Product` класса:

[!code-csharp[Main](working-with-entity-relations/samples/sample2.cs)]

Добавьте новый **DbSet** для `ProductServiceContext` класса, таким образом, чтобы платформа Entity Framework будет включать `Supplier` таблицы в базе данных.

[!code-csharp[Main](working-with-entity-relations/samples/sample3.cs?highlight=9)]

В файле WebApiConfig.cs добавьте модель EDM сущности «Поставщики»:

[!code-csharp[Main](working-with-entity-relations/samples/sample4.cs?highlight=4)]

## <a name="navigation-properties"></a>Свойства навигации

Чтобы получить поставщик для продукта, клиент отправляет запрос GET:

[!code-console[Main](working-with-entity-relations/samples/sample5.cmd)]

Здесь «Поставщик» является свойством навигации на `Product` типа. В этом случае `Supplier` ссылается на один элемент, но переход свойство также может возвращать коллекции (отношения один ко многим "или" многие ко многим).

Чтобы этот запрос в службу поддержки, добавьте следующий метод в `ProductsController` класса:

[!code-csharp[Main](working-with-entity-relations/samples/sample6.cs)]

*Ключ* параметр — ключ продукта. Этот метод возвращает связанные сущности&#8212;в этом случае `Supplier` экземпляра. Имя метода и имени параметра являются важным. Как правило если свойство навигации называется «X», необходимо добавить метод с именем «GetX». Метод должен принимать параметр с именем "*ключ*", соответствующий тип данных ключа родительского элемента.

Также важно включить **[FromOdataUri]** атрибут в *ключ* параметра. Этот атрибут сообщает веб-API для использования правилами синтаксиса OData при синтаксическом анализе ключ из URI запроса.

## <a name="creating-and-deleting-links"></a>Создание и удаление ссылки

OData поддерживает создание или удаление связи между двумя сущностями. В терминологии OData связь является «ссылку». Каждая ссылка имеет URI с формой *сущности*/$links /*сущности*. Например ссылка продукта поставщика выглядит следующим образом:

[!code-console[Main](working-with-entity-relations/samples/sample7.cmd)]

Чтобы создать новую ссылку, клиент отправляет запрос POST к URI ссылки. Текст запроса является URI целевой сущности. Например предположим, что имеется поставщик с ключом «CTSO». Чтобы создать ссылку из «Product(1)» на «Supplier('CTSO')», клиент отправляет запрос следующего вида:

[!code-console[Main](working-with-entity-relations/samples/sample8.cmd)]

Чтобы удалить ссылку, клиент отправляет запрос DELETE к URI ссылки.

**Создание связей между элементами**

Чтобы включить клиента для создания ссылок на поставщика продукта, добавьте следующий код, чтобы `ProductsController` класса:

[!code-csharp[Main](working-with-entity-relations/samples/sample9.cs)]

Этот метод принимает три параметра:

- *Ключ*: Ключ на родительскую сущность (продукт)
- *navigationProperty*: Имя свойства навигации. В этом примере свойство навигации, единственным допустимым является «Поставщик».
- *ссылка*: URI OData связанной сущности. Это значение берется из текста запроса. Например, ссылка URI может быть "`http://localhost/odata/Suppliers('CTSO')`, то есть поставщика с Идентификатором = «CTSO».

Данный метод использует ссылку для поиска поставщика. Если найден соответствующий поставщик, метод устанавливает `Product.Supplier` свойство и сохраняет результат в базе данных.

Самая важная часть синтаксического анализа URI ссылки. По сути вам нужно имитировать результат при отправке запроса GET к этому URI. Следующий вспомогательный метод показано, как это сделать. Метод вызывает процесс маршрутизации веб-API, а затем возвращает **ODataPath** экземпляр, представляющий проанализированный пути OData. Для URI ссылки один из сегментов должно быть ключом сущности. (В противном случае клиент отправил недопустимый URI.)

[!code-csharp[Main](working-with-entity-relations/samples/sample10.cs)]

**Удаление ссылки**

Чтобы удалить ссылку, добавьте следующий код, чтобы `ProductsController` класса:

[!code-csharp[Main](working-with-entity-relations/samples/sample11.cs)]

В этом примере свойство навигации представляет собой одну `Supplier` сущности. Если свойство навигации является коллекцией, URI, чтобы удалить ссылку необходимо включить ключ для связанной сущности. Пример:

[!code-console[Main](working-with-entity-relations/samples/sample12.cmd)]

Этот запрос удаляет порядка 1 из клиента 1. В этом случае метод DeleteLink будут иметь следующую сигнатуру:

[!code-csharp[Main](working-with-entity-relations/samples/sample13.cs)]

*RelatedKey* параметр предоставляет ключ для связанной сущности. Таким образом, в вашей `DeleteLink` метод, для поиска основной сущностью, *ключ* параметра, найти связанные сущности, *relatedKey* параметра, а затем удалите связь. В зависимости от вашей модели данных, может потребоваться реализовать обе версии `DeleteLink`. Веб-API вызовет правильную версию, в зависимости от URI запроса.
