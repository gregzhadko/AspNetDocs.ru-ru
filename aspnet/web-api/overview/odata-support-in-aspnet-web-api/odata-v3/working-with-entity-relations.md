---
uid: web-api/overview/odata-support-in-aspnet-web-api/odata-v3/working-with-entity-relations
title: Поддержка отношений сущностей в OData v3 с веб-API 2 | Документация Майкрософт
author: MikeWasson
description: 'Большинство наборов данных определяют связи между сущностями: у клиентов есть заказы. книги имеют авторов; продукты имеют поставщики. С помощью OData клиенты могут перемещаться по...'
ms.author: riande
ms.date: 02/26/2014
ms.assetid: 1e4c2eb4-b6cf-42ff-8a65-4d71ddca0394
msc.legacyurl: /web-api/overview/odata-support-in-aspnet-web-api/odata-v3/working-with-entity-relations
msc.type: authoredcontent
ms.openlocfilehash: 726a7d51123805e05f6831ef9cd7eaa84b6c44bd
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2019
ms.locfileid: "74600317"
---
# <a name="supporting-entity-relations-in-odata-v3-with-web-api-2"></a>Поддержка отношений сущностей в OData v3 с веб-API 2

по [Майк Уоссон](https://github.com/MikeWasson)

[Скачать завершенный проект](https://code.msdn.microsoft.com/ASPNET-Web-API-OData-cecdb524)

> Большинство наборов данных определяют связи между сущностями: у клиентов есть заказы. книги имеют авторов; продукты имеют поставщики. С помощью OData клиенты могут перемещаться по связям сущностей. С учетом продукта можно найти поставщика. Также можно создавать и удалять связи. Например, можно задать поставщика для продукта.
> 
> В этом руководстве показано, как поддерживать эти операции в веб-API ASP.NET. Руководство строится на руководстве по [созданию конечной точки OData v3 с веб-API 2](creating-an-odata-endpoint.md).
> 
> ## <a name="software-versions-used-in-the-tutorial"></a>Версии программного обеспечения, используемые в этом руководстве
> 
> 
> - Веб-API 2
> - OData версии 3
> - Entity Framework 6

## <a name="add-a-supplier-entity"></a>Добавление сущности поставщика

Сначала необходимо добавить новый тип сущности в наш веб-канал OData. Мы добавим класс `Supplier`.

[!code-csharp[Main](working-with-entity-relations/samples/sample1.cs)]

Этот класс использует строку для ключа сущности. На практике это может быть менее распространенным, чем использование целочисленного ключа. Но стоит рассмотреть, как OData обрабатывает другие типы ключей помимо целых чисел.

Далее мы создадим отношение, добавив свойство `Supplier` к классу `Product`:

[!code-csharp[Main](working-with-entity-relations/samples/sample2.cs)]

Добавьте новый **DbSet** в класс `ProductServiceContext`, чтобы Entity Framework включала в базу данных таблицу `Supplier`.

[!code-csharp[Main](working-with-entity-relations/samples/sample3.cs?highlight=9)]

В WebApiConfig.cs добавьте сущность «поставщики» в модель EDM:

[!code-csharp[Main](working-with-entity-relations/samples/sample4.cs?highlight=4)]

## <a name="navigation-properties"></a>Свойства навигации

Чтобы получить поставщик для продукта, клиент отправляет запрос GET:

[!code-console[Main](working-with-entity-relations/samples/sample5.cmd)]

Здесь "поставщик" — это свойство навигации типа `Product`. В этом случае `Supplier` ссылается на один элемент, но свойство навигации также может возвращать коллекцию (связь «один ко многим» или «многие ко многим»).

Для поддержки этого запроса добавьте в класс `ProductsController` следующий метод:

[!code-csharp[Main](working-with-entity-relations/samples/sample6.cs)]

*Ключевым* параметром является ключ продукта. Метод возвращает связанную сущность&#8212;в данном случае — экземпляр `Supplier`. Имя метода и имя параметра являются важными. В общем случае, если свойство навигации имеет имя «X», необходимо добавить метод с именем «Жеткс». Метод должен принимать параметр с именем*Key*, соответствующий типу данных родительского ключа.

Также важно включить атрибут **[фромодатаури]** в параметр *Key* . Этот атрибут указывает, что веб-API будет использовать правила синтаксиса OData при анализе ключа из URI запроса.

## <a name="creating-and-deleting-links"></a>Создание и удаление ссылок

OData поддерживает создание или удаление связей между двумя сущностями. В терминологии OData связь является "связью". Каждая ссылка имеет универсальный код ресурса (URI) с формой *Entity*/$Links или*Entity*. Например, ссылка от Product к поставщику выглядит следующим образом:

[!code-console[Main](working-with-entity-relations/samples/sample7.cmd)]

Чтобы создать новую ссылку, клиент отправляет запрос POST в URI ссылки. Тело запроса — это URI целевой сущности. Например, предположим, что имеется поставщик с ключом «КТСО». Чтобы создать ссылку с "Product (1)" на "поставщик (" КТСО ")", клиент отправляет запрос, подобный следующему:

[!code-console[Main](working-with-entity-relations/samples/sample8.cmd)]

Чтобы удалить ссылку, клиент отправляет запрос на удаление в URI ссылки.

**Создание ссылок**

Чтобы разрешить клиенту создавать связи продуктов и поставщиков, добавьте следующий код в класс `ProductsController`:

[!code-csharp[Main](working-with-entity-relations/samples/sample9.cs)]

Этот метод принимает три параметра:

- *ключ*: ключ к родительской сущности (продукт).
- *navigationProperty*: имя свойства навигации. В этом примере единственным допустимым свойством навигации является «поставщик».
- *ссылка*: URI OData связанной сущности. Это значение берется из текста запроса. Например, URI ссылки может быть "`http://localhost/odata/Suppliers('CTSO')`, то есть поставщик с ИДЕНТИФИКАТОРом" КТСО ".

Метод использует ссылку для поиска поставщика. Если найден соответствующий поставщик, метод задает свойство `Product.Supplier` и сохраняет результат в базе данных.

Самая сложная часть — это анализ универсального кода ресурса (URI) ссылки. По сути, необходимо имитировать результат отправки запроса GET на этот универсальный код ресурса (URI). В следующем вспомогательном методе показано, как это сделать. Метод вызывает процесс маршрутизации веб-API и возвращает экземпляр **ODataPath** , представляющий проанализированный путь OData. Для URI ссылки один из сегментов должен быть ключом сущности. (Если нет, клиент отправил некорректный URI.)

[!code-csharp[Main](working-with-entity-relations/samples/sample10.cs)]

**Удаление ссылок**

Чтобы удалить ссылку, добавьте следующий код в класс `ProductsController`:

[!code-csharp[Main](working-with-entity-relations/samples/sample11.cs)]

В этом примере свойство навигации является одной сущностью `Supplier`. Если свойство навигации является коллекцией, URI для удаления ссылки должен включать ключ для связанной сущности. Например:

[!code-console[Main](working-with-entity-relations/samples/sample12.cmd)]

Этот запрос удаляет заказ 1 из клиента 1. В этом случае метод Делетелинк будет иметь следующую сигнатуру:

[!code-csharp[Main](working-with-entity-relations/samples/sample13.cs)]

Параметр *релатедкэй* предоставляет ключ для связанной сущности. Поэтому в методе `DeleteLink` найдите основную сущность по *ключевому* параметру, найдите связанную сущность с помощью параметра *релатедкэй* , а затем удалите связь. В зависимости от модели данных может потребоваться реализовать обе версии `DeleteLink`. Веб-API будет вызывать правильную версию на основе URI запроса.
