---
uid: web-api/overview/odata-support-in-aspnet-web-api/odata-security-guidance
title: Руководство по безопасности для веб-API 2 ASP.NET OData | Документация Майкрософт
author: MikeWasson
description: ''
ms.author: riande
ms.date: 02/06/2013
ms.assetid: b91e6424-1544-4747-bd0b-d1f8418c9653
msc.legacyurl: /web-api/overview/odata-support-in-aspnet-web-api/odata-security-guidance
msc.type: authoredcontent
ms.openlocfilehash: 0e43ec6b1cbe922b00f0f71d08aed4d0f4c08af8
ms.sourcegitcommit: 289e051cc8a90e8f7127e239fda73047bde4de12
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/25/2019
ms.locfileid: "58425864"
---
<a name="security-guidance-for-aspnet-web-api-2-odata"></a>Руководство по безопасности для веб-API 2 ASP.NET OData
====================
по [Майк Уоссон](https://github.com/MikeWasson)

В этом разделе описываются некоторые проблемы безопасности, которые следует учитывать при предоставлении объект dataset с помощью OData.

## <a name="edm-security"></a>Модель EDM безопасности

Семантики запросов основаны на модели EDM (модель EDM), не базовых типов модели. Свойство можно исключить из модели EDM, и он не будет видимым для запроса. Например предположим, что модель включает в себя тип со свойством заработной платы сотрудника. Может потребоваться исключить это свойство из модели EDM, чтобы скрыть его от клиентов.

Существует два способа исключить свойство из модели EDM. Можно задать **[IgnoreDataMember]** атрибут на свойство в класс модели:

[!code-csharp[Main](odata-security-guidance/samples/sample1.cs)]

Можно также удалить свойство из EDM программным способом.

[!code-csharp[Main](odata-security-guidance/samples/sample2.cs)]

## <a name="query-security"></a>Безопасность запросов

Вредоносный или упрощенный клиент может иметь возможность создайте запрос, который занимает очень много времени для выполнения. В худшем случае это может нарушить доступ к вашей службе.

**[Queryable]** атрибута является фильтром операции, которая выполняет синтаксический анализ, проверяет и применяет запрос. Фильтр преобразует параметры запроса в выражении LINQ. При возвращении контроллер OData **IQueryable** типа, **IQueryable** LINQ поставщик преобразует выражения LINQ в запрос. Таким образом производительность зависит от поставщика LINQ, который используется, а также от характеристик конкретной схемы набора данных или базы данных.

Дополнительные сведения об использовании параметров запроса OData в веб-API ASP.NET, см. в разделе [поддержки параметров запроса OData](supporting-odata-query-options.md).

Если вы знаете, что все клиенты являются доверенными (например, в корпоративной среде) или небольшой набор данных, производительность запросов может оказаться проблемой. В противном случае рассмотрите следующие рекомендации.

- Тестирование службы с помощью различных запросов и профиля базы данных.
- Включение сервера разбиение на страницы избежать возвращения большого набора данных в одном запросе. Дополнительные сведения см. в разделе [разбиение по страницам Server-Driven](supporting-odata-query-options.md#server-paging). 

    [!code-csharp[Main](odata-security-guidance/samples/sample3.cs)]
- Требуется $filter и $orderby? Некоторые приложения может разрешить клиентским разбиение по страницам, используя $top и $skip, но отключить другие параметры запроса. 

    [!code-csharp[Main](odata-security-guidance/samples/sample4.cs)]
- Можно ограничить $orderby к свойствам в кластеризованном индексе. Сортировка больших объемов данных без кластеризованного индекса выполняется медленно. 

    [!code-csharp[Main](odata-security-guidance/samples/sample5.cs)]
- Максимальное число узлов: **MaxNodeCount** свойство **[Queryable]** задает максимальное число узлов, разрешенных в синтаксического дерева $filter. Значение по умолчанию — 100, но вы можете задать более низкое значение, так как большое количество узлов может выполняться медленно для компиляции. Это особенно верно при использовании LINQ to Objects (т. е. запросы LINQ к коллекции в памяти, без использования промежуточного поставщика LINQ). 

    [!code-csharp[Main](odata-security-guidance/samples/sample6.cs)]
- Рекомендуется отключить функции any() и all(), так как они могут выполняться медленно. 

    [!code-csharp[Main](odata-security-guidance/samples/sample7.cs)]
- Если любые свойства строки содержат больших строк&#8212;к примеру, описание продукта или запись в блоге&#8212;рекомендуется отключить строковые функции. 

    [!code-csharp[Main](odata-security-guidance/samples/sample8.cs)]
- Рассмотрите возможность запрета, фильтрация по свойствам навигации. Фильтрация по свойствам навигации может привести соединение, которое может быть медленным, в зависимости от схемы базы данных. В следующем коде показано запроса проверяющий элемент управления, не позволяющая фильтрация по свойствам навигации. Дополнительные сведения о запросе проверяющие элементы управления, см. в разделе [Проверка запроса](supporting-odata-query-options.md#query-validation). 

    [!code-csharp[Main](odata-security-guidance/samples/sample9.cs)]
- Можно ограничить запросы $filter, написав проверяющий элемент управления, который настроен для базы данных. Например рассмотрим следующие два запроса: 

  - Все фильмы с субъектами, чья фамилия начинается с «A».
  - Все фильмы, выпущенная в 1994 г.

    Если субъекты индексированных фильмы, первый запрос может потребоваться ядра СУБД, чтобы проверять весь список фильмов. В то время как второй запрос может быть приемлемым, если предполагается, что фильмы индексируются год выпуска.

    В следующем коде показано проверяющий элемент управления, который позволяет фильтровать свойства «ReleaseYear» и «Title», но не других свойств.

    [!code-csharp[Main](odata-security-guidance/samples/sample10.cs)]
- В общем случае рекомендуется какие функции $filter. Если клиентам не требуется полный выразительность $filter, можно ограничить допустимые функции.
