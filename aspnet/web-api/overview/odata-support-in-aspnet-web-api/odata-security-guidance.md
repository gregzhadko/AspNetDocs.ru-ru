---
uid: web-api/overview/odata-support-in-aspnet-web-api/odata-security-guidance
title: Руководство по безопасности для веб-API ASP.NET 2 OData-ASP.NET 4. x
author: MikeWasson
description: Описывает вопросы безопасности, которые следует учитывать при предоставлении набора данных через OData для веб-API ASP.NET 2 на ASP.NET 4. x.
ms.author: riande
ms.date: 02/06/2013
ms.custom: seoapril2019
ms.assetid: b91e6424-1544-4747-bd0b-d1f8418c9653
msc.legacyurl: /web-api/overview/odata-support-in-aspnet-web-api/odata-security-guidance
msc.type: authoredcontent
ms.openlocfilehash: 8194a368cb0629c30e32ec05bf4bed150d442ad8
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78448296"
---
# <a name="security-guidance-for-aspnet-web-api-2-odata"></a>Руководство по безопасности для веб-API ASP.NET 2 OData

по [Майк Уоссон](https://github.com/MikeWasson)

В этом разделе описываются некоторые проблемы безопасности, которые следует учитывать при предоставлении набора данных через OData для веб-API ASP.NET 2 на ASP.NET 4. x.

## <a name="edm-security"></a>Безопасность EDM

Семантика запросов основана на модели EDM, а не на базовых типах моделей. Вы можете исключить свойство из модели EDM, и оно не будет видимо для запроса. Например, предположим, что модель включает тип сотрудника со свойством оклада. Может потребоваться исключить это свойство из EDM, чтобы скрыть его от клиентов.

Существует два способа исключить свойство из EDM. Вы можете задать атрибут **[игноредатамембер]** для свойства в классе Model:

[!code-csharp[Main](odata-security-guidance/samples/sample1.cs)]

Также можно удалить свойство из модели EDM программным способом:

[!code-csharp[Main](odata-security-guidance/samples/sample2.cs)]

## <a name="query-security"></a>Безопасность запросов

Вредоносный или упрощенный клиент может создать запрос, выполнение которого занимает очень много времени. В худшем случае это может нарушить доступ к службе.

Атрибут **[с поддержкой запроса]** — это фильтр действий, который анализирует, проверяет и применяет запрос. Фильтр преобразует параметры запроса в выражение LINQ. Когда контроллер OData возвращает тип **IQueryable** , поставщик **IQueryable** LINQ преобразует выражение LINQ в запрос. Таким образом, производительность зависит от используемого поставщика LINQ, а также от конкретных характеристик набора данных или схемы базы данных.

Дополнительные сведения об использовании параметров запросов OData в веб-API ASP.NET см. в разделе [Поддержка параметров запросов OData](supporting-odata-query-options.md).

Если известно, что все клиенты являются доверенными (например, в корпоративной среде) или если набор данных является небольшим, производительность запросов может быть не проблемой. В противном случае следует принять во внимание следующие рекомендации.

- Протестируйте службу с различными запросами и проверяйте базу данных.
- Включите серверную подкачку, чтобы избежать возвращения большого набора данных в одном запросе. Дополнительные сведения см. в разделе [подкачка, управляемая сервером](supporting-odata-query-options.md#server-paging). 

    [!code-csharp[Main](odata-security-guidance/samples/sample3.cs)]
- Требуется $filter и $orderby? Некоторые приложения могут разрешать подкачку клиента с помощью $top и $skip, но отключать другие параметры запроса. 

    [!code-csharp[Main](odata-security-guidance/samples/sample4.cs)]
- Рекомендуется ограничивать $orderby свойствами в кластеризованном индексе. Сортировка больших данных без кластеризованного индекса выполняется слишком долго. 

    [!code-csharp[Main](odata-security-guidance/samples/sample5.cs)]
- Максимальное число узлов: свойство **макснодекаунт** в **[запрашиваемое]** задает максимальное число узлов, допустимых в дереве синтаксиса $Filter. Значение по умолчанию — 100, но может потребоваться задать меньшее значение, так как большое количество узлов может замедляться для компиляции. Это особенно справедливо при использовании LINQ to Objects (т. е. запросов LINQ к коллекции в памяти без использования промежуточного поставщика LINQ). 

    [!code-csharp[Main](odata-security-guidance/samples/sample6.cs)]
- Рассмотрите возможность отключения функций Any () и All (), так как они могут быть слишком длительными. 

    [!code-csharp[Main](odata-security-guidance/samples/sample7.cs)]
- Если какие-либо строковые свойства&#8212;содержат большие строки, например, описание продукта или запись&#8212;в блоге, попробуйте отключить строковые функции. 

    [!code-csharp[Main](odata-security-guidance/samples/sample8.cs)]
- Рассмотрите возможность запрета фильтрации по свойствам навигации. Фильтрация по свойствам навигации может привести к созданию объединения, которое может быть заработано в зависимости от схемы базы данных. В следующем коде показан проверяющий элемент управления, который предотвращает фильтрацию свойств навигации. Дополнительные сведения о средствах проверки запросов см. в разделе [Проверка запросов](supporting-odata-query-options.md#query-validation). 

    [!code-csharp[Main](odata-security-guidance/samples/sample9.cs)]
- Рассмотрите возможность ограничивать $filter запросы, написав проверяющий элемент управления, настроенный для базы данных. Например, рассмотрим следующие два запроса: 

  - Все фильмы с субъектами, фамилии которых начинаются с "A".
  - Все фильмы, выпущенные в 1994.

    Если фильмы не индексируются субъектами, для первого запроса может потребоваться, чтобы ядро СУБД проверяло весь список фильмов. В то время как второй запрос может быть приемлемым, при условии, что фильмы индексируются по году выпуска.

    В следующем коде показан проверяющий элемент управления, позволяющий фильтровать свойства "Релеасэйеар" и "Title", но не другие свойства.

    [!code-csharp[Main](odata-security-guidance/samples/sample10.cs)]
- Как правило, определите, какие функции $filter вам нужны. Если клиентам не требуется полное выразительность $filter, можно ограничить разрешенные функции.
