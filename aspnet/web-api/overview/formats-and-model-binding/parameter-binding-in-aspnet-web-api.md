---
uid: web-api/overview/formats-and-model-binding/parameter-binding-in-aspnet-web-api
title: Привязка параметра в веб-API ASP.NET-ASP.NET 4. x
author: MikeWasson
description: Описывает, как веб-API привязывает параметры и как настроить процесс привязки в ASP.NET 4. x.
ms.author: riande
ms.date: 07/11/2013
ms.custom: seoapril2019
ms.assetid: e42c8388-04ed-4341-9fdb-41b1b4c06320
msc.legacyurl: /web-api/overview/formats-and-model-binding/parameter-binding-in-aspnet-web-api
msc.type: authoredcontent
ms.openlocfilehash: 464cb9b45dc0b62c4da38b7cf612934808854d32
ms.sourcegitcommit: e365196c75ce93cd8967412b1cfdc27121816110
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/07/2020
ms.locfileid: "77074908"
---
# <a name="parameter-binding-in-aspnet-web-api"></a>Привязка параметра в веб-API ASP.NET

по [Майк Уоссон](https://github.com/MikeWasson)

[!INCLUDE[](~/includes/coreWebAPI.md)]

В этой статье описывается, как веб-API привязывает параметры и как можно настроить процесс привязки. Когда веб-API вызывает метод на контроллере, он должен задать значения для параметров — процесс, называемый *Binding*.

По умолчанию для привязки параметров веб-API использует следующие правила:

- Если параметр имеет тип Simple, веб-API пытается получить значение из универсального кода ресурса (URI). Простые типы включают в себя [примитивные типы](https://msdn.microsoft.com/library/system.type.isprimitive.aspx) .NET (**int**, **bool**, **Double**и т. д.), а также **TimeSpan**, **DateTime**, **GUID**, **Decimal**и **String** *, а также любой тип* с преобразователем типов, который может выполнять преобразование из строки. (Дополнительные сведения о преобразователях типов см. ниже.)
- Для сложных типов веб-API пытается считать значение из текста сообщения с помощью [модуля форматирования типа мультимедиа](media-formatters.md).

Например, ниже приведен типичный метод контроллера веб-API.

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample1.cs)]

Параметр *ID* — это &quot;простой тип&quot;, поэтому веб-API пытается получить значение из универсального кода ресурса (URI) запроса. Параметр *Item* является сложным типом, поэтому веб-API использует модуль форматирования типа мультимедиа для считывания значения из текста запроса.

Чтобы получить значение из универсального кода ресурса (URI), веб-API ищет данные маршрута и строку запроса URI. Данные маршрута заполняются, когда система маршрутизации анализирует URI и сопоставляет его с маршрутом. Дополнительные сведения см. в разделе [Маршрутизация и выбор действий](../web-api-routing-and-actions/routing-and-action-selection.md).

В оставшейся части этой статьи я покажу, как можно настроить процесс привязки модели. Однако для сложных типов рекомендуется использовать модули форматирования типа мультимедиа везде, где это возможно. Ключевым принципом протокола HTTP является то, что ресурсы отправляются в тексте сообщения с помощью согласования содержимого для указания представления ресурса. Модули форматирования типа мультимедиа предназначены именно для этой цели.

## <a name="using-fromuri"></a>Использование [Фромури]

Чтобы заставить веб-API считывать сложный тип из универсального кода ресурса (URI), добавьте атрибут **[фромури]** в параметр. В следующем примере определяется тип `GeoPoint`, а также метод контроллера, который получает `GeoPoint` из универсального кода ресурса (URI).

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample2.cs)]

Клиент может разместить значения широты и долготы в строке запроса, а веб-API будет использовать их для создания `GeoPoint`. Например:

`http://localhost/api/values/?Latitude=47.678558&Longitude=-122.130989`

## <a name="using-frombody"></a>Использование [FromBody]

Чтобы заставить веб-API считывать простой тип из текста запроса, добавьте атрибут **[FromBody]** в параметр:

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample3.cs)]

В этом примере веб-API будет использовать модуль форматирования типа мультимедиа для считывания значения *имени* из текста запроса. Ниже приведен пример клиентского запроса.

[!code-console[Main](parameter-binding-in-aspnet-web-api/samples/sample4.cmd)]

Если параметр имеет значение [FromBody], веб-API использует заголовок Content-Type для выбора модуля форматирования. В этом примере тип содержимого — &quot;Application/JSON&quot;, а текст запроса — необработанная строка JSON (не объект JSON).

Для чтения текста сообщения может быть не более одного параметра. Поэтому это не будет работать:

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample5.cs)]

Причина этого правила заключается в том, что текст запроса может храниться в небуферизованном потоке, который может быть считан только один раз.

## <a name="type-converters"></a>Преобразователи типов

Веб-API может рассматривать класс как простой тип (поэтому веб-API будет пытаться привязать его из универсального кода ресурса (URI)), создав **TypeConverter** и добавив преобразование строки.

В следующем коде показан класс `GeoPoint`, представляющий географическую точку, а также **TypeConverter** , который преобразует строки в `GeoPoint` экземпляры. Класс `GeoPoint` снабжен атрибутом **[TypeConverter]** для указания преобразователя типов. (Этот пример был связан с записью блога Mike в блоге [о том, как выполнить привязку к пользовательским объектам в сигнатурах действий в MVC/WebAPI](https://blogs.msdn.com/b/jmstall/archive/2012/04/20/how-to-bind-to-custom-objects-in-action-signatures-in-mvc-webapi.aspx).)

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample6.cs)]

Теперь веб-API будет обрабатывать `GeoPoint` как простой тип, то есть будет пытаться привязать `GeoPoint` параметры из универсального кода ресурса (URI). В параметре не нужно включать **[фромури]** .

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample7.cs)]

Клиент может вызвать метод с URI следующим образом:

`http://localhost/api/values/?location=47.678558,-122.130989`

## <a name="model-binders"></a>Привязки моделей

Более гибкий вариант, чем преобразователь типов, заключается в создании пользовательского связывателя модели. При использовании связывателя модели у вас есть доступ к таким средствам, как HTTP-запрос, описание действия и необработанные значения из данных маршрута.

Чтобы создать связыватель модели, реализуйте интерфейс **имоделбиндер** . Этот интерфейс определяет единственный метод **биндмодел**:

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample8.cs)]

Ниже приведен связыватель модели для `GeoPoint` объектов.

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample9.cs)]

Связыватель модели получает необработанные входные значения от *поставщика значений*. Этот проект разделяет две отдельные функции:

- Поставщик значений принимает HTTP-запрос и заполняет словарь пар "ключ-значение".
- Связыватель модели использует этот словарь для заполнения модели.

Поставщик значений по умолчанию в веб-API получает значения из данных маршрута и строки запроса. Например, если универсальный код ресурса (URI) `http://localhost/api/values/1?location=48,-122`, поставщик значений создает следующие пары "ключ-значение":

- ID = &quot;1&quot;
- Расположение = &quot;48 122&quot;

(Предполагается, что используется шаблон маршрута по умолчанию, который &quot;API/{Controller}/{ID}&quot;.)

Имя параметра для привязки хранится в свойстве **моделбиндингконтекст. ModelName** . Связыватель модели ищет ключ с этим значением в словаре. Если значение существует и может быть преобразовано в `GeoPoint`, связыватель модели присваивает связанное значение свойству **моделбиндингконтекст. Model** .

Обратите внимание, что связыватель модели не ограничивается простым преобразованием типов. В этом примере связыватель модели сначала выполняет поиск в таблице известных расположений, и в случае сбоя он использует преобразование типов.

**Настройка связывателя модели**

Существует несколько способов задать связыватель модели. Во-первых, в параметр можно добавить атрибут **[моделбиндер]** .

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample10.cs)]

К типу можно также добавить атрибут **[моделбиндер]** . Веб-API будет использовать указанный связыватель модели для всех параметров этого типа.

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample11.cs)]

Наконец, можно добавить поставщик привязки модели в **HttpConfiguration**. Поставщик привязки модели — это просто класс фабрики, который создает связыватель модели. Поставщик можно создать, создав производный от класса [моделбиндерпровидер](https://msdn.microsoft.com/library/system.web.http.modelbinding.modelbinderprovider.aspx) . Однако если связыватель модели обрабатывает один тип, проще использовать встроенный **симплемоделбиндерпровидер**, который предназначен для этой цели. В следующем примере кода показано, как это сделать:

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample12.cs)]

При использовании поставщика привязки модели по-прежнему необходимо добавить атрибут **[моделбиндер]** в параметр, чтобы сообщить веб-API, что он должен использовать связыватель модели, а не модуль форматирования типа мультимедиа. Но теперь не нужно указывать тип связывателя модели в атрибуте:

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample13.cs)]

## <a name="value-providers"></a>Поставщики значений

Я упомянул, что связыватель модели получает значения от поставщика значений. Чтобы написать поставщик настраиваемого значения, реализуйте интерфейс **ивалуепровидер** . Ниже приведен пример, который извлекает значения из файлов cookie в запросе:

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample14.cs)]

Кроме того, необходимо создать фабрику поставщика значений, производная от класса **валуепровидерфактори** .

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample15.cs)]

Добавьте фабрику поставщика значений в **HttpConfiguration** , как показано ниже.

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample16.cs)]

Веб-API формирует все поставщики значений, поэтому когда связыватель модели вызывает **значение valueprovider. GetValue**, связыватель модели получает значение от первого поставщика значений, который может его создать.

Кроме того, можно задать фабрику поставщика значений на уровне параметров с помощью атрибута **значение valueprovider** , как показано ниже.

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample17.cs)]

Это указывает веб-API использовать привязку модели с заданной фабрикой поставщика значений, а не использовать другие зарегистрированные поставщики значений.

## <a name="httpparameterbinding"></a>хттппараметербиндинг

Связыватели моделей — это конкретный экземпляр более общего механизма. Если взглянуть на атрибут **[моделбиндер]** , вы увидите, что он является производным от абстрактного класса **параметербиндингаттрибуте** . Этот класс определяет единственный метод- **Binding**, который возвращает объект **хттппараметербиндинг** :

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample18.cs)]

**Хттппараметербиндинг** отвечает за привязку параметра к значению. В случае **[моделбиндер]** атрибут возвращает реализацию **хттппараметербиндинг** , которая использует **имоделбиндер** для выполнения фактической привязки. Вы также можете реализовать собственный **хттппараметербиндинг**.

Например, предположим, что необходимо получить ETag из `if-match` и `if-none-match` заголовков в запросе. Начнем с определения класса для представления ETag.

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample19.cs)]

Также будет определено перечисление, указывающее, следует ли получить ETag из заголовка `if-match` или `if-none-match`.

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample20.cs)]

Вот **хттппараметербиндинг** , который получает eTag из нужного заголовка и привязывает его к параметру типа ETag:

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample21.cs)]

Метод **ексекутебиндингасинк** выполняет привязку. В этом методе добавьте связанное значение параметра в словарь **актионаргумент** в **хттпактионконтекст**.

> [!NOTE]
> Если метод **ексекутебиндингасинк** считывает текст сообщения запроса, переопределите свойство **виллреадбоди** , чтобы оно возвращало значение true. Тело запроса может быть небуферизованным потоком, который может быть считан только один раз, поэтому веб-API принудительно применяет правило, которое может считывать только одна привязка к тексту сообщения.

Чтобы применить пользовательский **хттппараметербиндинг**, можно определить атрибут, производный от **параметербиндингаттрибуте**. Для `ETagParameterBinding`мы определим два атрибута: один для `if-match` заголовков и один для `if-none-match` заголовков. Оба являются производными от абстрактного базового класса.

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample22.cs)]

Ниже приведен метод контроллера, использующий атрибут `[IfNoneMatch]`.

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample23.cs)]

Помимо **параметербиндингаттрибуте**, существует еще один обработчик для добавления пользовательского **хттппараметербиндинг**. В объекте **HttpConfiguration** свойство **параметербиндингрулес** является коллекцией анонимных функций типа (**хттппараметердескриптор** -&gt; **хттппараметербиндинг**). Например, можно добавить правило, которое любой параметр ETag в методе GET использует `ETagParameterBinding` с `if-none-match`:

[!code-csharp[Main](parameter-binding-in-aspnet-web-api/samples/sample24.cs)]

Функция должна возвращать `null` для параметров, в которых привязка неприменима.

## <a name="iactionvaluebinder"></a>иактионвалуебиндер

Весь процесс привязки параметров управляется подключаемой службой **иактионвалуебиндер**. Реализация **иактионвалуебиндер** по умолчанию выполняет следующие действия:

1. Найдите **параметербиндингаттрибуте** в параметре. К ним относятся **[FromBody]** , **[фромури]** и **[моделбиндер]** , а также настраиваемые атрибуты.
2. В противном случае найдите в **HttpConfiguration. параметербиндингрулес** функцию, которая возвращает значение **хттппараметербиндинг**, отличное от NULL.
3. В противном случае используйте правила по умолчанию, описанные выше. 

    - Если параметр имеет тип "Simple" или имеет преобразователь типов, выполните привязку из универсального кода ресурса (URI). Это эквивалентно размещению атрибута **[фромури]** в параметре.
    - В противном случае попробуйте прочитать параметр из текста сообщения. Это эквивалентно размещению **[FromBody]** в параметре.

При необходимости можно заменить всю службу **иактионвалуебиндер** собственной реализацией.

## <a name="additional-resources"></a>Дополнительные ресурсы

[Пример пользовательской привязки параметра](https://github.com/aspnet/samples/tree/master/samples/aspnet/WebApi/CustomParameterBinding)

Майк записал хорошие серии записей блога о привязке параметров веб-API:

- [Как веб-API выполняет привязку параметров](https://blogs.msdn.com/b/jmstall/archive/2012/04/16/how-webapi-does-parameter-binding.aspx)
- [Привязка параметра стиля MVC для веб-API](https://blogs.msdn.com/b/jmstall/archive/2012/04/18/mvc-style-parameter-binding-for-webapi.aspx)
- [Привязка к пользовательским объектам в сигнатурах действий в MVC и веб-API](https://blogs.msdn.com/b/jmstall/archive/2012/04/20/how-to-bind-to-custom-objects-in-action-signatures-in-mvc-webapi.aspx)
- [Создание пользовательского поставщика значений в веб-API](https://blogs.msdn.com/b/jmstall/archive/2012/04/23/how-to-create-a-custom-value-provider-in-webapi.aspx)
- [Привязка параметра веб-API в невнутреннем режиме](https://blogs.msdn.com/b/jmstall/archive/2012/05/11/webapi-parameter-binding-under-the-hood.aspx)
