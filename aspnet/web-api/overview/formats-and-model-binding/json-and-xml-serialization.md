---
uid: web-api/overview/formats-and-model-binding/json-and-xml-serialization
title: Сериализация JSON и XML в веб-API ASP.NET-ASP.NET 4. x
author: MikeWasson
description: Описывает модули форматирования JSON и XML в веб-API ASP.NET ASP.NET 4. x.
ms.author: riande
ms.date: 05/30/2012
ms.custom: seoapril2019
ms.assetid: 1cd7525d-de5e-4ab6-94f0-51480d3255d1
msc.legacyurl: /web-api/overview/formats-and-model-binding/json-and-xml-serialization
msc.type: authoredcontent
ms.openlocfilehash: 00fa07f00eabf7e6c883c5e9ceaf9a38a8f49605
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78449130"
---
# <a name="json-and-xml-serialization-in-aspnet-web-api"></a>Сериализация JSON и XML в веб-API ASP.NET

по [Майк Уоссон](https://github.com/MikeWasson)

В этой статье описываются модули форматирования JSON и XML в веб-API ASP.NET.

В веб-API ASP.NET *модуль форматирования типа мультимедиа* — это объект, который может:

- Чтение объектов CLR из текста HTTP-сообщения
- Запись объектов среды CLR в текст сообщения HTTP

Веб-API предоставляет модули форматирования типа мультимедиа для JSON и XML. По умолчанию платформа вставляет эти модули форматирования в конвейер. Клиенты могут запрашивать JSON или XML в заголовке Accept HTTP-запроса.

## <a name="contents"></a>Содержимое

- [Модуль форматирования JSON-типов](#json_media_type_formatter)

    - [Свойства только для чтения](#json_readonly)
    - [Дату](#json_dates)
    - [Отступов](#json_indenting)
    - [Регистр в стиле Camel](#json_camelcasing)
    - [Анонимные и слабо типизированные объекты](#json_anon)
- [Модуль форматирования мультимедиа типа XML](#xml_media_type_formatter)

    - [Свойства только для чтения](#xml_readonly)
    - [Дату](#xml_dates)
    - [Отступов](#xml_indenting)
    - [Установка XML-сериализаторов для каждого типа](#xml_pertype)
- [Удаление модуля форматирования JSON или XML](#removing_the_json_or_xml_formatter)
- [Обработка циклических ссылок на объекты](#handling_circular_object_references)
- [Проверка сериализации объектов](#testing_object_serialization)

<a id="json_media_type_formatter"></a>
## <a name="json-media-type-formatter"></a>Модуль форматирования JSON-типов

Форматирование JSON предоставляется классом **жсонмедиатипеформаттер** . По умолчанию **жсонмедиатипеформаттер** использует библиотеку [JSON.NET](https://github.com/JamesNK/Newtonsoft.Json) для выполнения сериализации. Json.NET — сторонний проект с открытым исходным кодом.

При желании можно настроить класс **жсонмедиатипеформаттер** для использования **DataContractJsonSerializer** вместо JSON.NET. Для этого задайте для свойства **уседатаконтрактжсонсериализер** **значение true**:

[!code-csharp[Main](json-and-xml-serialization/samples/sample1.cs)]

### <a name="json-serialization"></a>Сериализация JSON

В этом разделе описываются некоторые особенности поведения модуля форматирования JSON с использованием сериализатора [JSON.NET](https://github.com/JamesNK/Newtonsoft.Json) по умолчанию. Это не предназначено для полной документации по библиотеке Json.NET. Дополнительные сведения см. в [документации по JSON.NET](http://james.newtonking.com/projects/json/help/).

#### <a name="what-gets-serialized"></a>Что сериализуется?

По умолчанию все открытые свойства и поля включаются в сериализованный код JSON. Чтобы опустить свойство или поле, необходимо снабдить его атрибутом **жсонигноре** .

[!code-csharp[Main](json-and-xml-serialization/samples/sample2.cs)]

Если вы предпочитаете &quot;согласие&quot;, добавьте класс с атрибутом **DataContract** . Если этот атрибут существует, элементы игнорируются, если только они не имеют **DataMember**. Можно также использовать **DataMember** для сериализации закрытых членов.

[!code-csharp[Main](json-and-xml-serialization/samples/sample3.cs)]

<a id="json_readonly"></a>
### <a name="read-only-properties"></a>Свойства только для чтения

Свойства, доступные только для чтения, сериализуются по умолчанию.

<a id="json_dates"></a>
### <a name="dates"></a>даты.

По умолчанию Json.NET записывает даты в формате [ISO 8601](http://www.w3.org/TR/NOTE-datetime) . Даты в формате UTC (всемирное время) записываются с суффиксом "Z". Даты в местном времени включают смещение часового пояса. Пример:

[!code-console[Main](json-and-xml-serialization/samples/sample4.cmd)]

По умолчанию Json.NET сохраняет часовой пояс. Это можно переопределить, задав свойство Датетимезонехандлинг:

[!code-csharp[Main](json-and-xml-serialization/samples/sample5.cs)]

Если вы предпочитаете использовать [Формат даты Microsoft JSON](https://msdn.microsoft.com/library/bb299886.aspx#intro_to_json_sidebarb) (`"\/Date(ticks)\/"`) вместо ISO 8601, задайте свойство **датеформасандлинг** в параметрах сериализатора:

[!code-csharp[Main](json-and-xml-serialization/samples/sample6.cs)]

<a id="json_indenting"></a>
### <a name="indenting"></a>Отступы

Чтобы написать код JSON с отступом, задайте для параметра **форматирования** значение **Форматирование. отступ**:

[!code-csharp[Main](json-and-xml-serialization/samples/sample7.cs)]

<a id="json_camelcasing"></a>
### <a name="camel-casing"></a>Регистр в стиле Camel

Чтобы записать имена свойств JSON с использованием прописных букв, не изменяя модель данных, задайте **камелкасепропертинамесконтрактресолвер** для сериализатора:

[!code-csharp[Main](json-and-xml-serialization/samples/sample8.cs)]

<a id="json_anon"></a>
### <a name="anonymous-and-weakly-typed-objects"></a>Анонимные и слабо типизированные объекты

Метод действия может возвращать анонимный объект и сериализовать его в JSON. Пример:

[!code-csharp[Main](json-and-xml-serialization/samples/sample9.cs)]

Текст ответного сообщения будет содержать следующий код JSON:

[!code-json[Main](json-and-xml-serialization/samples/sample10.json)]

Если веб-API получает слабо структурированные объекты JSON от клиентов, текст запроса можно десериализовать в тип **Newtonsoft. JSON. LINQ. JObject** .

[!code-csharp[Main](json-and-xml-serialization/samples/sample11.cs)]

Однако обычно лучше использовать строго типизированные объекты данных. Затем вам не нужно самостоятельно анализировать данные, и вы получаете преимущества проверки модели.

XML-сериализатор не поддерживает анонимные типы или экземпляры **JObject** . При использовании этих функций для данных JSON следует удалить модуль форматирования XML из конвейера, как описано далее в этой статье.

<a id="xml_media_type_formatter"></a>
## <a name="xml-media-type-formatter"></a>Модуль форматирования мультимедиа типа XML

Форматирование XML предоставляется классом **ксмлмедиатипеформаттер** . По умолчанию **ксмлмедиатипеформаттер** использует класс **DataContractSerializer** для выполнения сериализации.

При желании можно настроить **ксмлмедиатипеформаттер** для использования **XmlSerializer** вместо **DataContractSerializer**. Для этого задайте для свойства **усексмлсериализер** **значение true**:

[!code-csharp[Main](json-and-xml-serialization/samples/sample12.cs)]

Класс **XmlSerializer** поддерживает более узкий набор типов, чем **DataContractSerializer**, но предоставляет больший контроль над результирующим XML. Если необходимо сопоставить существующую схему XML, рассмотрите возможность использования **XmlSerializer** .

### <a name="xml-serialization"></a>Сериализация XML

В этом разделе описываются некоторые особенности поведения модуля форматирования XML с использованием **DataContractSerializer**по умолчанию.

По умолчанию DataContractSerializer ведет себя следующим образом:

- Все открытые свойства и поля для чтения и записи сериализуются. Чтобы опустить свойство или поле, необходимо снабдить его атрибутом **игноредатамембер** .
- Закрытые и защищенные члены не сериализуются.
- Свойства, доступные только для чтения, не сериализуются. (Однако содержимое свойства коллекции, доступного только для чтения, сериализуется.)
- Имена классов и членов записываются в XML-коде точно так же, как они отображаются в объявлении класса.
- Используется пространство имен XML по умолчанию.

Если требуется больший контроль над сериализацией, можно снабдить класс атрибутом **DataContract** . При наличии этого атрибута класс сериализуется следующим образом:

- &quot;согласие&quot;. свойства и поля не сериализуются по умолчанию. Чтобы сериализовать свойство или поле, добавьте к нему атрибут **DataMember** .
- Чтобы сериализовать закрытый или защищенный член, добавьте его в атрибут **DataMember** .
- Свойства, доступные только для чтения, не сериализуются.
- Чтобы изменить способ отображения имени класса в XML, задайте параметр *Name* в атрибуте **DataContract** .
- Чтобы изменить способ отображения имени члена в XML, задайте параметр *Name* в атрибуте **DataMember** .
- Чтобы изменить пространство имен XML, задайте параметр *Namespace* в классе **DataContract** .

<a id="xml_readonly"></a>
### <a name="read-only-properties"></a>Свойства только для чтения

Свойства, доступные только для чтения, не сериализуются. Если свойство только для чтения имеет резервное закрытое поле, можно пометить частное поле атрибутом **DataMember** . Этот подход требует наличия атрибута **DataContract** в классе.

[!code-csharp[Main](json-and-xml-serialization/samples/sample13.cs)]

<a id="xml_dates"></a>
### <a name="dates"></a>даты.

Даты записываются в формате ISO 8601. Например, &quot;2012-05-23T20:21:37.9116538 Z&quot;.

<a id="xml_indenting"></a>
### <a name="indenting"></a>Отступы

Чтобы написать XML с отступом, задайте для свойства **Indent** значение **true**:

[!code-csharp[Main](json-and-xml-serialization/samples/sample14.cs)]

<a id="xml_pertype"></a>
## <a name="setting-per-type-xml-serializers"></a>Установка XML-сериализаторов для каждого типа

Можно задать различные XML-сериализаторы для разных типов CLR. Например, у вас может быть определенный объект данных, для обеспечения обратной совместимости которого требуется **XmlSerializer** . Для этого объекта можно использовать **XmlSerializer** и продолжить использовать **DataContractSerializer** для других типов.

Чтобы задать сериализатор XML для определенного типа, вызовите **сетсериализер**.

[!code-csharp[Main](json-and-xml-serialization/samples/sample15.cs)]

Можно указать **XmlSerializer** или любой объект, производный от **XmlObjectSerializer**.

<a id="removing_the_json_or_xml_formatter"></a>
## <a name="removing-the-json-or-xml-formatter"></a>Удаление модуля форматирования JSON или XML

Вы можете удалить модуль форматирования JSON или модуль форматирования XML из списка модулей форматирования, если вы не хотите их использовать. Вот основные причины этого:

- Для ограничения ответов веб-API на определенный тип носителя. Например, можно выбрать поддержку только ответов JSON и удалить модуль форматирования XML.
- Для замены модуля форматирования по умолчанию пользовательским модулем форматирования. Например, можно заменить модуль форматирования JSON собственной пользовательской реализацией модуля форматирования JSON.

В следующем коде показано, как удалить модули форматирования по умолчанию. Вызовите его из **приложения\_метод Start** , определенный в Global. asax.

[!code-csharp[Main](json-and-xml-serialization/samples/sample16.cs)]

<a id="handling_circular_object_references"></a>
## <a name="handling-circular-object-references"></a>Обработка циклических ссылок на объекты

По умолчанию модули форматирования JSON и XML записывают все объекты в виде значений. Если два свойства ссылаются на один объект или один объект встречается дважды в коллекции, модуль форматирования сериализует объект дважды. Это конкретная проблема, если граф объектов содержит циклы, так как сериализатор выдаст исключение при обнаружении цикла в графе.

Рассмотрим следующие модели объектов и контроллер.

[!code-csharp[Main](json-and-xml-serialization/samples/sample17.cs)]

Вызов этого действия приведет к тому, что модуль форматирования создаст исключение, которое преобразуется в ответ на клиентский код состояния 500 (внутренняя ошибка сервера).

Чтобы сохранить ссылки на объекты в JSON, добавьте следующий код в **приложение\_запуск** метода в файле Global. asax:

[!code-csharp[Main](json-and-xml-serialization/samples/sample18.cs)]

Теперь действие контроллера вернет JSON, который выглядит следующим образом:

[!code-json[Main](json-and-xml-serialization/samples/sample19.json)]

Обратите внимание, что сериализатор добавляет к обоим объектам свойство &quot;$id&quot;. Кроме того, он обнаруживает, что свойство Employee. Department создает цикл, поэтому оно заменяет значение ссылкой на объект: {&quot;$ref&quot;:&quot;1&quot;}.

> [!NOTE]
> Ссылки на объекты не являются стандартными в JSON. Прежде чем использовать эту функцию, определите, будут ли клиенты иметь возможность анализировать результаты. Возможно, лучше просто удалить циклы из графа. Например, в этом примере нет необходимости в связи между сотрудниками и Отделом.

Для сохранения ссылок на объекты в XML существует два варианта. Более простой вариант заключается в добавлении `[DataContract(IsReference=true)]` в класс модели. Параметр *IsReference* включает ссылки на объекты. Помните, что **контракт DataContract** выполняет явный вход, поэтому также необходимо добавить атрибуты **DataMember** в свойства:

[!code-csharp[Main](json-and-xml-serialization/samples/sample20.cs)]

Теперь модуль форматирования создаст XML-код следующего вида:

[!code-xml[Main](json-and-xml-serialization/samples/sample21.xml)]

Если вы хотите избежать атрибутов в классе модели, существует еще один вариант: создать новый экземпляр **DataContractSerializer** конкретного типа и установить для *пресервеобжектреференцес* **значение true** в конструкторе. Затем установите этот экземпляр в качестве сериализатора для каждого типа на модуль форматирования мультимедиа типа XML. В следующем коде показано, как это сделать:

[!code-csharp[Main](json-and-xml-serialization/samples/sample22.cs?highlight=3)]

<a id="testing_object_serialization"></a>
## <a name="testing-object-serialization"></a>Проверка сериализации объектов

При проектировании веб-API полезно проверить, как будут сериализованы объекты данных. Это можно сделать без создания контроллера или вызова действия контроллера.

[!code-csharp[Main](json-and-xml-serialization/samples/sample23.cs)]
