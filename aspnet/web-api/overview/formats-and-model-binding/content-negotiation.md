---
uid: web-api/overview/formats-and-model-binding/content-negotiation
title: Содержимое согласование в ASP.NET Web API — ASP.NET 4.x
author: MikeWasson
description: Описывает, как веб-API ASP.NET реализует согласования содержимого HTTP для ASP.NET 4.x.
ms.author: riande
ms.date: 05/20/2012
ms.custom: seoapril2019
ms.assetid: 0dd51b30-bf5a-419f-a1b7-2817ccca3c7d
msc.legacyurl: /web-api/overview/formats-and-model-binding/content-negotiation
msc.type: authoredcontent
ms.openlocfilehash: cb6668ff6de276d3778ce11f27ce597d8bf1f9c7
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/09/2019
ms.locfileid: "59380165"
---
# <a name="content-negotiation-in-aspnet-web-api"></a>Согласование содержимого в веб-API ASP.NET

по [Майк Уоссон](https://github.com/MikeWasson)

В этой статье описывается, как веб-API ASP.NET реализует согласование содержимого для ASP.NET 4.x.

Спецификация HTTP (RFC 2616) определяет согласование содержимого, как «процесс выбора наиболее представлением ответ на запрос, когда доступны несколько представлений». Основной механизм согласования содержимого по протоколу HTTP, эти заголовки запроса:

- **Примите:** Типы мультимедиа, допустимые для ответа, например «application/json», «application/xml», или тип пользовательского носитель, такой как &quot;application/vnd.example+xml&quot;
- **Accept-Charset:** Какие наборы символов допустимы, например UTF-8 или ISO-8859-1.
- **Приемлемой кодировкой:** Какие кодировки содержимого являются допустимыми, таких как gzip.
- **Примите язык:** Предпочтительный естественного языка, такие как «en-us».

Сервер также можно просмотреть другие части HTTP-запроса. Например если запрос содержит заголовок X-Requested-With, указывающее, является AJAX-запрос, сервер может по умолчанию JSON Если отсутствует заголовок Accept.

В этой статье мы рассмотрим, как веб-API использует заголовки Accept "и" Accept-Charset. (В настоящее время не поддерживается встроенная Accept-Encoding "или" Accept-Language.)

## <a name="serialization"></a>Сериализация

Если контроллер Web API возвращает ресурс как тип CLR, конвейер сериализует возвращаемое значение и записывает его в тексте ответа HTTP.

Например рассмотрим следующее действие контроллера:

[!code-csharp[Main](content-negotiation/samples/sample1.cs)]

Клиент может передавать этого HTTP-запроса:

[!code-console[Main](content-negotiation/samples/sample2.cmd)]

Сервер может отправить в ответ:

[!code-console[Main](content-negotiation/samples/sample3.cmd)]

В этом примере клиент запросил JSON, Javascript или «все», что (\*/\*). Сервер вернул JSON-представление `Product` объекта. Обратите внимание, что имеет значение заголовка Content-Type в ответе &quot;application/json&quot;.

Контроллер также может возвращать **HttpResponseMessage** объекта. Чтобы указать объект среды CLR, текст ответа, вызовите **CreateResponse** метод расширения:

[!code-csharp[Main](content-negotiation/samples/sample4.cs)]

Этот параметр обеспечивает больший контроль над сведения об ответе. Можно задать код состояния, добавьте HTTP-заголовков и т. д.

Объект, который выполняет сериализацию ресурс называется *форматирования мультимедиа*. Модули форматирования мультимедиа являются производными от **MediaTypeFormatter** класса. Веб-API предоставляет модули форматирования мультимедиа для XML и JSON, и можно создать пользовательские модули форматирования для поддержки других типов мультимедиа. Сведения о написании пользовательского модуля форматирования, см. в разделе [модули форматирования мультимедиа](media-formatters.md).

## <a name="how-content-negotiation-works"></a>Как содержимого Works согласования

Во-первых, конвейер получает **IContentNegotiator** службы из **HttpConfiguration** объекта. Он также возвращает список модулей форматирования мультимедиа из **HttpConfiguration.Formatters** коллекции.

Затем конвейер вызывает **IContentNegotiator.Negotiate**, передавая:

- Тип объекта для сериализации
- Коллекция модулей форматирования мультимедиа
- HTTP-запроса

**Negotiate** метод возвращает два фрагмента информации:

- Какой модуль форматирования
- Тип носителя для ответа

Если модуль форматирования не найден, **Negotiate** возвращает **null**, и клиент получает ошибки HTTP 406 (неприемлемо).

В следующем коде показано, как контроллер может напрямую вызывать согласование содержимого:

[!code-csharp[Main](content-negotiation/samples/sample5.cs)]

Этот код эквивалентен на то, что конвейер выполняет автоматически.

## <a name="default-content-negotiator"></a>Согласователь содержимого по умолчанию

**DefaultContentNegotiator** класс предоставляет реализацию по умолчанию **IContentNegotiator**. Она использует несколько критериев для выбора модуля форматирования.

Во-первых модуль форматирования должен иметь возможность сериализовать тип. Проверка пройдена, вызвав **MediaTypeFormatter.CanWriteType**.

Согласователь содержимого просматривает каждый модуль форматирования затем оценивает, насколько хорошо она соответствует HTTP-запроса. Чтобы оценить соответствие, согласователь содержимого проверяет две вещи в модуль форматирования:

- **SupportedMediaTypes** коллекции, которая содержит список типов носителей, поддерживаемых. Согласователь содержимого предпринимается попытка этот список для запроса заголовок Accept. Обратите внимание, что заголовок Accept может содержать диапазонов. Например, «text/plain» — соответствие для текста /\* или \* / \*.
- **MediaTypeMappings** коллекции, которая содержит список **MediaTypeMapping** объектов. **MediaTypeMapping** класс предоставляет универсальный способ для сопоставления HTTP-запросов с типами мультимедиа. Например он может сопоставить HTTP-заголовка для определенного типа носителя.

При наличии нескольких совпадает, совпадение с наивысшим wins коэффициент качества. Пример:

[!code-console[Main](content-negotiation/samples/sample6.cmd)]

В этом примере application/json имеет коэффициент подразумеваемых качества, 1.0, поэтому она предпочтительнее, чем application/xml.

Если соответствий не найдено, согласователь содержимого пытается сопоставить с типом мультимедиа тела запроса, если таковые имеются. Например если запрос содержит данные JSON, согласователь содержимого ищет модуль форматирования JSON.

Если по-прежнему нет совпадений, согласователь содержимого просто выбирает первый модуль форматирования, который может сериализовать тип.

## <a name="selecting-a-character-encoding"></a>Выбрать кодировку

После выбора модуля форматирования согласователь содержимого выбирает лучшую кодировку символов, просмотрев **SupportedEncodings** свойству в модуль форматирования и ее противопоставления заголовок Accept-Charset в запросе (если таковые имеются).
