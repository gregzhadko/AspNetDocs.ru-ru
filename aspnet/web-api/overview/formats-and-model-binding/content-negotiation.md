---
uid: web-api/overview/formats-and-model-binding/content-negotiation
title: Согласование содержимого в веб-API ASP.NET ASP.NET 4. x
author: MikeWasson
description: Описывает, как веб-API ASP.NET реализует согласование содержимого HTTP для ASP.NET 4. x.
ms.author: riande
ms.date: 05/20/2012
ms.custom: seoapril2019
ms.assetid: 0dd51b30-bf5a-419f-a1b7-2817ccca3c7d
msc.legacyurl: /web-api/overview/formats-and-model-binding/content-negotiation
msc.type: authoredcontent
ms.openlocfilehash: cb6668ff6de276d3778ce11f27ce597d8bf1f9c7
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78504660"
---
# <a name="content-negotiation-in-aspnet-web-api"></a>Согласование содержимого в веб-API ASP.NET

по [Майк Уоссон](https://github.com/MikeWasson)

В этой статье описывается, как веб-API ASP.NET реализует согласование содержимого для ASP.NET 4. x.

Спецификация HTTP (RFC 2616) определяет согласование содержимого как "процесс выбора наилучшего представления для данного ответа, если доступно несколько представлений". Основным механизмом согласования содержимого в HTTP являются следующие заголовки запросов:

- **Принять:** Типы мультимедиа, приемлемые для ответа, такие как "Application/JSON", "Application/XML", или пользовательский тип мультимедиа, например &quot;application/vnd. example + XML&quot;
- **Accept-Charset:** Допустимые наборы символов, такие как UTF-8 или ISO 8859-1.
- **Accept — кодировка:** Допустимые кодировки содержимого, например gzip.
- **Accept — Language:** Предпочтительный естественный язык, например "en-US".

Сервер также может просматривать другие части HTTP-запроса. Например, если запрос содержит заголовок X-Request-with, указывающий на запрос AJAX, то сервер может по умолчанию использовать JSON, если заголовок Accept отсутствует.

В этой статье мы рассмотрим, как веб-API использует заголовки Accept и Accept-CharSet. (В настоящее время отсутствует встроенная поддержка Accept-Encoding или Accept-Language.)

## <a name="serialization"></a>Сериализация

Если контроллер веб-API возвращает ресурс как тип CLR, конвейер сериализует возвращаемое значение и записывает его в текст ответа HTTP.

Например, рассмотрим следующее действие контроллера:

[!code-csharp[Main](content-negotiation/samples/sample1.cs)]

Клиент может отправить этот HTTP-запрос:

[!code-console[Main](content-negotiation/samples/sample2.cmd)]

В ответ сервер может отправить следующее сообщение:

[!code-console[Main](content-negotiation/samples/sample3.cmd)]

В этом примере клиент запросил либо JSON, JavaScript, либо "что угодно" (\*/\*). Сервер ответил с помощью JSON-представления объекта `Product`. Обратите внимание, что заголовок Content-Type в ответе имеет значение &quot;Application/JSON&quot;.

Контроллер также может возвращать объект **HttpResponseMessage** . Чтобы указать объект CLR для текста ответа, вызовите метод расширения **креатереспонсе** :

[!code-csharp[Main](content-negotiation/samples/sample4.cs)]

Этот параметр обеспечивает более полный контроль над данными ответа. Можно задать код состояния, добавить заголовки HTTP и т. д.

Объект, который сериализует ресурс, называется *модулем форматирования мультимедиа*. Модули форматирования мультимедиа являются производными от класса **MediaTypeFormatter** . Веб-API предоставляет средства форматирования мультимедиа для XML и JSON, а также позволяет создавать пользовательские модули форматирования для поддержки других типов мультимедиа. Сведения о написании пользовательского модуля форматирования см. в разделе [модули форматирования мультимедиа](media-formatters.md).

## <a name="how-content-negotiation-works"></a>Как работает согласование содержимого

Сначала конвейер получает службу **иконтентнеготиатор** из объекта **HttpConfiguration** . Он также получает список модулей форматирования мультимедиа из коллекции **HttpConfiguration. Formatter** .

Затем конвейер вызывает **иконтентнеготиатор. Negotiate**, передавая:

- Тип объекта для сериализации
- Коллекция модулей форматирования мультимедиа
- HTTP-запрос

Метод **Negotiate** возвращает два фрагмента информации:

- Используемый модуль форматирования
- Тип носителя для ответа

Если модуль форматирования не найден, метод **Negotiate** возвращает **значение NULL**, и клиент получает ошибку HTTP 406 (неприемлемо).

В следующем коде показано, как контроллер может напрямую вызывать согласование содержимого:

[!code-csharp[Main](content-negotiation/samples/sample5.cs)]

Этот код эквивалентен тому, что делает конвейер автоматическим.

## <a name="default-content-negotiator"></a>Negotiator содержимого по умолчанию

Класс **дефаултконтентнеготиатор** предоставляет реализацию **иконтентнеготиатор**по умолчанию. Для выбора модуля форматирования используется несколько критериев.

Во первых, модуль форматирования должен иметь возможность сериализовать тип. Это проверяется путем вызова **MediaTypeFormatter. канвритетипе**.

Затем Negotiator содержимого просматривает каждый модуль форматирования и оценивает, насколько хорошо он соответствует HTTP-запросу. Чтобы оценить соответствие, Negotiator содержимого просматривает два объекта модуля форматирования:

- Коллекция **суппортедмедиатипес** , которая содержит список поддерживаемых типов носителей. Negotiator содержимого пытается сопоставить этот список с заголовком запроса Accept. Обратите внимание, что заголовок Accept может включать диапазоны. Например, "text/plain" — это совпадение для Text/\* или \*/\*.
- Коллекция **медиатипемаппингс** , которая содержит список объектов **медиатипемаппинг** . Класс **медиатипемаппинг** предоставляет универсальный способ сопоставления HTTP-запросов с типами мультимедиа. Например, он может сопоставлять пользовательский заголовок HTTP с определенным типом носителя.

Если существует несколько совпадений, то сопоставление с наивысшим коэффициентом качества — WINS. Пример:

[!code-console[Main](content-negotiation/samples/sample6.cmd)]

В этом примере приложение/JSON имеет неявный фактор качества 1,0, поэтому он предпочтительнее приложения или XML.

Если совпадения не найдены, содержимое Negotiator пытается сопоставить тип носителя текста запроса, если таковой имеется. Например, если запрос содержит данные JSON, Negotiator содержимого ищет модуль форматирования JSON.

Если совпадений по-прежнему нет, Negotiator содержимого просто выбирает первый модуль форматирования, который может сериализовать тип.

## <a name="selecting-a-character-encoding"></a>Выбор кодировки символов

После выбора модуля форматирования содержимого Negotiator выбирает наилучшую кодировку символов, просмотрев свойство **суппортеденкодингс** в модуле форматирования и сопоставляя его с заголовком Accept-Charset в запросе (если есть).
