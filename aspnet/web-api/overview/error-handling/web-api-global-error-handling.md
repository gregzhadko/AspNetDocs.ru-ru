---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: Глобальная обработка ошибок в ASP.NET Web API 2 | Документация Майкрософт
author: davidmatson
description: ''
ms.author: riande
ms.date: 02/03/2014
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: 3e371760d2b34eb2be492e6ebbb33a5f9f7eff10
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57058981"
---
<a name="global-error-handling-in-aspnet-web-api-2"></a>Глобальная обработка ошибок в ASP.NET Web API 2
====================
по [Matson Дэвид](https://github.com/davidmatson), [Рик Андерсон]((https://twitter.com/RickAndMSFT))

Сегодняшний день не существует простого способа в веб-API, чтобы вести журнал или глобально обработки ошибок. Некоторые необработанные исключения, которые можно обрабатывать с помощью [фильтры исключений](exception-handling.md), но существует несколько вариантов, обработка фильтров исключений невозможна. Пример:

1. Исключения выброшены из конструкторов контроллеров.
2. Исключения выброшены из обработчиков сообщений.
3. Исключения выброшены при маршрутизации.
4. Исключения выброшены при сериализации содержимого ответа.

Корпорация Майкрософт стремится предоставить простой, согласованный способ журнала и обработки (где это возможно) эти исключения. 

Существует два основных варианта обработки исключений, можно получить сообщение об ошибке и случай, где все мы можем — журнал исключение. Например в последнем случае, если исключение середине потоковой передачи содержимого ответа; в этом случае уже слишком поздно для отправки нового сообщения ответа, так как код состояния, заголовков и Частичное содержимое уже прошли по каналу связи, поэтому мы просто отменить соединение. Несмотря на то, что исключение не обрабатывается для создания нового сообщения ответа, по-прежнему поддерживает ведение журнала исключений. В случаях, где можно обнаружить ошибку мы может возвратить ответ соответствующее сообщение об ошибке, как показано в следующем примере:

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a>Существующие параметры

В дополнение к [фильтры исключений](exception-handling.md), [обработчиков сообщений](../advanced/http-message-handlers.md) может использоваться для просмотра всех ответов уровня 500 сегодня, но реагирования на эти ответы сложно, как они отсутствуют сведения об исходной ошибки. Обработчики сообщений также от наличия те же ограничения, что фильтры исключений, касающиеся случаев, которые они обрабатывают. Хотя веб-API инфраструктура трассировки, который фиксирует ошибки инфраструктуры для целей диагностики и не планирование и подходит для выполнения в рабочих средах. Глобальные обработки исключений и ведения журнала должен быть службы, которые можно выполнить в процессе производства и подключать к существующими решениями мониторинга (например, [ELMAH](https://code.google.com/p/elmah/) ).

### <a name="solution-overview"></a>Общие сведения о решении

 Мы предоставляем две новые службы ресурсом [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) и IExceptionHandler для журнала и обработки необработанных исключений. Службы очень похожи, с помощью два основных различия:

1. Мы поддерживаем регистрации несколько средств ведения журнала исключений, но только единственный обработчик исключений.
2. Средств ведения журнала исключений всегда вызываются, даже если мы собираемся прервать соединение. Обработчики исключений только получить вызывается, когда мы можем по-прежнему выбирать ответное сообщение для отправки.

Обе службы предоставляют доступ к контексту исключения, содержащий важные сведения из точки, в которой обнаружено исключение, особенно [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), возникает исключение и источник исключения (Подробное описание ниже).

### <a name="design-principles"></a>Принципы проектирования

1. **Никаких критических изменений** так как эта функция добавляется в дополнительного номера версии, один — важное ограничение, влияющие на решения, существовать никаких критических изменений, либо к типу контрактов или поведение. Это ограничение исключить некоторые очистки, которую мы сделали с точки зрения существующих блоки catch, включение исключения в 500 ответов. Этой дополнительной очистки является то, что было бы рассмотреть вариант для последующих основного выпуска. Если это важно, чтобы вы проголосуйте на ее на сайте [мнение пользователей веб-API ASP.NET](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).
2. **Поддержание согласованности с веб-API создает** конвейер фильтра веб-API — это отличный способ обработки сквозных задач благодаря гибким возможностям применения логики в конкретных действий, относящиеся к контроллеру или глобальной области видимости. Фильтры, включая фильтры исключений, всегда имеют действия и контроллера контекстах, даже в том случае, если зарегистрирован в глобальной области. Существует контракта имеет смысл для фильтров, что это означает, что фильтры исключений, даже глобальной области из них, не подходят для обработки случаев, например для исключения из обработчиков сообщений, где контекст не действий или контроллера некоторых исключений. Если мы хотим использовать гибкие области, обеспечиваемую фильтры для обработки исключений, мы по-прежнему должны фильтры исключений. Но если нам нужно обработать исключение вне контекста контроллера, необходимо также отдельные конструкции для полной глобальной обработки ошибок (что-то без контроллера контекст и действие ограничений контекста).

### <a name="when-to-use"></a>Когда следует использовать

- Средств ведения журнала исключений — это решение, чтобы видеть все необработанного исключения перехватываются веб-API.
- Обработчики исключений являются решением для настройки всех возможных ответов на необработанные исключения перехватываются веб-API.
- Фильтры исключений являются самым простым решением для обработки необработанных подмножества исключений, связанных с определенного действия или контроллер.

### <a name="service-details"></a>Сведения о службе

 Интерфейсы службы средства ведения журнала и обработчик исключений, простых асинхронных методов, принимающих в соответствующих контекстах: 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 Мы также предоставляют базовые классы для этих интерфейсов. Переопределение методов core (синхронный или асинхронный) — все, что для входа или обработки на рекомендуемую требуется время. Для ведения журнала, `ExceptionLogger` базового класса будет убедиться, что метод ведения журнала core вызывается только один раз для каждого исключения (даже если позже распространяет дальнейшей выше по стеку вызовов и перехватывается снова). `ExceptionHandler` Базового класса будет вызывать основной метод обработки только для вызова исключения в верхней части стека вызовов, игнорируется для прежних версий вложенные блоки catch. (Упрощенные версии эти базовые классы находятся в приложении ниже). Оба `IExceptionLogger` и `IExceptionHandler` получать сведения об исключении через `ExceptionContext`.

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

Когда платформа вызывает средство ведения журнала исключений или обработчик исключений, будет всегда предоставлять `Exception` и `Request`. За исключением модульного тестирования, которая предоставит также всегда `RequestContext`. Он предоставит редко `ControllerContext` и `ActionContext` (только при вызове из блока catch для фильтров исключений). Он предоставит очень редко `Response`(только в определенных случаях IIS при середине при записи ответа). Обратите внимание, что, так как некоторые из этих свойств могут быть `null` возлагается потребитель на наличие `null` перед доступом к членам класса исключения.`CatchBlock` Строка, указывающая, какой блок catch видели исключение. Далее приведены строки блока catch.

- Сервер HTTP (SendAsync метод)
- HttpControllerDispatcher (SendAsync метод)
- HttpBatchHandler (SendAsync метод)
- IExceptionFilter (обработка в ApiController конвейера фильтра исключений в ExecuteAsync)
- Узел OWIN:

    - HttpMessageHandlerAdapter.BufferResponseContentAsync (для буферизации выходных данных)
    - HttpMessageHandlerAdapter.CopyResponseContentAsync (для потоковой передачи выходных данных)
- Веб-узел:

    - HttpControllerHandler.WriteBufferedResponseContentAsync (для буферизации выходных данных)
    - HttpControllerHandler.WriteStreamedResponseContentAsync (для потоковой передачи выходных данных)
    - HttpControllerHandler.WriteErrorResponseContentAsync (для сбоев в восстановление после ошибок в режиме буферизации выходных данных)

Список строк блок catch доступен также через статические свойства. (Строки блока catch core статический ExceptionCatchBlocks; остаток будет отображаться на один статический класс каждого для OWIN и веб-узла).`IsTopLevelCatchBlock` полезен для следующих рекомендуемый шаблон обработки исключений только в верхней части стека вызовов. Вместо того, чтобы включить исключения в 500 ответов, везде, где возникает в блоке catch вложенных, обработчик исключений можно позволить им распространяться, пока они будут доступны для просмотра узла.

В дополнение к `ExceptionContext`, средство ведения журнала получает дополнительные часть информации с помощью полной `ExceptionLoggerContext`:

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

Второе свойство `CanBeHandled`, позволяет средство ведения журнала для идентификации исключение, которое невозможно обработать. Когда является подключение прерывается и не нового ответного сообщения могут отправляться, средства ведения журнала будет вызываться но обработчик будет ***не*** вызываться, и средства ведения журнала можно обнаружить эту ситуацию из этого свойства.

В дополнение к `ExceptionContext`, обработчик получает еще одно свойство, его можно задать на полную `ExceptionHandlerContext` обработать исключение:

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

Обработчик исключений указывает, что он обработал исключение, задав `Result` свойство результат действия (например, [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [ StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), или пользовательским результатом). Если `Result` свойство имеет значение null, исключение не обрабатывается и исходное исключение будет создано повторно.

Для исключений, в верхней части стека вызовов мы воспользовались дополнительное действие, чтобы убедиться, что ответ подходит для вызова API. Если исключение распространяется на хост, вызывающий объект будет см. в разделе желтый экраном смерти, или некоторых других узлов предоставляться ответ, как правило, HTML и обычно не сообщение об ошибке соответствующие API. В таких случаях, то результат начинается, отличных от null, и только в том случае, если пользовательский обработчик исключений явным образом задает его обратно в `null` (необработанные) исключение распространяется на узле. Установка `Result` для `null` в таких случаях может оказаться полезным для двух сценариев:

1. OWIN размещенные веб-API с помощью пользовательского исключения, обработка по промежуточного слоя, зарегистрированные до/за пределами веб-API.
2. Локальная отладка через браузер, где желтый экраном смерти — фактически полезные ответ для необработанных исключений.

Для средств ведения журнала исключений и обработчики исключений мы ничего не делать для восстановления, если средство ведения журнала или сам обработчик вызывает исключение. (Кроме позволить исключению публикации, то оставьте отзыв в нижней части этой страницы, если у вас есть более эффективный подход.) Контракт для средств ведения журнала исключений и обработчики является то, что они не могут исключения распространится до их вызывающие объекты; в противном случае исключение будет просто распространить, часто вплоть до узла, что приводит к ошибке HTML (например, ASP. NET желтый экран), отправляемые обратно в клиенте (который обычно не является предпочтительным для вызова API, которые ожидают JSON или XML).

## <a name="examples"></a>Примеры

### <a name="tracing-exception-logger"></a>Средство ведения журнала трассировки исключений

Средство ведения журнала исключений ниже отправлять их исключение настроенные источники трассировки (в том числе в окно выходных данных отладки в Visual Studio).

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a>Обработчик исключений сообщение настраиваемых ошибок

Следующие ниже формирует ответ настраиваемых ошибок для клиентов, включая адрес электронной почты для обращения в службу поддержки.

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a>Регистрация фильтры исключений

Если вы используете шаблон проекта «ASP.NET MVC 4 веб-приложение» для создания проекта, поместите код конфигурации веб-API внутри `WebApiConfig` класса, в *приложения/_запуск* папку:

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a>Приложение. Сведения о базовых классах

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
