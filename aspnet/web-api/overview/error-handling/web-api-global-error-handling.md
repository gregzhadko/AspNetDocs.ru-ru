---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: Глобальная обработка ошибок в ASP.NET Web API 2 - ASP.NET 4.x
author: davidmatson
description: Обзор глобальной обработки ошибок в ASP.NET Web API 2 для ASP.NET 4.x.
ms.author: riande
ms.date: 02/03/2014
ms.custom: seoapril2019
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: 5ff54d2e4ed881ce927d0a401fb79d9b8bc5b8a1
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675420"
---
# <a name="global-error-handling-in-aspnet-web-api-2"></a>Глобальная обработка ошибок в ASP.NET Web API 2

[Дэвид Мэтсон](https://github.com/davidmatson), [Рик Андерсон](https://twitter.com/RickAndMSFT)

Эта тема содержит обзор глобальной обработки ошибок в ASP.NET Web API 2 для ASP.NET 4.x. Сегодня в Web API нет простого способа войти или обрабатывать ошибки по всему миру. Некоторые необработанные исключения могут быть обработаны с помощью [фильтров исключений,](exception-handling.md)но есть ряд случаев, которые фильтры исключений не могут обрабатывать. Пример:

1. Исключения выброшены из конструкторов контроллеров.
2. Исключения выброшены из обработчиков сообщений.
3. Исключения выброшены при маршрутизации.
4. Исключения выброшены при сериализации содержимого ответа.

Мы хотим предоставить простой и последовательный способ регистрации и обработки (где это возможно) этих исключений. 

Есть два основных случая для обработки исключений, случай, когда мы можем отправить ответ на ошибку и случай, когда все, что мы можем сделать, это войти в исключение. Примером последнего случая является случай, когда исключение выбрасывается в середину потокового содержимого ответа; в этом случае уже слишком поздно отправлять новое сообщение ответа, так как код состояния, заголовки и частичное содержимое уже перешли через провод, поэтому мы просто прерываем соединение. Несмотря на то, что исключение не может быть обработано для получения нового сообщения ответа, мы по-прежнему поддерживаем регистрацию исключения. В тех случаях, когда мы можем обнаружить ошибку, мы можем вернуть соответствующий ответ на ошибку, как показано в следующем:

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a>Существующие параметры

В дополнение к [фильтрам исключений](exception-handling.md) [обработчики сообщений](../advanced/http-message-handlers.md) могут быть использованы сегодня для наблюдения за всеми 500-уровневыми ответами, но действовать на этих ответах сложно, так как им не хватает контекста об исходной ошибке. Обработчики сообщений также имеют те же ограничения, что и фильтры исключений в отношении случаев, с которыми они могут обрабатывать. В то время как Web API имеет инфраструктуру отслеживания, которая фиксирует условия ошибки, инфраструктура трассировки предназначена для целей диагностики и не предназначена или не подходит для работы в производственных средах. Глобальная обработка исключений и журналирование должны быть службами, которые могут работать во время производства и быть подключены к существующим решениям мониторинга (например, [ELMAH).](https://code.google.com/p/elmah/)

### <a name="solution-overview"></a>Общие сведения о решении

 Мы предоставляем два новых сервиса по замене пользователей, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) и IExceptionHandler, для регистрации и обработки необработанных исключений. Услуги очень похожи, с двумя основными отличиями:

1. Мы поддерживаем регистрацию нескольких регистраторов исключений, но только одного обработчика исключений.
2. Регистраторы исключений всегда вызываются, даже если мы собираемся прервать соединение. Обработчики исключений вызываются только тогда, когда мы все еще можем выбрать, какое сообщение ответа отправить.

Обе службы предоставляют доступ к контексту исключения, содержащему соответствующую информацию с точки, где было обнаружено исключение, в частности [httpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), брошенное исключение и источник исключения (подробности ниже).

### <a name="design-principles"></a>Принципы проектирования

1. **Без изменений** Поскольку эта функциональность добавляется в незначительный выпуск, одним из важных ограничений, влияющих на решение, является то, что не будет никаких изменений, как для ввода контрактов, так и для поведения. Это ограничение исключило некоторую очистку, которая мы хотели бы сделать с точки зрения существующих блоков улова, превращающих исключения в 500 ответов. Эта дополнительная очистка является то, что мы могли бы рассмотреть для последующего крупного релиза. Если это важно для вас, пожалуйста, проголосуйте по нему на [ASP.NET голос пользователя Web API](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).
2. **Поддержание согласованности с построениями Web API** Конвейер фильтров Web API — это отличный способ справиться с проблемами перекрестного разреза с гибкостью применения логики в конкретном, конкретном контроллере или глобальном объеме. Фильтры, включая фильтры исключений, всегда имеют контексты действия и контроллера, даже если они зарегистрированы в глобальной области. Этот контракт имеет смысл для фильтров, но это означает, что фильтры исключений, даже в глобальном масштабе, не подходят для некоторых случаев обработки исключений, таких как исключения из обработчиков сообщений, где не существует контекста действий или контроллера. Если мы хотим использовать гибкий скопирование, предоставляемое фильтрами для обработки исключений, нам по-прежнему нужны фильтры исключений. Но если нам нужно обрабатывать исключение вне контекста контроллера, нам также нужна отдельная конструкция для полной глобальной обработки ошибок (что-то без контекста контроллера и ограничений контекста действия).

### <a name="when-to-use"></a>Назначение

- Регистраторы исключений являются решением для просмотра всех необработанных исключений, пойманных Web API.
- Обработчики исключений являются решением для настройки всех возможных ответов на необработанные исключения, пойманные Web API.
- Фильтры исключений являются самым простым решением для обработки необработанных исключений, связанных с определенным действием или контроллером.

### <a name="service-details"></a>Сведения о службе

 Интерфейсы службы за исключением исходят — это простые методы асинс, учитывая соответствующие контексты: 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 Мы также предоставляем базовые классы для обоих этих интерфейсов. Переопределение основных (синхронизированных или асиновых) методов — это все, что требуется для входа или обработки в рекомендуемое время. Для ведения `ExceptionLogger` журнала базовый класс гарантирует, что метод регистрации ядра вызывается только один раз для каждого исключения (даже если он позже распространяет дополнительный стек вызова и снова пойман). Базовый `ExceptionHandler` класс будет вызывать метод обработки ядра только для исключений в верхней части стека вызовов, игнорируя устаревшие вложенные блоки. (Упрощенные версии этих базовых классов приведены в приложении ниже.) Оба `IExceptionLogger` `IExceptionHandler` и получать информацию `ExceptionContext`об исключении через .

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

Когда фреймворк вызывает регистратор исключений или `Exception` обработчик исключений, он всегда будет предоставлять `Request`и За исключением модульного тестирования, `RequestContext`он также всегда будет предоставлять . Он редко предоставляет `ControllerContext` и `ActionContext` (только при вызове из блока улова для фильтров исключений). Он будет очень редко `Response`предоставлять (только в некоторых случаях IIS, когда в середине пытается написать ответ). Обратите внимание, что, поскольку некоторые из этих свойств могут быть, `null` потребитель должен `null` проверить, прежде чем получить доступ к членам класса исключений.`CatchBlock` — это строка, указывающая, какой блок ловли увидел исключение. Строки блока улова таковы:

- HttpServer (метод SendAsync)
- HttpControllerDispatcher (метод SendAsync)
- Httpbatchhandler (метод Сендасинка)
- IExceptionFilter (обработка ApiController конвейера фильтра исключений в ExecuteAsync)
- Хозяин OWIN:

    - HttpMessageHandlerAdapter.BufferResponseContentAsync (для буферизации выход)
    - HttpMessageHandlerAdapter.CopyResponseContentAsync (для потокового вывода)
- Веб-хостинг:

    - HttpControllerHandler.WriteBufferedResponseContentAsync (для буферизации выход)
    - HttpControllerHandler.WriteStreamedResponseContentAsync (для потокового вывода)
    - HttpControllerHandler.WriteErrorResponseContentAsync (за сбои в восстановлении ошибок в буферизированном режиме вывода)

Список строк блока ловли также доступен через статические только свойства чтения. (Основная строка блока catch находятся на статическом ExceptionCatchBlocks; остальная часть отображается на одном статичном классе для OWIN и веб-хостинга).`IsTopLevelCatchBlock` полезно следовать рекомендуемому шаблону обработки исключений только в верхней части стека вызовов. Вместо того, чтобы превращать исключения в 500 ответов в любом месте, где происходит вложенный блок улова, обработчик исключений может позволить исключениям распространяться до тех пор, пока они не будут замечены устомом.

В дополнение `ExceptionContext`к , регистратор получает еще одну часть `ExceptionLoggerContext`информации через полный:

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

Второе свойство, `CanBeHandled`позволяет регистратору определить исключение, которое не может быть обработано. Когда соединение будет прервано и новое сообщение ответа не может быть отправлено, регистраторы будут вызваны, но обработчик ***не*** будет вызываться, и регистраторы могут определить этот сценарий из этого свойства.

В дополнение `ExceptionContext`к, обработчик получает еще одно `ExceptionHandlerContext` свойство он может установить на полную обработку исключения:

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

Обработчик исключений указывает, что он `Result` обработал исключение, установив свойство в результате действия (например, [ExceptionResult,](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx) [InternalServerErrorResult,](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx) [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), или пользовательский результат). Если `Result` свойство является недействительным, исключение не обрабатывается и первоначальное исключение будет повторно брошено.

Для исключений в верхней части стека вызовов мы сделали дополнительный шаг, чтобы убедиться, что ответ подходит для абонентов API. Если исключение распространяется на узел, вызываец увидит желтый экран смерти или какой-либо другой узел, ответ, который обычно HTML и обычно не является подходящим ответом на ошибку API. В этих случаях результат начинается без нулевых, и только в том `null` случае, если пользовательский обработчик исключений явно устанавливает его обратно (необработанное) будет исключением, распространяемым на унитазу. Установка `Result` `null` в таких случаях может быть полезна для двух сценариев:

1. OWIN размещал Web API с пользовательским обработкой исключений, зарегистрированных до/вне Web API.
2. Локальная отладка через браузер, где желтый экран смерти на самом деле полезный ответ для необработанного исключения.

Как для регистраторов исключений, так и для обработчиков исключений мы не делаем ничего для восстановления, если регистратор или обработчик сам бросает исключение. (Помимо того, что исключение распространяется, оставьте обратную связь в нижней части этой страницы, если у вас есть лучший подход.) Контракт для регистраторов исключений и обработчиков заключается в том, что они не должны допускать распространения исключений до их абонентов; в противном случае исключение будет просто распространяться, часто вплоть до узла, что приводит к ошибке HTML (например, ASP. желтый экран NET) отправляется обратно клиенту (который обычно не является предпочтительным вариантом для абонентов API, которые ожидают JSON или XML).

## <a name="examples"></a>Примеры

### <a name="tracing-exception-logger"></a>Отслеживание исключение Логгер

Регистратор исключений ниже отправляет данные об исключениях в настроенные источники тегов (включая окно вывода Debug в Visual Studio).

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a>Обработка пользовательского сообщения об ошибках

Обработчик исключений ниже производит пользовательский ответ на ошибку для клиентов, в ключая адрес электронной почты для обращения в службу поддержки.

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a>Регистрация фильтров исключения

Если для создания проекта используется шаблон проекта "ASP.NET MVC 4 Web Application", `WebApiConfig` поместите код конфигурации Web API в класс в *App_Start* папку:

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a>Приложение: Подробная информация о базовом классе

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
