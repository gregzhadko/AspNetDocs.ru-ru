---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: Глобальная обработка ошибок в веб-API ASP.NET 2 — ASP.NET 4. x
author: davidmatson
description: Общие сведения об глобальной обработке ошибок в веб-API ASP.NET 2 для ASP.NET 4. x.
ms.author: riande
ms.date: 02/03/2014
ms.custom: seoapril2019
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: 94f2d6d31d0b37f9bb0077e6258c70a2dfb1918d
ms.sourcegitcommit: 7709c0a091b8d55b7b33bad8849f7b66b23c3d72
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/19/2020
ms.locfileid: "77457743"
---
# <a name="global-error-handling-in-aspnet-web-api-2"></a>Глобальная обработка ошибок в веб-API ASP.NET 2

по [Дэвида Матсон](https://github.com/davidmatson), [Рик Андерсон (](https://twitter.com/RickAndMSFT)

В этом разделе приводится обзор глобальной обработки ошибок в веб-API ASP.NET 2 для ASP.NET 4. x. Сегодня в веб-API нет простого способа для глобального протоколирования или обработки ошибок. Некоторые необработанные исключения могут обрабатываться с помощью [фильтров исключений](exception-handling.md), но существует ряд случаев, когда фильтры исключений не могут обрабатываться. Например:

1. Исключения выброшены из конструкторов контроллеров.
2. Исключения выброшены из обработчиков сообщений.
3. Исключения выброшены при маршрутизации.
4. Исключения, возникшие во время сериализации содержимого ответа.

Мы хотим предоставить простой, согласованный способ ведения журнала и управления (где это возможно) этих исключений. 

Существует два основных случая обработки исключений, случаи, когда мы можем отправить ответ об ошибке, и случай, когда все мы можем сделать, — записать исключение. Примером для последнего случая является случай возникновения исключения в середине содержимого ответа потоковой передачи. в этом случае слишком поздно отправить новое ответное сообщение, так как код состояния, заголовки и часть содержимого уже пропали по сети, поэтому мы просто прервать соединение. Несмотря на то, что исключение не может быть обработано для создания нового ответного сообщения, мы по-прежнему поддерживаем ведение журнала исключения. В случаях, когда мы можем обнаружить ошибку, можно вернуть соответствующий ответ об ошибке, как показано ниже:

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a>Существующие параметры

В дополнение к [фильтрам исключений](exception-handling.md), [обработчики сообщений](../advanced/http-message-handlers.md) можно использовать сегодня для отслеживания всех ответов уровня 500, но обработка этих ответов усложняется, так как в них отсутствует контекст исходной ошибки. Обработчики сообщений также имеют некоторые из тех же ограничений, что и фильтры исключений, касающиеся случаев, когда они могут быть обработаны. Хотя веб-API имеет инфраструктуру трассировки, которая фиксирует условия ошибки, инфраструктура трассировки предназначена для диагностики и не предназначена для работы в рабочих средах. Глобальная обработка исключений и ведение журнала должны быть службами, которые могут выполняться во время рабочей среды и быть подключенными к существующим решениям для мониторинга (например, [ELMAH](https://code.google.com/p/elmah/) ).

### <a name="solution-overview"></a>Общие сведения о решении

 Мы предоставляем две новые пользовательские службы, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) и IExceptionHandler, для ведения журнала и обработки необработанных исключений. Службы очень похожи, и два основных отличия:

1. Мы поддерживаем регистрацию нескольких средств ведения журнала исключений, но только один обработчик исключений.
2. Средства ведения журнала исключений всегда вызываются, даже если мы собираемся прервать подключение. Обработчики исключений вызываются только тогда, когда мы по-прежнему можем выбрать ответное сообщение для отправки.

Обе службы предоставляют доступ к контексту исключения, содержащему важную информацию, из точки, где было обнаружено исключение, в частности [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), [хттпрекуестконтекст](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), вызванного исключения и источника исключения (подробные сведения приведены ниже).

### <a name="design-principles"></a>Принципы проектирования

1. **Нет критических изменений** Так как эта функциональность добавляется во вспомогательную версию, одно важное ограничение, влияющее на решение, состоит в отсутствии критических изменений либо для ввода контрактов, либо для поведения. Это ограничение потребовало некоторой очистки, которую мы хотели бы сделать с точки зрения существующих блоков catch, переключив исключения в ответы 500. Эта дополнительная очистка — это то, что мы можем рассмотреть для последующих основных выпусков. Если это важно, проголосуйте по адресу [веб-API ASP.NET пользовательским голосом](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).
2. **Поддержание согласованности с конструкциями веб-API** Конвейер фильтров веб-API — это отличный способ обработки перекрестных задач с гибкостью применения логики к конкретной или глобальной области, относящейся к конкретному действию или конкретному контроллеру. Фильтры, включая фильтры исключений, всегда имеют контексты действий и контроллеров, даже если они зарегистрированы в глобальной области. Этот контракт имеет смысл для фильтров, но это означает, что фильтры исключений, даже глобальные, не подходят для некоторых случаев обработки исключений, таких как исключения обработчиков сообщений, где не существует действия или контекста контроллера. Если мы хотим использовать гибкую область действия, обеспечиваемую фильтрами для обработки исключений, нам по-прежнему нужны фильтры исключений. Но если нам нужно обрабатывать исключение вне контекста контроллера, нам также потребуется отдельная конструкция для полной глобальной обработки ошибок (что не имеет ограничений контекста контроллера и контекста действия).

### <a name="when-to-use"></a>Назначение

- Средства ведения журнала исключений — это решение для просмотра всех необработанных исключений, перехваченных веб-API.
- Обработчики исключений — это решение для настройки всех возможных ответов на необработанные исключения, перехваченные веб-API.
- Фильтры исключений являются самым простым решением для обработки необработанных исключений подмножества, связанных с определенным действием или контроллером.

### <a name="service-details"></a>Service Details

 Интерфейсы средства ведения журнала исключений и службы обработчиков — это простые асинхронные методы, принимающие соответствующие контексты: 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 Мы также предоставляем базовые классы для обоих интерфейсов. Переопределение основных методов (Sync или Async) — это все, что требуется для регистрации или работы в рекомендуемом времени. Для ведения журнала базовый класс `ExceptionLogger` гарантирует, что основной метод ведения журнала вызывается только один раз для каждого исключения (даже если позже он передается дальше по стеку вызовов и снова перехватывается). Базовый класс `ExceptionHandler` будет вызывать основной метод обработки только для исключений в верхней части стека вызовов, игнорируя устаревшие вложенные блоки catch. (Упрощенные версии этих базовых классов приведены в приложении ниже.) И `IExceptionLogger`, и `IExceptionHandler` получают сведения об исключении через `ExceptionContext`.

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

Когда платформа вызывает средство ведения журнала исключений или обработчик исключений, всегда будет предоставляться `Exception` и `Request`. За исключением модульного тестирования, также всегда будет предоставляться `RequestContext`. Он редко предоставляет `ControllerContext` и `ActionContext` (только при вызове из блока catch для фильтров исключений). Он очень редко предоставляет `Response`(только в определенных случаях IIS, когда в ходе попытки записи ответа). Обратите внимание, что, так как некоторые из этих свойств могут быть `null`, пользователь должен проверить наличие `null` перед доступом к членам класса Exception.`CatchBlock` Строка, указывающая, какой блок catch обнаружил исключение. Ниже приведены строки блока catch.

- HttpServer (метод SendAsync)
- Хттпконтроллердиспатчер (метод SendAsync)
- Хттпбатчхандлер (метод SendAsync)
- Иексцептионфилтер (ApiController обработка конвейера фильтра исключений в ExecuteAsync)
- Узел OWIN:

    - HttpMessageHandlerAdapter. Буфферреспонсеконтентасинк (для буферизации выходных данных)
    - HttpMessageHandlerAdapter. Копиреспонсеконтентасинк (для потокового вывода)
- Веб-узел:

    - HttpControllerHandler. WriteBufferedResponseContentAsync (для буферизации выходных данных)
    - HttpControllerHandler. Вритестреамедреспонсеконтентасинк (для потокового вывода)
    - HttpControllerHandler. Вритиррорреспонсеконтентасинк (для сбоев при восстановлении после ошибок в режиме буферизации вывода)

Список строк блока catch также доступен через статические свойства ReadOnly. (Основная строка блока catch находится на статическом ExceptionCatchBlocks; остаток отображается по одному статическому классу для OWIN и веб-узла).`IsTopLevelCatchBlock` рекомендуется использовать для поддержки рекомендуемого шаблона обработки исключений только в верхней части стека вызовов. Вместо того чтобы включать исключения в ответы 500 в любом месте во вложенном блоке catch, обработчик исключений может разрешить распространение исключений до тех пор, пока они не будут видны узлу.

Помимо `ExceptionContext`, средство ведения журнала получает еще один фрагмент информации с помощью полной `ExceptionLoggerContext`:

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

Второе свойство, `CanBeHandled`, позволяет средству ведения журнала определять исключение, которое не может быть обработано. Если соединение скоро будет прервано и не удается отправить новое ответное сообщение, то средства ведения журнала будут вызываться, но обработчик ***не*** будет вызываться, и средства ведения журнала смогут опознать этот сценарий из этого свойства.

В дополнительных `ExceptionContext`обработчик получает еще одно свойство, которое может быть задано для полной `ExceptionHandlerContext` для обработки исключения:

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

Обработчик исключений указывает, что он обработал исключение, присвоив свойству `Result` результат действия (например, [ексцептионресулт](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [интерналсервереррорресулт](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [статускодересулт](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx)или пользовательский результат). Если свойство `Result` имеет значение null, исключение не обработано, и исходное исключение будет создано повторно.

Для исключений в верхней части стека вызовов мы заняли дополнительный шаг, чтобы убедиться, что ответ подходит для вызывающих объектов API. Если исключение распространяется на узел, вызывающий объект увидит желтый экран смерти или другой ответ, предоставленный ведущим узлом, который обычно является HTML, и не является, как правило, соответствующим ответом на ошибку API. В этих случаях результат начинается со значения, отличного от NULL, и только в том случае, если пользовательский обработчик исключений явно задает для него значение `null` (не обработано). это приведет к распространению исключения на узел. Установка `Result` в `null` в таких случаях может оказаться полезной в двух сценариях:

1. OWIN размещенный веб-API с настраиваемой обработки исключений по промежуточного слоя, зарегистрированный до или вне веб-API.
2. Локальная отладка через браузер, где желтый экран смерти фактически является полезным ответом для необработанного исключения.

Для средств ведения журнала исключений и обработчиков исключений мы не делаем никаких действий для восстановления, если само средство ведения журнала или обработчик создает исключение. (Кроме распространения исключения, оставьте отзыв в нижней части этой страницы, если у вас есть лучший подход.) Контракт для средств ведения журнала исключений и обработчиков заключается в том, что они не должны допустить распространение исключений на вызывающие объекты. в противном случае исключение просто будет распространено, как правило, в результате ошибки HTML (например, ASP). Желтый экран в сети) отправляется обратно клиенту (что обычно не является предпочтительным вариантом для вызывающих объектов API, которые предполагают формат JSON или XML).

## <a name="examples"></a>Примеры

### <a name="tracing-exception-logger"></a>Трассировка средства ведения журнала исключений

В средстве ведения журнала исключений ниже отправляются данные исключений в настроенные источники трассировки (включая окно выходных данных отладки в Visual Studio).

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a>Обработчик исключений настраиваемых сообщений об ошибках

Следующий пример приводит к возникновению настраиваемого ответа об ошибке клиентам, включая адрес электронной почты для обращения в службу поддержки.

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a>Регистрация фильтров исключений

Если вы используете шаблон проекта "веб-приложение ASP.NET MVC 4" для создания проекта, разместите код конфигурации веб-API в классе `WebApiConfig` в папке *app/_Start* :

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a>Приложение. сведения о базовом классе

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
