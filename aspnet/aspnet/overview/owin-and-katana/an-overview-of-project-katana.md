---
uid: aspnet/overview/owin-and-katana/an-overview-of-project-katana
title: Обзор проекта Katana | Документация Майкрософт
author: howarddierking
description: Платформа ASP.NET используется уже более десяти лет, и включения платформы разработки бесчисленное множество веб-сайтов и служб. Как веб-приложений...
ms.author: riande
ms.date: 08/30/2013
ms.assetid: 0ee21741-c1bf-4025-a9b0-24580cae24bc
msc.legacyurl: /aspnet/overview/owin-and-katana/an-overview-of-project-katana
msc.type: authoredcontent
ms.openlocfilehash: 72f70faa151007558ecbb270143ecd5b37c2134d
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59392577"
---
# <a name="an-overview-of-project-katana"></a>Обзор проекта Katana

по [Говард Дайеркинг](https://github.com/howarddierking)

> Платформа ASP.NET используется уже более десяти лет, и включения платформы разработки бесчисленное множество веб-сайтов и служб. Как развились стратегии разработки веб-приложений, платформа была развивающихся шаг с помощью технологии, такие как ASP.NET MVC и веб-API ASP.NET. При разработке веб-приложений принимает его Далее целый эволюционный этап в мире облачных вычислений, проект [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) предоставляет базовый набор компонентов для приложений ASP.NET, что позволяет им быть гибкий и переносимый упрощенный и обеспечить более высокую производительность – другими словами, проектов [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) cloud оптимизирует приложений ASP.NET.


## <a name="why-katana--why-now"></a>Почему Katana — почему сейчас?

 Независимо от одного занимает обсуждение разработчиков продукта framework или конечных пользователей, важно понять базовые этих причин для создания продукта и часть, включает в себя знание того, кем продукт был создан для. ASP.NET была создана с помощью двух клиентов в виду.   
  
**Первая группа клиентов было разработчики классических страниц ASP.** В то время ASP был одним из основные технологии для создания динамических, управляемых данными веб-сайтов и приложений при смешении разметка и скрипт на стороне сервера. Среда выполнения ASP предоставленный скрипт на стороне сервера с набором объектов, которые абстрагированы основными аспектами базового протокола HTTP и веб-сервер и предоставленный доступ к дополнительным службам такие управление состоянием сеанса и приложения кэширования и т. д. Мощная, Классические приложения ASP становится непростой задачей для управления по мере роста размера и сложности. Это было в основном из-за отсутствия структуре, обнаруженной в средах, в сочетании с дублирование кода, полученный в результате чередование кода и разметки для создания скриптов. Для капитализации сильные стороны классического ASP, а также предоставляет некоторые из проблем, его, ASP.NET воспользовался организации кода, предоставляемые объектно ориентированных языках платформы .NET Framework, при этом сохраняя модель программирования на стороне сервера к какой классической технологии ASP разработчикам выросла привыкли.

**Вторая группа целевых клиентов для ASP.NET был разработчикам бизнес-приложений Windows.** В отличие от разработчики классических страниц ASP, кто привык записи HTML-разметка и код, чтобы создать дополнительные HTML-разметка, разработчики WinForms (например, перед их разработчики VB6) было пользоваться среды разработки, которое включено canvas и широкий набор пользователей элементы управления интерфейса. Первая версия ASP.NET, также называется «Веб-форм» предоставленные аналогичное поведение времени разработки вместе с модели событий на стороне сервера для компонентов пользовательского интерфейса и набор компонентов инфраструктуры (например, ViewState) для создания эффективной разработки между клиентом и программирование на стороне сервера. Веб-форм эффективно hid веб состояний в модели с отслеживанием состояния события, знакомые разработчикам WinForms.

### <a name="challenges-raised-by-the-historical-model"></a>Проблемы, вызванные исторической модели

**Конечный результат был зрелой, богатые возможностями среды выполнения и модель программирования разработчика.** Тем не менее, при, набор функций приходится на несколько важных проблем. Во-первых, платформа была **монолитных**, с логически неравных единицами функциональные возможности становятся тесно связанными в той же сборке System.Web.dll (например, HTTP базовым объектам с помощью форм на веб-платформе). Во-вторых, ASP.NET был включен как часть более крупной платформы .NET, что означало, что **время между выпусками, составило порядка нескольких лет.** Это затрудняет для ASP.NET, чтобы не отставать от все изменения, происходящие в быстро развивающихся веб-разработки. Наконец System.Web.dll, сам был связан в несколько разных способов для конкретного варианта размещения веб: Internet Information Services (IIS).

### <a name="evolutionary-steps-aspnet-mvc-and-aspnet-web-api"></a>Эволюционных этапов: ASP.NET MVC и ASP.NET Web API

И случается много изменений в веб-разработке! Веб-приложения были более разрабатываются как ряд небольших, имеющий фокус, компоненты, а не больших платформ. Число компонентов, а также частоту, с которой они были выпущены незначительный рост быстрее, когда-либо скоростью. Было ясно, что сохранение темпа веб-потребует платформ для получения меньшего размера, несвязанный и сосредоточиться вместо крупных и более богатые, поэтому **группа разработчиков ASP.NET занял несколько эволюционных этапов для запуска ASP.NET как семейство Подключаемые веб-компоненты, а не одну платформу**.

Одно из изменений, раннее была рост популярности известный шаблон разработки model-view-controller (MVC) благодаря веб-платформ разработки, такие как Ruby on Rails. Этот стиль создания веб-приложений дал разработчику больший контроль над разметкой приложения, при этом сохранить разделение разметки и бизнес-логика, что являлось одним их начальной точки продажи для ASP.NET. Для удовлетворения этих потребностей, для этого стиля разработки веб-приложений, Майкрософт воспользовались возможностью располагаться в будущем, лучше **разработки ASP.NET MVC аппаратного** (и не включая его в .NET Framework). Как независимая загрузка была выпущена ASP.NET MVC. Этот модуль позволял команды разработчиков гибкие возможности для доставки обновлений гораздо чаще, чем было возможно раньше.

Другой радикальные перемены в разработке веб-приложений был переход с динамической, сформированные сервером веб-страниц на статическую разметку начального с динамических разделов, страницы, созданные из клиентского скрипта взаимодействия **с серверной частью веб-API через Запросов AJAX**. Этот сдвиг в архитектуре помогла развития рассвет веб-API и разработкой веб-API ASP.NET framework. В случае ASP.NET MVC, в выпуске веб-API ASP.NET предоставляются еще одну возможность развивать дальнейшей как более модульную платформу ASP.NET. Команды разработчиков воспользовался возможной сделки и **встроенные веб-API ASP.NET, таким образом, что без зависимостей и на любой из типов framework core, найденные в System.Web.dll**. Эта функция включена две вещи: во-первых, оно означает, что веб-API ASP.NET может развиваться в виде полностью самодостаточной (и он может продолжать итерации быстро, так как оно будет доставлено через NuGet). Во-вторых из-за без внешних зависимостей для System.Web.dll и таким образом, нет зависимостей, в службах IIS, веб-API ASP.NET была предусмотрена возможность для запуска в настраиваемом узле (например, консольного приложения, службы Windows, и т.д.)

### <a name="the-future-a-nimble-framework"></a>Будущее: Гибкими Framework

Разделение компонентов framework друг от друга, и их выпуском в NuGet, платформы может теперь **итерации более независимо и быстрее**. Кроме того, мощные и гибкие возможности резидентного размещения веб-API оказался очень привлекательным для разработчиков, которым было **небольшой, облегченный узла** для своих служб. Оказалось настолько привлекательными, на самом деле, других платформ также нужна эта возможность того, это отображается новый запрос, в том, что каждая платформа работали в свои собственные хост-процессе на собственный базовый адрес и его нужно управлять (запущена, остановлена, т. д.) независимо друг от друга. Современные веб-приложения, как правило, поддерживает обслуживания статических файлов, создания динамической страницы, веб-API и более недавно реальном-времени или Push-уведомления. Ожидается, что каждая из этих служб следует запустить и управляемые независимо друг от друга не просто реалистичные.

Требовался одну ограниченную абстракцию размещения, дают разработчику возможность составлять приложения из множества различных компонентов и инфраструктур и затем запустите это приложение на узле поддержки.

## <a name="the-open-web-interface-for-net-owin"></a>Открытый веб-интерфейс для .NET (OWIN)

 Получив вдохновение преимущества, достигнутые [стойки](http://rack.github.io/) в сообществе Ruby несколько членов сообщества .NET решил написать абстракции между веб-серверы и компоненты инфраструктуры. Два миссий абстракции OWIN были, что она была проста и что заняло наименьшее число возможных зависимостей с другими типами framework. Эти две цели вы можете:

- Новые компоненты может более легко создается и использованы.
- Приложения могут более легко перенести между узлами и потенциально всей платформы и операционные системы.

Итоговый абстракции состоит из двух основных элементов. Первый — словарь среды. Эта структура данных отвечает за хранение все сведения о состоянии, необходимые для обработки HTTP-запроса и ответа, а также любой состоянии соответствующего сервера. Словарь среды определяется следующим образом:

[!code-console[Main](an-overview-of-project-katana/samples/sample1.cmd)]

Совместимые с OWIN веб-сервер отвечает за заполнение словарь среды, с данными, такие как потоки текста и коллекциями заголовков HTTP-запроса и ответа. Он отвечает затем компонентов приложение или платформу для заполнения или обновить словарь дополнительные значения и записи в поток тела откликов.

Помимо указания типа для словарь среды, в спецификации OWIN определяется список пар ключ-значение словаря core. Например ниже приведены необходимые словарь ключей для HTTP-запроса:

| Имя ключа | Описание значения |
| --- | --- |
| `"owin.RequestBody"` | Stream с текстом запроса, если таковые имеются. Stream.Null может использоваться как заполнитель, если тело отсутствует запрос. См. в разделе [текст запроса](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics). |
| `"owin.RequestHeaders"` | `IDictionary<string, string[]>` Заголовков запросов. См. в разделе [заголовки](http://owin.org/html/owin.html#3-3-headers). |
| `"owin.RequestMethod"` | Объект `string` содержащий метод запроса HTTP запроса (например, `"GET"`, `"POST"`). |
| `"owin.RequestPath"` | Объект `string` , содержащая путь запроса. Путь должен задаваться относительно «root» делегата приложения; см. в разделе [пути](http://owin.org/html/owin.html#5-3-paths). |
| `"owin.RequestPathBase"` | Объект `string` содержащая часть пути запроса, соответствующий «root» делегата приложения; см. в разделе [пути](http://owin.org/html/owin.html#5-3-paths). |
| `"owin.RequestProtocol"` | Объект `string` , содержащую имя протокола и версии (например `"HTTP/1.0"` или `"HTTP/1.1"`). |
| `"owin.RequestQueryString"` | Объект `string` содержащий компонент строки запроса HTTP-запроса URI, без начального знака «?» (например, `"foo=bar&baz=quux"`). Значение может быть пустой строкой. |
| `"owin.RequestScheme"` | Объект `string` содержащий схему URI, используемый для запроса (например, `"http"`, `"https"`); см. в разделе [схема URI](http://owin.org/html/owin.html#5-1-uri-scheme). |

Второй ключевой элемент OWIN — это делегат приложения. Это Сигнатура функции, который служит в качестве основной интерфейс между всеми компонентами приложения OWIN. Определение делегата приложения выглядит следующим образом:

`Func<IDictionary<string, object>, Task>;`

Делегат приложения, то просто реализацию типа делегата Func, где функция принимает словарь среды, как входные данные и возвращает задачу. Такой подход имеет несколько последствий для разработчиков:

- Существует очень небольшое количество тип зависимости, необходимые для записи компоненты OWIN. Это значительно увеличивает доступность OWIN для разработчиков.
- Асинхронной разработки позволяет абстракции эффективность его обработке вычислительных ресурсов, особенно в дополнительные с большим объемом операций ввода-вывода.
- Поскольку делегат приложения является неделимой единицей работы, а поскольку словарь среды переносятся в качестве параметра в делегате, компоненты OWIN можно легко объединить в цепочку для создания сложных HTTP, конвейеры обработки данных.

С точки зрения реализации OWIN — это спецификация ([http://owin.org/html/owin.html](http://owin.org/html/owin.html)). Его целью является не быть на следующем веб-платформе, но вместо спецификацию взаимодействия веб-платформами и веб-серверов.

Если изучения [OWIN](http://owin.org/) или [Katana](https://github.com/aspnet/AspNetKatana/wiki), вы также могли заметить, [пакет Owin NuGet](http://nuget.org/packages/Owin) и Owin.dll. Эта библиотека содержит единый интерфейс, [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs), который является формальным и фиксирует принципы последовательности запуска, описанные в [подраздел 4](http://owin.org/html/owin.html#4-application-startup) спецификации OWIN. Хотя не требуется для создания серверов OWIN [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs) интерфейс предоставляет конкретные опорную точку, и он используется компоненты проекта Katana.

## <a name="project-katana"></a>Проект Katana

Тогда как как [OWIN](http://owin.org/html/owin.html) спецификации и *Owin.dll* принадлежит сообщества и сообщества, запустите усилия с открытым исходным кодом, [Katana](https://github.com/aspnet/AspNetKatana/wiki) проекта входит набор OWIN компоненты, а по-прежнему открытым исходным кодом, создаются и выпускаемых корпорацией Майкрософт. К этим компонентам относятся как компонентами инфраструктуры, такими как узлы и серверы, так и функциональные компоненты, такие как компоненты проверки подлинности и привязки к платформам например [SignalR](../../../signalr/index.md) и [ASP.NET Web API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md). Проект содержит следующие три задачи верхнего уровня: 

- **Переносимые** — компоненты должны иметь возможность легко заменить новые компоненты, которые становятся доступными. Сюда относятся все типы компонентов из .NET framework для сервера и узел. Для этой цели подразумевается, что сторонние платформы позволяет легко запускать на серверах Microsoft хотя платформ Microsoft потенциально могут выполняться на сторонние серверы и узлы.
- **Модульная/гибкие**— в отличие от многих платформ, которые включают в себя множество функций, которые включены по умолчанию, компоненты проекта Katana должны быть компактными и направленными, предоставляя контроль разработчику приложения определить, какие компоненты необходимо Используйте в приложения.
- **Упрощенный и высокопроизводительных и масштабируемых** —, разбив традиционных концепция платформы на ряд небольших, компоненты, которые будут добавлены явно разработчиком приложения, полученное приложение Katana можно использовать меньшее количество вычислений с фокусом ввода ресурсы и таким образом, обрабатывать большую нагрузку, чем с другими типами серверов и платформ. Как приложения требует больше возможностей от базовой инфраструктуры, их можно добавить в конвейер OWIN, но это должно быть явное решение со стороны разработчика приложения. Кроме того заменяемости компонентами нижнего уровня означает, что как только они станут доступны, новых высокопроизводительных серверов могут легко быть введены для повышения производительности приложений OWIN, не нарушая работу этих приложений.

## <a name="getting-started-with-katana-components"></a>Приступая к работе с компонентами Katana

Когда она впервые появилась, один из аспектов [Node.js](http://nodejs.org/) платформа, которая сразу же нарисованную привлекает внимание была простота, с помощью которого можно создать и запустить веб-сервер. Если Katana цели были заключенных light из [Node.js](http://nodejs.org/), один может суммировать их, мы говорим, что Katana предоставляет многие преимущества [Node.js](http://nodejs.org/) (и платформы, как она) не заставляя разработчика выкидывать все, что она знает о разработке веб-приложений ASP.NET. Для этой инструкции, представленных Приступая к работе с проектом Katana должно быть так же просто в по своей природе [Node.js](http://nodejs.org/).

## <a name="creating-hello-world"></a>Создание «Hello World!»

Примечательным отличием между JavaScript и .NET приложений является наличие (или отсутствие) компилятора. Таким образом отправной точкой для простого сервера Katana — это проект Visual Studio. Тем не менее, мы начнем с минимальными типов проектов: пустое веб-приложение ASP.NET.

[![](an-overview-of-project-katana/_static/image1.png)](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)

Далее мы установим [Microsoft.Owin.Host.SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) пакет NuGet в проект. Этот пакет содержит сервер OWIN, который выполняется в конвейере запросов ASP.NET. Его можно найти на [коллекции NuGet](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) и могут быть установлены с помощью диалогового окна диспетчера пакетов Visual Studio или консоли диспетчера пакетов с помощью следующей команды:

[!code-console[Main](an-overview-of-project-katana/samples/sample2.cmd)]

Установка `Microsoft.Owin.Host.SystemWeb` пакета установит несколько дополнительных пакетов как зависимости. Одним из этих зависимостей является `Microsoft.Owin`, библиотеку, которая предоставляет несколько вспомогательных типов и методов для разработки приложений OWIN. Эти типы можно использовать для быстрого написания следующий сервер «hello world».

[!code-csharp[Main](an-overview-of-project-katana/samples/sample3.cs)]

Это очень простой веб-сервера можно запустить с помощью Visual Studio **F5** команды и обеспечивает полную поддержку отладки.

## <a name="switching-hosts"></a>Переключение узлов

По умолчанию в предыдущем примере «hello world» выполняется в конвейере запросов ASP.NET, который использует System.Web в контексте IIS. Это сама по себе добавляются значительные преимущества как она позволяет нам пользоваться гибкость и возможность компоновки конвейер OWIN с функциями управления и общую надежность IIS. Однако возможны ситуации, где преимущества, предоставляемые IIS не требуются, а также желание — для узла меньшего размера, проще. Необходимые, затем, чтобы запустить простой веб-сервере за пределами служб IIS и System.Web?

Чтобы проиллюстрировать цель переносимости, перемещения с узла веб сервера на узле командной строки требуется, простое добавление нового сервера и узел зависимостей выходную папку проекта, а затем запустить узел. В этом примере будут размещены наши веб-сервера в Katana узла с именем `OwinHost.exe` и будет использовать сервер на основе Katana HttpListener. Аналогичным образом для других компонентов Katana, их будет получен из NuGet, выполнив следующую команду:

[!code-console[Main](an-overview-of-project-katana/samples/sample4.cmd)]

Из командной строки, можно затем перейдите в корневую папку проекта и просто запустить `OwinHost.exe` (который был установлен в папке инструментов, соответствующего пакета NuGet). По умолчанию `OwinHost.exe` настроен для поиска серверов на основе HttpListener и поэтому не требуется никаких дополнительных настроек. Переходы в веб-браузер для `http://localhost:5000/` , что приложение теперь выполняется через консоль.

![](an-overview-of-project-katana/_static/image2.png)

## <a name="katana-architecture"></a>Архитектура Katana

 Архитектура компонентов Katana приложение разделяется на четыре логических слоев, как показано ниже: *узла, server, по промежуточного слоя,* и *приложения*. Архитектура компонентов добавляется таким образом, что реализации этих уровней можно легко заменить, во многих случаях без необходимости повторной компиляции приложения.   

![](an-overview-of-project-katana/_static/image3.png)

## <a name="host"></a>Узел

 Узел отвечает за:

- Управление происходящего.
- Оркестрация рабочего процесса, который приводит к выбора сервера и конструкцию конвейер OWIN через какие запросы будут обрабатываться.

  В настоящее время существует 3 основных варианта размещения приложений на основе Katana:  
  
**IIS/ASP.NET**: С помощью стандартных типов HttpModule и HttpHandler, OWIN конвейеры могут работать на IIS в составе поток запроса ASP.NET. Поддержка размещения ASP.NET включена путем установки пакета Microsoft.AspNet.Host.SystemWeb NuGet в проект веб-приложения. Кроме того поскольку IIS действует как узел и сервер, различие сервера или узла OWIN связывается в этот пакет NuGet, это означает, что если узел systemweb, разработчик не может заменить реализацию альтернативного сервера.  
  
**Пользовательский узел**: Suite компонент Katana позволяет разработчику для размещения приложений в собственный пользовательский процесс, будь то консольного приложения, службы Windows, и т.д. Эта функция выглядит аналогично возможность резидентного размещения, предоставляемые веб-API. В следующем примере показано пользовательское основное приложение веб-API кода:  

[!code-csharp[Main](an-overview-of-project-katana/samples/sample5.cs)]

Это аналогично Установка резидентного размещения для приложения Katana:

[!code-csharp[Main](an-overview-of-project-katana/samples/sample6.cs)]

Одно важное различие между веб-API и Katana примеры резидентного размещения является отсутствует пример резидентного размещения Katana код конфигурации веб-API. Чтобы включить переносимости и Компонуемость, Katana отделяет код, который запускает сервер из кода, который настраивает конвейер обработки запросов. Код, который настраивает веб-API, а затем содержится в классе Startup, кроме того заданное в качестве параметра типа в WebApplication.Start.

[!code-csharp[Main](an-overview-of-project-katana/samples/sample7.cs)]

Класс startup будут рассматриваться более подробно далее в этой статье. Тем не менее код, необходимые для запуска Katana, резидентного размещения соответствует процессу удивительно код, который используется в настоящее время в приложениях резидентного размещения веб-API ASP.NET.

**OwinHost.exe**: Хотя некоторые захотите написать пользовательский процесс для запуска приложений Katana Web, многие могут предпочесть просто запустить исполняемый файл с предварительно созданные, который можно запустить сервер и запускать приложения. В этом сценарии в набор компонентов Katana входят `OwinHost.exe`. При запуске из в корневом каталоге проекта, этот исполняемый файл будет запустить сервер (использует HttpListener сервер по умолчанию) и использовать соглашения найти и запустить класс startup пользователя. Для более детального контроля исполняемый файл предоставляет ряд дополнительных параметров командной строки.

![](an-overview-of-project-katana/_static/image4.png)

## <a name="server"></a>Сервер

 Ведущее приложение отвечает за запуск и обслуживание процесс, в котором выполняется приложение, ответственность за сервер открыть к сетевому сокету и прослушивать запросы отправлять их через конвейер OWIN компоненты по-настоящему пользователем (как вы уже могли заметить, этот конвейер указывается в классе Startup разработчик приложения). В настоящее время проект Katana включает две реализации серверов: 

- **Microsoft.Owin.Host.SystemWeb**: Как упоминалось ранее, IIS, в сочетании с действует конвейера ASP.NET, как и на узле, так и на сервер. Таким образом при выборе этого варианта размещения, IIS управляет детали реализации на уровне сервера, например процесс активации и прослушивает HTTP-запросы. Для веб-приложений ASP.NET затем отправляет запросы к конвейеру ASP.NET. Узел systemweb Katana регистрирует ASP.NET HttpModule и HttpHandler для перехвата запросов, так как они проходят через конвейер HTTP и отправить их через конвейер OWIN определяемое пользователем.
- **Microsoft.Owin.Host.HttpListener**: Как его названия, этот сервер Katana использует класс HttpListener платформы .NET Framework для открыть сокет и отправлять запросы в конвейер OWIN указанных разработчиком. Сейчас это значение сервера по умолчанию для резидентного размещения API Katana и OwinHost.exe.

## <a name="middlewareframework"></a>По промежуточного слоя и платформы

 Как упоминалось ранее когда сервер принимает запрос от клиента, он отвечает за передается через конвейер OWIN компоненты, которые задаются в коде запуска разработчика. Эти компоненты конвейера известны как по промежуточного слоя.  
 В самом простом уровне компонент по промежуточного слоя OWIN просто необходимо реализовать делегат приложения OWIN, таким образом, чтобы его можно вызывать.

[!code-console[Main](an-overview-of-project-katana/samples/sample8.cmd)]

Тем не менее для упрощения разработки и сочетание компонентов по промежуточного слоя, Katana поддерживает несколько соглашений и вспомогательные типы для компонентов по промежуточного слоя. Наиболее распространенные из них является `OwinMiddleware` класса. Компонента пользовательского по промежуточного слоя, созданного с помощью этого класса будет выглядеть аналогично следующему: 

[!code-csharp[Main](an-overview-of-project-katana/samples/sample9.cs)]

 Этот класс является производным от `OwinMiddleware`, реализующий конструктор, который принимает экземпляр следующее по промежуточного слоя в конвейере как один из аргументов, а затем передает его конструктора базового класса. Дополнительные аргументы, используемые для настройки по промежуточного слоя также объявляются в качестве параметров конструктора после параметра далее по промежуточного слоя.   
  
Во время выполнения, выполняется по промежуточного слоя с помощью переопределенный `Invoke` метод. Этот метод принимает один аргумент типа `OwinContext`. Предоставляемые этим объектом контекста `Microsoft.Owin` пакет NuGet, описанные ранее и предоставляет строго типизированный доступ в запросе, ответе и среды словарь, а также несколько дополнительных вспомогательных типов.   
  
Класс по промежуточного слоя можно легко добавить в конвейер OWIN в коде запуска приложения следующим образом:   

[!code-csharp[Main](an-overview-of-project-katana/samples/sample10.cs)]

Поскольку инфраструктуры Katana просто создает конвейер из компонентов по промежуточного слоя OWIN, а компоненты просто необходимо поддерживать делегат приложения для участия в конвейере, компоненты промежуточного слоя может отличаться по сложности от простой средства ведения журнала для всей платформы, такие как ASP.NET, веб-API или [SignalR](../../../signalr/index.md). Например добавление веб-API ASP.NET в предыдущем конвейер OWIN необходимо добавить следующий код запуска:

[!code-csharp[Main](an-overview-of-project-katana/samples/sample11.cs)]

Инфраструктура Katana построит конвейера компонентов по промежуточного слоя на основе порядка, в котором они были добавлены в объект IAppBuilder, в метод конфигурации. Затем, в нашем примере LoggerMiddleware может обрабатывать все запросы, которые проходят через конвейер, независимо от того, как эти запросы обрабатываются в конечном счете. Это позволяет реализовать эффективные сценарии, где компонент по промежуточного слоя (например компонент проверки подлинности) может обрабатывать запросы для конвейера, который включает в себя несколько компонентов и инфраструктур (например веб-API ASP.NET SignalR и статический файловый сервер).
 
## <a name="applications"></a>Приложения

Как показано в предыдущих примерах, OWIN и Katana проекта следует не рассматривать как новую модель программирования приложения, а также как абстрактный способ отделить моделями программирования приложений и платформ с сервера и инфраструктуры размещения. Например при создании приложений, веб-API, платформа разработчика продолжат использовать веб-API ASP.NET framework, независимо от того, является ли приложение выполняется в конвейер OWIN с помощью компонентов из проекта Katana. Одном месте, где будет отображаться на разработчик приложения код, связанный с OWIN будет код запуска приложения, где разработчик выполняет композицию конвейера OWIN. В код запуска разработчику необходимо зарегистрировать ряд инструкций UseXx, как правило, один для каждого компонента по промежуточного слоя, который будет обрабатывать входящие запросы. Этот процесс будет иметь то же действие регистрации HTTP-модулей в текущий мире System.Web. Как правило, большего размера framework по промежуточного слоя, например веб-API ASP.NET или [SignalR](../../../signalr/index.md) будет зарегистрирован в конце конвейера. Компоненты промежуточного слоя решать, например, для проверки подлинности или кэширование, обычно регистрируются к началу конвейера, чтобы они будет обрабатывать запросы для всех платформ и компоненты, зарегистрированные далее в конвейере. Такое разделение компонентов по промежуточного слоя друг от друга и от базовых компонентов инфраструктуры позволяет разделять компоненты развиваться в разных скоростей гарантией того, что системы в целом остается неизменным.

## <a name="components--nuget-packages"></a>Компоненты — пакеты NuGet

Как и многие текущего библиотек и платформ компоненты проекта Katana предоставляются как набор пакетов NuGet. Для грядущей версии 2.0 граф зависимостей пакета Katana выглядит следующим образом. (Щелкните изображение для его увеличения).

[![](an-overview-of-project-katana/_static/image6.png)](an-overview-of-project-katana/_static/image5.png)

Почти каждый пакет в проекте Katana зависит, прямо или косвенно, пакет Owin. Вы помните, что это пакет, содержащий интерфейс IAppBuilder, который предоставляет конкретную реализацию последовательность запуска приложения, описанные в разделе 4 спецификации OWIN. Кроме того многие пакеты зависят от Microsoft.Owin, который предоставляет набор вспомогательных типов для работы с HTTP-запросов и ответов. В оставшейся части пакета можно классифицировать как размещения пакеты инфраструктуры (серверов или узлов) или по промежуточного слоя. Пакеты и зависимости, которые являются внешними по отношению к проекту Katana отображаются оранжевым цветом.

Размещающая инфраструктура для Katana 2.0 включает в себя SystemWeb и серверы на основе HttpListener, OwinHost пакета для запуска приложений OWIN с помощью OwinHost.exe и Microsoft.Owin.Hosting пакет для самостоятельного размещения приложений OWIN в пользовательский узел (например консольного приложения, службы Windows, и т.д.)

Для Katana 2.0 компонентов по промежуточного слоя в первую очередь занимающихся разных средства проверки подлинности. Предоставляется один компонент дополнительного по промежуточного слоя для диагностики, который обеспечивает поддержку на странице начала или ошибка. При увеличении OWIN в де-факто размещения абстракции в экосистеме компоненты промежуточного слоя, разработанных корпорацией Майкрософт и сторонними компаниями, которые также будет увеличиваться в число.

## <a name="conclusion"></a>Заключение

 С самого начала проекта Katana цель не для создания и тем самым требует от разработчиков, чтобы узнать еще один веб-платформа. Вместо этого целью было создание абстракцию, чтобы предоставить больше вариантов, чем ранее разработчики .NET веб-приложений. Разбивая логические слои типичный веб-стек приложения в виде набора компонентов, можно заменить, проект Katana позволяет компонентам во всем стеке для улучшения в независимо от частоты лучше всего подходит для этих компонентов. Используя все компоненты вокруг простые абстракции OWIN, Katana позволяет платформ и приложений, построенный на базе их, можно переносить на другие разнообразные различные серверы и узлы. Поместив разработчик в элементе управления стека, Katana гарантирует, что разработчик вносит окончательное решение о том, как упрощенный или как возможностями, которые должны быть свой веб-стек.  
  

## <a name="for-more-information-about-katana"></a>Дополнительные сведения о Katana

- Проект Katana на GitHub: [ https://github.com/aspnet/AspNetKatana/ ](https://github.com/aspnet/AspNetKatana/).
- Видео: [Проект Katana — OWIN для ASP.NET](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET), Говард Дайеркинг.

## <a name="acknowledgements"></a>Благодарности

- [Рик Андерсон](https://blogs.msdn.com/b/rickandy/): (twitter [ @RickAndMSFT ](http://twitter.com/RickAndMSFT) ) Рик — старший разработчик программирования для Microsoft Azure и MVC.
- [Скотт Хансельман](http://www.hanselman.com/blog/): (twitter [ @shanselman ](https://twitter.com/shanselman) )
- [Джон Гэллоуэй](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [ @jongalloway ](https://twitter.com/jongalloway) )
