---
uid: aspnet/overview/owin-and-katana/an-overview-of-project-katana
title: Обзор проекта Katana | Документация Майкрософт
author: howarddierking
description: ASP.NET Framework составляет около десяти лет, и платформа позволила разрабатывать бесчисленные веб-сайты и службы. Как веб-защи...
ms.author: riande
ms.date: 08/30/2013
ms.assetid: 0ee21741-c1bf-4025-a9b0-24580cae24bc
msc.legacyurl: /aspnet/overview/owin-and-katana/an-overview-of-project-katana
msc.type: authoredcontent
ms.openlocfilehash: 1f28db822930cdfd2ebf4cf9bb27d173f4aa4201
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78500346"
---
# <a name="an-overview-of-project-katana"></a>Обзор проекта Katana

по [Говард Дайеркинг](https://github.com/howarddierking)

> ASP.NET Framework составляет около десяти лет, и платформа позволила разрабатывать бесчисленные веб-сайты и службы. По мере развития стратегий разработки веб-приложений платформа могла развивать свою поэтапную разработку с помощью таких технологий, как ASP.NET MVC и веб-API ASP.NET. По мере того, как разработка веб-приложений применяет свой следующий эволюционный этап в мире облачных вычислений, Project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) предоставляет базовый набор компонентов для ASP.NET приложений, обеспечивая гибкость, переносимость, упрощенную и лучшую производительность — поместив другой способ, проект [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) Cloud оптимизирует приложения ASP.NET.

## <a name="why-katana--why-now"></a>Зачем Katana — Зачем сейчас?

 Независимо от того, обсуждают ли вы платформу разработчика или продукт для конечных пользователей, важно понимать основные причины создания продукта, а также его часть, которая включает в себя знание того, для кого был создан продукт. ASP.NET изначально был создан с учетом двух клиентов.   
  
**Первая группа клиентов была классической средой разработки ASP.** В то время ASP был одной из основных технологий для создания динамических, управляемых данными веб-сайтов и приложений путем переплетения разметки и серверного скрипта. В среде выполнения ASP предоставлен серверный сценарий с набором объектов, которые являются абстрактными основными аспектами базового протокола HTTP и веб-сервером и обеспечивают доступ к дополнительным службам, таким как управление состоянием сеанса и приложениями, кэш и т. д. Несмотря на то, что мощные классические приложения ASP стали проблемой для управления, так как они увеличили размер и сложность. Это произошло в основном из-за отсутствия структуры в средах сценариев, связанных с дублированием кода, полученным в результате выполнения кода и разметки. Чтобы воспользоваться преимуществами классической технологии ASP во время устранения некоторых проблем, ASP.NET использовала организацию кода, предоставляемую объектно-ориентированными языками .NET Framework а также сохранив модель программирования на стороне сервера. на то, к каким классическим разработчикам ASP привыкли выросли.

**Вторая группа целевых клиентов для ASP.NET — это разработчики бизнес-приложений Windows.** В отличие от классических разработчиков ASP, привычных для написания разметки HTML и кода для создания разметки HTML, разработчики WinForms (например, разработчики VB6 до них) привыкли к опыту разработки, включающему холст и обширный набор пользователей. элементы управления интерфейсом. Первая версия ASP.NET, также известная как «веб-формы», предоставляет аналогичные возможности разработки и серверную модель событий для компонентов пользовательского интерфейса, а также набор функций инфраструктуры (например, ViewState) для создания эффективной работы разработчиков. между клиентским и серверным программированием. Веб-формы эффективно преобразуются в веб-среду без отслеживания состояния в рамках модели событий с отслеживанием состояния, которая была знакома разработчикам WinForms.

### <a name="challenges-raised-by-the-historical-model"></a>Проблемы, вызванные исторической моделью

**В итоге была реализована развитая, полнофункциональная среда выполнения и модель программирования разработчиков.** Однако с этой особенностью возникли две важные проблемы. Во-первых, платформа была **монолитной**, и логически разнородные блоки функциональности тесно связаны в одной сборке System. Web. dll (например, основные объекты HTTP с платформой веб-форм). Во-вторых, ASP.NET был включен в состав большего .NET Framework, что означало, что **время между выпусками было в течение нескольких лет.** Это усложняет ASP.NET, чтобы сократить скорость выполнения всех изменений, происходящих в быстро развивающихся веб-разработках. Наконец, сама библиотека System. Web. dll была связана несколькими способами для конкретного варианта размещения веб-узлов: службы IIS (IIS).

### <a name="evolutionary-steps-aspnet-mvc-and-aspnet-web-api"></a>Эволюционные шаги: ASP.NET MVC и веб-API ASP.NET

И много изменений произошли в веб-разработке. Веб-приложения все еще разрабатывались как ряд небольших, ориентированных на компоненты, а не больших платформ. Количество компонентов, а также частота, с которой они были выпущены, были увеличены с более высокой скоростью. Было ясно, что для работы с веб-средой требуется, чтобы платформы занимали меньшую, отделенную и более обширную функциональность, поэтому **группа ASP.NET заняла несколько эволюционных этапов, чтобы обеспечить ASP.NET в качестве семейства подключаемых веб-компонентов, а не единой платформы**.

Одним из первых изменений было повышение популярности хорошо известного шаблона проектирования Model-View-Controller (MVC) благодаря таким платформам разработки веб-приложений, как Ruby на шинах. Этот стиль создания веб-приложений дает разработчикам больший контроль над разметкой приложения, сохраняя при этом разделение разметки и бизнес-логики, которые были одной из начальных точек продаж для ASP.NET. Чтобы удовлетворить спрос на этот стиль разработки веб-приложений, корпорация Майкрософт потратила возможность лучше позиционироваться на будущее, **разрабатывая ASP.NET MVC с использованием аппаратного контроллера управления** (и не включая его в .NET Framework). ASP.NET MVC была выпущена как независимая загрузка. Это позволяло группе разработчиков гибко доставлять обновления гораздо чаще, чем было возможно ранее.

Еще один важный сдвиг в разработке веб-приложений был смещен от динамических, созданных сервером веб-страниц до статической первоначальной разметки с динамическими разделами страницы, созданной на основе клиентского сценария, взаимодействующего **с внутренними веб-API через запросы AJAX**. Эта смена архитектуры позволила пропелся в выиграх веб-API и разработке веб-API ASP.NET Framework. Как и в случае с ASP.NET MVC, выпуск веб-API ASP.NET предоставил еще одну возможность развития ASP.NET в качестве более модульной платформы. Группа разработчиков использовала возможности и **построенные веб-API ASP.NET так, что она не зависит от каких-либо типов базовых платформ, найденных в System. Web. dll**. Это позволило два вещи: во-первых, это означало, что веб-API ASP.NET может развиваться полностью автономно (и может продолжать итерацию быстро, так как она доставляется через NuGet). Во-вторых, поскольку нет внешних зависимостей для System. Web. dll и, следовательно, нет зависимостей к службам IIS, веб-API ASP.NET включала возможность запуска в пользовательском узле (например, консольное приложение, служба Windows и т. д.).

### <a name="the-future-a-nimble-framework"></a>Будущее: платформа гибко

Благодаря разделению компонентов инфраструктуры друг от друга и последующему их освобождению в NuGet платформы теперь могут **выполнять итерации более независимо друг от друга и быстрее**. Кроме того, возможности и гибкость самостоятельного размещения веб-API были очень привлекательными для разработчиков, которым требовалось **небольшой простой узел** для своих служб. Он оказался настолько привлекательным, на самом деле, что другие платформы также требовали этой возможности, и это помогла создать новую задачу в том, что каждая инфраструктура выполнялась в собственном хост-процессе на собственном базовом адресе и должна быть управляема (запущена, остановлена и т. д.) независимо. Современное веб-приложение обычно поддерживает статические файловые функции, динамическое создание страниц, веб-API и более поздние в реальном времени и Push-уведомления. Предполагается, что каждая из этих служб должна запускаться и управляться независимо. это просто нереалистично.

Требуется одна абстракция размещения, позволяющая разработчику создавать приложения из различных компонентов и платформ, а затем запускать это приложение на поддерживающем узле.

## <a name="the-open-web-interface-for-net-owin"></a>Открытый веб-интерфейс для .NET (OWIN)

 В основе преимуществ, предоставляемых [стойкой](http://rack.github.io/) в сообществе Ruby, некоторые члены сообщества .NET создали абстракцию между веб-серверами и компонентами платформы. Две цели проектирования для абстракции OWIN: это было просто, и оно занимало минимально возможное количество зависимостей от других типов платформы. Эти две цели помогут обеспечить следующее:

- Новые компоненты можно легко разрабатывать и использовать.
- Приложения могут быть более легко перенесены между узлами и потенциально целыми платформами и операционными системами.

Итоговая абстракция состоит из двух основных элементов. Первый — это словарь среды. Эта структура данных отвечает за хранение всех состояний, необходимых для обработки HTTP-запроса и ответа, а также любого соответствующего состояния сервера. Словарь среды определяется следующим образом:

[!code-console[Main](an-overview-of-project-katana/samples/sample1.cmd)]

Веб-сервер, совместимый с OWIN, отвечает за заполнение словаря среды данными, такими как потоки текста и коллекции заголовков для HTTP-запроса и ответа. Затем он отвечает за компоненты приложения или платформы для заполнения или обновления словаря с дополнительными значениями и записи в поток текста ответа.

Помимо указания типа для словаря среды, спецификация OWIN определяет список пар "ключ-значение" основного словаря. Например, в следующей таблице показаны необходимые ключи словаря для HTTP-запроса.

| Имя ключа | Описание значения |
| --- | --- |
| `"owin.RequestBody"` | Поток с текстом запроса, если таковой имеется. Stream. NULL можно использовать в качестве заполнителя, если текст запроса отсутствует. См. [текст запроса](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics). |
| `"owin.RequestHeaders"` | `IDictionary<string, string[]>` заголовков запроса. См. [заголовки](http://owin.org/html/owin.html#3-3-headers). |
| `"owin.RequestMethod"` | `string`, содержащий метод запроса HTTP (например, `"GET"`, `"POST"`). |
| `"owin.RequestPath"` | `string`, содержащий путь запроса. Путь должен относиться к корневому элементу делегата приложения. см. раздел [пути](http://owin.org/html/owin.html#5-3-paths). |
| `"owin.RequestPathBase"` | `string`, содержащий часть пути запроса, соответствующую "root" делегата приложения; см. раздел [пути](http://owin.org/html/owin.html#5-3-paths). |
| `"owin.RequestProtocol"` | `string`, содержащий имя и версию протокола (например, `"HTTP/1.0"` или `"HTTP/1.1"`). |
| `"owin.RequestQueryString"` | `string`, содержащая компонент строки запроса URI HTTP-запроса без начального символа "?" (например, `"foo=bar&baz=quux"`). Значение может быть пустой строкой. |
| `"owin.RequestScheme"` | `string`, содержащая схему URI, используемую для запроса (например, `"http"`, `"https"`); см. раздел [Схема URI](http://owin.org/html/owin.html#5-1-uri-scheme). |

Вторым ключевым элементом OWIN является делегат приложения. Это сигнатура функции, которая служит основным интерфейсом между всеми компонентами в приложении OWIN. Определение делегата приложения выглядит следующим образом:

`Func<IDictionary<string, object>, Task>;`

Затем делегат приложения — это просто реализация типа делегата Func, где функция принимает словарь среды в качестве входных данных и возвращает задачу. Эта схема имеет несколько последствий для разработчиков:

- Для записи компонентов OWIN требуется очень небольшое число зависимостей типов. Это значительно увеличивает доступность OWIN для разработчиков.
- Асинхронная разработка позволяет эффективно работать с обработкой вычислительных ресурсов, в частности в более ресурсоемких операциях ввода-вывода.
- Поскольку делегат приложения является атомарной единицей выполнения и, поскольку словарь среды переносится в качестве параметра делегата, компоненты OWIN можно легко объединить в цепочку, чтобы создать сложные конвейеры обработки HTTP.

С точки зрения реализации OWIN является спецификацией ([http://owin.org/html/owin.html](http://owin.org/html/owin.html)). Его целью является не использование следующей веб-платформы, а определение того, как взаимодействуют веб-платформы и веб-серверы.

Если вы изучаете [OWIN](http://owin.org/) или [Katana](https://github.com/aspnet/AspNetKatana/wiki), вы можете также заметить [пакет NuGet OWIN](http://nuget.org/packages/Owin) и OWIN. dll. Эта библиотека содержит один интерфейс [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs), который является формализацией и кодифицирует последовательность запуска, описанную в [разделе 4](http://owin.org/html/owin.html#4-application-startup) спецификации OWIN. Но не требуется для создания серверов OWIN, интерфейс [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs) предоставляет конкретную опорную точку и используется компонентами проекта Katana.

## <a name="project-katana"></a>Проект Katana

В то время как спецификация [OWIN](http://owin.org/html/owin.html) и *OWIN. dll* являются владельцами сообщества и работают с открытым исходным кодом, проект [Katana](https://github.com/aspnet/AspNetKatana/wiki) представляет набор OWIN компонентов, которые, в то же время открытый исходный код, создаются и выпускаются корпорацией Майкрософт. К этим компонентам относятся как компоненты инфраструктуры, такие как узлы и серверы, так и функциональные компоненты, такие как компоненты проверки подлинности и привязки к платформам, таким как [SignalR](../../../signalr/index.md) и [веб-API ASP.NET](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md). Проект имеет следующие три цели высокого уровня: 

- **Переносимые** — компоненты должны быть легко заменены новыми компонентами по мере их появления. Сюда входят все типы компонентов, от платформы к серверу и узлу. Смысл этой цели заключается в том, что сторонние платформы могут беспрепятственно работать на серверах Майкрософт, а Microsoft Frameworks может работать на серверах и узлах сторонних производителей.
- **Модульная или гибкая**— в отличие от многих платформ, которые включают множество функций, включенных по умолчанию, компоненты проекта Katana должны быть малыми и сосредоточенными, предоставляя разработчику приложения возможность определять, какие компоненты использовать в своем приложении.
- **Упрощенное или масштабируемое** — путем разбиения традиционного представления платформы на набор небольших, отправных компонентов, которые явно добавляются разработчиком приложения, полученное Katana приложение может потреблять меньше вычислительных ресурсов, а в результате обрабатывать больше нагрузки, чем с другими типами серверов и платформ. Поскольку требования приложения требуют больше возможностей от базовой инфраструктуры, их можно добавить в конвейер OWIN, но это должно быть явным решением для разработчика приложения. Кроме того, замена компонентов нижнего уровня означает, что, как только они становятся доступными, новые высокопроизводительные серверы могут легко вводиться для повышения производительности OWIN приложений без нарушения работы этих приложений.

## <a name="getting-started-with-katana-components"></a>начало работы с компонентами Katana

Когда он впервые появился, одним из аспектов платформы [node. js](http://nodejs.org/) , которые немедленно нарисованы внимание пользователей, было Простота создания и запуска веб-сервера. Если Katanaе цели были встроены в освещение [node. js](http://nodejs.org/), можно обобщить их, указав, что Katana приносит множество преимуществ [node. js](http://nodejs.org/) (и таких платформ, как ИТ), не вынуждая разработчика выдавать все, что известно о разработке веб-приложений ASP.NET. Чтобы эта инструкция содержала значение true, Приступая к работе с проектом Katana должна быть так же простой в природе для [node. js](http://nodejs.org/).

## <a name="creating-hello-world"></a>Создание "Hello World!"

Одно важное различие между разработками JavaScript и .NET — наличие компилятора (или отсутствия). Таким образом, отправной точкой для простого сервера Katana является проект Visual Studio. Однако мы можем начать с минимального числа типов проектов: пустое веб-приложение ASP.NET.

[![](an-overview-of-project-katana/_static/image1.png)](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)

Далее мы установим пакет NuGet [Microsoft. Owin. host. SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) в проект. Этот пакет предоставляет сервер OWIN, работающий в конвейере запросов ASP.NET. Его можно найти в [коллекции NuGet](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) . его можно установить с помощью диалогового окна диспетчера пакетов Visual Studio или консоли диспетчера пакетов с помощью следующей команды:

[!code-console[Main](an-overview-of-project-katana/samples/sample2.cmd)]

При установке пакета `Microsoft.Owin.Host.SystemWeb` в качестве зависимостей будут установлены несколько дополнительных пакетов. Одной из этих зависимостей является `Microsoft.Owin`, Библиотека, предоставляющая несколько вспомогательных типов и методов для разработки приложений OWIN. Эти типы можно использовать для быстрой записи следующего сервера "Hello World".

[!code-csharp[Main](an-overview-of-project-katana/samples/sample3.cs)]

Этот очень простой веб-сервер теперь можно запустить с помощью команды **F5** Visual Studio и обеспечивает полную поддержку отладки.

## <a name="switching-hosts"></a>Переключение узлов

По умолчанию предыдущий пример "Hello World" выполняется в конвейере запросов ASP.NET, который использует System. Web в контексте IIS. Это само по себе допускает значительную ценность, так как позволяет нам воспользоваться преимуществами гибкости и компонуемости конвейера OWIN с возможностями управления и общей зрелости служб IIS. Однако возможны случаи, когда преимущества, предоставляемые службами IIS, не требуются, и потребность в меньшем, более упрощенном узле. Что необходимо, чтобы запустить наш простой веб-сервер вне служб IIS и System. Web?

Чтобы проиллюстрировать цель переносимости, при переходе с узла веб-сервера на узел командной строки необходимо просто добавить новые зависимости сервера и узла в выходную папку проекта, а затем запустить узел. В этом примере наш веб-сервер будет размещен на узле Katana с именем `OwinHost.exe` и будет использоваться сервер на основе Katana HttpListener. Аналогично другим компонентам Katana они будут получены из NuGet с помощью следующей команды:

[!code-console[Main](an-overview-of-project-katana/samples/sample4.cmd)]

В командной строке можно переходить к корневой папке проекта и просто запустить `OwinHost.exe` (которая была установлена в папку Tools соответствующего пакета NuGet). По умолчанию `OwinHost.exe` настроен на поиск сервера на основе HttpListener, поэтому дополнительная настройка не требуется. При переходе в веб-браузере `http://localhost:5000/` отображает приложение, которое теперь выполняется через консоль.

![](an-overview-of-project-katana/_static/image2.png)

## <a name="katana-architecture"></a>Архитектура Katana

 Архитектура компонента Katana разделяет приложение на четыре логических слоя, как показано ниже: *узел, сервер, по промежуточного слоя* и *приложение*. Архитектура компонента состоит в том, что реализации этих уровней можно легко заменить, во многих случаях без необходимости перекомпиляции приложения.   

![](an-overview-of-project-katana/_static/image3.png)

## <a name="host"></a>Узел

 Узел отвечает за следующее:

- Управление базовым процессом.
- Управление рабочим процессом, результатом которого является выбор сервера и создание конвейера OWIN, через который будут обрабатываться запросы.

  В настоящее время существует 3 основных варианта размещения для приложений на основе Katana:  
  
**IIS/ASP. NET**: использование стандартных типов HttpModule и HttpHandler, конвейеры OWIN могут выполняться в службах IIS как часть потока запросов ASP.NET. Поддержка размещения ASP.NET включается путем установки пакета NuGet Microsoft. AspNet. host. SystemWeb в проект веб-приложения. Кроме того, поскольку службы IIS действуют как как узел, так и сервер, различие между сервером и узлом OWIN в этом пакете NuGet уменьшается, что означает, что при использовании узла SystemWeb разработчик не может заменить альтернативную реализацию сервера.  
  
**Пользовательский узел**. набор компонентов Katana предоставляет разработчику возможность размещать приложения в собственном пользовательском процессе, будь то консольное приложение, служба Windows и т. д. Эта возможность похожа на возможность самостоятельного размещения, обеспечиваемая веб-API. В следующем примере показан пользовательский узел кода веб-API:  

[!code-csharp[Main](an-overview-of-project-katana/samples/sample5.cs)]

Настройка самообслуживания для приложения Katana подобна:

[!code-csharp[Main](an-overview-of-project-katana/samples/sample6.cs)]

Важным различием между веб-API и Katanaми с самостоятельным размещением является то, что код конфигурации веб-API отсутствует в примере с самообслуживающимися узлами Katana. Чтобы обеспечить переносимость и компонуемости, Katana разделяет код, который запускает сервер, из кода, который настраивает конвейер обработки запросов. Код, который настраивает веб-API, затем содержится в запуске класса, который дополнительно указывается в качестве параметра типа в веб-приложении. Start.

[!code-csharp[Main](an-overview-of-project-katana/samples/sample7.cs)]

Класс Startup будет обсуждаться более подробно далее в этой статье. Однако код, необходимый для запуска процесса саморазмещения Katana, выглядит примерно так же, как и код, который вы можете использовать сегодня в веб-API ASP.NET приложений с самостоятельным размещением.

**Овинхост. exe**. Хотя в некоторых случаях требуется написать пользовательский процесс для запуска веб-приложений Katana, многие из них предпочитают просто запустить готовый исполняемый файл, который может запустить сервер и запустить приложение. В этом сценарии набор компонентов Katana включает `OwinHost.exe`. При запуске из корневого каталога проекта этот исполняемый файл запускает сервер (по умолчанию использует сервер HttpListener) и использует соглашения для поиска и запуска класса Startup пользователя. Для более детального контроля исполняемый файл предоставляет ряд дополнительных параметров командной строки.

![](an-overview-of-project-katana/_static/image4.png)

## <a name="server"></a>Сервер

 Хотя узел отвечает за запуск и обслуживание процесса, в котором выполняется приложение, ответственность сервера заключается в том, чтобы открыть сетевой сокет, прослушивать запросы и отправить его через конвейер компонентов OWIN, заданных пользователем (как вы возможно, уже заметили, что этот конвейер указан в классе запуска разработчика приложения. В настоящее время проект Katana включает две реализации сервера: 

- **Microsoft. Owin. host. SystemWeb**. Как упоминалось ранее, IIS в сочетании с конвейером ASP.NET выступает в качестве узла и сервера. Поэтому при выборе этого варианта размещения службы IIS управляют вопросами уровня узла, такими как активация процессов и прослушивание HTTP-запросов. Для веб-приложений ASP.NET отправляет запросы в конвейер ASP.NET. Узел Katana SystemWeb регистрирует ASP.NET HttpModule и HttpHandler для перехвата запросов по мере их передачи через конвейер HTTP и отправляет их через указанный пользователем конвейер OWIN.
- **Microsoft. Owin. host. HttpListener**. как указано в имени, этот сервер Katana использует класс HttpListener .NET Framework для открытия сокета и отправки запросов в конвейер Owin, указанный разработчиком. В настоящее время это выбор сервера по умолчанию для API самообслуживания Katana и Овинхост. exe.

## <a name="middlewareframework"></a>По промежуточного слоя и платформы

 Как упоминалось ранее, когда сервер принимает запрос от клиента, он отвечает за его передачу через конвейер компонентов OWIN, которые задаются кодом запуска разработчика. Эти компоненты конвейера называются по промежуточного слоя.  
 На очень базовом уровне компонент по промежуточного слоя OWIN просто должен реализовать делегат OWIN приложения, чтобы он был вызываемым.

[!code-console[Main](an-overview-of-project-katana/samples/sample8.cmd)]

Однако, чтобы упростить разработку и композицию компонентов по промежуточного слоя, Katana поддерживает несколько соглашений и вспомогательных типов для компонентов по промежуточного слоя. Наиболее распространенным из них является класс `OwinMiddleware`. Пользовательский компонент промежуточного слоя, созданный с помощью этого класса, будет выглядеть следующим образом: 

[!code-csharp[Main](an-overview-of-project-katana/samples/sample9.cs)]

 Этот класс является производным от `OwinMiddleware`, реализует конструктор, который принимает экземпляр следующего по промежуточного слоя в конвейере в качестве одного из своих аргументов, а затем передает его в базовый конструктор. Дополнительные аргументы, используемые для настройки по промежуточного слоя, также объявляются как параметры конструктора после следующего параметра по промежуточного слоя.   
  
Во время выполнения по промежуточного слоя выполняется через переопределенный метод `Invoke`. Этот метод принимает один аргумент типа `OwinContext`. Этот объект контекста предоставляется `Microsoft.Owin`ным пакетом NuGet, описанным выше, и предоставляет строго типизированный доступ к словарю запросов, ответов и среды, а также несколько дополнительных вспомогательных типов.   
  
Класс по промежуточного слоя можно легко добавить в конвейер OWIN в коде запуска приложения следующим образом:   

[!code-csharp[Main](an-overview-of-project-katana/samples/sample10.cs)]

Поскольку инфраструктура Katana просто создает конвейер компонентов по промежуточного слоя OWIN, и поскольку компоненты просто нуждаются в поддержке делегата приложения для участия в конвейере, компоненты по промежуточного слоя могут варьироваться от простых средств ведения журналов до целых платформ, таких как ASP.NET, веб-API или [SignalR](../../../signalr/index.md). Например, Добавление веб-API ASP.NET к предыдущему конвейеру OWIN требует добавления следующего кода запуска:

[!code-csharp[Main](an-overview-of-project-katana/samples/sample11.cs)]

Инфраструктура Katana строит конвейер компонентов промежуточного слоя в соответствии с порядком, в котором они были добавлены в объект IAppBuilder в методе конфигурации. В нашем примере Логжермиддлеваре может обрабатывать все запросы, которые проходят через конвейер, независимо от того, как эти запросы в конечном итоге обрабатываются. Это позволяет создавать эффективные сценарии, в которых компонент по промежуточного слоя (например, компонент проверки подлинности) может обрабатывать запросы для конвейера, включающего несколько компонентов и платформ (например, веб-API ASP.NET, SignalR и статический файловый сервер).
 
## <a name="applications"></a>Приложения

Как показано в предыдущих примерах, OWIN и проект Katana не следует рассматривать как новую модель программирования приложений, а в качестве абстракции для разделения моделей программирования приложений и платформ от сервера и инфраструктуры размещения. Например, при создании приложений веб-API платформа разработчика продолжит использовать веб-API ASP.NET Framework независимо от того, выполняется ли приложение в конвейере OWIN с помощью компонентов из проекта Katana. Одним из мест, где код, связанный с OWIN, будет видимым для разработчика приложения, будет код запуска приложения, где разработчик создает конвейер OWIN. В коде запуска разработчик будет регистрировать ряд инструкций Усекскс, обычно по одному для каждого компонента по промежуточного слоя, который будет обрабатывать входящие запросы. Этот интерфейс будет иметь тот же результат, что и регистрация модулей HTTP в текущем мире System. Web. Как правило, по промежуточного слоя платформы, например веб-API ASP.NET или [SignalR](../../../signalr/index.md) , будет зарегистрировано в конце конвейера. Перекрестные компоненты промежуточного слоя, такие как для проверки подлинности или кэширования, обычно регистрируются в начале конвейера, чтобы они обрабатывали запросы для всех платформ и компонентов, зарегистрированных позже в конвейере. Такое разделение компонентов по промежуточного слоя друг от друга и от базовых компонентов инфраструктуры позволяет компонентам развиваться в разных скоростей, обеспечивая стабильность всей системы.

## <a name="components--nuget-packages"></a>Компоненты — пакеты NuGet

Как и в случае с множеством текущих библиотек и платформ, компоненты проекта Katana доставляются в виде набора пакетов NuGet. Для следующей версии 2,0 граф зависимостей пакета Katana выглядит следующим образом. (Щелкните изображение для увеличения представления.)

[![](an-overview-of-project-katana/_static/image6.png)](an-overview-of-project-katana/_static/image5.png)

Практически каждый пакет в проекте Katana напрямую или косвенно зависит от пакета Owin. Вы можете помнить, что это пакет, содержащий интерфейс IAppBuilder, который предоставляет конкретную реализацию последовательности запуска приложения, описанную в разделе 4 спецификации OWIN. Кроме того, многие пакеты зависят от Microsoft. Owin, предоставляющего набор вспомогательных типов для работы с HTTP-запросами и ответами. Оставшаяся часть пакета может классифицироваться как либо пакеты инфраструктуры размещения (серверы или узлы), либо по промежуточного слоя. Пакеты и зависимости, которые являются внешними по отношению к проекту Katana, отображаются оранжевым цветом.

Инфраструктура размещения для Katana 2,0 включает серверы на основе SystemWeb и HttpListener, пакет Овинхост для запуска OWIN приложений с помощью Овинхост. exe и пакет Microsoft. Owin. Hosting для размещения приложений OWIN в Пользовательский узел (например, консольное приложение, служба Windows и т. д.)

Для Katana 2,0 компоненты по промежуточного слоя в основном нацелены на предоставление различных средств проверки подлинности. Предоставляется еще один дополнительный компонент по промежуточного слоя для диагностики, обеспечивающий поддержку страницы начальной и ошибки. Так как OWIN растет в абстракции размещения в де – факто, экосистема компонентов промежуточного слоя, разработанных корпорацией Майкрософт и сторонними производителями, также будет расти в количестве.

## <a name="conclusion"></a>Заключение

 С самого начала, цель проекта Katana не была создана и, таким образом, заставляет разработчиков изучать еще одну веб-платформу. Скорее, целью было создание абстракции для предоставления разработчикам веб-приложений .NET большего выбора, чем было возможно ранее. Разбивая логические уровни типичного стека веб-приложения на набор заменяемых компонентов, проект Katana позволяет компонентам в стеке улучшать, что имеет смысл для этих компонентов. Создавая все компоненты вокруг простой OWIN абстракции, Katana позволяет платформам и приложениям, построенным на их основе, быть переносимыми на различных серверах и узлах. Поместив разработчика в контроль над стеком, Katana гарантирует, что разработчик сделает лучший выбор относительно упрощения и того, как должен быть веб-стек с широкими возможностями.  

## <a name="for-more-information-about-katana"></a>Дополнительные сведения о Katana

- Проект Katana на GitHub: [https://github.com/aspnet/AspNetKatana/](https://github.com/aspnet/AspNetKatana/).
- Видео. [проект Katana — OWIN для ASP.NET, который](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)Говард Дайеркинг.

## <a name="acknowledgements"></a>Благодарности

- [Рик Андерсон (](https://blogs.msdn.com/b/rickandy/): (Twitter [@RickAndMSFT](http://twitter.com/RickAndMSFT) ) Рик — старший модуль записи программирования для Microsoft, сосредоточенный на Azure и MVC.
- [Скотт Hanselman](http://www.hanselman.com/blog/): (Twitter [@shanselman](https://twitter.com/shanselman) )
- [Джон Гэллоуэй](https://weblogs.asp.net/jgalloway/default.aspx): (Twitter [@jongalloway](https://twitter.com/jongalloway) )
