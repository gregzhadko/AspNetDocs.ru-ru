---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
title: Рабочий шаблон, ориентированный на очередь (создание облачных приложений в реальном мире с помощью Azure) | Документация Майкрософт
author: MikeWasson
description: Создание реальных облачных приложений с помощью электронной книги Azure основано на презентации, разработанной Скотт Гатри (. В нем объясняются 13 шаблонов и методик, которые могут...
ms.author: riande
ms.date: 06/12/2014
ms.assetid: cc1ad51b-40c3-4c68-8620-9aaa0fd1f6cf
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
msc.type: authoredcontent
ms.openlocfilehash: c73b070f11366e781bcea70ffc84fd49a47d469a
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/28/2019
ms.locfileid: "74582774"
---
# <a name="queue-centric-work-pattern-building-real-world-cloud-apps-with-azure"></a>Рабочий шаблон, ориентированный на очередь (создание облачных приложений в реальном мире с помощью Azure)

[Майк Уоссон](https://github.com/MikeWasson), [Рик Андерсон (]((https://twitter.com/RickAndMSFT)), том [Dykstra)](https://github.com/tdykstra)

[Скачивание решения ИТ-проекта](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) или [Загрузка электронной книги](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)

> **Создание реальных облачных приложений с помощью** электронной книги Azure основано на презентации, разработанной Скотт Гатри (. В нем объясняются 13 шаблонов и методик, которые могут помочь в успешной разработке веб-приложений для облака. Сведения о электронной книге см. [в первой главе](introduction.md).

Ранее мы видели, что использование нескольких служб может привести к созданию "составного" соглашения об уровне обслуживания, где эффективное соглашение об уровне обслуживания приложения — это *продукт* отдельных SLA. Например, приложение для устранения проблем использует веб-сайты, хранилище и базу данных SQL. В случае сбоя любой из этих служб приложение вернет пользователю сообщение об ошибке.

Кэширование — это хороший способ обработки временных сбоев для содержимого, доступного только для чтения. Но что делать, если приложению нужно работать? Например, когда пользователь отправляет новую задачу Fix ИТ, приложение не может просто разместить задачу в кэше. Приложению необходимо записать задачу Fix ИТ в постоянное хранилище данных, чтобы его можно было обработать.

Именно здесь поступает рабочий шаблон, ориентированный на очередь. Этот шаблон обеспечивает слабую связь между веб-уровнем и внутренней службой.

Вот как работает этот шаблон. Когда приложение получает запрос, оно помещает рабочий элемент в очередь и немедленно возвращает ответ. Затем отдельный внутренний процесс извлекает из очереди рабочие элементы и выполняет работу.

Рабочий шаблон, ориентированный на очередь, полезен для следующих задач:

- Работа, требующая длительного времени (с высокой задержкой).
- Работа, для которой требуется внешняя служба, которая может быть не всегда доступна.
- Работа, интенсивно использующая ресурсы (высокая загрузка ЦП).
- Работа, для которой выгодно выравнивание скорости (в условиях внезапного ускорения нагрузки).

## <a name="reduced-latency"></a>Уменьшенная задержка

Очереди удобно использовать в любой момент, когда вы выполняете трудоемкую работу. Если задача занимает несколько секунд или больше, вместо блокировки конечного пользователя помещайте рабочий элемент в очередь. Сообщите пользователю "Мы работаем над этим", а затем используйте прослушиватель очереди для обработки задачи в фоновом режиме.

Например, если вы приобрели что-либо в Интернет-магазине, он немедленно подтверждает Ваш заказ. Но это не значит, что ваши материалы уже есть в грузовике. Они помещают задачу в очередь и в фоновом режиме выполняют проверку кредита, подготавливая элементы для доставки и т. д.

В сценариях с небольшой задержкой общее время может быть больше, чем при использовании очереди, по сравнению с выполнением задачи в синхронном режиме. Но даже тогда другие преимущества могут перевесить это преимущество.

## <a name="increased-reliability"></a>Повышенная надежность

В той версии, которую мы рассматривали до сих пор, внешний веб-интерфейс тесно связан с серверной частью базы данных SQL. Если служба базы данных SQL недоступна, пользователь получает сообщение об ошибке. Если повторные попытки не работают (т. е. сбой является более временным), единственное, что можно сделать, это отобразить ошибку и попросить пользователя повторить попытку позже.

![Схема сбоя фонового веб-интерфейса при сбое серверной части базы данных SQL](queue-centric-work-pattern/_static/image1.png)

При использовании очередей, когда пользователь отправляет задачу Fix ИТ, приложение записывает сообщение в очередь. Полезные данные сообщения представляют собой представление [JSON](http://json.org/) задачи. Как только сообщение записывается в очередь, приложение возвращает и сразу же отображает сообщение об успешном выполнении для пользователя.

Если какая-либо из серверных служб, например база данных SQL или прослушиватель очереди, переходит в автономный режим, пользователи по-прежнему могут отправлять новые задачи устранения проблем. Сообщения будут просто ставиться в очередь до тех пор, пока серверные службы снова не будут доступны. На этом этапе серверные службы будут отслеживать невыполненную работу.

![Схема, показывающая, что клиентский веб-интерфейс продолжает работать при возникновении ошибки базы данных SQL](queue-centric-work-pattern/_static/image2.png)

Более того, теперь можно добавить дополнительную серверную логику, не беспокоясь о устойчивости внешнего интерфейса. Например, может потребоваться отправить владельцу сообщение электронной почты или SMS при каждом назначении нового исправления. Если электронная почта или служба SMS становятся недоступными, можно обработать все остальное, а затем поместить сообщение в отдельную очередь для отправки сообщений электронной почты и SMS.

Ранее наше соглашение об уровне обслуживания было веб-приложениями &times; хранилище &times; база данных SQL = 99,7%. (См. раздел [Разработка для выдерживаться сбоев](design-to-survive-failures.md).)

При изменении приложения для использования очереди клиентский веб-интерфейс зависит только от веб-приложений и хранилища, для составного соглашения об уровне обслуживания 99,8%. (Обратите внимание, что очереди являются частью службы хранилища Azure, поэтому они включены в то же соглашение об уровне обслуживания, что и хранилище BLOB-объектов.)

Если вам нужно еще более чем 99,8%, можно создать две очереди в двух разных регионах. Назначьте один из них первичным, а другой — базой данных-получателем. В приложении отработка отказа во вторичную очередь, если основная очередь недоступна. Вероятность одновременного недоступности обоих экземпляров очень мала.

## <a name="rate-leveling-and-independent-scaling"></a>Скорость и независимое масштабирование

Очереди также полезны для чего-либо, называемого *выравниванием скорости* или *выравниванием нагрузки*.

Веб-приложения часто чувствительны к резкому увеличению трафика. Хотя Автомасштабирование можно использовать для автоматического добавления веб-серверов для обработки увеличенного веб-трафика, автоматическое масштабирование может не удаться быстро реагировать на обработку внезапных пиков нагрузки. Если веб-серверы могут разгрузить часть работы, которую они должны выполнить, записав сообщение в очередь, они могут справиться с большим объемом трафика. Серверная служба может затем считывать сообщения из очереди и обрабатывать их. Глубина очереди будет увеличиваться или уменьшаться по мере того, как входящая нагрузка меняется.

В значительной степени длительной работы, загруженной в серверную службу, веб-уровень может более легко реагировать на внезапные пики трафика. И вы экономите деньги, поскольку любой заданный объем трафика может обрабатываться меньшим числом веб-серверов.

Веб-уровень и серверную службу можно масштабировать независимо друг от друга. Например, может потребоваться три веб-сервера, но только один сервер обрабатывает сообщения очереди. Или, если вы используете ресурсоемкие задачи в фоновом режиме, может потребоваться большее количество внутренних серверов.

![](queue-centric-work-pattern/_static/image3.png)

Автомасштабирование работает с серверными службами, а также с веб-уровнем. Можно увеличить или уменьшить количество виртуальных машин, обрабатывающих задачи в очереди, на основе загрузки ЦП серверных виртуальных машин. Кроме того, можно выполнить Автомасштабирование в зависимости от количества элементов в очереди. Например, можно настроить автоматическое масштабирование, чтобы попытаться не более 10 элементов в очереди. Если очередь содержит более 10 элементов, автоматическое масштабирование добавит виртуальные машины. Когда они захватываются, автомасштабирование приведет к разрыву дополнительных виртуальных машин.

## <a name="adding-queues-to-the-fix-it-application"></a>Добавление очередей в приложение Fix It

Чтобы реализовать шаблон очереди, необходимо внести два изменения в приложение Fix ИТ.

- Когда пользователь отправляет новую задачу Fix ИТ, добавьте ее в очередь, а не записывая в базу данных.
- Создайте серверную службу, которая обрабатывает сообщения в очереди.

Для очереди мы будем использовать [службу хранилища очередей Azure](https://www.windowsazure.com/develop/net/how-to-guides/queue-service/). Другой вариант — использовать [служебную шину Azure](https://docs.microsoft.com/azure/service-bus/).

Чтобы решить, какую службу очередей использовать, определите, как ваше приложение должно отправлять и получать сообщения в очереди:

- Если у вас есть сооперационные производители и конкурирующие потребители, рассмотрите возможность использования службы хранилища очередей Azure. «Взаиморабочие производители» означает, что несколько процессов добавляют сообщения в очередь. «Конкурирующие потребители» означает, что несколько процессов получают сообщения из очереди для их обработки, но любое конкретное сообщение может обрабатываться только одним «потребителем». Если требуется больше пропускной способности, чем можно получить с помощью одной очереди, используйте дополнительные очереди и (или) дополнительные учетные записи хранения.
- Если вам нужна [модель публикации и подписки](http://en.wikipedia.org/wiki/Publish/subscribe), рассмотрите возможность использования очередей служебной шины Azure.

Приложение для устранения проблем соответствует требованиям к взаимоэксплуатационным производителям и модели конкурирующих потребителей.

Еще один вопрос — доступность приложения. Служба хранилища очередей является частью той же службы, которую мы используем для хранения BLOB-объектов, поэтому ее использование не влияет на соглашение об уровне обслуживания. Служебная шина Azure — это отдельная служба с собственным соглашением об уровне обслуживания. Если мы использовали очереди служебной шины, нам пришлось бы учесть дополнительный процент соглашения об уровне обслуживания, и наше составное соглашение об уровне обслуживания было бы ниже. При выборе службы очередей убедитесь, что вы понимаете влияние вашего выбора на доступность приложения. Дополнительные сведения см. в разделе [Resources](#resources) .

## <a name="creating-queue-messages"></a>Создание сообщений очереди

Чтобы поместить в очередь эту задачу, веб-интерфейс выполняет следующие действия.

1. Создайте экземпляр [CloudQueueClient](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueueclient.aspx) . Экземпляр `CloudQueueClient` используется для выполнения запросов к службе очередей.
2. Создайте очередь, если она еще не существует.
3. Сериализация задачи Fix ИТ.
4. Вызовите [CloudQueue. аддмессажеасинк](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueue.addmessageasync.aspx) , чтобы поместить сообщение в очередь.

Мы выполним эту работу в конструкторе и `SendMessageAsync` методе нового класса `FixItQueueManager`.

[!code-csharp[Main](queue-centric-work-pattern/samples/sample1.cs?highlight=11-12,16,18-25)]

Здесь мы используем библиотеку [JSON.NET](https://github.com/JamesNK/Newtonsoft.Json) для сериализации формата Fixit в формат JSON. Вы можете использовать любой предпочтительный подход к сериализации. Формат JSON имеет преимущество для человеческого восприятия, но менее подробный, чем XML.

Код рабочего качества добавляет логику обработки ошибок, приостанавливает выполнение, если база данных становится недоступной, полностью обрабатывает восстановление, создает очередь для запуска приложения и управляет[подозрительными сообщениями](https://msdn.microsoft.com/library/ms789028(v=vs.110).aspx). (Опасное сообщение — это сообщение, которое не может быть обработано по какой-либо причине. Вы не хотите, чтобы подозрительные сообщения находились в очереди, где рабочая роль будет постоянно пытаться обработать их, завершиться ошибкой, повторить попытку, завершиться сбоем и т. д.)

В приложении MVC внешнего интерфейса необходимо обновить код, который создает новую задачу. Вместо помещения задачи в репозиторий вызовите метод `SendMessageAsync`, показанный выше.

[!code-csharp[Main](queue-centric-work-pattern/samples/sample2.cs?highlight=10)]

## <a name="processing-queue-messages"></a>Обработка сообщений очереди

Для обработки сообщений в очереди мы создадим серверную службу. Серверная служба будет выполнять бесконечный цикл, который выполняет следующие действия:

1. Получение следующего сообщения из очереди.
2. Десериализация сообщения в задачу Fix ИТ.
3. Напишите задачу Fix ИТ в базу данных.

Чтобы разместить серверную службу, мы создадим облачную службу Azure, которая содержит *рабочую роль*. Рабочая роль состоит из одной или нескольких виртуальных машин, которые могут выполнять серверную обработку. Код, выполняемый на этих виртуальных машинах, будет извлекать сообщения из очереди по мере их появления. Для каждого сообщения будут десериализованы полезные данные JSON и записан экземпляр сущности Fix ИТ Task в базу данных, используя тот же репозиторий, который мы использовали ранее на веб-уровне.

В следующих шагах показано, как добавить проект рабочей роли в решение, имеющее стандартный веб-проект. Эти действия уже выполнены в проекте Fix, который можно загрузить.

Сначала добавьте проект облачной службы в решение Visual Studio. Щелкните решение правой кнопкой мыши и выберите **Добавить**, а затем **Новый проект**. В левой области разверните узел **визуальный C#**  элемент и выберите **облако**.

[![](queue-centric-work-pattern/_static/image5.png)](queue-centric-work-pattern/_static/image4.png)

В диалоговом окне **новая облачная служба Azure** разверните **узел C# визуальный** элемент в левой области. Выберите **Рабочая роль** и щелкните значок стрелки вправо.

![](queue-centric-work-pattern/_static/image6.png)

(Обратите внимание, что можно также добавить *веб-роль*. Мы могли бы запустить интерфейс исправления ИТ-интерфейса в той же облачной службе, а не запускать его на веб-сайте Azure. У него есть некоторые преимущества, позволяющие упростить координацию соединений между внешним интерфейсом и серверной частью. Однако для простоты этой демонстрации мы работаем в веб-приложении службы приложений Azure и только в облачной службе.

Рабочей роли назначается имя по умолчанию. Чтобы изменить имя, наведите указатель мыши на рабочую роль на правой панели, а затем щелкните значок карандаша.

![](queue-centric-work-pattern/_static/image7.png)

Нажмите кнопку **ОК** , чтобы завершить диалог. При этом в решение Visual Studio добавляются два проекта.

- проект Azure, который определяет облачную службу, включая сведения о конфигурации.
- Проект рабочей роли, определяющий рабочую роль.

![](queue-centric-work-pattern/_static/image8.png)

Дополнительные сведения см. в статье [Создание проекта Azure с помощью Visual Studio.](https://msdn.microsoft.com/library/windowsazure/ee405487.aspx)

Внутри рабочей роли мы будем опрашивать сообщения, вызывая метод `ProcessMessageAsync` класса `FixItQueueManager`, который мы видели ранее.

[!code-csharp[Main](queue-centric-work-pattern/samples/sample3.cs?highlight=25)]

Метод `ProcessMessagesAsync` проверяет, находится ли сообщение в состоянии ожидания. Если таковой имеется, он десериализует сообщение в сущность `FixItTask` и сохраняет сущность в базе данных. Он проходит до тех пор, пока очередь не будет пустой.

[!code-csharp[Main](queue-centric-work-pattern/samples/sample4.cs)]

При опросе сообщений очереди возникает небольшая плата за транзакцию, поэтому при отсутствии сообщений, ожидающих обработки, метод `RunAsync` рабочей роли ожидает повторного опроса, вызывая `Task.Delay(1000)`.

В веб-проекте Добавление асинхронного кода может автоматически повысить производительность, так как службы IIS управляют ограниченным пулом потоков. Это не так в проекте рабочей роли. Чтобы повысить масштабируемость рабочей роли, можно написать многопоточный код или использовать асинхронный код для реализации [параллельного программирования](https://msdn.microsoft.com/library/ff963553.aspx). Пример не реализует параллельное программирование, но демонстрирует, как сделать код асинхронным, чтобы можно было реализовать параллельное программирование.

## <a name="summary"></a>Сводка

В этой главе вы узнали, как улучшить скорость реагирования приложений, надежность и масштабируемость, реализовав рабочий шаблон, ориентированный на очередь.

Это последний из 13 шаблонов, рассмотренных в этой электронной книге, но существует множество других шаблонов и методик, которые могут помочь в создании успешных облачных приложений. В [последней главе](more-patterns-and-guidance.md) содержатся ссылки на ресурсы для разделов, которые не были включены в эти 13 шаблонов.

<a id="resources"></a>
## <a name="resources"></a>Ресурсы

Дополнительные сведения об очередях см. в следующих ресурсах.

Документация:

- [Служба хранилища Microsoft Azure очереди, часть 1: Начало работы](https://www.red-gate.com/simple-talk/cloud/platform-as-a-service/microsoft-azure-storage-queues-part-1-getting-started/). Статьи по римских Счачерл.
- [Выполняя фоновые задачи](https://msdn.microsoft.com/library/ff803365.aspx), глава 5 [перемещения приложений в облако, третий выпуск](https://msdn.microsoft.com/library/ff728592.aspx) из шаблонов и практических рекомендаций Майкрософт. (В частности, раздел ["Использование очередей службы хранилища Azure"](https://msdn.microsoft.com/library/ff803365.aspx#sec7).)
- Рекомендации [по максимальному увеличению масштабируемости и экономичности решений по обмену сообщениями на основе очередей в Azure](https://msdn.microsoft.com/library/windowsazure/hh697709.aspx). Технический документ, Valery Мизонов.
- [Сравнение очередей Azure и очередей служебной шины](https://msdn.microsoft.com/magazine/jj159884.aspx). Статья журнала MSDN Magazine содержит дополнительные сведения, которые помогут выбрать используемую службу очередей. В статье упоминается, что служебная шина зависит от службы ACS для проверки подлинности, что означает, что очереди SB будут недоступны, если служба ACS недоступна. Однако с момента написания статьи SB был изменен, чтобы вы использовали [маркеры SAS](https://msdn.microsoft.com/library/windowsazure/dn170477.aspx) в качестве АЛЬТЕРНАТИВы службам ACS.
- [Шаблоны и методики Майкрософт. Руководство по Azure](https://msdn.microsoft.com/library/dn568099.aspx). См. Руководство по асинхронному обмену сообщениями, шаблону каналов и фильтров, шаблону компенсирующих транзакций, шаблону конкурирующих потребителей, шаблону CQRS.
- [Путешествие в CQRS](https://msdn.microsoft.com/library/jj554200). Электронная книга, посвященная CQRS с помощью шаблонов и методик корпорации Майкрософт.

Видео:

- [Отказоустойчивость: создание масштабируемых отказоустойчивых облачных служб](https://channel9.msdn.com/Series/FailSafe). Серия видео из девяти частей по Ульрих Хоманн, (Marc Меркури и пометить SIMM. Предоставляет основные понятия и архитектурные принципы в очень удобном и интересном смысле, а также истории, полученные от работы группы консультирования клиентов Майкрософт (CAT) с реальными клиентами. Общие сведения о службе хранилища Azure и очередях см. в разделе Эпизод 5 начиная с 35:13.

> [!div class="step-by-step"]
> [Назад](distributed-caching.md)
> [Вперед](more-patterns-and-guidance.md)
