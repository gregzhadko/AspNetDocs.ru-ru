---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
title: Шаблон на основе очередей работы (Создание реальных облачных приложений в Azure) | Документация Майкрософт
author: MikeWasson
description: Создание реальных облачных приложений в условиях электронная книга основана на презентацию, разработанная Скоттом Гатри. Здесь объясняется, 13 шаблонов и практических рекомендаций, которые он может...
ms.author: riande
ms.date: 06/12/2014
ms.assetid: cc1ad51b-40c3-4c68-8620-9aaa0fd1f6cf
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/queue-centric-work-pattern
msc.type: authoredcontent
ms.openlocfilehash: 03b6950104b6f293271d9f9a0feed4071e9b1174
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/01/2019
ms.locfileid: "57056941"
---
<a name="queue-centric-work-pattern-building-real-world-cloud-apps-with-azure"></a>Шаблон на основе очередей работы (Создание реальных облачных приложений в Azure)
====================
по [Майк Уоссон](https://github.com/MikeWasson), [Рик Андерсон]((https://twitter.com/RickAndMSFT)), [том Дайкстра](https://github.com/tdykstra)

[Загрузить решение проект](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) или [скачайте электронную книгу](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)

> **Создание реальных облачных приложений в условиях Azure** электронная книга основана на презентацию, разработанная Скоттом Гатри. Здесь объясняется 13 шаблоны и рекомендации, которые помогут вам быть в успешном развертывании веб-приложений для облака. Сведения о книге, см. в разделе [первой главы](introduction.md).


Ранее, мы видели, что с помощью нескольких служб может привести к «составного» SLA, где — это эффективный соглашение об уровне ОБСЛУЖИВАНИЯ приложения *продукта* отдельных соглашений об уровне обслуживания. Например приложение Fix It использует веб-сайтов, хранилища и базы данных SQL. В случае сбоя любого из этих служб приложения возникает сообщение об ошибке для пользователя.

Кэширование — хороший способ обработки временных сбоев для содержимого только для чтения. Но что делать, если приложение должно работать? Например при отправке новой задачи Fix It, приложение нельзя просто запустить задачу в кэш. Приложению необходимо написать задачу Fix It в постоянном хранилище данных, поэтому его можно обработать.

Это, когда вступает в дело основе очередей рабочий шаблон. Этот шаблон позволяет слабой связи между веб-уровня и серверной службы.

Шаблон работает следующим образом. Когда приложение получает запрос, он помещает рабочий элемент в очередь и немедленно возвращает ответ. Затем отдельный фоновый процесс извлекает рабочие элементы из очереди и выполняет работу.

Шаблон работы на основе очередей, можно использовать для:

- Трудозатраты — много времени (Высокая задержка).
- Действия, требующие внешнюю службу, которая может не всегда доступны.
- То есть работать много ресурсов (высокой загрузки ЦП).
- Работа, могут с выгодой скорость выравнивание (в соответствии с пиками нагрузки, неожиданные).

## <a name="reduced-latency"></a>Снижение задержки

Очереди полезны каждый раз, когда вы выполняете долгой работы. Если задача занимает несколько секунд или больше, вместо блокировки конечного пользователя, помещены в очередь рабочий элемент. Сообщите пользователю о «Мы работаем над этим», а затем используйте прослушиватель очереди для обработки задачи в фоновом режиме.

Например когда вы покупаете что-то в Интернет-магазине, веб-сайт подтверждают заказ немедленно. Но это не значит, что у вас уже находится в процессе доставки грузовик. Задача они помещаются в очередь, а в фоновом режиме они выполняете проверку кредитоспособности, Подготовка к поставке, элементы и т. д.

Для сценариев с минимальным временем задержки общее время начала до конца может быть больше, с помощью очереди, по сравнению с выполнением задачи, синхронно. Но даже в таком случае другие преимущества, могут перевесить этот недостаток.

## <a name="increased-reliability"></a>Повышенная надежность

В версии Fix It, мы рассматриваем в данный момент веб-интерфейса тесно связан с внутренней базой данных SQL. Если служба базы данных SQL недоступна, пользователь получает ошибку. Если повторные попытки не работают (то есть сбоя является более чем временной), единственное, что можно сделать — выводит ошибку и запрашивать у пользователя и повторите попытку позже.

![Схема отображение клиентского веб-интерфейса восстановление после сбоя серверной базы данных SQL](queue-centric-work-pattern/_static/image1.png)

С помощью очереди, когда пользователь отправляет задачи Fix It, приложение записывает сообщение в очередь. Полезные данные сообщения является [JSON](http://json.org/) представление задачи. Как только сообщение записывается в очередь, приложение возвращает и сразу же показывает сообщение об успешном выполнении пользователю.

Если какой-либо службы серверной части — например, база данных SQL или прослушивателя очереди--переходят в автономный режим, пользователи могут по-прежнему отправлять новые задачи Fix It. Сообщения просто помещаются в очередь до серверных служб не будут снова доступны. В таком случае будет вовремя серверных служб в невыполненной работе.

![Схема, показывающая web переднего плана продолжать работу при возникновении ошибки в базе данных SQL на](queue-centric-work-pattern/_static/image2.png)

Кроме того теперь можно добавить дополнительные логику серверной части, не беспокоясь об устойчивости внешнего интерфейса. Например может потребоваться отправить SMS-сообщения электронной почты или владельцу, всякий раз, когда назначается новый Fix It. Если адрес электронной почты или SMS службы становится недоступным, можно обрабатывать все остальные и затем поместить сообщение в отдельную очередь для отправки сообщений электронной почты или SMS.

Ранее наш действующие соглашения об уровне ОБСЛУЖИВАНИЯ было веб-приложений &times; хранения &times; базы данных SQL = 99.7%. (См. в разделе [проектирование для обработки отказов](design-to-survive-failures.md).)

Если мы изменили приложение для использования в очередь, веб-интерфейса зависит только от веб-приложений и хранилища, в составных приложениях соглашение об уровне ОБСЛУЖИВАНИЯ, есть на 99,8%. (Обратите внимание, что очереди являются частью службы хранилища Azure, поэтому они будут включены в соглашение об уровне ОБСЛУЖИВАНИЯ, как хранилище BLOB-объектов).

Если вам нужна еще лучше, чем есть на 99,8%, можно создать две очереди в двух разных регионах. Назначьте один в качестве основного, а другой — как вторичный. В приложении отработку отказа в дополнительную очередь Если основная очередь недоступна. Вероятность обоих станет недоступной в то же время очень мала.

## <a name="rate-leveling-and-independent-scaling"></a>Выравнивание скорость и независимого масштабирования

Очереди полезны также так называемое *оценить выравнивание* или *выравнивание нагрузки*.

Веб-приложений часто подвержены внезапные всплески трафика. При использовании автоматического масштабирования для автоматического добавления веб-серверы для обработки повышенной веб-трафика, автоматическое масштабирование может оказаться возможность реагировать на них достаточно быстро обрабатывать внезапные пики нагрузки. Если веб-серверов может разгрузить часть работы, которые им нужно сделать, записав сообщение в очередь, они могут обрабатывать больше трафика. В серверную службу можно читать сообщения из очереди и обрабатывать их. Глубина очереди будет расти или сокращаться, как входящие нагрузка изменяется.

С помощью основную часть времени работы выгружаются в серверную службу веб-уровень более легко может отвечать на внезапные всплески трафика. Производительность и сокращает расходы, так как для любого заданного объема трафика может обрабатываться с помощью меньшего числа веб-серверов.

Веб-уровня и серверной службы можно масштабировать независимо друг от друга. Например может потребоваться три веб-сервера, но только один сервер обработки очереди сообщений. Или, если вы используете ресурсоемкой задачи в фоновом режиме, может потребоваться несколько внутренних серверов.

![](queue-centric-work-pattern/_static/image3.png)

Автоматическое масштабирование работает с серверными службами, а также с веб-уровня. Можно увеличить или уменьшить число виртуальных машин, которые обрабатываются задач в очереди, на основе использования ЦП для виртуальных машин внутреннего пула. Вы также можете автомасштабирования, в зависимости от того, сколько элементов находятся в очереди. Например можно сказать, Автомасштабирование и попытаться сохранить не более 10 элементов в очереди. Если очередь содержит более 10 элементов, автомасштабирования будет добавить виртуальные машины. Когда они Догнать автомасштабирования будет деинициализации лишние виртуальные машины.

## <a name="adding-queues-to-the-fix-it-application"></a>Добавление исправления, помещает ее в очередь приложения

Чтобы реализовать шаблон очереди, необходимо внести два изменения в приложение Fix It.

- Когда пользователь отправляет новый Fix It задачу, поместите задачи в очереди, вместо того чтобы писать его к базе данных.
- Создание внутренней службы, который обрабатывает сообщения в очереди.

Для очереди, мы будем использовать [службы хранилища очередей Azure](https://www.windowsazure.com/develop/net/how-to-guides/queue-service/). Другой вариант — использовать [служебной шины Azure](https://docs.microsoft.com/azure/service-bus/).

Чтобы решить, какие службы очередей для использования, рассмотрим, как ваше приложение должно отправлять и получать сообщения в очереди:

- Если у вас есть совместно действующих поставщиков и конкурирующих потребителей, рассмотрите возможность использования службы хранилища очередей Azure. «Cooperating производители» означает, что несколько процессов при добавлении сообщения в очередь. «Конкурирующих потребителей» означает, что несколько процессов извлекать сообщения из очереди, для их обработки, но любого заданного сообщения могут обрабатываться только один «получатель». Если вам требуется более высокая пропускная способность, чем можно получить с помощью одной очереди, используйте дополнительные очереди и (или) дополнительные учетные записи хранения.
- Если вам нужна [модели публикации и подписки](http://en.wikipedia.org/wiki/Publish/subscribe), рассмотрите возможность использования очередей служебной шины Azure.

Приложение Fix It соответствует совместно действующих производители и конкурирующих потребителей модели.

Еще один нюанс заключается в доступности приложения. Службы хранения очередей является частью той же службе, которая используется для хранилища BLOB-объектов, поэтому использовать его не оказывает влияния на СОГЛАШЕНИИ. Служебная шина Azure — это отдельная служба, с помощью свои собственные соглашения об уровне ОБСЛУЖИВАНИЯ. При использовании очередей служебной шины, нам пришлось бы учитывать дополнительный процент соглашение об уровне ОБСЛУЖИВАНИЯ и наши составное соглашение об уровне ОБСЛУЖИВАНИЯ будет меньше. При выборе службы очередей, убедитесь, что вы понимаете влияние по своему выбору на доступность приложения. Дополнительные сведения см. в разделе [ресурсы](#resources) раздел.

## <a name="creating-queue-messages"></a>Создание очереди сообщений

Чтобы помещается в очередь задачу Fix It, веб-интерфейса выполняет следующие действия:

1. Создание [CloudQueueClient](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueueclient.aspx) экземпляра. `CloudQueueClient` Экземпляр используется для выполнения запросов к службе очередей.
2. Создайте очередь, если он еще не создан.
3. Сериализация задачи Fix It.
4. Вызовите [CloudQueue.AddMessageAsync](https://msdn.microsoft.com/library/microsoft.windowsazure.storage.queue.cloudqueue.addmessageasync.aspx) помещает его в очередь.

Мы сделаем эту работу в конструкторе и `SendMessageAsync` новый метод `FixItQueueManager` класса.

[!code-csharp[Main](queue-centric-work-pattern/samples/sample1.cs?highlight=11-12,16,18-25)]

Здесь мы используем [Json.NET](https://github.com/JamesNK/Newtonsoft.Json) библиотеки для сериализации fixit в формат JSON. Можно использовать независимо от выбранного подхода сериализации, вы предпочитаете. JSON имеет преимущество, удобное для восприятия, будучи менее многословной, чем XML.

Коду промышленного качества бы добавить логику обработки ошибок, приостановить, если база данных стала недоступной, обрабатывают восстановления более аккуратно, создать очередь при запуске приложения и управление "[подозрительных» сообщений](https://msdn.microsoft.com/library/ms789028(v=vs.110).aspx). (Подозрительное сообщение представляет собой сообщение, не может обрабатываться для какой-либо причине. Вы не хотите подозрительных сообщений, чтобы оно попало в очередь, где рабочая роль будет постоянно пытаться обрабатывать их, сбоем, повторите попытку, ошибкой и т. д.)

В интерфейсном приложении MVC необходимо обновить код, который создает новую задачу. Вместо размещения задачи в репозиторий, вызовите `SendMessageAsync` в приведенном выше примере.

[!code-csharp[Main](queue-centric-work-pattern/samples/sample2.cs?highlight=10)]

## <a name="processing-queue-messages"></a>Обработка сообщений в очереди

Для обработки сообщений в очереди, мы создадим серверную службу. Серверная служба будет выполняться бесконечный цикл, который выполняет следующие действия:

1. Получение следующего сообщения из очереди.
2. Десериализовать сообщение задаче Fix It.
3. Задачи Fix It разработать базу данных.

Чтобы разместить во внутреннюю службу, мы создадим в облачной службе Azure, который содержит *рабочей роли*. Рабочая роль состоит из одного или нескольких виртуальных машин, которые могут выполнять Внутренняя обработка вычислений. Код, выполняемый в этих виртуальных машин будет извлекать сообщения из очереди, как только они становятся доступными. Для каждого сообщения мы десериализации полезные данные JSON и записи экземпляра сущности исправить его задача в базу данных, используя тот же репозиторий, который мы использовали ранее в веб-уровня.

Ниже показано, как добавить рабочую роль проект роли в решение, включающее стандартный веб-проекта. Эти действия уже были выполнены в Fix It проект, который можно загрузить.

Сначала добавьте проект облачной службы в решение Visual Studio. Щелкните правой кнопкой мыши решение и выберите **добавить**, затем **новый проект**. В левой области разверните **Visual C#** и выберите **Cloud**.

[![](queue-centric-work-pattern/_static/image5.png)](queue-centric-work-pattern/_static/image4.png)

В **новая облачная служба Azure** диалоговом окне разверните **Visual C#** узел на панели слева. Выберите **рабочей роли** и щелкните значок со стрелкой вправо.

![](queue-centric-work-pattern/_static/image6.png)

(Обратите внимание, что вы также можете добавить *веб-роли*. Бы выполнять Fix It внешний интерфейс на той же облачной службе, вместо ее выполнения в на веб-сайте Azure. Который имеет некоторые преимущества в упрощение подключения между интерфейсной и серверной части для координации. Однако для простоты в этой демонстрации мы сохранение внешнего интерфейса в веб-приложении службы приложений Azure и только под управлением серверной части в облачной службе.)

Для рабочей роли назначается имя по умолчанию. Чтобы изменить имя, наведите указатель мыши рабочей роли в области справа, а затем щелкните значок карандаша.

![](queue-centric-work-pattern/_static/image7.png)

Нажмите кнопку **ОК** для заполните поля диалогового окна. Это добавляет два проекта в решение Visual Studio.

- проект Azure, который определяет облачной службы, включая сведения о конфигурации.
- Проект рабочей роли, который определяет рабочей роли.

![](queue-centric-work-pattern/_static/image8.png)

Дополнительные сведения см. в разделе [Создание проекта Azure в Visual Studio.](https://msdn.microsoft.com/library/windowsazure/ee405487.aspx)

Внутри рабочей роли, мы выполнять опрос не реже, вызвав `ProcessMessageAsync` метод `FixItQueueManager` класс, который мы видели ранее.

[!code-csharp[Main](queue-centric-work-pattern/samples/sample3.cs?highlight=25)]

`ProcessMessagesAsync` Метод проверяет, есть ли сообщение ожидания. Если таковой имеется, он десериализует сообщение в `FixItTask` сущности и сохраняет объект в базе данных. Он проходит, пока очередь пуста.

[!code-csharp[Main](queue-centric-work-pattern/samples/sample4.cs)]

Опрос очереди сообщений влечет за собой небольшой транзакции взимается, поэтому, когда нет сообщений, ожидающих обработки, рабочая роль `RunAsync` метод ожидает секунда, предшествующая опроса, снова вызвав `Task.Delay(1000)`.

В проекте веб-Добавление асинхронного кода может автоматически повышать производительность потому, что IIS управляет пулом ограниченной потока. Это не так в проекте рабочей роли. Чтобы повысить масштабируемость рабочей роли, можно написать многопоточного кода или использовать асинхронный код для реализации [параллельного программирования](https://msdn.microsoft.com/library/ff963553.aspx). В примере не реализует параллельного программирования, но также показано, как сделать код асинхронным, чтобы реализовать параллельного программирования.

## <a name="summary"></a>Сводка

В этой главе вы видели, как повысить скорость реагирования приложения, надежности и масштабируемости путем реализации модели на основе очередей рабочих.

Это последняя из 13 шаблонов, описанных в этой электронной книге, но само собой, есть много других шаблонов, и рекомендации, которые помогут вам создавать приложения успешно разработать Облачное. [Финальной главе](more-patterns-and-guidance.md) ссылки на ресурсы по темам, которые еще не были освещены в эти шаблоны 13.

<a id="resources"></a>
## <a name="resources"></a>Ресурсы

Дополнительные сведения об очередях см. следующие ресурсы.

Документация:

- [Microsoft Azure хранилища очередей, часть 1. Приступая к работе](http://justazure.com/microsoft-azure-storage-queues-part-1-getting-started/). Статьи по Schacherl римские цифры.
- [Выполнение фоновых задач](https://msdn.microsoft.com/library/ff803365.aspx), главе 5 [перемещение приложений в облако, 3-е издание](https://msdn.microsoft.com/library/ff728592.aspx) из шаблонов и методик Microsoft. (В частности, раздел [«С помощью хранилища очередей Azure»](https://msdn.microsoft.com/library/ff803365.aspx#sec7).)
- [Советы и рекомендации по достижению максимальной масштабируемости и экономической эффективности обмена сообщениями решений на основе очередей в Azure](https://msdn.microsoft.com/library/windowsazure/hh697709.aspx). Валерий Мизонов новом информационном документе.
- [Сравнение очередей Azure и очереди служебной шины](https://msdn.microsoft.com/magazine/jj159884.aspx). Статье журнала MSDN Magazine предоставляет дополнительные сведения, которые помогут вам выбрать, какие службы очередей для использования. В статье упоминается, что шина зависит ACS для проверки подлинности, это означает, что SB очередей будут недоступны, при недоступности ACS. Тем не менее, так как статья была написана, SB был изменен, позволяя использовать [маркеров SAS](https://msdn.microsoft.com/library/windowsazure/dn170477.aspx) в качестве альтернативы в ACS.
- [Microsoft Patterns and Practices — руководство по Azure](https://msdn.microsoft.com/library/dn568099.aspx). См. в разделе, основы асинхронного обмена сообщениями, шаблон каналов и фильтров, шаблон компенсирующих транзакций, шаблон конкурирующих потребителей, шаблон CQRS.
- [Пути взаимодействия CQRS](https://msdn.microsoft.com/library/jj554200). Электронная книга о CQRS, шаблонов и методик Microsoft.

Видео:

- [Отказоустойчивость. Построение масштабируемых, надежных облачных служб](https://channel9.msdn.com/Series/FailSafe). Серия видеоматериалов девяти частей, Ульрих Хоманн, Марк Меркьюри и (Mark simms). Отображает высокоуровневых концепциях и архитектурные принципы очень доступен и интересным способом, истории, извлеченных из консультационной группой Microsoft клиентов (CAT) опыт работы с реальными клиентами. Введение в службу хранилища Azure и очереди см. в разделе эпизод 5, начиная с 35:13.

> [!div class="step-by-step"]
> [Назад](distributed-caching.md)
> [Вперед](more-patterns-and-guidance.md)
