---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
title: Распределенное кэширование (Создание реальных облачных приложений в Azure) | Документация Майкрософт
author: MikeWasson
description: Создание реальных облачных приложений в условиях электронная книга основана на презентацию, разработанная Скоттом Гатри. Здесь объясняется, 13 шаблонов и практических рекомендаций, которые он может...
ms.author: riande
ms.date: 07/20/2015
ms.assetid: 406518e9-3817-49ce-8b90-e82bc461e2c0
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
msc.type: authoredcontent
ms.openlocfilehash: de4be20ed81ae356e0aa4e90e2ab61a6e25212a0
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65118822"
---
# <a name="distributed-caching-building-real-world-cloud-apps-with-azure"></a>Распределенного кэширования (Создание реальных облачных приложений в Azure)

по [Майк Уоссон](https://github.com/MikeWasson), [Рик Андерсон]((https://twitter.com/RickAndMSFT)), [том Дайкстра](https://github.com/tdykstra)

[Загрузить решение проект](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) или [скачайте электронную книгу](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)

> **Создание реальных облачных приложений в условиях Azure** электронная книга основана на презентацию, разработанная Скоттом Гатри. Здесь объясняется 13 шаблоны и рекомендации, которые помогут вам быть в успешном развертывании веб-приложений для облака. Сведения о книге, см. в разделе [первой главы](introduction.md).

Предыдущей главе рассмотрены обработки временных сбоев и упоминалось, для параметра кэширования стратегию Размыкатель цепи. В этой главе содержится общая информация о кэширования, включая его общие шаблоны для использования, использовании и как реализовать его в Azure.

## <a name="what-is-distributed-caching"></a>Что является распределенное кэширование

Кэш обеспечивает высокую пропускную способность, низкую задержку при обращении к данным часто используемых приложений, сохраняя данные в памяти. Для облачного приложения наиболее полезных тип кэша — распределенного кэша, поэтому данные не хранятся в памяти отдельных веб сервера, но в других облачных ресурсов и кэшированных данных становится доступным для всех веб-серверов приложения (или других облачных виртуальных машин, ar e используется приложением).

![Схема, показывающая нескольких веб-серверов, доступ к тем же серверам кэша](distributed-caching/_static/image1.png)

Когда приложение масштабируется путем добавления или удаления серверов или серверов заменяются из-за ошибок или обновлений, кэшированные данные будут оставаться доступными на каждый сервер, на котором выполняется приложение.

Рекомендуется избегать использования доступа высокой задержкой данных в постоянном хранилище данных, кэширование может значительно повысить скорость реагирования приложения. Например извлечение данных из кэша гораздо быстрее, чем их извлечения из реляционной базы данных.

Дополнительное преимущество от кэширования уменьшается трафик в хранилище постоянных данных, что может привести к снижению издержек при наличии исходящих данных оплата за хранилище постоянных данных.

## <a name="when-to-use-distributed-caching"></a>Когда следует использовать распределенное кэширование

Выполняется кэширование наилучшим образом подходит для рабочих нагрузок приложений, получить дополнительные сведения, чем записывать данные, и если модель данных поддерживает ключ/значение организации, которая используется для хранения и извлечения данных в кэше. Это также полезнее, если пользователи приложения имеют много общих данных; например кэш не предоставляет столько преимущества Если каждому пользователю, как правило, получает данные, уникальные для этого пользователя. Пример, где кэширование может оказаться очень полезным обусловлено каталог продукции, данные изменяются редко, и все клиенты рассматривают те же данные.

Преимущества кэширования становится все более измеримым более изменения масштаба приложения, как ограничения пропускной способности и задержки задержки хранилища постоянных данных становятся несколько ограничений на общую производительность приложения. Тем не менее можно реализовать кэширование по другим причинам, чем также гарантирует повышение производительности. Для данных, не должен быть вполне актуальном состоянии, когда видит пользователь доступа к кэшу можно использовать в качестве Размыкатель цепи для при постоянном хранилище данных не отвечает или недоступен.

## <a name="popular-cache-population-strategies"></a>Стратегии заполнение популярных кэширования

Чтобы иметь возможность получения данных из кэша, необходимо сначала сохранить ее там. Существует несколько стратегий для получения данных, необходимых в кэш.

- По требованию / Cache "отдельно от"

    Приложение пытается получить данные из кэша, и если кэш не имеет данных («miss»), приложение хранит данные в кэше, таким образом, чтобы она будет доступна следующего. Следующий раз, приложение пытается получить те же данные, он находит что нужно искать в кэше («попасть»). Чтобы предотвратить получение кэшированных данных, которая была изменена в базе данных, вы делают кэш недействительным при внесении изменений в хранилище данных.
- Принудительная отправка данных в фоновом режиме

    Фоновые службы Принудительная отправка данных в кэш по регулярному расписанию и оно всегда получает из кэша. Этот подход работает отлично с источниками данных высокой задержки, не требующие всегда возвращают последние данные.
- Размыкатель цепи

    Приложения обычно взаимодействует напрямую с хранилище постоянных данных, но при постоянном хранилище данных имеет проблем с доступностью, приложение извлекает данные из кэша. Данные могли быть помещены в кэш с помощью стратегии Push-уведомлений фона данных или выделить для кэша. Это стратегия, а не стратегию улучшению производительности по обработке сбоев.

Чтобы актуальность данных в кэше, когда приложение создает, обновляет, или удаляет данные записей связанных кэша можно будет удалить. Если это хорошо для вашего приложения, иногда получить данные, которые немного устарела, можно полагаться на другой настраиваемый срок действия, чтобы ограничить от возраста кэша, данные могут быть.

Можно настроить абсолютный срок действия (количество времени с момента создания элемента кэша) или скользящий срок действия (количество времени, со времени последнего обращения к элемент кэша). При истечении срока действия кэша, чтобы предотвратить устаревание данных зависят, используется абсолютный срок действия. В Fix It приложение мы вручную будут исключать элементы устаревший кэш, и мы будем использовать скользящий срок хранения самых последних данных в кэше. Независимо от того, выбранная политика истечения срока действия кэша автоматически исключить старых элементов (как минимум недавно использованных или LRU), при достижении предела памяти кэша.

## <a name="sample-cache-aside-code-for-fix-it-app"></a>Пример кода отдельно от кэша для приложения Fix It

В следующем примере кода мы проверяем кэша сначала при извлечении задачу Fix It. Если задача находится в кэше, мы возвращаем Если объект не найден, мы получить его из базы данных и сохранить их в кэше. Изменения, можно производить добавление кэширования `FindTaskByIdAsync` метод выделены.

[!code-csharp[Main](distributed-caching/samples/sample1.cs?highlight=5,9-11,13-15,19)]

При обновлении или удалении задачи Fix It, вам нужно сделать недействительным (удаление) кэшированных задач. В противном случае последующие попытки чтения этой задачи продолжит получать старые данные из кэша.

[!code-csharp[Main](distributed-caching/samples/sample2.cs?highlight=7)]

Ниже приведены образцы, демонстрирующие простой код кэширования; кэширование не был реализован в загружаемом проекте Fix It.

## <a name="azure-caching-services"></a>Службы кэша Azure

Azure предоставляет следующие службы кэширования: [Кэш Redis для Azure](https://msdn.microsoft.com/library/dn690523.aspx) и [Azure управляемый кэш](https://msdn.microsoft.com/library/dn386094.aspx). Кэш Azure Redis основан на популярном [открытым кодом кэша Redis](http://redis.io/) и кэширования является лучшим вариантом для большинства сценариев.

<a id="sessionstate"></a>
## <a name="aspnet-session-state-using-a-cache-provider"></a>С помощью кэш поставщика состояний сеансов ASP.NET

Как упоминалось в [web разработки лучшие методики глава](web-development-best-practices.md), рекомендуется избегать использования состояния сеанса. Если приложению требуется состояние сеанса, Далее рекомендуется избежать поставщик в памяти по умолчанию, поскольку, не позволяет использовать горизонтальное масштабирование (несколько экземпляров веб-сервера). Поставщик состояния сеанса ASP.NET SQL Server позволяет сайту, запущенному на нескольких веб-серверов для использования состояния сеанса, но он приводит к высокой задержке по сравнению с поставщиком в памяти. Если необходимо использовать состояние сеанса лучше использовать поставщик кэша, такие как [поставщик состояний сеансов для кэша Azure](https://msdn.microsoft.com/library/windowsazure/gg185668.aspx).

## <a name="summary"></a>Сводка

Вы видели, как приложение Fix It может реализовать кэширование, чтобы увеличить время отклика и масштабируемость и которая позволяет приложению продолжать должен отвечать для операций чтения, когда база данных недоступна. В [следующей главе](queue-centric-work-pattern.md) мы покажем, как для дальнейшего улучшения масштабируемости и предоставить приложение по-прежнему реагировать для операций записи.

## <a name="resources"></a>Ресурсы

Дополнительные сведения о кэшировании см. следующие ресурсы.

Документация

- [Кэш Azure](https://msdn.microsoft.com/library/gg278356.aspx). Официальная документация MSDN на кэширование в Azure.
- [Microsoft Patterns and Practices — руководство по Azure](https://msdn.microsoft.com/library/dn568099.aspx). См. руководстве по кэшированию и шаблон "кэш".
- [Отказоустойчивость. Рекомендации по устойчивой облачной архитектуре](https://msdn.microsoft.com/library/windowsazure/jj853352.aspx). Технический документ, Марк Меркьюри, Ульрих Хоманн и Эндрю Таунхилл. См. в разделе кэширование.
- [Советы и рекомендации по проектированию крупномасштабных служб в облачных службах Azure](https://msdn.microsoft.com/library/windowsazure/jj717232.aspx). ВТ. Технический документ по (Mark simms) и Майкл Томасси. Распределенное кэширование см. в разделе.
- [Распределенное кэширование на пути к масштабированию](https://msdn.microsoft.com/magazine/dd942840.aspx). Старая статья журнала MSDN Magazine (2009 г.), но четко написанное введение распределенного кэширования в целом; переходит в более подробно, чем кэширования разделы в технических документах FailSafe и рекомендации.

Видеоролики

- [Отказоустойчивость. Построение масштабируемых, надежных облачных служб](https://channel9.msdn.com/Series/FailSafe). Девять веб-трансляций, Ульрих Хоманн, Марк Меркьюри и (Mark simms). Представляет представление уровня 400 проектирования облачных приложений. В этой серии посвящена теории и причины, почему; более подробные инструкции см. в разделе Создание больших рядов по (Mark simms). См. в обсуждении кэширования эпизод 3, начиная с 1:24:14.
- [Создание больших: Уроки из клиентов Azure — часть I](https://channel9.msdn.com/Events/Build/2012/3-029). Simon Дэвис рассматриваются распределенного кэширования начиная 46:00. Как и серия Failsafe, но переход в практические подробности. Презентации передан 31 октября 2012 г., поэтому он не распространяется на службы кэширования веб-приложений в службе приложений Azure, которая была введена в 2013.

Пример кода

- [Основы облачных служб в Azure](https://code.msdn.microsoft.com/Cloud-Service-Fundamentals-4ca72649). Образец приложения, который реализует распределенного кэширования. Ознакомьтесь с сопутствующей записью блога [Основы облачных служб — кэширование основы](https://blogs.msdn.com/b/windowsazure/archive/2013/10/03/cloud-service-fundamentals-caching-basics.aspx).

> [!div class="step-by-step"]
> [Назад](transient-fault-handling.md)
> [Вперед](queue-centric-work-pattern.md)
