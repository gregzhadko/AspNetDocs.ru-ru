---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/source-control
title: Система управления версиями (создание облачных приложений в реальном мире с помощью Azure) | Документация Майкрософт
author: MikeWasson
description: Создание реальных облачных приложений с помощью электронной книги Azure основано на презентации, разработанной Скотт Гатри (. В нем объясняются 13 шаблонов и методик, которые могут...
ms.author: riande
ms.date: 06/23/2015
ms.assetid: 2a0370d3-c2fb-4bf3-88b8-aad5a736c793
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/source-control
msc.type: authoredcontent
ms.openlocfilehash: 5a1e0d7cd3c396d4be79c8958422602055eb3db1
ms.sourcegitcommit: 7709c0a091b8d55b7b33bad8849f7b66b23c3d72
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/19/2020
ms.locfileid: "77457106"
---
# <a name="source-control-building-real-world-cloud-apps-with-azure"></a>Система управления версиями (создание облачных приложений в реальном мире с помощью Azure)

[Майк Уоссон](https://github.com/MikeWasson), [Рик Андерсон (](https://twitter.com/RickAndMSFT), том [Dykstra)](https://github.com/tdykstra)

[Скачивание решения ИТ-проекта](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) или [Загрузка электронной книги](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)

> **Создание реальных облачных приложений с помощью** электронной книги Azure основано на презентации, разработанной Скотт Гатри (. В нем объясняются 13 шаблонов и методик, которые могут помочь в успешной разработке веб-приложений для облака. Сведения о электронной книге см. [в первой главе](introduction.md).

Система управления версиями является важнейшей для всех проектов разработки в облаке, а не только для командных сред. Вы не считаете, что редактируете исходный код или даже документ Word без функции отмены и автоматического резервного копирования, и система управления версиями предоставляет эти функции на уровне проекта, где они могут сэкономить еще больше времени, когда что-то пойдет не так. С облачными службами управления исходным кодом вам больше не нужно беспокоиться о сложной настройке, и вы можете использовать Azure Repos систему управления версиями для до 5 пользователей.

В первой части этой главы описаны три основных рекомендации, которые следует учитывать.

- [Рассматривать скрипты автоматизации в качестве исходного кода](#scripts) и их версию вместе с кодом приложения.
- [Никогда не выверяйте секреты](#secrets) (конфиденциальные данные, такие как учетные данные) в репозитории исходного кода.
- [Настройте исходные ветви](#devops) , чтобы включить рабочий процесс DevOps.

В оставшейся части главы приводится несколько примеров реализации этих шаблонов в Visual Studio, Azure и Azure Repos.

- [Добавление скриптов в систему управления версиями в Visual Studio](#vsscripts)
- [Хранение конфиденциальных данных в Azure](#appsettings)
- [Использование Git в Visual Studio и Azure Repos](#gittfs)

<a id="scripts"></a>
## <a name="treat-automation-scripts-as-source-code"></a>Рассматривать скрипты автоматизации в качестве исходного кода

Работая над облачным проектом, вы часто изменяете его и хотите иметь возможность быстро реагировать на проблемы, о которых сообщили ваши клиенты. Быстрый ответ заключается в использовании скриптов автоматизации, как описано в главе [Автоматизация всех](automate-everything.md) . Все сценарии, используемые для создания среды, развертывания в ней, масштабирования и т. д., должны быть синхронизированы с исходным кодом приложения.

Чтобы синхронизировать скрипты с кодом, храните их в системе управления версиями. Если вам когда-либо придется откатить изменения или выполнить быстрое исправление в рабочем коде, которое отличается от кода разработки, вам не придется тратить время на попытку отслеживания изменений параметров или членов группы, имеющих копии требуемой версии. Вы уверены, что необходимые скрипты синхронизированы с базой кода, для которой они необходимы, и вы уверены, что все члены группы работают с одними и теми же скриптами. Затем, нужно ли автоматизировать тестирование и развертывание горячего исправления в рабочей или новой функции, у вас будет правильный скрипт для кода, который необходимо обновить.

<a id="secrets"></a>
## <a name="dont-check-in-secrets"></a>Не возвращать секреты

Репозиторий исходного кода обычно доступен слишком большому числу людей, чтобы он был соответствующим образом защищенным местом для конфиденциальных данных, таких как пароли. Если скрипты зависят от секретов, таких как пароли, параметризовать эти параметры, чтобы они не сохранялись в исходном коде, и храните секреты в другом месте.

Например, Azure позволяет скачивать файлы, содержащие параметры публикации, для автоматизации создания профилей публикации. Эти файлы содержат имена пользователей и пароли, которым разрешено управлять службами Azure. При использовании этого метода для создания профилей публикации и при возврате этих файлов в систему управления версиями любой пользователь, имеющий доступ к репозиторию, сможет видеть эти имена пользователей и пароли. Пароль можно безопасно сохранить в самом профиле публикации, так как он шифруется и находится в файле *. pubxml. User* , который по умолчанию не включен в систему управления версиями.

<a id="devops"></a>
## <a name="structure-source-branches-to-facilitate-devops-workflow"></a>Структурирование исходных ветвей для упрощения рабочего процесса DevOps

Способ реализации ветвей в репозитории влияет на возможность разработки новых функций и устранения проблем в рабочей среде. Ниже приведен шаблон, который используется множеством групп среднего размера:

![Структура исходной ветви](source-control/_static/image1.png)

Главная ветвь всегда соответствует коду в рабочей среде. Ветви, расположенные под главной репликой, соответствуют разным этапам жизненного цикла разработки. В ветви разработки можно реализовать новые функции. Для небольшой команды, возможно, у вас есть Главная и разработка, но часто рекомендуется, чтобы у пользователей была промежуточная ветвь между разработкой и мастером. Промежуточное развертывание можно использовать для окончательного тестирования интеграции до перемещения обновления в рабочую среду.

Для больших групп могут существовать отдельные ветви для каждой новой функции. для группы меньшего размера может потребоваться возврат в ветвь Development.

Если у вас есть ветвь для каждого компонента, то когда компонент A готов, его исходный код будет преобразован в ветвь разработки и в другие ветви функций. Этот процесс слияния исходного кода может занять много времени. чтобы избежать этой работы, не прерывая работу отдельных функций, некоторые команды реализуют альтернативные *[переключатели](http://en.wikipedia.org/wiki/Feature_toggle)* , которые также называются *флагами функций*. Это означает, что весь код всех компонентов находится в той же ветви, но вы включаете или отключаете каждый компонент с помощью параметров в коде. Например, предположим, что функция A является новым полем для решения задач приложения для ИТ-приложений, а функция б добавляет функциональность кэширования. Код для обеих функций может находиться в ветви разработки, но приложение будет отображать новое поле только в том случае, если переменная имеет значение true, и будет использовать кэширование только в том случае, если для другой переменной задано значение true. Если компонент A не готов к повышению уровня, но компонент B готов, можно преобразовать весь код в рабочую среду с возможностью выключения переключателя, а также включить функцию B. Затем можно завершить функцию а и повысить ее уровень, не выполнив слияние исходного кода.

Независимо от того, используются ли ветви или переключатели для функций, подобная структура ветвления позволяет передавать код из разработки в рабочую среду в гибком и повторяемом способах.

Эта структура также позволяет быстро реагировать на Отзывы клиентов. Если вам нужно выполнить быстрое исправление в рабочей среде, это можно сделать эффективно в гибком виде. Вы можете создать ветвь из главной или промежуточной среды и когда она будет готова объединить ее в главную среду и ветви компонентов.

![ветвь исправления](source-control/_static/image2.png)

Без структуры ветвления, подобной этой, с разделением рабочей среды и ветвей разработки, проблема в рабочей среде может полагаться на необходимость продвижения нового кода функции вместе с производственным исправлением. Новый код функции может быть не полностью протестирован и готов к рабочей среде. при этом может потребоваться выполнить массовую работу по выполнению изменений, которые не готовы. Кроме того, может потребоваться отложить исправление, чтобы проверить изменения и подготовить их к развертыванию.

Далее вы увидите примеры реализации этих трех шаблонов в Visual Studio, Azure и Azure Repos. Это примеры, а не подробные пошаговые инструкции. подробные инструкции по обеспечению всего необходимого контекста см. в разделе [ресурсов](#resources) в конце главы.

<a id="vsscripts"></a>
## <a name="add-scripts-to-source-control-in-visual-studio"></a>Добавление скриптов в систему управления версиями в Visual Studio

Вы можете добавить скрипты в систему управления версиями в Visual Studio, включив их в папку решения Visual Studio (если проект находится в системе управления версиями). Вот один из способов сделать это.

Создайте папку для скриптов в папке решения (в той же папке, где находится *SLN* -файл).

![Папка службы автоматизации](source-control/_static/image3.png)

Скопируйте файлы сценариев в папку.

![Содержимое папки службы автоматизации](source-control/_static/image4.png)

В Visual Studio добавьте в проект папку решения.

![Выбор меню "папка" для нового решения](source-control/_static/image5.png)

И добавьте файлы скрипта в папку решения.

![Выбор меню "Добавить существующий элемент"](source-control/_static/image6.png)

![диалоговое окно «Добавление существующего элемента»](source-control/_static/image7.png)

Файлы скриптов теперь включены в проект, и система управления версиями отслеживает изменения версий вместе с соответствующими изменениями исходного кода.

<a id="appsettings"></a>
## <a name="store-sensitive-data-in-azure"></a>Хранение конфиденциальных данных в Azure

При запуске приложения на веб-сайте Azure один из способов избежать хранения учетных данных в системе управления версиями заключается в том, чтобы сохранить их в Azure.

Например, в файле Web. config сохраняются две строки подключения, которые будут иметь пароли в рабочей среде, и ключ, предоставляющий доступ к учетной записи хранения Azure.

[!code-xml[Main](source-control/samples/sample1.xml?highlight=2-3,11)]

Если поместить фактические значения для этих параметров в файл *Web. config* или поместить их в файл *Web. Release. config* , чтобы настроить преобразование web. config для их вставки во время развертывания, они будут сохранены в исходном репозитории. При вводе строк подключения к базе данных в профиль рабочей публикации пароль будет находиться в файле *. pubxml* . (Вы можете исключить файл *. pubxml* из системы управления версиями, но тогда вы потеряли преимущество совместного использования всех остальных параметров развертывания.)

Azure предоставляет альтернативу разделу **appSettings** и строкам подключения в файле *Web. config* . Ниже приведена соответствующая часть вкладки **Конфигурация** для веб-сайта на портале управления Azure.

![appSettings и connectionString на портале](source-control/_static/image8.png)

При развертывании проекта на этом веб-сайте и запуске приложения любые значения, сохраненные в Azure, переопределяют любые значения в файле Web. config.

Эти значения можно задать в Azure с помощью портала управления или сценариев. Сценарий автоматизации создания среды, который вы видели в главе [Автоматизация всех](automate-everything.md) , создает базу данных SQL Azure, получает строки подключения хранилища и базы данных SQL и сохраняет эти секреты в параметрах веб-сайта.

[!code-powershell[Main](source-control/samples/sample2.ps1)]

[!code-powershell[Main](source-control/samples/sample3.ps1)]

Обратите внимание, что скрипты параметризованы таким образом, чтобы фактические значения не сохранялись в исходном репозитории.

При локальном запуске в среде разработки приложение считывает локальный файл Web. config, а строка подключения указывает на базу данных SQL Server LocalDB в папке *приложения\_данных* веб-проекта. При запуске приложения в Azure приложение пытается считать эти значения из файла Web. config, что возвращается к работе и использует значения, хранящиеся на веб-сайте, а не на самом деле в файле Web. config.

<a id="gittfs"></a>
## <a name="use-git-in-visual-studio-and-azure-devops"></a>Использование Git в Visual Studio и Azure DevOps

Для реализации структуры ветвления DevOps, представленной ранее, можно использовать любую среду управления версиями. Для распределенных групп можно использовать [распределенную систему управления версиями](http://en.wikipedia.org/wiki/Distributed_revision_control) (DVCS). для других команд [централизованная система](http://en.wikipedia.org/wiki/Revision_control) может работать лучше.

[Git](http://git-scm.com/) — это популярная распределенная система управления версиями. При использовании Git для управления исходным кодом у вас есть полная копия репозитория со всеми его историями на локальном компьютере. Многие люди предпочитают, что так проще продолжать работу, если вы не подключены к сети — вы можете продолжить фиксацию и откат, создание и переключение ветвей и т. д. Даже если вы подключены к сети, проще и быстрее создавать ветви и переключать ветви, когда все локальные. Вы также можете выполнять локальные фиксации и откаты без влияния на других разработчиков. И можно выполнить пакетную фиксацию перед отправкой на сервер.

[Azure Repos](/azure/devops/repos/index?view=vsts) предлагает и [Git](/azure/devops/repos/git/?view=vsts) , и [система управления версиями Team Foundation](/azure/devops/repos/tfvc/index?view=vsts) (TFVC; централизованное управление версиями). Начните работу с Azure DevOps [здесь](https://app.vsaex.visualstudio.com/signup).

Visual Studio 2017 включает встроенную [поддержку Git](https://msdn.microsoft.com/library/hh850437.aspx)первого класса. Вот краткий пример того, как это работает.

Откройте проект в Visual Studio, щелкните решение в **Обозреватель решений**правой кнопкой мыши и выберите пункт **Добавить решение в систему управления версиями**.

![Добавить решение в систему управления версиями](source-control/_static/image9.png)

Visual Studio спрашивает, нужно ли использовать TFVC (централизованное управление версиями) или Git.

![Выбор системы управления версиями](source-control/_static/image10.png)

Если выбрать Git и нажать кнопку **ОК**, Visual Studio создаст новый локальный репозиторий Git в папке решения. Новый репозиторий еще не содержит файлов; их необходимо добавить в репозиторий, выполнив фиксацию Git. Щелкните правой кнопкой мыши решение в **Обозреватель решений**и выберите пункт **зафиксировать**.

![Commit](source-control/_static/image11.png)

Visual Studio автоматически размещает все файлы проекта для фиксации и перечисляет их в **Team Explorer** на панели " **добавленные изменения** ". (Если вы не хотите включать в фиксацию, выберите их, щелкните правой кнопкой мыши и выберите пункт **исключить**.)

![Team Explorer](source-control/_static/image12.png)

Введите комментарий фиксации и нажмите кнопку **зафиксировать**, и Visual Studio выполняет фиксацию и отображает идентификатор фиксации.

![Team Explorer изменения](source-control/_static/image13.png)

Теперь, если изменить код так, чтобы он отличался от того, что находится в репозитории, можно легко просмотреть различия. Щелкните правой кнопкой мыши файл, который вы изменили, выберите пункт **сравнить с неизмененным**и получите представление сравнения, которое показывает Незафиксированное изменение.

![Сравнить с неизмененным](source-control/_static/image14.png)

![Различие, отображающее изменения](source-control/_static/image15.png)

Вы можете легко увидеть, какие изменения вы вносите, и проверить их.

Предположим, что необходимо создать ветвь — это можно сделать и в Visual Studio. В **Team Explorer**щелкните **создать ветвь**.

![Team Explorer новой ветви](source-control/_static/image16.png)

Введите имя ветви, нажмите кнопку **создать ветвь**, а если выбран вариант **извлечь ветвь**, Visual Studio автоматически выполнит проверку новой ветви.

![Team Explorer новой ветви](source-control/_static/image17.png)

Теперь можно вносить изменения в файлы и возвращать их в эту ветвь. Вы можете легко переключаться между ветвями, и Visual Studio автоматически синхронизирует их с какой бы то ни было извлеченной ветвью. В этом примере заголовок веб-страницы в *\_Layout. cshtml* был изменен на "горячее исправление 1" в ветви HotFix1.

![Ветвь Hotfix1](source-control/_static/image18.png)

Если вернуться к главной ветви, содержимое файла *\_Layout. cshtml* автоматически вернется к тем, что находится в главной ветви.

![Главная ветвь](source-control/_static/image19.png)

Это простой пример того, как можно быстро создать ветвь и перевернуть между ветвями. Эта функция обеспечивает высокую гибкость рабочего процесса, используя структуру ветвей и сценарии автоматизации, представленные в главе [Автоматизация всех](automate-everything.md) . Например, вы можете работать в ветви разработки, создавать "горячее" ветвь исправлений для главной ветви, переключаться на новую ветвь, вносить изменения там и зафиксировать их, а затем переключаться обратно в ветвь разработки и продолжать работу.

Здесь вы узнали, как работать с локальным репозиторием Git в Visual Studio. В среде группы вы обычно отправляете изменения в общий репозиторий. Средства Visual Studio также позволяют указывать на удаленный репозиторий Git. Вы можете использовать GitHub.com для этой цели или использовать [Git и Azure Repos](/azure/devops/repos/git/overview?view=vsts) , интегрированные с другими возможностями Azure DevOps, такими как рабочие элементы и отслеживание ошибок.

Это не единственный способ реализации стратегии гибкого ветвления. Вы можете включить один и тот же рабочий процесс Agile с помощью централизованного репозитория системы управления версиями.

## <a name="summary"></a>Сводка

Измерьте успешность системы управления версиями в зависимости от того, как быстро можно внести изменения и получить его в реальном времени. Если вы нашли страх, чтобы внести изменения, так как вам приходится выполнять какие-либо действия по ручному тестированию, вы можете попросить себя, что нужно сделать, чтобы вы могли сделать это за несколько минут или в худшем случае не более часа. Одной из стратегий реализации этой процедуры является реализация непрерывной интеграции и непрерывной поставки, которая будет рассмотрена в [следующей главе](continuous-integration-and-continuous-delivery.md).

<a id="resources"></a>
## <a name="resources"></a>Ресурсы

Дополнительные сведения о стратегиях ветвления см. в следующих ресурсах:

- [Создание конвейера выпуска с Team Foundation Server 2012](https://msdn.microsoft.com/library/dn449957.aspx). Документация по шаблонам и методикам Майкрософт. Обсуждение стратегий ветвления см. в главе 6. Отвечает за функции, которые переключаются между ветвями компонентов, и если используются ветви для функций, то отвечает их кратковременно (в часах или днях).
- [Руководству по управлению версиями](https://aka.ms/vsarsolutions). Рекомендации по ветвлению стратегий с помощью диапазонов управления жизненным циклом приложений. См. раздел стратегии ветвления. PDF на вкладке загрузки.
- [Разработка программного обеспечения с переключателями компонентов](https://msdn.microsoft.com/magazine/dn683796.aspx). Статья журнала MSDN Magazine.
- [Переключатель функции](http://martinfowler.com/bliki/FeatureToggle.html). Общие сведения о переключателях и флагах функций в блоге Фаулер.
- [Функция переключает ветви компонентов VS](http://geekswithblogs.net/Optikal/archive/2013/02/10/152069.aspx). Еще одна запись в блоге о переключении компонентов с Дилан Смит.

Дополнительные сведения об обработке конфиденциальных данных, которые не должны храниться в репозиториях системы управления версиями, см. в следующих ресурсах:

- Рекомендации [по развертыванию паролей и других конфиденциальных данных в ASP.NET и службе приложений Azure](../../../../identity/overview/features-api/best-practices-for-deploying-passwords-and-other-sensitive-data-to-aspnet-and-azure.md).
- [Веб-сайты Azure: как работают строки приложения и строки подключения](https://azure.microsoft.com/blog/2013/07/17/windows-azure-web-sites-how-application-strings-and-connection-strings-work/). Описание функции Azure, которая переопределяет `appSettings` и `connectionStrings` данные в файле *Web. config* .
- [Пользовательские параметры конфигурации и приложения на веб-сайтах Azure — с Стефан Шаков (](https://azure.microsoft.com/documentation/videos/configuration-and-app-settings-of-azure-web-sites/).

Сведения о других методах хранения конфиденциальной информации из системы управления версиями см. в разделе [ASP.NET MVC: сохранить частные параметры из системы управления версиями](http://typecastexception.com/post/2014/04/06/ASPNET-MVC-Keep-Private-Settings-Out-of-Source-Control.aspx).

> [!div class="step-by-step"]
> [Назад](automate-everything.md)
> [Вперед](continuous-integration-and-continuous-delivery.md)
