---
uid: aspnet/overview/web-development-best-practices/what-not-to-do-in-aspnet-and-what-to-do-instead
title: Чего не следует делать в ASP.NET и что нужно делать вместо этого | Документация Майкрософт
author: Rick-Anderson
description: В этом разделе описывается несколько распространенных ошибок, которые люди делают в веб-проектов ASP.NET. Представлены рекомендации по что делать, чтобы избежать этих commo...
ms.author: riande
ms.date: 01/28/2019
ms.assetid: c39b9965-545c-4b04-8f55-21be7f28a9e5
msc.legacyurl: /aspnet/overview/web-development-best-practices/what-not-to-do-in-aspnet-and-what-to-do-instead
msc.type: authoredcontent
ms.openlocfilehash: 980d3544df70643043391e6573803ce21b3a824f
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/06/2019
ms.locfileid: "65118169"
---
# <a name="what-not-to-do-in-aspnet-and-what-to-do-instead"></a>Запрещенные и разрешенные действия в ASP.NET

> В этом разделе описывается несколько распространенных ошибок, которые люди делают в веб-проектов ASP.NET. Представлены рекомендации по что делать, чтобы избежать этих распространенных ошибок. Он основан на [презентации](http://vimeo.com/68390507) по **Damian Edwards** на конференции Norwegian Developers Conference.

## <a name="disclaimer"></a>Отказ от ответственности

В этом разделе не предназначен как полное руководство по, чтобы убедиться, что приложение является безопасной и эффективной. Необходимо по-прежнему следуйте рекомендациям по безопасности и производительности, не описанные в этом разделе. Только способы избежать типичных ошибок, связанных с классами .NET и процессы.

## <a name="overview"></a>Обзор

В этом разделе содержатся следующие подразделы.

- [Соответствие стандартам](#standards)

    - [Адаптеры элементов управления](#adapters)
    - [Свойства стиля для элементов управления](#styleprop)
    - [Страницы и обратные вызовы элемент управления](#callback)
    - [Определение возможностей браузера](#browsercap)
- [Безопасность](#security)

    - [Проверка запросов](#validation)
    - [Аутентификация с помощью форм без поддержки файлов cookie и сеансов](#cookieless)
    - [EnableViewStateMac](#viewstatemac)
    - [Средний уровень доверия](#medium)
    - [&lt;appSettings&gt;](#appsettings)
    - [UrlPathEncode](#urlpathencode)
- [Надежность и производительность](#performance)

    - [PreSendRequestHeaders и PreSendRequestContent](#presend)
    - [События асинхронной страницы с веб-форм](#asyncevents)
    - [Выстрелил и забыл работы](#fire)
    - [Тело сущности запроса](#requestentity)
    - [Response.Redirect и Response.End](#redirect)
    - [EnableViewState и ViewStateMode](#viewstatemode)
    - [SqlMembershipProvider](#sqlprovider)
    - [Длительные запросы, под управлением (> 110 секунд)](#long)

<a id="standards"></a>

## <a name="standards-compliance"></a>Соответствие стандартам

<a id="adapters"></a>

### <a name="control-adapters"></a>Адаптеры элементов управления

Рекомендация: Отключить использование адаптеров элементов управления для адаптивной отрисовки, а вместо этого использовать CSS медиа-запросами и соответствующих стандартам HTML.

Адаптеры элементов управления появились в .NET 2.0 для визуализации представления код, который был настроен для различных устройств и сред. Теперь это адаптивный отрисовку можно выполнить с помощью CSS и HTML. Следует прекратить использование адаптеров элементов управления и преобразовать любые существующие адаптеры CSS и HTML.

Дополнительные сведения см. в разделе [медиа-запросами](http://www.w3.org/TR/css3-mediaqueries/) и [How To: Добавление мобильных страниц в ASP.NET Web Forms и MVC-приложении](../../../whitepapers/add-mobile-pages-to-your-aspnet-web-forms-mvc-application.md).

<a id="styleprop"></a>

### <a name="style-properties-on-controls"></a>Свойства стиля для элементов управления

Рекомендация: Остановить задание значений стиля в разметку элемента управления, а вместо этого задать форматирование значений в таблицах стилей CSS.

Веб-сервера управления содержат множество свойств, которые могут использоваться для задания свойства встроенного стиля. Например свойства ForeColor задает цвет текста для элемента управления. Это можно сделать этот же эффект, более эффективно через таблицы стилей CSS. Таблицы стилей позволяют централизовать значений стиля и не рекомендуется устанавливать эти значения во всем приложении.

Приведенный ниже показан класс CSS на красный текст наборов.

[!code-css[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample1.css)]

В следующем примере показано, как динамически применить класс CSS.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample2.cs)]

<a id="callback"></a>

### <a name="page-and-control-callbacks"></a>Обратные вызовы страниц и элементов управления

Рекомендация: Прекратить использование обратных вызовов страниц и элементов управления и вместо этого использовать любой из следующих: AJAX UpdatePanel, MVC методы действий, веб-API и SignalR.

В более ранних версиях ASP.NET добавлены методы обратного вызова страницы и элемента управления позволяет обновлять части веб-страницы без обновления всей страницы. Теперь можно выполнить частичного обновления страницы через [AJAX](../../../ajax/index.md), [UpdatePanel](https://msdn.microsoft.com/library/bb386454.aspx), [MVC](../../../mvc/index.md), [веб-API](../../../web-api/index.md) или [SignalR](../../../signalr/index.md). Следует остановить с помощью методов обратного вызова, так как они могут вызвать проблемы с помощью удобных URL-адресов и маршрутизации. По умолчанию элементы управления не включайте методы обратного вызова, но если вы включили эту функцию в элементе управления, его следует отключать.

<a id="browsercap"></a>

### <a name="browser-capability-detection"></a>Определение возможностей браузера

Рекомендация: Прекратить использование статических обозревателя возможности обнаружения и вместо этого используйте функцию динамического обнаружения.

В более ранних версиях ASP.NET поддерживаемых функций для каждого браузера, хранятся в XML-файл. Обнаружение событий поддержка функций через статический уточняющего запроса не лучшим подходом. Теперь вы можете динамически обнаружить браузер поддерживаемых возможностей с помощью платформы обнаружение компонентов, таких как [Modernizr](http://modernizr.com/). Функция обнаружения определяет поддержки, попытка использовать метод или свойство, а затем щелкните для просмотра, если браузер создаваться нужного результата. По умолчанию Modernizr включается в шаблоны веб-приложений.

<a id="security"></a>

## <a name="security"></a>Безопасность

<a id="validation"></a>

### <a name="request-validation"></a>Проверка запросов

Рекомендация: Проверки пользовательского ввода и кодирования выходных данных от пользователей.

Проверка запросов — это функция ASP.NET, которое проверяет каждый запрос и останавливает запрос, если найден предполагаемых угроз. Не зависят от проверки запросов для защиты приложения от атак с использованием межузловых сценариев. Вместо этого проверяйте весь ввод от пользователей и кодирования выходных данных. В некоторых случаях можно использовать регулярные выражения для проверки входных данных, но в более сложных случаях следует проверять входные данные пользователя с помощью классов .NET, которые определяют, если значение соответствует допустимые значения.

В следующем примере показано, как использовать статический метод в класс Uri, чтобы определить, допустим ли Uri, предоставленное пользователем.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample3.cs)]

Тем не менее, чтобы проверить, достаточно Uri, следует также проверить чтобы убедиться в том, он указывает `http` или `https`. В следующем примере методы экземпляра убедитесь, что Uri является допустимым.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample4.cs)]

Перед отображением введенных пользователем данных как HTML или включая пользовательский ввод в SQL-запросе, закодируйте значения, чтобы убедиться, что вредоносный код не включается.

Вы можете HTML кодирования значения в разметке, с &lt;%: %&gt; синтаксис, как показано ниже.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample5.aspx?highlight=1)]

В синтаксисе Razor, вы также можете HTML кодирования с @, как показано ниже.

[!code-cshtml[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample6.cshtml?highlight=1)]

В следующем примере показано как в виде HTML кодировать значение, которое в коде.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample7.cs)]

Чтобы безопасно кодировать значение для команды SQL, используйте параметры команды, такие как [SqlParameter](https://msdn.microsoft.com/library/system.data.sqlclient.sqlparameter.aspx). <a id="cookieless"></a>

### <a name="cookieless-forms-authentication-and-session"></a>Аутентификация с помощью форм без поддержки файлов cookie и сеансов

Рекомендация: Требуются файлы cookie.

Передавая сведения о проверке подлинности в строке запроса не является безопасным. Таким образом требуется файлы cookie, если приложение включает проверку подлинности. Если файлы cookie с компьютера хранятся конфиденциальные сведения, рассмотрите возможность обязательное использование SSL для файла cookie.

В следующем примере показано, как укажите в файле Web.config, что аутентификация с помощью форм требуется файл cookie, который передается по протоколу SSL.

[!code-xml[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample8.xml)]

<a id="viewstatemac"></a>

### <a name="enableviewstatemac"></a>EnableViewStateMac

Рекомендация: Никогда не задано значение false.

По умолчанию, свойство EnableViewStateMac имеет значение в значение true. Даже если приложение не использует состояние просмотра, не устанавливайте свойство EnableViewStateMac значение false. Значение false делает приложение уязвимым для межузловых сценариев.

Начиная с ASP.NET 4.5.2, среда выполнения обеспечивает **EnableViewStateMac = true**. Даже если ему присвоено значение false, среда выполнения игнорирует это значение и выполняет заданное значение в значение true. Дополнительные сведения см. в разделе [ASP.NET 4.5.2 и EnableViewStateMac](https://blogs.msdn.com/b/webdev/archive/2014/05/07/asp-net-4-5-2-and-enableviewstatemac.aspx).

В следующем примере показано, как присвоено значение true, свойство EnableViewStateMac. Необходимо непосредственно задается значение true, поскольку он имеет значение true, по умолчанию. Тем не менее если вы задали ее значение false на любой странице в приложении, необходимо немедленно исправить это значение.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample9.aspx)]

<a id="medium"></a>

### <a name="medium-trust"></a>Средний уровень доверия

Рекомендация: Не зависят от средний уровень доверия (или любой другой уровень доверия) как границу безопасности.

Частичное доверие не обеспечить адекватную защиту приложения и не должны использоваться. Вместо этого используйте полное доверие и изолировать ненадежных приложений в отдельных пулах приложений. Кроме того запустите каждый пул приложений с уникальным удостоверением. Дополнительные сведения см. в разделе [частичного доверия в ASP.NET не обеспечивает изоляцию приложения](https://support.microsoft.com/kb/2698981).

<a id="appsettings"></a>

### <a name="ltappsettingsgt"></a>&lt;appSettings&gt;

Рекомендация: Не отключайте параметры безопасности в &lt;appSettings&gt; элемент.

Элемент appSettings содержит много значений, которые необходимы для обновления для системы безопасности. Нельзя изменить или отключить эти значения. Если необходимо отключить эти значения при развертывании обновлений, сразу же повторно включите после завершения развертывания.

Дополнительные сведения см. в разделе [ASP.NET: элемент appSettings](https://msdn.microsoft.com/library/hh975440.aspx).

<a id="urlpathencode"></a>

### <a name="urlpathencode"></a>UrlPathEncode

Рекомендация: Используйте [UrlEncode](https://msdn.microsoft.com/library/zttxte6w.aspx) вместо этого.

Метод UrlPathEncode была добавлена в .NET Framework для разрешения проблем совместимости очень конкретного браузера. Не адекватно кодирования URL-адрес и не обеспечивает дополнительную защиту от межузловых сценариев. Никогда не следует использовать его в приложении. Вместо этого используйте [UrlEncode](https://msdn.microsoft.com/library/zttxte6w.aspx).

В следующем примере показано, как для передачи закодированный URL-адрес в качестве параметра строки запроса для элемента управления hyperlink.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample10.cs)]

<a id="performance"></a>

## <a name="reliability-and-performance"></a>Надежность и производительность

<a id="presend"></a>

### <a name="presendrequestheaders-and-presendrequestcontent"></a>PreSendRequestHeaders и PreSendRequestContent

Рекомендация: Не используйте эти события с помощью управляемых модулей. Вместо этого можно напишите собственный модуль IIS для выполнения требуемой задачи. См. в разделе [создания машинного кода HTTP-модулей](https://msdn.microsoft.com/library/ms693629.aspx).

Можно использовать [PreSendRequestHeaders](https://msdn.microsoft.com/library/system.web.httpapplication.presendrequestheaders.aspx) и [PreSendRequestContent](https://msdn.microsoft.com/library/system.web.httpapplication.presendrequestcontent.aspx) событий с помощью собственных модулей IIS.
> [!WARNING]
> Не используйте `PreSendRequestHeaders` и `PreSendRequestContent` с управляемые модули, которые реализуют `IHttpModule`. Настройка этих свойств может вызвать проблемы с асинхронных запросов. Сочетание маршрутизации запрошенных приложений (ARR) и websockets может привести к исключения нарушения прав доступа, которые могут вызвать w3wp к сбою в работе. Например, iiscore! W3_CONTEXT_BASE::GetIsLastNotification + 68 в iiscore.dll вызвала нарушение прав доступа (0xC0000005).

<a id="asyncevents"></a>

### <a name="asynchronous-page-events-with-web-forms"></a>События асинхронной страницы с веб-форм

Рекомендация: В веб-формы, избежать написания асинхронные методы, возвращающие void, событий жизненного цикла страницы и вместо этого использовать [Page.RegisterAsyncTask](https://msdn.microsoft.com/library/system.web.ui.page.registerasynctask.aspx) для асинхронного кода.

Если пометить событие страницы с **async** и **void**, не может определить, когда асинхронный код будет завершено. Вместо этого используйте Page.RegisterAsyncTask для выполнения асинхронного кода способом, который позволяет отслеживать ее завершения.

В следующем примере показан кнопки щелкните обработчика, который содержит асинхронного кода. Этот пример включает чтения строковое значение, предоставляемое только как упрощенный пример асинхронной задачи, а не рекомендуется.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample11.cs)]

При использовании асинхронных задач, задать целевую платформу среды выполнения Http для 4.5 (или более поздней версии) в файле Web.config. Настройке требуемой версии .NET framework 4.5 включает на новый контекст синхронизации, была добавлена в .NET 4.5. Это значение по умолчанию в новых проектах в Visual Studio, но не была настроена, если вы работаете с существующим проектом.

[!code-xml[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample12.xml)]

<a id="fire"></a>

### <a name="fire-and-forget-work"></a>Выстрелил и забыл работы

Рекомендация: При обработке запроса в ASP.NET, избегайте запуска выстрелил и забыл рабочих (такой вызов метода ThreadPool.QueueUserWorkItem или создания таймера, который многократно вызывает делегат).

Если приложение имеет выстрелил и забыл работы, которая выполняется в ASP.NET, приложения могут стать асинхронными. В любое время домен приложения можно уничтожить это означает, что ваш непрерывный процесс больше не соответствует текущее состояние приложения.

Перенос такого рода работу за пределами ASP.NET. Можно использовать веб-задания, службы Windows или рабочей роли в Azure для выполнения текущей работы и выполните этот код от другого процесса.

Если необходимо выполнить эту работу в ASP.NET, можно добавить пакет Nuget [WebBackgrounder](http://www.nuget.org/packages/webbackgrounder) для выполнения кода.

<a id="requestentity"></a>

### <a name="request-entity-body"></a>Тело сущности запроса

Рекомендация: Избегайте чтения Request.Form или Request.InputStream перед выполнением обработчика событий.

Это самые ранние, которые следует прочитать из Request.Form или Request.InputStream во время данного обработчика, выполняют событий. В MVC контроллер является обработчиком, и событие выполнения при выполнении метода. В веб-формы страницы является обработчиком, а событие выполнения — при возникновении события Page.Init. Если более ранних, чем событие выполнения чтения тела сущности запроса, вам мешать обработки запроса.

Если вам нужно прочитать тело сущности запроса, прежде чем событие выполнения, используйте либо [Request.GetBufferlessInputStream](https://msdn.microsoft.com/library/ff406798.aspx) или [Request.GetBufferedInputStream](https://msdn.microsoft.com/library/system.web.httprequest.getbufferedinputstream.aspx). При использовании GetBufferlessInputStream, вы получаете исходный поток из запроса и принимают на себя ответственность за обработку всего запроса. После вызова GetBufferlessInputStream, Request.Form и Request.InputStream недоступны, так как они не заполнены в ASP.NET. При использовании GetBufferedInputStream, вы получите копию потока из запроса. Request.Form и Request.InputStream по-прежнему доступны позже в запросе, так как ASP.NET заполняет другие копии.

<a id="redirect"></a>

### <a name="responseredirect-and-responseend"></a>Response.Redirect и Response.End

Рекомендация: Следует учитывать различия в обработке поток после вызова метода [Response.Redirect(String)](https://msdn.microsoft.com/library/t9dwyts4.aspx).

[Response.Redirect(String)](https://msdn.microsoft.com/library/t9dwyts4.aspx) метод вызывает метод Response.End. В синхронном процессе вызов Request.Redirect вызывает немедленно прерывание текущего потока. Тем не менее в асинхронном процессе, вызов Response.Redirect не будет прерываться текущего потока, поэтому выполнение кода продолжается для запроса. В асинхронный процесс задача должна прекращать метод для остановки выполнения кода.

В проекте MVC не следует вызывать Response.Redirect. Вместо этого возвращает RedirectResult.

<a id="viewstatemode"></a>

### <a name="enableviewstate-and-viewstatemode"></a>EnableViewState и ViewStateMode

Рекомендация: Используйте ViewStateMode, вместо EnableViewState позволил выяснить, для обеспечения детального управления, по которому элементы управления используют состояние представления.

Если EnableViewState значение false в директиве Page, состояние представления отключено для всех элементов управления на странице и не может быть включен. Если вы хотите включить состояние просмотра только для определенных элементов управления на странице, установлен ViewStateMode отключено на странице.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample13.aspx)]

Затем задайте ViewStateMode включена только элементов управления, которые фактически должны состояние представления.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample14.aspx)]

Включение состояния представления только для элементов управления, которым она необходима, вы можете уменьшить размер состояния представления для веб-страниц.

<a id="sqlprovider"></a>

### <a name="sqlmembershipprovider"></a>SqlMembershipProvider

Рекомендация: Используйте универсальные поставщики.

В текущем шаблоны проектов, SqlMembershipProvider был заменен классом [универсальные поставщики ASP.NET](http://www.nuget.org/packages/Microsoft.AspNet.Providers), которая доступна как пакет NuGet. Если вы используете SqlMembershipProvider в проект, который был построен с более ранней версии шаблонов, необходимо переключиться на универсальные поставщики. Универсальные поставщики работать со всеми базами данных, которые поддерживаются платформой Entity Framework.

Дополнительные сведения см. в разделе [введение в универсальные поставщики ASP.NET](http://www.hanselman.com/blog/IntroducingSystemWebProvidersASPNETUniversalProvidersForSessionMembershipRolesAndUserProfileOnSQLCompactAndSQLAzure.aspx).

<a id="long"></a>

### <a name="long-running-requests-110-seconds"></a>Длительные запросы (> 110 секунд)

Рекомендация: Используйте [WebSockets](https://msdn.microsoft.com/library/system.net.websockets.websocket.aspx) или [SignalR](../../../signalr/index.md) для подключенных клиентов и используйте асинхронные операции ввода-вывода.

Длительных запросов может привести к непредсказуемым результатам и снижению производительности веб-приложения. По умолчанию время ожидания для запроса установлено значение 110 секунд. При использовании состояния сеанса с помощью выполняющейся длительное время запроса, ASP.NET будет снимать блокировку для объекта сеанса через 110 секунд. Тем не менее приложение может выполнять другие операции в объекте сеанса, когда блокировка снимается, и не может выполнить операцию. Если второй запрос от пользователя блокируется, пока первый запрос выполняется, второй запрос может получить доступ к объект сеанса в несогласованном состоянии.

Если приложение включает блокировки (или синхронный) операций ввода-вывода, приложение будет отвечать на запросы.

Чтобы повысить производительность, используйте асинхронные операции ввода-вывода в .NET Framework. Кроме того при подключении клиентов к серверу используете доступа WebSocket или SignalR. Эти функции предназначены для эффективной обработки длительных запросов.
