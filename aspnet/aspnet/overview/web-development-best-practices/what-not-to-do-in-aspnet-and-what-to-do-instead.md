---
uid: aspnet/overview/web-development-best-practices/what-not-to-do-in-aspnet-and-what-to-do-instead
title: Что не нужно делать в ASP.NET и что делать вместо этого | Документация Майкрософт
author: Rick-Anderson
description: В этом разделе описаны некоторые распространенные ошибки, вносимые пользователями в веб-проекты ASP.NET. В нем приводятся рекомендации по предотвращению этих Коммо...
ms.author: riande
ms.date: 01/28/2019
ms.assetid: c39b9965-545c-4b04-8f55-21be7f28a9e5
msc.legacyurl: /aspnet/overview/web-development-best-practices/what-not-to-do-in-aspnet-and-what-to-do-instead
msc.type: authoredcontent
ms.openlocfilehash: 980d3544df70643043391e6573803ce21b3a824f
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2020
ms.locfileid: "78500136"
---
# <a name="what-not-to-do-in-aspnet-and-what-to-do-instead"></a>Запрещенные и разрешенные действия в ASP.NET

> В этом разделе описаны некоторые распространенные ошибки, вносимые пользователями в веб-проекты ASP.NET. Он предоставляет рекомендации по предотвращению этих распространенных ошибок. Он основан на [презентации](http://vimeo.com/68390507) , **Дэмиен Edwards** на веб-сайте, посвященном норвежским разработчикам.

## <a name="disclaimer"></a>Отказ от ответственности

Этот раздел не является полным руководством по обеспечению безопасности и эффективности приложения. Вам по-прежнему необходимо следовать рекомендациям по безопасности и производительности, которые не описаны в этом разделе. Он только предлагает, как избежать распространенных ошибок, связанных с классами и процессами .NET.

## <a name="overview"></a>Обзор

Этот раздел состоит из следующих подразделов.

- [Соответствие стандартам](#standards)

    - [Адаптеры элементов управления](#adapters)
    - [Свойства стиля в элементах управления](#styleprop)
    - [Обратные вызовы страниц и элементов управления](#callback)
    - [Обнаружение возможностей браузера](#browsercap)
- [Безопасность](#security)

    - [Проверка запроса](#validation)
    - [Проверка подлинности и сеанс с помощью форм без файлов cookie](#cookieless)
    - [EnableViewStateMac](#viewstatemac)
    - [Средний уровень доверия](#medium)
    - [&lt;appSettings&gt;](#appsettings)
    - [урлпасенкоде](#urlpathencode)
- [Надежность и производительность](#performance)

    - [Пресендрекуессеадерс и PreSendRequestContent](#presend)
    - [Асинхронные события страниц с веб-формами](#asyncevents)
    - [Пожарные и забытые работы](#fire)
    - [Тело запроса объекта](#requestentity)
    - [Response. Redirect и Response. end](#redirect)
    - [EnableViewState и Виевстатемоде](#viewstatemode)
    - [SqlMembershipProvider](#sqlprovider)
    - [Долго выполняющиеся запросы (> 110 секунд)](#long)

<a id="standards"></a>

## <a name="standards-compliance"></a>Соответствие стандартам

<a id="adapters"></a>

### <a name="control-adapters"></a>Адаптеры элементов управления

Рекомендация: отключите использование адаптеров элементов управления для адаптивной отрисовки, а вместо этого используйте запросы к мультимедиа CSS и соответствующий стандартам HTML.

Адаптеры элементов управления появились в .NET 2,0 для отрисовки кода представления, настроенного для различных устройств и сред. Теперь эту адаптивную визуализацию можно выполнить с помощью CSS и HTML. Следует прерывать использование адаптеров элементов управления и преобразовывать существующие адаптеры в CSS и HTML.

Дополнительные сведения см. в статьях [запросы носителей](http://www.w3.org/TR/css3-mediaqueries/) и [инструкции: Добавление мобильных страниц в приложение ASP.NET Web Forms/MVC](../../../whitepapers/add-mobile-pages-to-your-aspnet-web-forms-mvc-application.md).

<a id="styleprop"></a>

### <a name="style-properties-on-controls"></a>Свойства стиля в элементах управления

Рекомендация: прерывать настройку значений стиля в разметке элемента управления, а также задавать значения форматирования в таблицах стилей CSS.

Серверные веб-элементы управления содержат десятки свойств, которые можно использовать для задания свойств встроенного стиля. Например, свойство ForeColor задает цвет текста для элемента управления. Этот же результат можно более эффективно реализовать с помощью таблиц стилей CSS. Таблицы стилей позволяют централизовать значения стилей и не задавать эти значения во всем приложении.

В следующем примере показан класс CSS, который устанавливает для текста красный цвет.

[!code-css[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample1.css)]

В следующем примере показано, как динамически применить класс CSS.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample2.cs)]

<a id="callback"></a>

### <a name="page-and-control-callbacks"></a>Обратные вызовы страниц и элементов управления

Рекомендация: прерывать использование обратных вызовов страниц и элементов управления, а вместо этого использовать следующие элементы: AJAX, UpdatePanel, методы действий MVC, веб-API или SignalR.

В предыдущих версиях ASP.NET методы обратного вызова страницы и управления позволили вам обновить часть веб-страницы без обновления всей страницы. Теперь можно выполнять частичные обновления страниц с помощью [AJAX](../../../ajax/index.md), [UpdatePanel](https://msdn.microsoft.com/library/bb386454.aspx), [MVC](../../../mvc/index.md), [веб-API](../../../web-api/index.md) или [SignalR](../../../signalr/index.md). Следует перестать использовать методы обратного вызова, так как они могут вызвать проблемы с понятными URL-адресами и маршрутизацией. По умолчанию элементы управления не поддерживают методы обратного вызова, но если эта функция включена в элементе управления, ее следует отключить.

<a id="browsercap"></a>

### <a name="browser-capability-detection"></a>Обнаружение возможностей браузера

Рекомендация: завершите использование статического обнаружения возможностей браузера, а вместо этого используйте обнаружение динамических компонентов.

В более ранних версиях ASP.NET поддерживаемые функции для каждого браузера хранились в XML-файле. Поиск поддержки функций посредством статического поиска не является лучшим подходом. Теперь можно динамически обнаруживать поддерживаемые в браузере функции с помощью платформы обнаружения компонентов, например [Modernizr](http://modernizr.com/). Обнаружение компонентов определяет поддержку, пытаясь использовать метод или свойство, а затем проверить, был ли браузер выдал желаемый результат. По умолчанию Modernizr включается в шаблоны веб-приложений.

<a id="security"></a>

## <a name="security"></a>безопасность

<a id="validation"></a>

### <a name="request-validation"></a>Проверка запросов

Рекомендация: проверка вводимых пользователем данных и кодирование выходных данных от пользователей.

Проверка запросов — это функция ASP.NET, которая проверяет каждый запрос и останавливает запрос, если обнаружена воспринимаемая угроза. Не зависят от проверки запроса для защиты приложения от атак с использованием межсайтовых сценариев. Вместо этого следует проверить все входные данные пользователей и закодировать выходные данные. В некоторых ограниченных случаях можно использовать регулярные выражения для проверки входных данных, но в более сложных случаях следует проверять вводимые пользователем данные с помощью классов .NET, которые определяют, соответствуют ли значения допустимым значениям.

В следующем примере показано, как использовать статический метод в классе URI, чтобы определить, является ли допустимым URI, предоставленный пользователем.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample3.cs)]

Тем не менее, чтобы достаточно проверить универсальный код ресурса (URI), необходимо также убедиться, что он указывает `http` или `https`. В следующем примере методы экземпляра используются для проверки допустимости URI.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample4.cs)]

Перед отображением вводимых пользователем данных в формате HTML или ввода данных пользователем в SQL-запросе необходимо закодировать значения, чтобы убедиться в том, что вредоносный код не включен.

Можно кодировать значение HTML в разметке с помощью синтаксиса &lt;%:%&gt;, как показано ниже.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample5.aspx?highlight=1)]

Или в синтаксис Razor можно выполнить кодирование в формате HTML с помощью @, как показано ниже.

[!code-cshtml[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample6.cshtml?highlight=1)]

В следующем примере показано, как кодировать значение HTML в коде программной части.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample7.cs)]

Чтобы безопасно закодировать значение для команд SQL, используйте параметры командной строки, такие как [SqlParameter](https://msdn.microsoft.com/library/system.data.sqlclient.sqlparameter.aspx). <a id="cookieless"></a>

### <a name="cookieless-forms-authentication-and-session"></a>Проверка подлинности и сеанс с помощью форм без файлов cookie

Рекомендация: требуются файлы cookie.

Передача сведений о проверке подлинности в строку запроса не является безопасной. Таким образом, если приложение включает проверку подлинности, требуются файлы cookie. Если файл cookie хранит конфиденциальные данные, рассмотрите возможность обязательного использования SSL для файла cookie.

В следующем примере показано, как указать в файле Web. config, что для проверки подлинности форм требуется файл cookie, передаваемый по протоколу SSL.

[!code-xml[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample8.xml)]

<a id="viewstatemac"></a>

### <a name="enableviewstatemac"></a>EnableViewStateMac

Рекомендация: не устанавливайте значение false.

По умолчанию EnableViewStateMac имеет значение true. Даже если приложение не использует состояние просмотра, не устанавливайте для EnableViewStateMac значение false. Установка этого параметра в значение false сделает приложение уязвимым для межсайтовых сценариев.

Начиная с ASP.NET 4.5.2 среда выполнения применяет **EnableViewStateMac = true**. Даже если задано значение false, среда выполнения игнорирует это значение и переходит к значению true. Дополнительные сведения см. в разделе [ASP.NET 4.5.2 and EnableViewStateMac](https://blogs.msdn.com/b/webdev/archive/2014/05/07/asp-net-4-5-2-and-enableviewstatemac.aspx).

В следующем примере показано, как установить для EnableViewStateMac значение true. Нет необходимости присвоить этому параметру значение true, так как по умолчанию имеет значение true. Тем не менее, если на любой странице приложения задано значение false, необходимо немедленно исправить это значение.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample9.aspx)]

<a id="medium"></a>

### <a name="medium-trust"></a>Средний уровень доверия

Рекомендация: не зависят от среднего уровня доверия (или любого другого) в качестве границы безопасности.

Частичное доверие не защищает приложение надлежащим образом и не должно использоваться. Вместо этого используйте полное доверие и изолируйте недоверенные приложения в отдельных пулах приложений. Кроме того, запустите каждый пул приложений с уникальным удостоверением. Дополнительные сведения см. в разделе [ASP.NET частичное доверие не гарантирует изоляцию приложений](https://support.microsoft.com/kb/2698981).

<a id="appsettings"></a>

### <a name="ltappsettingsgt"></a>&lt;appSettings&gt;

Рекомендация: не отключайте параметры безопасности в элементе &lt;appSettings&gt;.

Элемент appSettings содержит множество значений, необходимых для обновлений безопасности. Не следует изменять или отключать эти значения. Если необходимо отключить эти значения при развертывании обновления, сразу снова включите его после завершения развертывания.

Дополнительные сведения см. в разделе [ASP.NET appSettings element](https://msdn.microsoft.com/library/hh975440.aspx).

<a id="urlpathencode"></a>

### <a name="urlpathencode"></a>урлпасенкоде

Рекомендация: вместо этого используйте [UrlEncode](https://msdn.microsoft.com/library/zttxte6w.aspx) .

Метод Урлпасенкоде был добавлен в .NET Framework для разрешения очень специфической проблемы совместимости с браузером. Он не кодирует URL-адрес надлежащим образом и не защищает приложение от межузловых сценариев. Его никогда не следует использовать в приложении. Вместо этого используйте [UrlEncode](https://msdn.microsoft.com/library/zttxte6w.aspx).

В следующем примере показано, как передать закодированный URL-адрес как параметр строки запроса для элемента управления HyperLink.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample10.cs)]

<a id="performance"></a>

## <a name="reliability-and-performance"></a>Надежность и производительность

<a id="presend"></a>

### <a name="presendrequestheaders-and-presendrequestcontent"></a>Пресендрекуессеадерс и PreSendRequestContent

Рекомендация: не используйте эти события с управляемыми модулями. Вместо этого напишите собственный модуль IIS для выполнения требуемой задачи. См. раздел [Создание модулей HTTP с машинным кодом](https://msdn.microsoft.com/library/ms693629.aspx).

Вы можете использовать события [пресендрекуессеадерс](https://msdn.microsoft.com/library/system.web.httpapplication.presendrequestheaders.aspx) и [PreSendRequestContent](https://msdn.microsoft.com/library/system.web.httpapplication.presendrequestcontent.aspx) с собственными модулями IIS.
> [!WARNING]
> Не используйте `PreSendRequestHeaders` и `PreSendRequestContent` с управляемыми модулями, которые реализуют `IHttpModule`. Установка этих свойств может вызвать проблемы с асинхронными запросами. Сочетание запрошенного приложением маршрутизации (ARR) и WebSockets может привести к исключениям нарушения доступа, которые могут привести к сбою w3wp. Например, иискоре! W3_CONTEXT_BASE:: Жетисластнотификатион + 68 в иискоре. dll вызвало исключение нарушения прав доступа (0xC0000005).

<a id="asyncevents"></a>

### <a name="asynchronous-page-events-with-web-forms"></a>Асинхронные события страниц с веб-формами

Рекомендация: в веб-формах Избегайте написания асинхронных методов void для событий жизненного цикла страницы, а вместо этого используйте [Page. метод RegisterAsyncTask](https://msdn.microsoft.com/library/system.web.ui.page.registerasynctask.aspx) для асинхронного кода.

При пометке события страницы с **модификатором Async** и **void**невозможно определить время завершения асинхронного кода. Вместо этого используйте Page. метод RegisterAsyncTask для выполнения асинхронного кода способом, позволяющим отследить его завершение.

В следующем примере показан обработчик нажатия кнопки, который содержит асинхронный код. Этот пример включает асинхронное чтение строкового значения, которое предоставляется только в качестве упрощенного примера асинхронной задачи, а не рекомендуемой практикой.

[!code-csharp[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample11.cs)]

При использовании асинхронных задач задайте в качестве целевой платформы среды выполнения HTTP значение 4,5 (или более позднюю) в файле Web. config. При установке целевой платформы в значение 4,5 включается новый контекст синхронизации, добавленный в .NET 4,5. Это значение по умолчанию задается в новых проектах Visual Studio, но не устанавливается при работе с существующим проектом.

[!code-xml[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample12.xml)]

<a id="fire"></a>

### <a name="fire-and-forget-work"></a>Пожарные и забытые работы

Рекомендация. при обработке запроса в ASP.NET старайтесь не запускать запуск пожарной и забытой работы (например, вызов метода ThreadPool. QueueUserWorkItem или создание таймера, который многократно вызывает делегат).

Если в приложении есть работа, которая работает в ASP.NET, приложение может не синхронизироваться. В любое время домен приложения можно уничтожить, что означает, что текущий процесс может больше не соответствовать текущему состоянию приложения.

Этот тип работы следует перемещать за пределы ASP.NET. Вы можете использовать веб-задания, службу Windows или рабочую роль в Azure для выполнения текущей работы и запуска этого кода из другого процесса.

Если вам необходимо выполнить эту работу в ASP.NET, можно добавить пакет NuGet с именем " [фон](http://www.nuget.org/packages/webbackgrounder) " для запуска кода.

<a id="requestentity"></a>

### <a name="request-entity-body"></a>Тело запроса объекта

Рекомендация: Избегайте чтения запроса. Form или Request. InputStream перед событием выполнения обработчика.

Самая ранняя из них должна быть считана из запроса. Form или Request. InputStream во время события Execute обработчика. В MVC контроллер является обработчиком, а событие выполнения — при выполнении метода действия. В веб-формах страница является обработчиком, а событие выполнения — при срабатывании события Page. init. При чтении тела запроса, предшествующего событию Execute, вы повлияете на обработку запроса.

Если необходимо прочитать текст сущности запроса перед событием Execute, используйте [request. жетбуфферлессинпутстреам](https://msdn.microsoft.com/library/ff406798.aspx) или [request. GetBufferedInputStream](https://msdn.microsoft.com/library/system.web.httprequest.getbufferedinputstream.aspx). При использовании Жетбуфферлессинпутстреам вы получаете необработанный поток из запроса и несете ответственность за обработку всего запроса. После вызова Жетбуфферлессинпутстреам запросы. Form и Request. InputStream недоступны, так как они не заполнены ASP.NET. При использовании GetBufferedInputStream вы получаете копию потока из запроса. Запрос. Form и Request. InputStream по-прежнему доступны позже в запросе, так как ASP.NET заполняет другую копию.

<a id="redirect"></a>

### <a name="responseredirect-and-responseend"></a>Response. Redirect и Response. end

Рекомендация: Обратите внимание на различия в обработке потока после вызова [Response. Redirect (строка)](https://msdn.microsoft.com/library/t9dwyts4.aspx).

Метод Response [. Redirect (строка)](https://msdn.microsoft.com/library/t9dwyts4.aspx) вызывает метод Response. end. В синхронном процессе вызов запроса. Redirect приводит к немедленному прерыванию текущего потока. Однако в асинхронном процессе вызов Response. Redirect не прерывает текущий поток, поэтому выполнение кода продолжится для запроса. В асинхронном процессе необходимо вернуть задачу из метода, чтобы прерывать выполнение кода.

В проекте MVC не следует вызывать ответ. Redirect. Вместо этого следует возвращать Редиректресулт.

<a id="viewstatemode"></a>

### <a name="enableviewstate-and-viewstatemode"></a>EnableViewState и Виевстатемоде

Рекомендация: используйте Виевстатемоде вместо EnableViewState, чтобы обеспечить детальный контроль над тем, какие элементы управления используют состояние представления.

При установке для EnableViewState значения false в директиве Page состояние представления отключается для всех элементов управления на странице и не может быть включено. Если вы хотите включить состояние просмотра только для определенных элементов управления на странице, установите для параметра Виевстатемоде значение Disabled (отключено) для страницы.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample13.aspx)]

Затем установите Виевстатемоде в значение Enabled только для элементов управления, которые действительно требуют состояния представления.

[!code-aspx[Main](what-not-to-do-in-aspnet-and-what-to-do-instead/samples/sample14.aspx)]

Включив состояние просмотра только для тех элементов управления, которые им нужны, можно уменьшить размер состояния представления для веб-страниц.

<a id="sqlprovider"></a>

### <a name="sqlmembershipprovider"></a>SqlMembershipProvider

Рекомендация: используйте универсальные поставщики.

В текущих шаблонах проектов SqlMembershipProvider был заменен [универсальные поставщики ASP.NET](http://www.nuget.org/packages/Microsoft.AspNet.Providers), который доступен в виде пакета NuGet. При использовании SqlMembershipProvider в проекте, построенном с использованием более ранней версии шаблонов, следует переключиться на универсальные поставщики. Универсальные поставщики работать со всеми базами данных, которые поддерживаются Entity Framework.

Дополнительные сведения см. в разделе [Введение в универсальные поставщики ASP.NET](http://www.hanselman.com/blog/IntroducingSystemWebProvidersASPNETUniversalProvidersForSessionMembershipRolesAndUserProfileOnSQLCompactAndSQLAzure.aspx).

<a id="long"></a>

### <a name="long-running-requests-110-seconds"></a>Долго выполняющиеся запросы (> 110 секунд)

Рекомендация: используйте [WebSockets](https://msdn.microsoft.com/library/system.net.websockets.websocket.aspx) или [SignalR](../../../signalr/index.md) для подключенных клиентов и используйте асинхронные операции ввода-вывода.

Длительные запросы могут привести к непредсказуемым результатам и снижению производительности веб-приложения. Значение времени ожидания по умолчанию для запроса составляет 110 секунд. Если вы используете состояние сеанса с длительным запросом, ASP.NET снимает блокировку объекта сеанса через 110 секунд. Однако приложение может находиться в процессе операции над объектом Session, когда блокировка снимается, и операция может завершиться неудачно. Если второй запрос пользователя блокируется во время выполнения первого запроса, второй запрос может получить доступ к объекту сеанса в непротиворечивом состоянии.

Если приложение включает в себя блокирующие (или синхронные) операции ввода-вывода, приложение не будет отвечать.

Для повышения производительности используйте асинхронные операции ввода-вывода в .NET Framework. Кроме того, используйте WebSockets или SignalR для подключения клиентов к серверу. Эти функции предназначены для эффективной обработки долго выполняющихся запросов.
